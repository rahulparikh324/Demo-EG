;(function (C, pt) {
  typeof exports == 'object' && typeof module < 'u' ? pt(require('react'), require('react-dom')) : typeof define == 'function' && define.amd ? define(['react', 'react-dom'], pt) : ((C = typeof globalThis < 'u' ? globalThis : C || self), pt(C.React, C.ReactDOM))
})(this, function (C, pt) {
  'use strict'
  var $V = Object.defineProperty
  var e9 = (C, pt, ao) => (pt in C ? $V(C, pt, { enumerable: !0, configurable: !0, writable: !0, value: ao }) : (C[pt] = ao))
  var At = (C, pt, ao) => e9(C, typeof pt != 'symbol' ? pt + '' : pt, ao)
  function ao(e) {
    const t = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } })
    if (e) {
      for (const n in e)
        if (n !== 'default') {
          const o = Object.getOwnPropertyDescriptor(e, n)
          Object.defineProperty(t, n, o.get ? o : { enumerable: !0, get: () => e[n] })
        }
    }
    return (t.default = e), Object.freeze(t)
  }
  const N = ao(C),
    jl = ao(pt)
  function $d(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
  }
  function Mn(e) {
    if (e.__esModule) return e
    var t = e.default
    if (typeof t == 'function') {
      var n = function o() {
        return this instanceof o ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
      }
      n.prototype = t.prototype
    } else n = {}
    return (
      Object.defineProperty(n, '__esModule', { value: !0 }),
      Object.keys(e).forEach(function (o) {
        var r = Object.getOwnPropertyDescriptor(e, o)
        Object.defineProperty(
          n,
          o,
          r.get
            ? r
            : {
                enumerable: !0,
                get: function () {
                  return e[o]
                },
              }
        )
      }),
      n
    )
  }
  var ef = { exports: {} },
    ti = {}
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var xb = C,
    Cb = Symbol.for('react.element'),
    wb = Symbol.for('react.fragment'),
    Eb = Object.prototype.hasOwnProperty,
    Sb = xb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    Bb = { key: !0, ref: !0, __self: !0, __source: !0 }
  function tf(e, t, n) {
    var o,
      r = {},
      s = null,
      i = null
    n !== void 0 && (s = '' + n), t.key !== void 0 && (s = '' + t.key), t.ref !== void 0 && (i = t.ref)
    for (o in t) Eb.call(t, o) && !Bb.hasOwnProperty(o) && (r[o] = t[o])
    if (e && e.defaultProps) for (o in ((t = e.defaultProps), t)) r[o] === void 0 && (r[o] = t[o])
    return { $$typeof: Cb, type: e, key: s, ref: i, props: r, _owner: Sb.current }
  }
  ;(ti.Fragment = wb), (ti.jsx = tf), (ti.jsxs = tf), (ef.exports = ti)
  var p = ef.exports
  const Ko = { black: '#000', white: '#fff' },
    lo = { 50: '#ffebee', 100: '#ffcdd2', 200: '#ef9a9a', 300: '#e57373', 400: '#ef5350', 500: '#f44336', 600: '#e53935', 700: '#d32f2f', 800: '#c62828', 900: '#b71c1c', A100: '#ff8a80', A200: '#ff5252', A400: '#ff1744', A700: '#d50000' },
    Ib = { 50: '#fce4ec', 100: '#f8bbd0', 200: '#f48fb1', 300: '#f06292', 400: '#ec407a', 500: '#e91e63', 600: '#d81b60', 700: '#c2185b', 800: '#ad1457', 900: '#880e4f', A100: '#ff80ab', A200: '#ff4081', A400: '#f50057', A700: '#c51162' },
    co = { 50: '#f3e5f5', 100: '#e1bee7', 200: '#ce93d8', 300: '#ba68c8', 400: '#ab47bc', 500: '#9c27b0', 600: '#8e24aa', 700: '#7b1fa2', 800: '#6a1b9a', 900: '#4a148c', A100: '#ea80fc', A200: '#e040fb', A400: '#d500f9', A700: '#aa00ff' },
    kb = { 50: '#ede7f6', 100: '#d1c4e9', 200: '#b39ddb', 300: '#9575cd', 400: '#7e57c2', 500: '#673ab7', 600: '#5e35b1', 700: '#512da8', 800: '#4527a0', 900: '#311b92', A100: '#b388ff', A200: '#7c4dff', A400: '#651fff', A700: '#6200ea' },
    Nb = { 50: '#e8eaf6', 100: '#c5cae9', 200: '#9fa8da', 300: '#7986cb', 400: '#5c6bc0', 500: '#3f51b5', 600: '#3949ab', 700: '#303f9f', 800: '#283593', 900: '#1a237e', A100: '#8c9eff', A200: '#536dfe', A400: '#3d5afe', A700: '#304ffe' },
    uo = { 50: '#e3f2fd', 100: '#bbdefb', 200: '#90caf9', 300: '#64b5f6', 400: '#42a5f5', 500: '#2196f3', 600: '#1e88e5', 700: '#1976d2', 800: '#1565c0', 900: '#0d47a1', A100: '#82b1ff', A200: '#448aff', A400: '#2979ff', A700: '#2962ff' },
    fo = { 50: '#e1f5fe', 100: '#b3e5fc', 200: '#81d4fa', 300: '#4fc3f7', 400: '#29b6f6', 500: '#03a9f4', 600: '#039be5', 700: '#0288d1', 800: '#0277bd', 900: '#01579b', A100: '#80d8ff', A200: '#40c4ff', A400: '#00b0ff', A700: '#0091ea' },
    Mb = { 50: '#e0f7fa', 100: '#b2ebf2', 200: '#80deea', 300: '#4dd0e1', 400: '#26c6da', 500: '#00bcd4', 600: '#00acc1', 700: '#0097a7', 800: '#00838f', 900: '#006064', A100: '#84ffff', A200: '#18ffff', A400: '#00e5ff', A700: '#00b8d4' },
    Pb = { 50: '#e0f2f1', 100: '#b2dfdb', 200: '#80cbc4', 300: '#4db6ac', 400: '#26a69a', 500: '#009688', 600: '#00897b', 700: '#00796b', 800: '#00695c', 900: '#004d40', A100: '#a7ffeb', A200: '#64ffda', A400: '#1de9b6', A700: '#00bfa5' },
    Ao = { 50: '#e8f5e9', 100: '#c8e6c9', 200: '#a5d6a7', 300: '#81c784', 400: '#66bb6a', 500: '#4caf50', 600: '#43a047', 700: '#388e3c', 800: '#2e7d32', 900: '#1b5e20', A100: '#b9f6ca', A200: '#69f0ae', A400: '#00e676', A700: '#00c853' },
    Lb = { 50: '#f1f8e9', 100: '#dcedc8', 200: '#c5e1a5', 300: '#aed581', 400: '#9ccc65', 500: '#8bc34a', 600: '#7cb342', 700: '#689f38', 800: '#558b2f', 900: '#33691e', A100: '#ccff90', A200: '#b2ff59', A400: '#76ff03', A700: '#64dd17' },
    Tb = { 50: '#f9fbe7', 100: '#f0f4c3', 200: '#e6ee9c', 300: '#dce775', 400: '#d4e157', 500: '#cddc39', 600: '#c0ca33', 700: '#afb42b', 800: '#9e9d24', 900: '#827717', A100: '#f4ff81', A200: '#eeff41', A400: '#c6ff00', A700: '#aeea00' },
    Fb = { 50: '#fffde7', 100: '#fff9c4', 200: '#fff59d', 300: '#fff176', 400: '#ffee58', 500: '#ffeb3b', 600: '#fdd835', 700: '#fbc02d', 800: '#f9a825', 900: '#f57f17', A100: '#ffff8d', A200: '#ffff00', A400: '#ffea00', A700: '#ffd600' },
    Db = { 50: '#fff8e1', 100: '#ffecb3', 200: '#ffe082', 300: '#ffd54f', 400: '#ffca28', 500: '#ffc107', 600: '#ffb300', 700: '#ffa000', 800: '#ff8f00', 900: '#ff6f00', A100: '#ffe57f', A200: '#ffd740', A400: '#ffc400', A700: '#ffab00' },
    qo = { 50: '#fff3e0', 100: '#ffe0b2', 200: '#ffcc80', 300: '#ffb74d', 400: '#ffa726', 500: '#ff9800', 600: '#fb8c00', 700: '#f57c00', 800: '#ef6c00', 900: '#e65100', A100: '#ffd180', A200: '#ffab40', A400: '#ff9100', A700: '#ff6d00' },
    zb = { 50: '#fbe9e7', 100: '#ffccbc', 200: '#ffab91', 300: '#ff8a65', 400: '#ff7043', 500: '#ff5722', 600: '#f4511e', 700: '#e64a19', 800: '#d84315', 900: '#bf360c', A100: '#ff9e80', A200: '#ff6e40', A400: '#ff3d00', A700: '#dd2c00' },
    Qb = { 50: '#efebe9', 100: '#d7ccc8', 200: '#bcaaa4', 300: '#a1887f', 400: '#8d6e63', 500: '#795548', 600: '#6d4c41', 700: '#5d4037', 800: '#4e342e', 900: '#3e2723', A100: '#d7ccc8', A200: '#bcaaa4', A400: '#8d6e63', A700: '#5d4037' },
    nf = { 50: '#fafafa', 100: '#f5f5f5', 200: '#eeeeee', 300: '#e0e0e0', 400: '#bdbdbd', 500: '#9e9e9e', 600: '#757575', 700: '#616161', 800: '#424242', 900: '#212121', A100: '#f5f5f5', A200: '#eeeeee', A400: '#bdbdbd', A700: '#616161' },
    Rb = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          amber: Db,
          blue: uo,
          blueGrey: { 50: '#eceff1', 100: '#cfd8dc', 200: '#b0bec5', 300: '#90a4ae', 400: '#78909c', 500: '#607d8b', 600: '#546e7a', 700: '#455a64', 800: '#37474f', 900: '#263238', A100: '#cfd8dc', A200: '#b0bec5', A400: '#78909c', A700: '#455a64' },
          brown: Qb,
          common: Ko,
          cyan: Mb,
          deepOrange: zb,
          deepPurple: kb,
          green: Ao,
          grey: nf,
          indigo: Nb,
          lightBlue: fo,
          lightGreen: Lb,
          lime: Tb,
          orange: qo,
          pink: Ib,
          purple: co,
          red: lo,
          teal: Pb,
          yellow: Fb,
        },
        Symbol.toStringTag,
        { value: 'Module' }
      )
    )
  function Zo(e) {
    let t = 'https://mui.com/production-error/?code=' + e
    for (let n = 1; n < arguments.length; n += 1) t += '&args[]=' + encodeURIComponent(arguments[n])
    return 'Minified MUI error #' + e + '; visit ' + t + ' for the full message.'
  }
  const Jo = '$$material'
  function M() {
    return (
      (M = Object.assign
        ? Object.assign.bind()
        : function (e) {
            for (var t = 1; t < arguments.length; t++) {
              var n = arguments[t]
              for (var o in n) ({}.hasOwnProperty.call(n, o) && (e[o] = n[o]))
            }
            return e
          }),
      M.apply(null, arguments)
    )
  }
  function he(e, t) {
    if (e == null) return {}
    var n = {}
    for (var o in e)
      if ({}.hasOwnProperty.call(e, o)) {
        if (t.includes(o)) continue
        n[o] = e[o]
      }
    return n
  }
  function of(e) {
    let t = 'https://mui.com/production-error/?code=' + e
    for (let n = 1; n < arguments.length; n += 1) t += '&args[]=' + encodeURIComponent(arguments[n])
    return 'Minified MUI error #' + e + '; visit ' + t + ' for the full message.'
  }
  const Ob = Object.freeze(Object.defineProperty({ __proto__: null, default: of }, Symbol.toStringTag, { value: 'Module' }))
  var jb = !1
  function Wb(e) {
    if (e.sheet) return e.sheet
    for (var t = 0; t < document.styleSheets.length; t++) if (document.styleSheets[t].ownerNode === e) return document.styleSheets[t]
  }
  function Gb(e) {
    var t = document.createElement('style')
    return t.setAttribute('data-emotion', e.key), e.nonce !== void 0 && t.setAttribute('nonce', e.nonce), t.appendChild(document.createTextNode('')), t.setAttribute('data-s', ''), t
  }
  var Vb = (function () {
      function e(n) {
        var o = this
        ;(this._insertTag = function (r) {
          var s
          o.tags.length === 0 ? (o.insertionPoint ? (s = o.insertionPoint.nextSibling) : o.prepend ? (s = o.container.firstChild) : (s = o.before)) : (s = o.tags[o.tags.length - 1].nextSibling), o.container.insertBefore(r, s), o.tags.push(r)
        }),
          (this.isSpeedy = n.speedy === void 0 ? !jb : n.speedy),
          (this.tags = []),
          (this.ctr = 0),
          (this.nonce = n.nonce),
          (this.key = n.key),
          (this.container = n.container),
          (this.prepend = n.prepend),
          (this.insertionPoint = n.insertionPoint),
          (this.before = null)
      }
      var t = e.prototype
      return (
        (t.hydrate = function (o) {
          o.forEach(this._insertTag)
        }),
        (t.insert = function (o) {
          this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Gb(this))
          var r = this.tags[this.tags.length - 1]
          if (this.isSpeedy) {
            var s = Wb(r)
            try {
              s.insertRule(o, s.cssRules.length)
            } catch {}
          } else r.appendChild(document.createTextNode(o))
          this.ctr++
        }),
        (t.flush = function () {
          this.tags.forEach(function (o) {
            var r
            return (r = o.parentNode) == null ? void 0 : r.removeChild(o)
          }),
            (this.tags = []),
            (this.ctr = 0)
        }),
        e
      )
    })(),
    wt = '-ms-',
    ni = '-moz-',
    ze = '-webkit-',
    rf = 'comm',
    Wl = 'rule',
    Gl = 'decl',
    Xb = '@import',
    sf = '@keyframes',
    Yb = '@layer',
    Hb = Math.abs,
    oi = String.fromCharCode,
    Ub = Object.assign
  function Kb(e, t) {
    return vt(e, 0) ^ 45 ? (((((((t << 2) ^ vt(e, 0)) << 2) ^ vt(e, 1)) << 2) ^ vt(e, 2)) << 2) ^ vt(e, 3) : 0
  }
  function af(e) {
    return e.trim()
  }
  function qb(e, t) {
    return (e = t.exec(e)) ? e[0] : e
  }
  function Qe(e, t, n) {
    return e.replace(t, n)
  }
  function Vl(e, t) {
    return e.indexOf(t)
  }
  function vt(e, t) {
    return e.charCodeAt(t) | 0
  }
  function jr(e, t, n) {
    return e.slice(t, n)
  }
  function mn(e) {
    return e.length
  }
  function Xl(e) {
    return e.length
  }
  function ri(e, t) {
    return t.push(e), e
  }
  function Zb(e, t) {
    return e.map(t).join('')
  }
  var si = 1,
    _o = 1,
    lf = 0,
    Pt = 0,
    ut = 0,
    $o = ''
  function ii(e, t, n, o, r, s, i) {
    return { value: e, root: t, parent: n, type: o, props: r, children: s, line: si, column: _o, length: i, return: '' }
  }
  function Wr(e, t) {
    return Ub(ii('', null, null, '', null, null, 0), e, { length: -e.length }, t)
  }
  function Jb() {
    return ut
  }
  function _b() {
    return (ut = Pt > 0 ? vt($o, --Pt) : 0), _o--, ut === 10 && ((_o = 1), si--), ut
  }
  function zt() {
    return (ut = Pt < lf ? vt($o, Pt++) : 0), _o++, ut === 10 && ((_o = 1), si++), ut
  }
  function yn() {
    return vt($o, Pt)
  }
  function ai() {
    return Pt
  }
  function Gr(e, t) {
    return jr($o, e, t)
  }
  function Vr(e) {
    switch (e) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4
      case 58:
        return 3
      case 34:
      case 39:
      case 40:
      case 91:
        return 2
      case 41:
      case 93:
        return 1
    }
    return 0
  }
  function cf(e) {
    return (si = _o = 1), (lf = mn(($o = e))), (Pt = 0), []
  }
  function uf(e) {
    return ($o = ''), e
  }
  function li(e) {
    return af(Gr(Pt - 1, Yl(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
  }
  function $b(e) {
    for (; (ut = yn()) && ut < 33; ) zt()
    return Vr(e) > 2 || Vr(ut) > 3 ? '' : ' '
  }
  function ev(e, t) {
    for (; --t && zt() && !(ut < 48 || ut > 102 || (ut > 57 && ut < 65) || (ut > 70 && ut < 97)); );
    return Gr(e, ai() + (t < 6 && yn() == 32 && zt() == 32))
  }
  function Yl(e) {
    for (; zt(); )
      switch (ut) {
        case e:
          return Pt
        case 34:
        case 39:
          e !== 34 && e !== 39 && Yl(ut)
          break
        case 40:
          e === 41 && Yl(e)
          break
        case 92:
          zt()
          break
      }
    return Pt
  }
  function tv(e, t) {
    for (; zt() && e + ut !== 57; ) if (e + ut === 84 && yn() === 47) break
    return '/*' + Gr(t, Pt - 1) + '*' + oi(e === 47 ? e : zt())
  }
  function nv(e) {
    for (; !Vr(yn()); ) zt()
    return Gr(e, Pt)
  }
  function ov(e) {
    return uf(ci('', null, null, null, [''], (e = cf(e)), 0, [0], e))
  }
  function ci(e, t, n, o, r, s, i, a, l) {
    for (var c = 0, u = 0, d = i, f = 0, A = 0, h = 0, g = 1, x = 1, m = 1, v = 0, y = '', b = r, w = s, k = o, E = y; x; )
      switch (((h = v), (v = zt()))) {
        case 40:
          if (h != 108 && vt(E, d - 1) == 58) {
            Vl((E += Qe(li(v), '&', '&\f')), '&\f') != -1 && (m = -1)
            break
          }
        case 34:
        case 39:
        case 91:
          E += li(v)
          break
        case 9:
        case 10:
        case 13:
        case 32:
          E += $b(h)
          break
        case 92:
          E += ev(ai() - 1, 7)
          continue
        case 47:
          switch (yn()) {
            case 42:
            case 47:
              ri(rv(tv(zt(), ai()), t, n), l)
              break
            default:
              E += '/'
          }
          break
        case 123 * g:
          a[c++] = mn(E) * m
        case 125 * g:
        case 59:
        case 0:
          switch (v) {
            case 0:
            case 125:
              x = 0
            case 59 + u:
              m == -1 && (E = Qe(E, /\f/g, '')), A > 0 && mn(E) - d && ri(A > 32 ? ff(E + ';', o, n, d - 1) : ff(Qe(E, ' ', '') + ';', o, n, d - 2), l)
              break
            case 59:
              E += ';'
            default:
              if ((ri((k = df(E, t, n, c, u, r, a, y, (b = []), (w = []), d)), s), v === 123))
                if (u === 0) ci(E, t, k, k, b, s, d, a, w)
                else
                  switch (f === 99 && vt(E, 3) === 110 ? 100 : f) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      ci(e, k, k, o && ri(df(e, k, k, 0, 0, r, a, y, r, (b = []), d), w), r, w, d, a, o ? b : w)
                      break
                    default:
                      ci(E, k, k, k, [''], w, 0, a, w)
                  }
          }
          ;(c = u = A = 0), (g = m = 1), (y = E = ''), (d = i)
          break
        case 58:
          ;(d = 1 + mn(E)), (A = h)
        default:
          if (g < 1) {
            if (v == 123) --g
            else if (v == 125 && g++ == 0 && _b() == 125) continue
          }
          switch (((E += oi(v)), v * g)) {
            case 38:
              m = u > 0 ? 1 : ((E += '\f'), -1)
              break
            case 44:
              ;(a[c++] = (mn(E) - 1) * m), (m = 1)
              break
            case 64:
              yn() === 45 && (E += li(zt())), (f = yn()), (u = d = mn((y = E += nv(ai())))), v++
              break
            case 45:
              h === 45 && mn(E) == 2 && (g = 0)
          }
      }
    return s
  }
  function df(e, t, n, o, r, s, i, a, l, c, u) {
    for (var d = r - 1, f = r === 0 ? s : [''], A = Xl(f), h = 0, g = 0, x = 0; h < o; ++h) for (var m = 0, v = jr(e, d + 1, (d = Hb((g = i[h])))), y = e; m < A; ++m) (y = af(g > 0 ? f[m] + ' ' + v : Qe(v, /&\f/g, f[m]))) && (l[x++] = y)
    return ii(e, t, n, r === 0 ? Wl : a, l, c, u)
  }
  function rv(e, t, n) {
    return ii(e, t, n, rf, oi(Jb()), jr(e, 2, -2), 0)
  }
  function ff(e, t, n, o) {
    return ii(e, t, n, Gl, jr(e, 0, o), jr(e, o + 1, -1), o)
  }
  function er(e, t) {
    for (var n = '', o = Xl(e), r = 0; r < o; r++) n += t(e[r], r, e, t) || ''
    return n
  }
  function sv(e, t, n, o) {
    switch (e.type) {
      case Yb:
        if (e.children.length) break
      case Xb:
      case Gl:
        return (e.return = e.return || e.value)
      case rf:
        return ''
      case sf:
        return (e.return = e.value + '{' + er(e.children, o) + '}')
      case Wl:
        e.value = e.props.join(',')
    }
    return mn((n = er(e.children, o))) ? (e.return = e.value + '{' + n + '}') : ''
  }
  function iv(e) {
    var t = Xl(e)
    return function (n, o, r, s) {
      for (var i = '', a = 0; a < t; a++) i += e[a](n, o, r, s) || ''
      return i
    }
  }
  function av(e) {
    return function (t) {
      t.root || ((t = t.return) && e(t))
    }
  }
  function Af(e) {
    var t = Object.create(null)
    return function (n) {
      return t[n] === void 0 && (t[n] = e(n)), t[n]
    }
  }
  var lv = function (t, n, o) {
      for (var r = 0, s = 0; (r = s), (s = yn()), r === 38 && s === 12 && (n[o] = 1), !Vr(s); ) zt()
      return Gr(t, Pt)
    },
    cv = function (t, n) {
      var o = -1,
        r = 44
      do
        switch (Vr(r)) {
          case 0:
            r === 38 && yn() === 12 && (n[o] = 1), (t[o] += lv(Pt - 1, n, o))
            break
          case 2:
            t[o] += li(r)
            break
          case 4:
            if (r === 44) {
              ;(t[++o] = yn() === 58 ? '&\f' : ''), (n[o] = t[o].length)
              break
            }
          default:
            t[o] += oi(r)
        }
      while ((r = zt()))
      return t
    },
    uv = function (t, n) {
      return uf(cv(cf(t), n))
    },
    pf = new WeakMap(),
    dv = function (t) {
      if (!(t.type !== 'rule' || !t.parent || t.length < 1)) {
        for (var n = t.value, o = t.parent, r = t.column === o.column && t.line === o.line; o.type !== 'rule'; ) if (((o = o.parent), !o)) return
        if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !pf.get(o)) && !r) {
          pf.set(t, !0)
          for (var s = [], i = uv(n, s), a = o.props, l = 0, c = 0; l < i.length; l++) for (var u = 0; u < a.length; u++, c++) t.props[c] = s[l] ? i[l].replace(/&\f/g, a[u]) : a[u] + ' ' + i[l]
        }
      }
    },
    fv = function (t) {
      if (t.type === 'decl') {
        var n = t.value
        n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && ((t.return = ''), (t.value = ''))
      }
    }
  function hf(e, t) {
    switch (Kb(e, t)) {
      case 5103:
        return ze + 'print-' + e + e
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return ze + e + e
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return ze + e + ni + e + wt + e + e
      case 6828:
      case 4268:
        return ze + e + wt + e + e
      case 6165:
        return ze + e + wt + 'flex-' + e + e
      case 5187:
        return ze + e + Qe(e, /(\w+).+(:[^]+)/, ze + 'box-$1$2' + wt + 'flex-$1$2') + e
      case 5443:
        return ze + e + wt + 'flex-item-' + Qe(e, /flex-|-self/, '') + e
      case 4675:
        return ze + e + wt + 'flex-line-pack' + Qe(e, /align-content|flex-|-self/, '') + e
      case 5548:
        return ze + e + wt + Qe(e, 'shrink', 'negative') + e
      case 5292:
        return ze + e + wt + Qe(e, 'basis', 'preferred-size') + e
      case 6060:
        return ze + 'box-' + Qe(e, '-grow', '') + ze + e + wt + Qe(e, 'grow', 'positive') + e
      case 4554:
        return ze + Qe(e, /([^-])(transform)/g, '$1' + ze + '$2') + e
      case 6187:
        return Qe(Qe(Qe(e, /(zoom-|grab)/, ze + '$1'), /(image-set)/, ze + '$1'), e, '') + e
      case 5495:
      case 3959:
        return Qe(e, /(image-set\([^]*)/, ze + '$1$`$1')
      case 4968:
        return Qe(Qe(e, /(.+:)(flex-)?(.*)/, ze + 'box-pack:$3' + wt + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + ze + e + e
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return Qe(e, /(.+)-inline(.+)/, ze + '$1$2') + e
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (mn(e) - 1 - t > 6)
          switch (vt(e, t + 1)) {
            case 109:
              if (vt(e, t + 4) !== 45) break
            case 102:
              return Qe(e, /(.+:)(.+)-([^]+)/, '$1' + ze + '$2-$3$1' + ni + (vt(e, t + 3) == 108 ? '$3' : '$2-$3')) + e
            case 115:
              return ~Vl(e, 'stretch') ? hf(Qe(e, 'stretch', 'fill-available'), t) + e : e
          }
        break
      case 4949:
        if (vt(e, t + 1) !== 115) break
      case 6444:
        switch (vt(e, mn(e) - 3 - (~Vl(e, '!important') && 10))) {
          case 107:
            return Qe(e, ':', ':' + ze) + e
          case 101:
            return Qe(e, /(.+:)([^;!]+)(;|!.+)?/, '$1' + ze + (vt(e, 14) === 45 ? 'inline-' : '') + 'box$3$1' + ze + '$2$3$1' + wt + '$2box$3') + e
        }
        break
      case 5936:
        switch (vt(e, t + 11)) {
          case 114:
            return ze + e + wt + Qe(e, /[svh]\w+-[tblr]{2}/, 'tb') + e
          case 108:
            return ze + e + wt + Qe(e, /[svh]\w+-[tblr]{2}/, 'tb-rl') + e
          case 45:
            return ze + e + wt + Qe(e, /[svh]\w+-[tblr]{2}/, 'lr') + e
        }
        return ze + e + wt + e + e
    }
    return e
  }
  var Av = function (t, n, o, r) {
      if (t.length > -1 && !t.return)
        switch (t.type) {
          case Gl:
            t.return = hf(t.value, t.length)
            break
          case sf:
            return er([Wr(t, { value: Qe(t.value, '@', '@' + ze) })], r)
          case Wl:
            if (t.length)
              return Zb(t.props, function (s) {
                switch (qb(s, /(::plac\w+|:read-\w+)/)) {
                  case ':read-only':
                  case ':read-write':
                    return er([Wr(t, { props: [Qe(s, /:(read-\w+)/, ':' + ni + '$1')] })], r)
                  case '::placeholder':
                    return er([Wr(t, { props: [Qe(s, /:(plac\w+)/, ':' + ze + 'input-$1')] }), Wr(t, { props: [Qe(s, /:(plac\w+)/, ':' + ni + '$1')] }), Wr(t, { props: [Qe(s, /:(plac\w+)/, wt + 'input-$1')] })], r)
                }
                return ''
              })
        }
    },
    pv = [Av],
    gf = function (t) {
      var n = t.key
      if (n === 'css') {
        var o = document.querySelectorAll('style[data-emotion]:not([data-s])')
        Array.prototype.forEach.call(o, function (g) {
          var x = g.getAttribute('data-emotion')
          x.indexOf(' ') !== -1 && (document.head.appendChild(g), g.setAttribute('data-s', ''))
        })
      }
      var r = t.stylisPlugins || pv,
        s = {},
        i,
        a = []
      ;(i = t.container || document.head),
        Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function (g) {
          for (var x = g.getAttribute('data-emotion').split(' '), m = 1; m < x.length; m++) s[x[m]] = !0
          a.push(g)
        })
      var l,
        c = [dv, fv]
      {
        var u,
          d = [
            sv,
            av(function (g) {
              u.insert(g)
            }),
          ],
          f = iv(c.concat(r, d)),
          A = function (x) {
            return er(ov(x), f)
          }
        l = function (x, m, v, y) {
          ;(u = v), A(x ? x + '{' + m.styles + '}' : m.styles), y && (h.inserted[m.name] = !0)
        }
      }
      var h = { key: n, sheet: new Vb({ key: n, container: i, nonce: t.nonce, speedy: t.speedy, prepend: t.prepend, insertionPoint: t.insertionPoint }), nonce: t.nonce, inserted: s, registered: {}, insert: l }
      return h.sheet.hydrate(a), h
    },
    mf = { exports: {} },
    je = {}
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var mt = typeof Symbol == 'function' && Symbol.for,
    Hl = mt ? Symbol.for('react.element') : 60103,
    Ul = mt ? Symbol.for('react.portal') : 60106,
    ui = mt ? Symbol.for('react.fragment') : 60107,
    di = mt ? Symbol.for('react.strict_mode') : 60108,
    fi = mt ? Symbol.for('react.profiler') : 60114,
    Ai = mt ? Symbol.for('react.provider') : 60109,
    pi = mt ? Symbol.for('react.context') : 60110,
    Kl = mt ? Symbol.for('react.async_mode') : 60111,
    hi = mt ? Symbol.for('react.concurrent_mode') : 60111,
    gi = mt ? Symbol.for('react.forward_ref') : 60112,
    mi = mt ? Symbol.for('react.suspense') : 60113,
    hv = mt ? Symbol.for('react.suspense_list') : 60120,
    yi = mt ? Symbol.for('react.memo') : 60115,
    bi = mt ? Symbol.for('react.lazy') : 60116,
    gv = mt ? Symbol.for('react.block') : 60121,
    mv = mt ? Symbol.for('react.fundamental') : 60117,
    yv = mt ? Symbol.for('react.responder') : 60118,
    bv = mt ? Symbol.for('react.scope') : 60119
  function Qt(e) {
    if (typeof e == 'object' && e !== null) {
      var t = e.$$typeof
      switch (t) {
        case Hl:
          switch (((e = e.type), e)) {
            case Kl:
            case hi:
            case ui:
            case fi:
            case di:
            case mi:
              return e
            default:
              switch (((e = e && e.$$typeof), e)) {
                case pi:
                case gi:
                case bi:
                case yi:
                case Ai:
                  return e
                default:
                  return t
              }
          }
        case Ul:
          return t
      }
    }
  }
  function yf(e) {
    return Qt(e) === hi
  }
  ;(je.AsyncMode = Kl),
    (je.ConcurrentMode = hi),
    (je.ContextConsumer = pi),
    (je.ContextProvider = Ai),
    (je.Element = Hl),
    (je.ForwardRef = gi),
    (je.Fragment = ui),
    (je.Lazy = bi),
    (je.Memo = yi),
    (je.Portal = Ul),
    (je.Profiler = fi),
    (je.StrictMode = di),
    (je.Suspense = mi),
    (je.isAsyncMode = function (e) {
      return yf(e) || Qt(e) === Kl
    }),
    (je.isConcurrentMode = yf),
    (je.isContextConsumer = function (e) {
      return Qt(e) === pi
    }),
    (je.isContextProvider = function (e) {
      return Qt(e) === Ai
    }),
    (je.isElement = function (e) {
      return typeof e == 'object' && e !== null && e.$$typeof === Hl
    }),
    (je.isForwardRef = function (e) {
      return Qt(e) === gi
    }),
    (je.isFragment = function (e) {
      return Qt(e) === ui
    }),
    (je.isLazy = function (e) {
      return Qt(e) === bi
    }),
    (je.isMemo = function (e) {
      return Qt(e) === yi
    }),
    (je.isPortal = function (e) {
      return Qt(e) === Ul
    }),
    (je.isProfiler = function (e) {
      return Qt(e) === fi
    }),
    (je.isStrictMode = function (e) {
      return Qt(e) === di
    }),
    (je.isSuspense = function (e) {
      return Qt(e) === mi
    }),
    (je.isValidElementType = function (e) {
      return (
        typeof e == 'string' ||
        typeof e == 'function' ||
        e === ui ||
        e === hi ||
        e === fi ||
        e === di ||
        e === mi ||
        e === hv ||
        (typeof e == 'object' && e !== null && (e.$$typeof === bi || e.$$typeof === yi || e.$$typeof === Ai || e.$$typeof === pi || e.$$typeof === gi || e.$$typeof === mv || e.$$typeof === yv || e.$$typeof === bv || e.$$typeof === gv))
      )
    }),
    (je.typeOf = Qt),
    (mf.exports = je)
  var vv = mf.exports,
    bf = vv,
    xv = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 },
    Cv = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 },
    vf = {}
  ;(vf[bf.ForwardRef] = xv), (vf[bf.Memo] = Cv)
  var wv = !0
  function xf(e, t, n) {
    var o = ''
    return (
      n.split(' ').forEach(function (r) {
        e[r] !== void 0 ? t.push(e[r] + ';') : r && (o += r + ' ')
      }),
      o
    )
  }
  var ql = function (t, n, o) {
      var r = t.key + '-' + n.name
      ;(o === !1 || wv === !1) && t.registered[r] === void 0 && (t.registered[r] = n.styles)
    },
    Zl = function (t, n, o) {
      ql(t, n, o)
      var r = t.key + '-' + n.name
      if (t.inserted[n.name] === void 0) {
        var s = n
        do t.insert(n === s ? '.' + r : '', s, t.sheet, !0), (s = s.next)
        while (s !== void 0)
      }
    }
  function Ev(e) {
    for (var t = 0, n, o = 0, r = e.length; r >= 4; ++o, r -= 4)
      (n = (e.charCodeAt(o) & 255) | ((e.charCodeAt(++o) & 255) << 8) | ((e.charCodeAt(++o) & 255) << 16) | ((e.charCodeAt(++o) & 255) << 24)), (n = (n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)), (n ^= n >>> 24), (t = ((n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)) ^ ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)))
    switch (r) {
      case 3:
        t ^= (e.charCodeAt(o + 2) & 255) << 16
      case 2:
        t ^= (e.charCodeAt(o + 1) & 255) << 8
      case 1:
        ;(t ^= e.charCodeAt(o) & 255), (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16))
    }
    return (t ^= t >>> 13), (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)), ((t ^ (t >>> 15)) >>> 0).toString(36)
  }
  var Sv = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      scale: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
    },
    Bv = /[A-Z]|^ms/g,
    Iv = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
    Cf = function (t) {
      return t.charCodeAt(1) === 45
    },
    wf = function (t) {
      return t != null && typeof t != 'boolean'
    },
    Jl = Af(function (e) {
      return Cf(e) ? e : e.replace(Bv, '-$&').toLowerCase()
    }),
    Ef = function (t, n) {
      switch (t) {
        case 'animation':
        case 'animationName':
          if (typeof n == 'string')
            return n.replace(Iv, function (o, r, s) {
              return (bn = { name: r, styles: s, next: bn }), r
            })
      }
      return Sv[t] !== 1 && !Cf(t) && typeof n == 'number' && n !== 0 ? n + 'px' : n
    }
  function Xr(e, t, n) {
    if (n == null) return ''
    var o = n
    if (o.__emotion_styles !== void 0) return o
    switch (typeof n) {
      case 'boolean':
        return ''
      case 'object': {
        var r = n
        if (r.anim === 1) return (bn = { name: r.name, styles: r.styles, next: bn }), r.name
        var s = n
        if (s.styles !== void 0) {
          var i = s.next
          if (i !== void 0) for (; i !== void 0; ) (bn = { name: i.name, styles: i.styles, next: bn }), (i = i.next)
          var a = s.styles + ';'
          return a
        }
        return kv(e, t, n)
      }
      case 'function': {
        if (e !== void 0) {
          var l = bn,
            c = n(e)
          return (bn = l), Xr(e, t, c)
        }
        break
      }
    }
    var u = n
    if (t == null) return u
    var d = t[u]
    return d !== void 0 ? d : u
  }
  function kv(e, t, n) {
    var o = ''
    if (Array.isArray(n)) for (var r = 0; r < n.length; r++) o += Xr(e, t, n[r]) + ';'
    else
      for (var s in n) {
        var i = n[s]
        if (typeof i != 'object') {
          var a = i
          t != null && t[a] !== void 0 ? (o += s + '{' + t[a] + '}') : wf(a) && (o += Jl(s) + ':' + Ef(s, a) + ';')
        } else if (Array.isArray(i) && typeof i[0] == 'string' && (t == null || t[i[0]] === void 0)) for (var l = 0; l < i.length; l++) wf(i[l]) && (o += Jl(s) + ':' + Ef(s, i[l]) + ';')
        else {
          var c = Xr(e, t, i)
          switch (s) {
            case 'animation':
            case 'animationName': {
              o += Jl(s) + ':' + c + ';'
              break
            }
            default:
              o += s + '{' + c + '}'
          }
        }
      }
    return o
  }
  var Sf = /label:\s*([^\s;{]+)\s*(;|$)/g,
    bn
  function vi(e, t, n) {
    if (e.length === 1 && typeof e[0] == 'object' && e[0] !== null && e[0].styles !== void 0) return e[0]
    var o = !0,
      r = ''
    bn = void 0
    var s = e[0]
    if (s == null || s.raw === void 0) (o = !1), (r += Xr(n, t, s))
    else {
      var i = s
      r += i[0]
    }
    for (var a = 1; a < e.length; a++)
      if (((r += Xr(n, t, e[a])), o)) {
        var l = s
        r += l[a]
      }
    Sf.lastIndex = 0
    for (var c = '', u; (u = Sf.exec(r)) !== null; ) c += '-' + u[1]
    var d = Ev(r) + c
    return { name: d, styles: r, next: bn }
  }
  var Nv = function (t) {
      return t()
    },
    Bf = N.useInsertionEffect ? N.useInsertionEffect : !1,
    If = Bf || Nv,
    kf = Bf || N.useLayoutEffect,
    Mv = !1,
    Nf = N.createContext(typeof HTMLElement < 'u' ? gf({ key: 'css' }) : null),
    Pv = Nf.Provider,
    _l = function (t) {
      return C.forwardRef(function (n, o) {
        var r = C.useContext(Nf)
        return t(n, r, o)
      })
    },
    tr = N.createContext({}),
    $l = {}.hasOwnProperty,
    ec = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__',
    Lv = function (t, n) {
      var o = {}
      for (var r in n) $l.call(n, r) && (o[r] = n[r])
      return (o[ec] = t), o
    },
    Tv = function (t) {
      var n = t.cache,
        o = t.serialized,
        r = t.isStringTag
      return (
        ql(n, o, r),
        If(function () {
          return Zl(n, o, r)
        }),
        null
      )
    },
    Fv = _l(function (e, t, n) {
      var o = e.css
      typeof o == 'string' && t.registered[o] !== void 0 && (o = t.registered[o])
      var r = e[ec],
        s = [o],
        i = ''
      typeof e.className == 'string' ? (i = xf(t.registered, s, e.className)) : e.className != null && (i = e.className + ' ')
      var a = vi(s, void 0, N.useContext(tr))
      i += t.key + '-' + a.name
      var l = {}
      for (var c in e) $l.call(e, c) && c !== 'css' && c !== ec && !Mv && (l[c] = e[c])
      return (l.className = i), n && (l.ref = n), N.createElement(N.Fragment, null, N.createElement(Tv, { cache: t, serialized: a, isStringTag: typeof r == 'string' }), N.createElement(r, l))
    }),
    Dv = Fv,
    tc = { exports: {} },
    Mf
  function Pf() {
    return (
      Mf ||
        ((Mf = 1),
        (function (e) {
          function t() {
            return (
              (e.exports = t =
                Object.assign
                  ? Object.assign.bind()
                  : function (n) {
                      for (var o = 1; o < arguments.length; o++) {
                        var r = arguments[o]
                        for (var s in r) ({}.hasOwnProperty.call(r, s) && (n[s] = r[s]))
                      }
                      return n
                    }),
              (e.exports.__esModule = !0),
              (e.exports.default = e.exports),
              t.apply(null, arguments)
            )
          }
          ;(e.exports = t), (e.exports.__esModule = !0), (e.exports.default = e.exports)
        })(tc)),
      tc.exports
    )
  }
  Pf()
  var zv = function (t, n) {
    var o = arguments
    if (n == null || !$l.call(n, 'css')) return N.createElement.apply(void 0, o)
    var r = o.length,
      s = new Array(r)
    ;(s[0] = Dv), (s[1] = Lv(t, n))
    for (var i = 2; i < r; i++) s[i] = o[i]
    return N.createElement.apply(null, s)
  }
  ;(function (e) {
    var t
    t || (t = e.JSX || (e.JSX = {}))
  })(zv)
  var Qv = _l(function (e, t) {
    var n = e.styles,
      o = vi([n], void 0, N.useContext(tr)),
      r = N.useRef()
    return (
      kf(
        function () {
          var s = t.key + '-global',
            i = new t.sheet.constructor({ key: s, nonce: t.sheet.nonce, container: t.sheet.container, speedy: t.sheet.isSpeedy }),
            a = !1,
            l = document.querySelector('style[data-emotion="' + s + ' ' + o.name + '"]')
          return (
            t.sheet.tags.length && (i.before = t.sheet.tags[0]),
            l !== null && ((a = !0), l.setAttribute('data-emotion', s), i.hydrate([l])),
            (r.current = [i, a]),
            function () {
              i.flush()
            }
          )
        },
        [t]
      ),
      kf(
        function () {
          var s = r.current,
            i = s[0],
            a = s[1]
          if (a) {
            s[1] = !1
            return
          }
          if ((o.next !== void 0 && Zl(t, o.next, !0), i.tags.length)) {
            var l = i.tags[i.tags.length - 1].nextElementSibling
            ;(i.before = l), i.flush()
          }
          t.insert('', o, i, !1)
        },
        [t, o.name]
      ),
      null
    )
  })
  function Lf() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n]
    return vi(t)
  }
  function xi() {
    var e = Lf.apply(void 0, arguments),
      t = 'animation-' + e.name
    return {
      name: t,
      styles: '@keyframes ' + t + '{' + e.styles + '}',
      anim: 1,
      toString: function () {
        return '_EMO_' + this.name + '_' + this.styles + '_EMO_'
      },
    }
  }
  var Rv =
      /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
    Ov = Af(function (e) {
      return Rv.test(e) || (e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91)
    }),
    jv = Ov,
    Wv = function (t) {
      return t !== 'theme'
    },
    Tf = function (t) {
      return typeof t == 'string' && t.charCodeAt(0) > 96 ? jv : Wv
    },
    Ff = function (t, n, o) {
      var r
      if (n) {
        var s = n.shouldForwardProp
        r =
          t.__emotion_forwardProp && s
            ? function (i) {
                return t.__emotion_forwardProp(i) && s(i)
              }
            : s
      }
      return typeof r != 'function' && o && (r = t.__emotion_forwardProp), r
    },
    Gv = function (t) {
      var n = t.cache,
        o = t.serialized,
        r = t.isStringTag
      return (
        ql(n, o, r),
        If(function () {
          return Zl(n, o, r)
        }),
        null
      )
    },
    Vv = function e(t, n) {
      var o = t.__emotion_real === t,
        r = (o && t.__emotion_base) || t,
        s,
        i
      n !== void 0 && ((s = n.label), (i = n.target))
      var a = Ff(t, n, o),
        l = a || Tf(r),
        c = !l('as')
      return function () {
        var u = arguments,
          d = o && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : []
        if ((s !== void 0 && d.push('label:' + s + ';'), u[0] == null || u[0].raw === void 0)) d.push.apply(d, u)
        else {
          var f = u[0]
          d.push(f[0])
          for (var A = u.length, h = 1; h < A; h++) d.push(u[h], f[h])
        }
        var g = _l(function (x, m, v) {
          var y = (c && x.as) || r,
            b = '',
            w = [],
            k = x
          if (x.theme == null) {
            k = {}
            for (var E in x) k[E] = x[E]
            k.theme = N.useContext(tr)
          }
          typeof x.className == 'string' ? (b = xf(m.registered, w, x.className)) : x.className != null && (b = x.className + ' ')
          var P = vi(d.concat(w), m.registered, k)
          ;(b += m.key + '-' + P.name), i !== void 0 && (b += ' ' + i)
          var T = c && a === void 0 ? Tf(y) : l,
            F = {}
          for (var D in x) (c && D === 'as') || (T(D) && (F[D] = x[D]))
          return (F.className = b), v && (F.ref = v), N.createElement(N.Fragment, null, N.createElement(Gv, { cache: m, serialized: P, isStringTag: typeof y == 'string' }), N.createElement(y, F))
        })
        return (
          (g.displayName = s !== void 0 ? s : 'Styled(' + (typeof r == 'string' ? r : r.displayName || r.name || 'Component') + ')'),
          (g.defaultProps = t.defaultProps),
          (g.__emotion_real = g),
          (g.__emotion_base = r),
          (g.__emotion_styles = d),
          (g.__emotion_forwardProp = a),
          Object.defineProperty(g, 'toString', {
            value: function () {
              return '.' + i
            },
          }),
          (g.withComponent = function (x, m) {
            var v = e(x, M({}, n, m, { shouldForwardProp: Ff(g, m, !0) }))
            return v.apply(void 0, d)
          }),
          g
        )
      }
    },
    Xv = [
      'a',
      'abbr',
      'address',
      'area',
      'article',
      'aside',
      'audio',
      'b',
      'base',
      'bdi',
      'bdo',
      'big',
      'blockquote',
      'body',
      'br',
      'button',
      'canvas',
      'caption',
      'cite',
      'code',
      'col',
      'colgroup',
      'data',
      'datalist',
      'dd',
      'del',
      'details',
      'dfn',
      'dialog',
      'div',
      'dl',
      'dt',
      'em',
      'embed',
      'fieldset',
      'figcaption',
      'figure',
      'footer',
      'form',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'head',
      'header',
      'hgroup',
      'hr',
      'html',
      'i',
      'iframe',
      'img',
      'input',
      'ins',
      'kbd',
      'keygen',
      'label',
      'legend',
      'li',
      'link',
      'main',
      'map',
      'mark',
      'marquee',
      'menu',
      'menuitem',
      'meta',
      'meter',
      'nav',
      'noscript',
      'object',
      'ol',
      'optgroup',
      'option',
      'output',
      'p',
      'param',
      'picture',
      'pre',
      'progress',
      'q',
      'rp',
      'rt',
      'ruby',
      's',
      'samp',
      'script',
      'section',
      'select',
      'small',
      'source',
      'span',
      'strong',
      'style',
      'sub',
      'summary',
      'sup',
      'table',
      'tbody',
      'td',
      'textarea',
      'tfoot',
      'th',
      'thead',
      'time',
      'title',
      'tr',
      'track',
      'u',
      'ul',
      'var',
      'video',
      'wbr',
      'circle',
      'clipPath',
      'defs',
      'ellipse',
      'foreignObject',
      'g',
      'image',
      'line',
      'linearGradient',
      'mask',
      'path',
      'pattern',
      'polygon',
      'polyline',
      'radialGradient',
      'rect',
      'stop',
      'svg',
      'text',
      'tspan',
    ],
    nc = Vv.bind(null)
  Xv.forEach(function (e) {
    nc[e] = nc(e)
  })
  let oc
  typeof document == 'object' && (oc = gf({ key: 'css', prepend: !0 }))
  function Yv(e) {
    const { injectFirst: t, children: n } = e
    return t && oc ? p.jsx(Pv, { value: oc, children: n }) : n
  }
  function Hv(e) {
    return e == null || Object.keys(e).length === 0
  }
  function Df(e) {
    const { styles: t, defaultTheme: n = {} } = e,
      o = typeof t == 'function' ? r => t(Hv(r) ? n : r) : t
    return p.jsx(Qv, { styles: o })
  }
  function rc(e, t) {
    return nc(e, t)
  }
  const zf = (e, t) => {
      Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles))
    },
    Uv = Object.freeze(Object.defineProperty({ __proto__: null, GlobalStyles: Df, StyledEngineProvider: Yv, ThemeContext: tr, css: Lf, default: rc, internal_processStyles: zf, keyframes: xi }, Symbol.toStringTag, { value: 'Module' }))
  function Pn(e) {
    if (typeof e != 'object' || e === null) return !1
    const t = Object.getPrototypeOf(e)
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
  }
  function Qf(e) {
    if (N.isValidElement(e) || !Pn(e)) return e
    const t = {}
    return (
      Object.keys(e).forEach(n => {
        t[n] = Qf(e[n])
      }),
      t
    )
  }
  function po(e, t, n = { clone: !0 }) {
    const o = n.clone ? M({}, e) : e
    return (
      Pn(e) &&
        Pn(t) &&
        Object.keys(t).forEach(r => {
          N.isValidElement(t[r]) ? (o[r] = t[r]) : Pn(t[r]) && Object.prototype.hasOwnProperty.call(e, r) && Pn(e[r]) ? (o[r] = po(e[r], t[r], n)) : n.clone ? (o[r] = Pn(t[r]) ? Qf(t[r]) : t[r]) : (o[r] = t[r])
        }),
      o
    )
  }
  const Kv = Object.freeze(Object.defineProperty({ __proto__: null, default: po, isPlainObject: Pn }, Symbol.toStringTag, { value: 'Module' })),
    qv = ['values', 'unit', 'step'],
    Zv = e => {
      const t = Object.keys(e).map(n => ({ key: n, val: e[n] })) || []
      return t.sort((n, o) => n.val - o.val), t.reduce((n, o) => M({}, n, { [o.key]: o.val }), {})
    }
  function Rf(e) {
    const { values: t = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 }, unit: n = 'px', step: o = 5 } = e,
      r = he(e, qv),
      s = Zv(t),
      i = Object.keys(s)
    function a(f) {
      return `@media (min-width:${typeof t[f] == 'number' ? t[f] : f}${n})`
    }
    function l(f) {
      return `@media (max-width:${(typeof t[f] == 'number' ? t[f] : f) - o / 100}${n})`
    }
    function c(f, A) {
      const h = i.indexOf(A)
      return `@media (min-width:${typeof t[f] == 'number' ? t[f] : f}${n}) and (max-width:${(h !== -1 && typeof t[i[h]] == 'number' ? t[i[h]] : A) - o / 100}${n})`
    }
    function u(f) {
      return i.indexOf(f) + 1 < i.length ? c(f, i[i.indexOf(f) + 1]) : a(f)
    }
    function d(f) {
      const A = i.indexOf(f)
      return A === 0 ? a(i[1]) : A === i.length - 1 ? l(i[A]) : c(f, i[i.indexOf(f) + 1]).replace('@media', '@media not all and')
    }
    return M({ keys: i, values: s, up: a, down: l, between: c, only: u, not: d, unit: n }, r)
  }
  const Jv = { borderRadius: 4 }
  function Yr(e, t) {
    return t ? po(e, t, { clone: !1 }) : e
  }
  const sc = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
    Of = { keys: ['xs', 'sm', 'md', 'lg', 'xl'], up: e => `@media (min-width:${sc[e]}px)` }
  function on(e, t, n) {
    const o = e.theme || {}
    if (Array.isArray(t)) {
      const s = o.breakpoints || Of
      return t.reduce((i, a, l) => ((i[s.up(s.keys[l])] = n(t[l])), i), {})
    }
    if (typeof t == 'object') {
      const s = o.breakpoints || Of
      return Object.keys(t).reduce((i, a) => {
        if (Object.keys(s.values || sc).indexOf(a) !== -1) {
          const l = s.up(a)
          i[l] = n(t[a], a)
        } else {
          const l = a
          i[l] = t[l]
        }
        return i
      }, {})
    }
    return n(t)
  }
  function jf(e = {}) {
    var t
    return (
      ((t = e.keys) == null
        ? void 0
        : t.reduce((o, r) => {
            const s = e.up(r)
            return (o[s] = {}), o
          }, {})) || {}
    )
  }
  function Wf(e, t) {
    return e.reduce((n, o) => {
      const r = n[o]
      return (!r || Object.keys(r).length === 0) && delete n[o], n
    }, t)
  }
  function _v(e, ...t) {
    const n = jf(e),
      o = [n, ...t].reduce((r, s) => po(r, s), {})
    return Wf(Object.keys(n), o)
  }
  function $v(e, t) {
    if (typeof e != 'object') return {}
    const n = {},
      o = Object.keys(t)
    return (
      Array.isArray(e)
        ? o.forEach((r, s) => {
            s < e.length && (n[r] = !0)
          })
        : o.forEach(r => {
            e[r] != null && (n[r] = !0)
          }),
      n
    )
  }
  function ic({ values: e, breakpoints: t, base: n }) {
    const o = n || $v(e, t),
      r = Object.keys(o)
    if (r.length === 0) return e
    let s
    return r.reduce((i, a, l) => (Array.isArray(e) ? ((i[a] = e[l] != null ? e[l] : e[s]), (s = l)) : typeof e == 'object' ? ((i[a] = e[a] != null ? e[a] : e[s]), (s = a)) : (i[a] = e), i), {})
  }
  function ac(e) {
    if (typeof e != 'string') throw new Error(of(7))
    return e.charAt(0).toUpperCase() + e.slice(1)
  }
  const ex = Object.freeze(Object.defineProperty({ __proto__: null, default: ac }, Symbol.toStringTag, { value: 'Module' }))
  function Ci(e, t, n = !0) {
    if (!t || typeof t != 'string') return null
    if (e && e.vars && n) {
      const o = `vars.${t}`.split('.').reduce((r, s) => (r && r[s] ? r[s] : null), e)
      if (o != null) return o
    }
    return t.split('.').reduce((o, r) => (o && o[r] != null ? o[r] : null), e)
  }
  function wi(e, t, n, o = n) {
    let r
    return typeof e == 'function' ? (r = e(n)) : Array.isArray(e) ? (r = e[n] || o) : (r = Ci(e, n) || o), t && (r = t(r, o, e)), r
  }
  function lt(e) {
    const { prop: t, cssProperty: n = e.prop, themeKey: o, transform: r } = e,
      s = i => {
        if (i[t] == null) return null
        const a = i[t],
          l = i.theme,
          c = Ci(l, o) || {}
        return on(i, a, d => {
          let f = wi(c, r, d)
          return d === f && typeof d == 'string' && (f = wi(c, r, `${t}${d === 'default' ? '' : ac(d)}`, d)), n === !1 ? f : { [n]: f }
        })
      }
    return (s.propTypes = {}), (s.filterProps = [t]), s
  }
  function tx(e) {
    const t = {}
    return n => (t[n] === void 0 && (t[n] = e(n)), t[n])
  }
  const nx = { m: 'margin', p: 'padding' },
    ox = { t: 'Top', r: 'Right', b: 'Bottom', l: 'Left', x: ['Left', 'Right'], y: ['Top', 'Bottom'] },
    Gf = { marginX: 'mx', marginY: 'my', paddingX: 'px', paddingY: 'py' },
    rx = tx(e => {
      if (e.length > 2)
        if (Gf[e]) e = Gf[e]
        else return [e]
      const [t, n] = e.split(''),
        o = nx[t],
        r = ox[n] || ''
      return Array.isArray(r) ? r.map(s => o + s) : [o + r]
    }),
    lc = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'],
    cc = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd']
  ;[...lc, ...cc]
  function Hr(e, t, n, o) {
    var r
    const s = (r = Ci(e, t, !1)) != null ? r : n
    return typeof s == 'number' ? i => (typeof i == 'string' ? i : s * i) : Array.isArray(s) ? i => (typeof i == 'string' ? i : s[i]) : typeof s == 'function' ? s : () => {}
  }
  function uc(e) {
    return Hr(e, 'spacing', 8)
  }
  function ho(e, t) {
    if (typeof t == 'string' || t == null) return t
    const n = Math.abs(t),
      o = e(n)
    return t >= 0 ? o : typeof o == 'number' ? -o : `-${o}`
  }
  function sx(e, t) {
    return n => e.reduce((o, r) => ((o[r] = ho(t, n)), o), {})
  }
  function ix(e, t, n, o) {
    if (t.indexOf(n) === -1) return null
    const r = rx(n),
      s = sx(r, o),
      i = e[n]
    return on(e, i, s)
  }
  function Vf(e, t) {
    const n = uc(e.theme)
    return Object.keys(e)
      .map(o => ix(e, t, o, n))
      .reduce(Yr, {})
  }
  function ot(e) {
    return Vf(e, lc)
  }
  ;(ot.propTypes = {}), (ot.filterProps = lc)
  function rt(e) {
    return Vf(e, cc)
  }
  ;(rt.propTypes = {}), (rt.filterProps = cc)
  function ax(e = 8) {
    if (e.mui) return e
    const t = uc({ spacing: e }),
      n = (...o) =>
        (o.length === 0 ? [1] : o)
          .map(s => {
            const i = t(s)
            return typeof i == 'number' ? `${i}px` : i
          })
          .join(' ')
    return (n.mui = !0), n
  }
  function Ei(...e) {
    const t = e.reduce(
        (o, r) => (
          r.filterProps.forEach(s => {
            o[s] = r
          }),
          o
        ),
        {}
      ),
      n = o => Object.keys(o).reduce((r, s) => (t[s] ? Yr(r, t[s](o)) : r), {})
    return (n.propTypes = {}), (n.filterProps = e.reduce((o, r) => o.concat(r.filterProps), [])), n
  }
  function Yt(e) {
    return typeof e != 'number' ? e : `${e}px solid`
  }
  function Ht(e, t) {
    return lt({ prop: e, themeKey: 'borders', transform: t })
  }
  const lx = Ht('border', Yt),
    cx = Ht('borderTop', Yt),
    ux = Ht('borderRight', Yt),
    dx = Ht('borderBottom', Yt),
    fx = Ht('borderLeft', Yt),
    Ax = Ht('borderColor'),
    px = Ht('borderTopColor'),
    hx = Ht('borderRightColor'),
    gx = Ht('borderBottomColor'),
    mx = Ht('borderLeftColor'),
    yx = Ht('outline', Yt),
    bx = Ht('outlineColor'),
    Si = e => {
      if (e.borderRadius !== void 0 && e.borderRadius !== null) {
        const t = Hr(e.theme, 'shape.borderRadius', 4),
          n = o => ({ borderRadius: ho(t, o) })
        return on(e, e.borderRadius, n)
      }
      return null
    }
  ;(Si.propTypes = {}), (Si.filterProps = ['borderRadius']), Ei(lx, cx, ux, dx, fx, Ax, px, hx, gx, mx, Si, yx, bx)
  const Bi = e => {
    if (e.gap !== void 0 && e.gap !== null) {
      const t = Hr(e.theme, 'spacing', 8),
        n = o => ({ gap: ho(t, o) })
      return on(e, e.gap, n)
    }
    return null
  }
  ;(Bi.propTypes = {}), (Bi.filterProps = ['gap'])
  const Ii = e => {
    if (e.columnGap !== void 0 && e.columnGap !== null) {
      const t = Hr(e.theme, 'spacing', 8),
        n = o => ({ columnGap: ho(t, o) })
      return on(e, e.columnGap, n)
    }
    return null
  }
  ;(Ii.propTypes = {}), (Ii.filterProps = ['columnGap'])
  const ki = e => {
    if (e.rowGap !== void 0 && e.rowGap !== null) {
      const t = Hr(e.theme, 'spacing', 8),
        n = o => ({ rowGap: ho(t, o) })
      return on(e, e.rowGap, n)
    }
    return null
  }
  ;(ki.propTypes = {}), (ki.filterProps = ['rowGap'])
  const vx = lt({ prop: 'gridColumn' }),
    xx = lt({ prop: 'gridRow' }),
    Cx = lt({ prop: 'gridAutoFlow' }),
    wx = lt({ prop: 'gridAutoColumns' }),
    Ex = lt({ prop: 'gridAutoRows' }),
    Sx = lt({ prop: 'gridTemplateColumns' }),
    Bx = lt({ prop: 'gridTemplateRows' }),
    Ix = lt({ prop: 'gridTemplateAreas' }),
    kx = lt({ prop: 'gridArea' })
  Ei(Bi, Ii, ki, vx, xx, Cx, wx, Ex, Sx, Bx, Ix, kx)
  function nr(e, t) {
    return t === 'grey' ? t : e
  }
  const Nx = lt({ prop: 'color', themeKey: 'palette', transform: nr }),
    Mx = lt({ prop: 'bgcolor', cssProperty: 'backgroundColor', themeKey: 'palette', transform: nr }),
    Px = lt({ prop: 'backgroundColor', themeKey: 'palette', transform: nr })
  Ei(Nx, Mx, Px)
  function Rt(e) {
    return e <= 1 && e !== 0 ? `${e * 100}%` : e
  }
  const Lx = lt({ prop: 'width', transform: Rt }),
    dc = e => {
      if (e.maxWidth !== void 0 && e.maxWidth !== null) {
        const t = n => {
          var o, r
          const s = ((o = e.theme) == null || (o = o.breakpoints) == null || (o = o.values) == null ? void 0 : o[n]) || sc[n]
          return s ? (((r = e.theme) == null || (r = r.breakpoints) == null ? void 0 : r.unit) !== 'px' ? { maxWidth: `${s}${e.theme.breakpoints.unit}` } : { maxWidth: s }) : { maxWidth: Rt(n) }
        }
        return on(e, e.maxWidth, t)
      }
      return null
    }
  dc.filterProps = ['maxWidth']
  const Tx = lt({ prop: 'minWidth', transform: Rt }),
    Fx = lt({ prop: 'height', transform: Rt }),
    Dx = lt({ prop: 'maxHeight', transform: Rt }),
    zx = lt({ prop: 'minHeight', transform: Rt })
  lt({ prop: 'size', cssProperty: 'width', transform: Rt }), lt({ prop: 'size', cssProperty: 'height', transform: Rt })
  const Qx = lt({ prop: 'boxSizing' })
  Ei(Lx, dc, Tx, Fx, Dx, zx, Qx)
  const Ur = {
    border: { themeKey: 'borders', transform: Yt },
    borderTop: { themeKey: 'borders', transform: Yt },
    borderRight: { themeKey: 'borders', transform: Yt },
    borderBottom: { themeKey: 'borders', transform: Yt },
    borderLeft: { themeKey: 'borders', transform: Yt },
    borderColor: { themeKey: 'palette' },
    borderTopColor: { themeKey: 'palette' },
    borderRightColor: { themeKey: 'palette' },
    borderBottomColor: { themeKey: 'palette' },
    borderLeftColor: { themeKey: 'palette' },
    outline: { themeKey: 'borders', transform: Yt },
    outlineColor: { themeKey: 'palette' },
    borderRadius: { themeKey: 'shape.borderRadius', style: Si },
    color: { themeKey: 'palette', transform: nr },
    bgcolor: { themeKey: 'palette', cssProperty: 'backgroundColor', transform: nr },
    backgroundColor: { themeKey: 'palette', transform: nr },
    p: { style: rt },
    pt: { style: rt },
    pr: { style: rt },
    pb: { style: rt },
    pl: { style: rt },
    px: { style: rt },
    py: { style: rt },
    padding: { style: rt },
    paddingTop: { style: rt },
    paddingRight: { style: rt },
    paddingBottom: { style: rt },
    paddingLeft: { style: rt },
    paddingX: { style: rt },
    paddingY: { style: rt },
    paddingInline: { style: rt },
    paddingInlineStart: { style: rt },
    paddingInlineEnd: { style: rt },
    paddingBlock: { style: rt },
    paddingBlockStart: { style: rt },
    paddingBlockEnd: { style: rt },
    m: { style: ot },
    mt: { style: ot },
    mr: { style: ot },
    mb: { style: ot },
    ml: { style: ot },
    mx: { style: ot },
    my: { style: ot },
    margin: { style: ot },
    marginTop: { style: ot },
    marginRight: { style: ot },
    marginBottom: { style: ot },
    marginLeft: { style: ot },
    marginX: { style: ot },
    marginY: { style: ot },
    marginInline: { style: ot },
    marginInlineStart: { style: ot },
    marginInlineEnd: { style: ot },
    marginBlock: { style: ot },
    marginBlockStart: { style: ot },
    marginBlockEnd: { style: ot },
    displayPrint: { cssProperty: !1, transform: e => ({ '@media print': { display: e } }) },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: { style: Bi },
    rowGap: { style: ki },
    columnGap: { style: Ii },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: { themeKey: 'zIndex' },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: { themeKey: 'shadows' },
    width: { transform: Rt },
    maxWidth: { style: dc },
    minWidth: { transform: Rt },
    height: { transform: Rt },
    maxHeight: { transform: Rt },
    minHeight: { transform: Rt },
    boxSizing: {},
    fontFamily: { themeKey: 'typography' },
    fontSize: { themeKey: 'typography' },
    fontStyle: { themeKey: 'typography' },
    fontWeight: { themeKey: 'typography' },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: { cssProperty: !1, themeKey: 'typography' },
  }
  function Rx(...e) {
    const t = e.reduce((o, r) => o.concat(Object.keys(r)), []),
      n = new Set(t)
    return e.every(o => n.size === Object.keys(o).length)
  }
  function Ox(e, t) {
    return typeof e == 'function' ? e(t) : e
  }
  function Xf() {
    function e(n, o, r, s) {
      const i = { [n]: o, theme: r },
        a = s[n]
      if (!a) return { [n]: o }
      const { cssProperty: l = n, themeKey: c, transform: u, style: d } = a
      if (o == null) return null
      if (c === 'typography' && o === 'inherit') return { [n]: o }
      const f = Ci(r, c) || {}
      return d
        ? d(i)
        : on(i, o, h => {
            let g = wi(f, u, h)
            return h === g && typeof h == 'string' && (g = wi(f, u, `${n}${h === 'default' ? '' : ac(h)}`, h)), l === !1 ? g : { [l]: g }
          })
    }
    function t(n) {
      var o
      const { sx: r, theme: s = {} } = n || {}
      if (!r) return null
      const i = (o = s.unstable_sxConfig) != null ? o : Ur
      function a(l) {
        let c = l
        if (typeof l == 'function') c = l(s)
        else if (typeof l != 'object') return l
        if (!c) return null
        const u = jf(s.breakpoints),
          d = Object.keys(u)
        let f = u
        return (
          Object.keys(c).forEach(A => {
            const h = Ox(c[A], s)
            if (h != null)
              if (typeof h == 'object')
                if (i[A]) f = Yr(f, e(A, h, s, i))
                else {
                  const g = on({ theme: s }, h, x => ({ [A]: x }))
                  Rx(g, h) ? (f[A] = t({ sx: h, theme: s })) : (f = Yr(f, g))
                }
              else f = Yr(f, e(A, h, s, i))
          }),
          Wf(d, f)
        )
      }
      return Array.isArray(r) ? r.map(a) : a(r)
    }
    return t
  }
  const or = Xf()
  or.filterProps = ['sx']
  function Yf(e, t) {
    const n = this
    return n.vars && typeof n.getColorSchemeSelector == 'function' ? { [n.getColorSchemeSelector(e).replace(/(\[[^\]]+\])/, '*:where($1)')]: t } : n.palette.mode === e ? t : {}
  }
  const jx = ['breakpoints', 'palette', 'spacing', 'shape']
  function Kr(e = {}, ...t) {
    const { breakpoints: n = {}, palette: o = {}, spacing: r, shape: s = {} } = e,
      i = he(e, jx),
      a = Rf(n),
      l = ax(r)
    let c = po({ breakpoints: a, direction: 'ltr', components: {}, palette: M({ mode: 'light' }, o), spacing: l, shape: M({}, Jv, s) }, i)
    return (
      (c.applyStyles = Yf),
      (c = t.reduce((u, d) => po(u, d), c)),
      (c.unstable_sxConfig = M({}, Ur, i == null ? void 0 : i.unstable_sxConfig)),
      (c.unstable_sx = function (d) {
        return or({ sx: d, theme: this })
      }),
      c
    )
  }
  const Wx = Object.freeze(Object.defineProperty({ __proto__: null, default: Kr, private_createBreakpoints: Rf, unstable_applyStyles: Yf }, Symbol.toStringTag, { value: 'Module' }))
  function Gx(e) {
    return Object.keys(e).length === 0
  }
  function Hf(e = null) {
    const t = N.useContext(tr)
    return !t || Gx(t) ? e : t
  }
  const Vx = Kr()
  function Ni(e = Vx) {
    return Hf(e)
  }
  function Xx({ styles: e, themeId: t, defaultTheme: n = {} }) {
    const o = Ni(n),
      r = typeof e == 'function' ? e((t && o[t]) || o) : e
    return p.jsx(Df, { styles: r })
  }
  const Yx = ['sx'],
    Hx = e => {
      var t, n
      const o = { systemProps: {}, otherProps: {} },
        r = (t = e == null || (n = e.theme) == null ? void 0 : n.unstable_sxConfig) != null ? t : Ur
      return (
        Object.keys(e).forEach(s => {
          r[s] ? (o.systemProps[s] = e[s]) : (o.otherProps[s] = e[s])
        }),
        o
      )
    }
  function Mi(e) {
    const { sx: t } = e,
      n = he(e, Yx),
      { systemProps: o, otherProps: r } = Hx(n)
    let s
    return (
      Array.isArray(t)
        ? (s = [o, ...t])
        : typeof t == 'function'
        ? (s = (...i) => {
            const a = t(...i)
            return Pn(a) ? M({}, o, a) : o
          })
        : (s = M({}, o, t)),
      M({}, r, { sx: s })
    )
  }
  const Ux = Object.freeze(Object.defineProperty({ __proto__: null, default: or, extendSxProp: Mi, unstable_createStyleFunctionSx: Xf, unstable_defaultSxConfig: Ur }, Symbol.toStringTag, { value: 'Module' })),
    Uf = e => e,
    Kx = (() => {
      let e = Uf
      return {
        configure(t) {
          e = t
        },
        generate(t) {
          return e(t)
        },
        reset() {
          e = Uf
        },
      }
    })()
  function Kf(e) {
    var t,
      n,
      o = ''
    if (typeof e == 'string' || typeof e == 'number') o += e
    else if (typeof e == 'object')
      if (Array.isArray(e)) {
        var r = e.length
        for (t = 0; t < r; t++) e[t] && (n = Kf(e[t])) && (o && (o += ' '), (o += n))
      } else for (n in e) e[n] && (o && (o += ' '), (o += n))
    return o
  }
  function fe() {
    for (var e, t, n = 0, o = '', r = arguments.length; n < r; n++) (e = arguments[n]) && (t = Kf(e)) && (o && (o += ' '), (o += t))
    return o
  }
  const qx = ['className', 'component']
  function Zx(e = {}) {
    const { themeId: t, defaultTheme: n, defaultClassName: o = 'MuiBox-root', generateClassName: r } = e,
      s = rc('div', { shouldForwardProp: a => a !== 'theme' && a !== 'sx' && a !== 'as' })(or)
    return N.forwardRef(function (l, c) {
      const u = Ni(n),
        d = Mi(l),
        { className: f, component: A = 'div' } = d,
        h = he(d, qx)
      return p.jsx(s, M({ as: A, ref: c, className: fe(f, r ? r(o) : o), theme: (t && u[t]) || u }, h))
    })
  }
  const Jx = { active: 'active', checked: 'checked', completed: 'completed', disabled: 'disabled', error: 'error', expanded: 'expanded', focused: 'focused', focusVisible: 'focusVisible', open: 'open', readOnly: 'readOnly', required: 'required', selected: 'selected' }
  function _x(e, t, n = 'Mui') {
    const o = Jx[t]
    return o ? `${n}-${o}` : `${Kx.generate(e)}-${t}`
  }
  var qf = { exports: {} },
    Xe = {}
  /**
   * @license React
   * react-is.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var fc = Symbol.for('react.transitional.element'),
    Ac = Symbol.for('react.portal'),
    Pi = Symbol.for('react.fragment'),
    Li = Symbol.for('react.strict_mode'),
    Ti = Symbol.for('react.profiler'),
    Fi = Symbol.for('react.consumer'),
    Di = Symbol.for('react.context'),
    zi = Symbol.for('react.forward_ref'),
    Qi = Symbol.for('react.suspense'),
    Ri = Symbol.for('react.suspense_list'),
    Oi = Symbol.for('react.memo'),
    ji = Symbol.for('react.lazy'),
    $x = Symbol.for('react.offscreen'),
    eC = Symbol.for('react.client.reference')
  function Ut(e) {
    if (typeof e == 'object' && e !== null) {
      var t = e.$$typeof
      switch (t) {
        case fc:
          switch (((e = e.type), e)) {
            case Pi:
            case Ti:
            case Li:
            case Qi:
            case Ri:
              return e
            default:
              switch (((e = e && e.$$typeof), e)) {
                case Di:
                case zi:
                case ji:
                case Oi:
                  return e
                case Fi:
                  return e
                default:
                  return t
              }
          }
        case Ac:
          return t
      }
    }
  }
  ;(Xe.ContextConsumer = Fi),
    (Xe.ContextProvider = Di),
    (Xe.Element = fc),
    (Xe.ForwardRef = zi),
    (Xe.Fragment = Pi),
    (Xe.Lazy = ji),
    (Xe.Memo = Oi),
    (Xe.Portal = Ac),
    (Xe.Profiler = Ti),
    (Xe.StrictMode = Li),
    (Xe.Suspense = Qi),
    (Xe.SuspenseList = Ri),
    (Xe.isContextConsumer = function (e) {
      return Ut(e) === Fi
    }),
    (Xe.isContextProvider = function (e) {
      return Ut(e) === Di
    }),
    (Xe.isElement = function (e) {
      return typeof e == 'object' && e !== null && e.$$typeof === fc
    }),
    (Xe.isForwardRef = function (e) {
      return Ut(e) === zi
    }),
    (Xe.isFragment = function (e) {
      return Ut(e) === Pi
    }),
    (Xe.isLazy = function (e) {
      return Ut(e) === ji
    }),
    (Xe.isMemo = function (e) {
      return Ut(e) === Oi
    }),
    (Xe.isPortal = function (e) {
      return Ut(e) === Ac
    }),
    (Xe.isProfiler = function (e) {
      return Ut(e) === Ti
    }),
    (Xe.isStrictMode = function (e) {
      return Ut(e) === Li
    }),
    (Xe.isSuspense = function (e) {
      return Ut(e) === Qi
    }),
    (Xe.isSuspenseList = function (e) {
      return Ut(e) === Ri
    }),
    (Xe.isValidElementType = function (e) {
      return typeof e == 'string' || typeof e == 'function' || e === Pi || e === Ti || e === Li || e === Qi || e === Ri || e === $x || (typeof e == 'object' && e !== null && (e.$$typeof === ji || e.$$typeof === Oi || e.$$typeof === Di || e.$$typeof === Fi || e.$$typeof === zi || e.$$typeof === eC || e.getModuleId !== void 0))
    }),
    (Xe.typeOf = Ut),
    (qf.exports = Xe)
  var Zf = qf.exports
  const tC = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/
  function Jf(e) {
    const t = `${e}`.match(tC)
    return (t && t[1]) || ''
  }
  function _f(e, t = '') {
    return e.displayName || e.name || Jf(e) || t
  }
  function $f(e, t, n) {
    const o = _f(t)
    return e.displayName || (o !== '' ? `${n}(${o})` : n)
  }
  function nC(e) {
    if (e != null) {
      if (typeof e == 'string') return e
      if (typeof e == 'function') return _f(e, 'Component')
      if (typeof e == 'object')
        switch (e.$$typeof) {
          case Zf.ForwardRef:
            return $f(e, e.render, 'ForwardRef')
          case Zf.Memo:
            return $f(e, e.type, 'memo')
          default:
            return
        }
    }
  }
  const oC = Object.freeze(Object.defineProperty({ __proto__: null, default: nC, getFunctionName: Jf }, Symbol.toStringTag, { value: 'Module' })),
    rC = ['ownerState'],
    sC = ['variants'],
    iC = ['name', 'slot', 'skipVariantsResolver', 'skipSx', 'overridesResolver']
  function aC(e) {
    return Object.keys(e).length === 0
  }
  function lC(e) {
    return typeof e == 'string' && e.charCodeAt(0) > 96
  }
  function pc(e) {
    return e !== 'ownerState' && e !== 'theme' && e !== 'sx' && e !== 'as'
  }
  const cC = Kr(),
    uC = e => e && e.charAt(0).toLowerCase() + e.slice(1)
  function Wi({ defaultTheme: e, theme: t, themeId: n }) {
    return aC(t) ? e : t[n] || t
  }
  function dC(e) {
    return e ? (t, n) => n[e] : null
  }
  function Gi(e, t) {
    let { ownerState: n } = t,
      o = he(t, rC)
    const r = typeof e == 'function' ? e(M({ ownerState: n }, o)) : e
    if (Array.isArray(r)) return r.flatMap(s => Gi(s, M({ ownerState: n }, o)))
    if (r && typeof r == 'object' && Array.isArray(r.variants)) {
      const { variants: s = [] } = r
      let a = he(r, sC)
      return (
        s.forEach(l => {
          let c = !0
          typeof l.props == 'function'
            ? (c = l.props(M({ ownerState: n }, o, n)))
            : Object.keys(l.props).forEach(u => {
                ;(n == null ? void 0 : n[u]) !== l.props[u] && o[u] !== l.props[u] && (c = !1)
              }),
            c && (Array.isArray(a) || (a = [a]), a.push(typeof l.style == 'function' ? l.style(M({ ownerState: n }, o, n)) : l.style))
        }),
        a
      )
    }
    return r
  }
  function fC(e = {}) {
    const { themeId: t, defaultTheme: n = cC, rootShouldForwardProp: o = pc, slotShouldForwardProp: r = pc } = e,
      s = i => or(M({}, i, { theme: Wi(M({}, i, { defaultTheme: n, themeId: t })) }))
    return (
      (s.__mui_systemSx = !0),
      (i, a = {}) => {
        zf(i, w => w.filter(k => !(k != null && k.__mui_systemSx)))
        const { name: l, slot: c, skipVariantsResolver: u, skipSx: d, overridesResolver: f = dC(uC(c)) } = a,
          A = he(a, iC),
          h = u !== void 0 ? u : (c && c !== 'Root' && c !== 'root') || !1,
          g = d || !1
        let x,
          m = pc
        c === 'Root' || c === 'root' ? (m = o) : c ? (m = r) : lC(i) && (m = void 0)
        const v = rc(i, M({ shouldForwardProp: m, label: x }, A)),
          y = w => ((typeof w == 'function' && w.__emotion_real !== w) || Pn(w) ? k => Gi(w, M({}, k, { theme: Wi({ theme: k.theme, defaultTheme: n, themeId: t }) })) : w),
          b = (w, ...k) => {
            let E = y(w)
            const P = k ? k.map(y) : []
            l &&
              f &&
              P.push(D => {
                const Q = Wi(M({}, D, { defaultTheme: n, themeId: t }))
                if (!Q.components || !Q.components[l] || !Q.components[l].styleOverrides) return null
                const R = Q.components[l].styleOverrides,
                  S = {}
                return (
                  Object.entries(R).forEach(([L, I]) => {
                    S[L] = Gi(I, M({}, D, { theme: Q }))
                  }),
                  f(D, S)
                )
              }),
              l &&
                !h &&
                P.push(D => {
                  var Q
                  const R = Wi(M({}, D, { defaultTheme: n, themeId: t })),
                    S = R == null || (Q = R.components) == null || (Q = Q[l]) == null ? void 0 : Q.variants
                  return Gi({ variants: S }, M({}, D, { theme: R }))
                }),
              g || P.push(s)
            const T = P.length - k.length
            if (Array.isArray(w) && T > 0) {
              const D = new Array(T).fill('')
              ;(E = [...w, ...D]), (E.raw = [...w.raw, ...D])
            }
            const F = v(E, ...P)
            return i.muiName && (F.muiName = i.muiName), F
          }
        return v.withConfig && (b.withConfig = v.withConfig), b
      }
    )
  }
  const AC = fC()
  function Vi(e, t) {
    const n = M({}, t)
    return (
      Object.keys(e).forEach(o => {
        if (o.toString().match(/^(components|slots)$/)) n[o] = M({}, e[o], n[o])
        else if (o.toString().match(/^(componentsProps|slotProps)$/)) {
          const r = e[o] || {},
            s = t[o]
          ;(n[o] = {}),
            !s || !Object.keys(s)
              ? (n[o] = r)
              : !r || !Object.keys(r)
              ? (n[o] = s)
              : ((n[o] = M({}, s)),
                Object.keys(r).forEach(i => {
                  n[o][i] = Vi(r[i], s[i])
                }))
        } else n[o] === void 0 && (n[o] = e[o])
      }),
      n
    )
  }
  function pC(e) {
    const { theme: t, name: n, props: o } = e
    return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? o : Vi(t.components[n].defaultProps, o)
  }
  function hC({ props: e, name: t, defaultTheme: n, themeId: o }) {
    let r = Ni(n)
    return o && (r = r[o] || r), pC({ theme: r, name: t, props: e })
  }
  function gC(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, n))
  }
  const mC = Object.freeze(Object.defineProperty({ __proto__: null, default: gC }, Symbol.toStringTag, { value: 'Module' })),
    eA = N.createContext(null)
  function tA() {
    return N.useContext(eA)
  }
  const yC = typeof Symbol == 'function' && Symbol.for ? Symbol.for('mui.nested') : '__THEME_NESTED__'
  function bC(e, t) {
    return typeof t == 'function' ? t(e) : M({}, e, t)
  }
  function vC(e) {
    const { children: t, theme: n } = e,
      o = tA(),
      r = N.useMemo(() => {
        const s = o === null ? n : bC(o, n)
        return s != null && (s[yC] = o !== null), s
      }, [n, o])
    return p.jsx(eA.Provider, { value: r, children: t })
  }
  const xC = ['value'],
    nA = N.createContext()
  function CC(e) {
    let { value: t } = e,
      n = he(e, xC)
    return p.jsx(nA.Provider, M({ value: t ?? !0 }, n))
  }
  const hc = () => {
      const e = N.useContext(nA)
      return e ?? !1
    },
    oA = N.createContext(void 0)
  function wC({ value: e, children: t }) {
    return p.jsx(oA.Provider, { value: e, children: t })
  }
  function EC(e) {
    const { theme: t, name: n, props: o } = e
    if (!t || !t.components || !t.components[n]) return o
    const r = t.components[n]
    return r.defaultProps ? Vi(r.defaultProps, o) : !r.styleOverrides && !r.variants ? Vi(r, o) : o
  }
  function SC({ props: e, name: t }) {
    const n = N.useContext(oA)
    return EC({ props: e, name: t, theme: { components: n } })
  }
  const rA = {}
  function sA(e, t, n, o = !1) {
    return N.useMemo(() => {
      const r = (e && t[e]) || t
      if (typeof n == 'function') {
        const s = n(r),
          i = e ? M({}, t, { [e]: s }) : s
        return o ? () => i : i
      }
      return e ? M({}, t, { [e]: n }) : M({}, t, n)
    }, [e, t, n, o])
  }
  function BC(e) {
    const { children: t, theme: n, themeId: o } = e,
      r = Hf(rA),
      s = tA() || rA,
      i = sA(o, r, n),
      a = sA(o, s, n, !0),
      l = i.direction === 'rtl'
    return p.jsx(vC, { theme: a, children: p.jsx(tr.Provider, { value: i, children: p.jsx(CC, { value: l, children: p.jsx(wC, { value: i == null ? void 0 : i.components, children: t }) }) }) })
  }
  function IC(e, t, n = void 0) {
    const o = {}
    return (
      Object.keys(e).forEach(r => {
        o[r] = e[r]
          .reduce((s, i) => {
            if (i) {
              const a = t(i)
              a !== '' && s.push(a), n && n[i] && s.push(n[i])
            }
            return s
          }, [])
          .join(' ')
      }),
      o
    )
  }
  const kC = ['component', 'direction', 'spacing', 'divider', 'children', 'className', 'useFlexGap'],
    NC = Kr(),
    MC = AC('div', { name: 'MuiStack', slot: 'Root', overridesResolver: (e, t) => t.root })
  function PC(e) {
    return hC({ props: e, name: 'MuiStack', defaultTheme: NC })
  }
  function LC(e, t) {
    const n = N.Children.toArray(e).filter(Boolean)
    return n.reduce((o, r, s) => (o.push(r), s < n.length - 1 && o.push(N.cloneElement(t, { key: `separator-${s}` })), o), [])
  }
  const TC = e => ({ row: 'Left', 'row-reverse': 'Right', column: 'Top', 'column-reverse': 'Bottom' }[e]),
    FC = ({ ownerState: e, theme: t }) => {
      let n = M(
        { display: 'flex', flexDirection: 'column' },
        on({ theme: t }, ic({ values: e.direction, breakpoints: t.breakpoints.values }), o => ({ flexDirection: o }))
      )
      if (e.spacing) {
        const o = uc(t),
          r = Object.keys(t.breakpoints.values).reduce((l, c) => (((typeof e.spacing == 'object' && e.spacing[c] != null) || (typeof e.direction == 'object' && e.direction[c] != null)) && (l[c] = !0), l), {}),
          s = ic({ values: e.direction, base: r }),
          i = ic({ values: e.spacing, base: r })
        typeof s == 'object' &&
          Object.keys(s).forEach((l, c, u) => {
            if (!s[l]) {
              const f = c > 0 ? s[u[c - 1]] : 'column'
              s[l] = f
            }
          }),
          (n = po(
            n,
            on({ theme: t }, i, (l, c) => (e.useFlexGap ? { gap: ho(o, l) } : { '& > :not(style):not(style)': { margin: 0 }, '& > :not(style) ~ :not(style)': { [`margin${TC(c ? s[c] : e.direction)}`]: ho(o, l) } }))
          ))
      }
      return (n = _v(t.breakpoints, n)), n
    }
  function DC(e = {}) {
    const { createStyledComponent: t = MC, useThemeProps: n = PC, componentName: o = 'MuiStack' } = e,
      r = () => IC({ root: ['root'] }, l => _x(o, l), {}),
      s = t(FC)
    return N.forwardRef(function (l, c) {
      const u = n(l),
        d = Mi(u),
        { component: f = 'div', direction: A = 'column', spacing: h = 0, divider: g, children: x, className: m, useFlexGap: v = !1 } = d,
        y = he(d, kC),
        b = { direction: A, spacing: h, useFlexGap: v },
        w = r()
      return p.jsx(s, M({ as: f, ownerState: b, ref: c, className: fe(w.root, m) }, y, { children: g ? LC(x, g) : x }))
    })
  }
  function rr(e) {
    if (typeof e != 'object' || e === null) return !1
    const t = Object.getPrototypeOf(e)
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
  }
  function iA(e) {
    if (N.isValidElement(e) || !rr(e)) return e
    const t = {}
    return (
      Object.keys(e).forEach(n => {
        t[n] = iA(e[n])
      }),
      t
    )
  }
  function Ln(e, t, n = { clone: !0 }) {
    const o = n.clone ? M({}, e) : e
    return (
      rr(e) &&
        rr(t) &&
        Object.keys(t).forEach(r => {
          N.isValidElement(t[r]) ? (o[r] = t[r]) : rr(t[r]) && Object.prototype.hasOwnProperty.call(e, r) && rr(e[r]) ? (o[r] = Ln(e[r], t[r], n)) : n.clone ? (o[r] = rr(t[r]) ? iA(t[r]) : t[r]) : (o[r] = t[r])
        }),
      o
    )
  }
  const aA = e => e,
    gc = (() => {
      let e = aA
      return {
        configure(t) {
          e = t
        },
        generate(t) {
          return e(t)
        },
        reset() {
          e = aA
        },
      }
    })(),
    zC = { active: 'active', checked: 'checked', completed: 'completed', disabled: 'disabled', error: 'error', expanded: 'expanded', focused: 'focused', focusVisible: 'focusVisible', open: 'open', readOnly: 'readOnly', required: 'required', selected: 'selected' }
  function Fe(e, t, n = 'Mui') {
    const o = zC[t]
    return o ? `${n}-${o}` : `${gc.generate(e)}-${t}`
  }
  function QC(e, t) {
    return M({ toolbar: { minHeight: 56, [e.up('xs')]: { '@media (orientation: landscape)': { minHeight: 48 } }, [e.up('sm')]: { minHeight: 64 } } }, t)
  }
  var ct = {},
    lA = { exports: {} }
  ;(function (e) {
    function t(n) {
      return n && n.__esModule ? n : { default: n }
    }
    ;(e.exports = t), (e.exports.__esModule = !0), (e.exports.default = e.exports)
  })(lA)
  var qr = lA.exports
  const RC = Mn(Ob),
    OC = Mn(mC)
  var cA = qr
  Object.defineProperty(ct, '__esModule', { value: !0 })
  var Bt = (ct.alpha = pA)
  ;(ct.blend = ZC), (ct.colorChannel = void 0)
  var mc = (ct.darken = vc)
  ;(ct.decomposeColor = Kt), (ct.emphasize = hA)
  var jC = (ct.getContrastRatio = YC)
  ;(ct.getLuminance = Xi), (ct.hexToRgb = dA), (ct.hslToRgb = AA)
  var yc = (ct.lighten = xc)
  ;(ct.private_safeAlpha = HC), (ct.private_safeColorChannel = void 0), (ct.private_safeDarken = UC), (ct.private_safeEmphasize = qC), (ct.private_safeLighten = KC), (ct.recomposeColor = sr), (ct.rgbToHex = XC)
  var uA = cA(RC),
    WC = cA(OC)
  function bc(e, t = 0, n = 1) {
    return (0, WC.default)(e, t, n)
  }
  function dA(e) {
    e = e.slice(1)
    const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, 'g')
    let n = e.match(t)
    return n && n[0].length === 1 && (n = n.map(o => o + o)), n ? `rgb${n.length === 4 ? 'a' : ''}(${n.map((o, r) => (r < 3 ? parseInt(o, 16) : Math.round((parseInt(o, 16) / 255) * 1e3) / 1e3)).join(', ')})` : ''
  }
  function GC(e) {
    const t = e.toString(16)
    return t.length === 1 ? `0${t}` : t
  }
  function Kt(e) {
    if (e.type) return e
    if (e.charAt(0) === '#') return Kt(dA(e))
    const t = e.indexOf('('),
      n = e.substring(0, t)
    if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(n) === -1) throw new Error((0, uA.default)(9, e))
    let o = e.substring(t + 1, e.length - 1),
      r
    if (n === 'color') {
      if (((o = o.split(' ')), (r = o.shift()), o.length === 4 && o[3].charAt(0) === '/' && (o[3] = o[3].slice(1)), ['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(r) === -1)) throw new Error((0, uA.default)(10, r))
    } else o = o.split(',')
    return (o = o.map(s => parseFloat(s))), { type: n, values: o, colorSpace: r }
  }
  const fA = e => {
    const t = Kt(e)
    return t.values
      .slice(0, 3)
      .map((n, o) => (t.type.indexOf('hsl') !== -1 && o !== 0 ? `${n}%` : n))
      .join(' ')
  }
  ct.colorChannel = fA
  const VC = (e, t) => {
    try {
      return fA(e)
    } catch {
      return e
    }
  }
  ct.private_safeColorChannel = VC
  function sr(e) {
    const { type: t, colorSpace: n } = e
    let { values: o } = e
    return t.indexOf('rgb') !== -1 ? (o = o.map((r, s) => (s < 3 ? parseInt(r, 10) : r))) : t.indexOf('hsl') !== -1 && ((o[1] = `${o[1]}%`), (o[2] = `${o[2]}%`)), t.indexOf('color') !== -1 ? (o = `${n} ${o.join(' ')}`) : (o = `${o.join(', ')}`), `${t}(${o})`
  }
  function XC(e) {
    if (e.indexOf('#') === 0) return e
    const { values: t } = Kt(e)
    return `#${t.map((n, o) => GC(o === 3 ? Math.round(255 * n) : n)).join('')}`
  }
  function AA(e) {
    e = Kt(e)
    const { values: t } = e,
      n = t[0],
      o = t[1] / 100,
      r = t[2] / 100,
      s = o * Math.min(r, 1 - r),
      i = (c, u = (c + n / 30) % 12) => r - s * Math.max(Math.min(u - 3, 9 - u, 1), -1)
    let a = 'rgb'
    const l = [Math.round(i(0) * 255), Math.round(i(8) * 255), Math.round(i(4) * 255)]
    return e.type === 'hsla' && ((a += 'a'), l.push(t[3])), sr({ type: a, values: l })
  }
  function Xi(e) {
    e = Kt(e)
    let t = e.type === 'hsl' || e.type === 'hsla' ? Kt(AA(e)).values : e.values
    return (t = t.map(n => (e.type !== 'color' && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4))), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3))
  }
  function YC(e, t) {
    const n = Xi(e),
      o = Xi(t)
    return (Math.max(n, o) + 0.05) / (Math.min(n, o) + 0.05)
  }
  function pA(e, t) {
    return (e = Kt(e)), (t = bc(t)), (e.type === 'rgb' || e.type === 'hsl') && (e.type += 'a'), e.type === 'color' ? (e.values[3] = `/${t}`) : (e.values[3] = t), sr(e)
  }
  function HC(e, t, n) {
    try {
      return pA(e, t)
    } catch {
      return e
    }
  }
  function vc(e, t) {
    if (((e = Kt(e)), (t = bc(t)), e.type.indexOf('hsl') !== -1)) e.values[2] *= 1 - t
    else if (e.type.indexOf('rgb') !== -1 || e.type.indexOf('color') !== -1) for (let n = 0; n < 3; n += 1) e.values[n] *= 1 - t
    return sr(e)
  }
  function UC(e, t, n) {
    try {
      return vc(e, t)
    } catch {
      return e
    }
  }
  function xc(e, t) {
    if (((e = Kt(e)), (t = bc(t)), e.type.indexOf('hsl') !== -1)) e.values[2] += (100 - e.values[2]) * t
    else if (e.type.indexOf('rgb') !== -1) for (let n = 0; n < 3; n += 1) e.values[n] += (255 - e.values[n]) * t
    else if (e.type.indexOf('color') !== -1) for (let n = 0; n < 3; n += 1) e.values[n] += (1 - e.values[n]) * t
    return sr(e)
  }
  function KC(e, t, n) {
    try {
      return xc(e, t)
    } catch {
      return e
    }
  }
  function hA(e, t = 0.15) {
    return Xi(e) > 0.5 ? vc(e, t) : xc(e, t)
  }
  function qC(e, t, n) {
    try {
      return hA(e, t)
    } catch {
      return e
    }
  }
  function ZC(e, t, n, o = 1) {
    const r = (l, c) => Math.round((l ** (1 / o) * (1 - n) + c ** (1 / o) * n) ** o),
      s = Kt(e),
      i = Kt(t),
      a = [r(s.values[0], i.values[0]), r(s.values[1], i.values[1]), r(s.values[2], i.values[2])]
    return sr({ type: 'rgb', values: a })
  }
  const JC = ['mode', 'contrastThreshold', 'tonalOffset'],
    gA = {
      text: { primary: 'rgba(0, 0, 0, 0.87)', secondary: 'rgba(0, 0, 0, 0.6)', disabled: 'rgba(0, 0, 0, 0.38)' },
      divider: 'rgba(0, 0, 0, 0.12)',
      background: { paper: Ko.white, default: Ko.white },
      action: { active: 'rgba(0, 0, 0, 0.54)', hover: 'rgba(0, 0, 0, 0.04)', hoverOpacity: 0.04, selected: 'rgba(0, 0, 0, 0.08)', selectedOpacity: 0.08, disabled: 'rgba(0, 0, 0, 0.26)', disabledBackground: 'rgba(0, 0, 0, 0.12)', disabledOpacity: 0.38, focus: 'rgba(0, 0, 0, 0.12)', focusOpacity: 0.12, activatedOpacity: 0.12 },
    },
    Cc = {
      text: { primary: Ko.white, secondary: 'rgba(255, 255, 255, 0.7)', disabled: 'rgba(255, 255, 255, 0.5)', icon: 'rgba(255, 255, 255, 0.5)' },
      divider: 'rgba(255, 255, 255, 0.12)',
      background: { paper: '#121212', default: '#121212' },
      action: { active: Ko.white, hover: 'rgba(255, 255, 255, 0.08)', hoverOpacity: 0.08, selected: 'rgba(255, 255, 255, 0.16)', selectedOpacity: 0.16, disabled: 'rgba(255, 255, 255, 0.3)', disabledBackground: 'rgba(255, 255, 255, 0.12)', disabledOpacity: 0.38, focus: 'rgba(255, 255, 255, 0.12)', focusOpacity: 0.12, activatedOpacity: 0.24 },
    }
  function mA(e, t, n, o) {
    const r = o.light || o,
      s = o.dark || o * 1.5
    e[t] || (e.hasOwnProperty(n) ? (e[t] = e[n]) : t === 'light' ? (e.light = yc(e.main, r)) : t === 'dark' && (e.dark = mc(e.main, s)))
  }
  function _C(e = 'light') {
    return e === 'dark' ? { main: uo[200], light: uo[50], dark: uo[400] } : { main: uo[700], light: uo[400], dark: uo[800] }
  }
  function $C(e = 'light') {
    return e === 'dark' ? { main: co[200], light: co[50], dark: co[400] } : { main: co[500], light: co[300], dark: co[700] }
  }
  function e1(e = 'light') {
    return e === 'dark' ? { main: lo[500], light: lo[300], dark: lo[700] } : { main: lo[700], light: lo[400], dark: lo[800] }
  }
  function t1(e = 'light') {
    return e === 'dark' ? { main: fo[400], light: fo[300], dark: fo[700] } : { main: fo[700], light: fo[500], dark: fo[900] }
  }
  function n1(e = 'light') {
    return e === 'dark' ? { main: Ao[400], light: Ao[300], dark: Ao[700] } : { main: Ao[800], light: Ao[500], dark: Ao[900] }
  }
  function o1(e = 'light') {
    return e === 'dark' ? { main: qo[400], light: qo[300], dark: qo[700] } : { main: '#ed6c02', light: qo[500], dark: qo[900] }
  }
  function r1(e) {
    const { mode: t = 'light', contrastThreshold: n = 3, tonalOffset: o = 0.2 } = e,
      r = he(e, JC),
      s = e.primary || _C(t),
      i = e.secondary || $C(t),
      a = e.error || e1(t),
      l = e.info || t1(t),
      c = e.success || n1(t),
      u = e.warning || o1(t)
    function d(g) {
      return jC(g, Cc.text.primary) >= n ? Cc.text.primary : gA.text.primary
    }
    const f = ({ color: g, name: x, mainShade: m = 500, lightShade: v = 300, darkShade: y = 700 }) => {
        if (((g = M({}, g)), !g.main && g[m] && (g.main = g[m]), !g.hasOwnProperty('main'))) throw new Error(Zo(11, x ? ` (${x})` : '', m))
        if (typeof g.main != 'string') throw new Error(Zo(12, x ? ` (${x})` : '', JSON.stringify(g.main)))
        return mA(g, 'light', v, o), mA(g, 'dark', y, o), g.contrastText || (g.contrastText = d(g.main)), g
      },
      A = { dark: Cc, light: gA }
    return Ln(
      M(
        {
          common: M({}, Ko),
          mode: t,
          primary: f({ color: s, name: 'primary' }),
          secondary: f({ color: i, name: 'secondary', mainShade: 'A400', lightShade: 'A200', darkShade: 'A700' }),
          error: f({ color: a, name: 'error' }),
          warning: f({ color: u, name: 'warning' }),
          info: f({ color: l, name: 'info' }),
          success: f({ color: c, name: 'success' }),
          grey: nf,
          contrastThreshold: n,
          getContrastText: d,
          augmentColor: f,
          tonalOffset: o,
        },
        A[t]
      ),
      r
    )
  }
  const s1 = ['fontFamily', 'fontSize', 'fontWeightLight', 'fontWeightRegular', 'fontWeightMedium', 'fontWeightBold', 'htmlFontSize', 'allVariants', 'pxToRem']
  function i1(e) {
    return Math.round(e * 1e5) / 1e5
  }
  const yA = { textTransform: 'uppercase' },
    bA = '"Roboto", "Helvetica", "Arial", sans-serif'
  function a1(e, t) {
    const n = typeof t == 'function' ? t(e) : t,
      { fontFamily: o = bA, fontSize: r = 14, fontWeightLight: s = 300, fontWeightRegular: i = 400, fontWeightMedium: a = 500, fontWeightBold: l = 700, htmlFontSize: c = 16, allVariants: u, pxToRem: d } = n,
      f = he(n, s1),
      A = r / 14,
      h = d || (m => `${(m / c) * A}rem`),
      g = (m, v, y, b, w) => M({ fontFamily: o, fontWeight: m, fontSize: h(v), lineHeight: y }, o === bA ? { letterSpacing: `${i1(b / v)}em` } : {}, w, u),
      x = {
        h1: g(s, 96, 1.167, -1.5),
        h2: g(s, 60, 1.2, -0.5),
        h3: g(i, 48, 1.167, 0),
        h4: g(i, 34, 1.235, 0.25),
        h5: g(i, 24, 1.334, 0),
        h6: g(a, 20, 1.6, 0.15),
        subtitle1: g(i, 16, 1.75, 0.15),
        subtitle2: g(a, 14, 1.57, 0.1),
        body1: g(i, 16, 1.5, 0.15),
        body2: g(i, 14, 1.43, 0.15),
        button: g(a, 14, 1.75, 0.4, yA),
        caption: g(i, 12, 1.66, 0.4),
        overline: g(i, 12, 2.66, 1, yA),
        inherit: { fontFamily: 'inherit', fontWeight: 'inherit', fontSize: 'inherit', lineHeight: 'inherit', letterSpacing: 'inherit' },
      }
    return Ln(M({ htmlFontSize: c, pxToRem: h, fontFamily: o, fontSize: r, fontWeightLight: s, fontWeightRegular: i, fontWeightMedium: a, fontWeightBold: l }, x), f, { clone: !1 })
  }
  const l1 = 0.2,
    c1 = 0.14,
    u1 = 0.12
  function _e(...e) {
    return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${l1})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${c1})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${u1})`].join(',')
  }
  const d1 = [
      'none',
      _e(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
      _e(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
      _e(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
      _e(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
      _e(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
      _e(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
      _e(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
      _e(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
      _e(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
      _e(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
      _e(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
      _e(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
      _e(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
      _e(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
      _e(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
      _e(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
      _e(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
      _e(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
      _e(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
      _e(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
      _e(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
      _e(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
      _e(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
      _e(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
    ],
    f1 = ['duration', 'easing', 'delay'],
    A1 = { easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)', easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)', easeIn: 'cubic-bezier(0.4, 0, 1, 1)', sharp: 'cubic-bezier(0.4, 0, 0.6, 1)' },
    p1 = { shortest: 150, shorter: 200, short: 250, standard: 300, complex: 375, enteringScreen: 225, leavingScreen: 195 }
  function vA(e) {
    return `${Math.round(e)}ms`
  }
  function h1(e) {
    if (!e) return 0
    const t = e / 36
    return Math.round((4 + 15 * t ** 0.25 + t / 5) * 10)
  }
  function g1(e) {
    const t = M({}, A1, e.easing),
      n = M({}, p1, e.duration)
    return M(
      {
        getAutoHeightDuration: h1,
        create: (r = ['all'], s = {}) => {
          const { duration: i = n.standard, easing: a = t.easeInOut, delay: l = 0 } = s
          return he(s, f1), (Array.isArray(r) ? r : [r]).map(c => `${c} ${typeof i == 'string' ? i : vA(i)} ${a} ${typeof l == 'string' ? l : vA(l)}`).join(',')
        },
      },
      e,
      { easing: t, duration: n }
    )
  }
  const m1 = { mobileStepper: 1e3, fab: 1050, speedDial: 1050, appBar: 1100, drawer: 1200, modal: 1300, snackbar: 1400, tooltip: 1500 },
    y1 = ['breakpoints', 'mixins', 'spacing', 'palette', 'transitions', 'typography', 'shape']
  function wc(e = {}, ...t) {
    const { mixins: n = {}, palette: o = {}, transitions: r = {}, typography: s = {} } = e,
      i = he(e, y1)
    if (e.vars) throw new Error(Zo(18))
    const a = r1(o),
      l = Kr(e)
    let c = Ln(l, { mixins: QC(l.breakpoints, n), palette: a, shadows: d1.slice(), typography: a1(a, s), transitions: g1(r), zIndex: M({}, m1) })
    return (
      (c = Ln(c, i)),
      (c = t.reduce((u, d) => Ln(u, d), c)),
      (c.unstable_sxConfig = M({}, Ur, i == null ? void 0 : i.unstable_sxConfig)),
      (c.unstable_sx = function (d) {
        return or({ sx: d, theme: this })
      }),
      c
    )
  }
  const Ec = wc()
  function Zr() {
    const e = Ni(Ec)
    return e[Jo] || e
  }
  var Jr = {},
    Sc = { exports: {} },
    xA
  function b1() {
    return (
      xA ||
        ((xA = 1),
        (function (e) {
          function t(n, o) {
            if (n == null) return {}
            var r = {}
            for (var s in n)
              if ({}.hasOwnProperty.call(n, s)) {
                if (o.includes(s)) continue
                r[s] = n[s]
              }
            return r
          }
          ;(e.exports = t), (e.exports.__esModule = !0), (e.exports.default = e.exports)
        })(Sc)),
      Sc.exports
    )
  }
  const v1 = Mn(Uv),
    x1 = Mn(Kv),
    C1 = Mn(ex),
    w1 = Mn(oC),
    E1 = Mn(Wx),
    S1 = Mn(Ux)
  var ir = qr
  Object.defineProperty(Jr, '__esModule', { value: !0 })
  var B1 = (Jr.default = O1)
  ;(Jr.shouldForwardProp = Yi), (Jr.systemDefaultTheme = void 0)
  var qt = ir(Pf()),
    Bc = ir(b1()),
    CA = T1(v1),
    I1 = x1
  ir(C1), ir(w1)
  var k1 = ir(E1),
    N1 = ir(S1)
  const M1 = ['ownerState'],
    P1 = ['variants'],
    L1 = ['name', 'slot', 'skipVariantsResolver', 'skipSx', 'overridesResolver']
  function wA(e) {
    if (typeof WeakMap != 'function') return null
    var t = new WeakMap(),
      n = new WeakMap()
    return (wA = function (o) {
      return o ? n : t
    })(e)
  }
  function T1(e, t) {
    if (e && e.__esModule) return e
    if (e === null || (typeof e != 'object' && typeof e != 'function')) return { default: e }
    var n = wA(t)
    if (n && n.has(e)) return n.get(e)
    var o = { __proto__: null },
      r = Object.defineProperty && Object.getOwnPropertyDescriptor
    for (var s in e)
      if (s !== 'default' && Object.prototype.hasOwnProperty.call(e, s)) {
        var i = r ? Object.getOwnPropertyDescriptor(e, s) : null
        i && (i.get || i.set) ? Object.defineProperty(o, s, i) : (o[s] = e[s])
      }
    return (o.default = e), n && n.set(e, o), o
  }
  function F1(e) {
    return Object.keys(e).length === 0
  }
  function D1(e) {
    return typeof e == 'string' && e.charCodeAt(0) > 96
  }
  function Yi(e) {
    return e !== 'ownerState' && e !== 'theme' && e !== 'sx' && e !== 'as'
  }
  const z1 = (Jr.systemDefaultTheme = (0, k1.default)()),
    Q1 = e => e && e.charAt(0).toLowerCase() + e.slice(1)
  function Hi({ defaultTheme: e, theme: t, themeId: n }) {
    return F1(t) ? e : t[n] || t
  }
  function R1(e) {
    return e ? (t, n) => n[e] : null
  }
  function Ui(e, t) {
    let { ownerState: n } = t,
      o = (0, Bc.default)(t, M1)
    const r = typeof e == 'function' ? e((0, qt.default)({ ownerState: n }, o)) : e
    if (Array.isArray(r)) return r.flatMap(s => Ui(s, (0, qt.default)({ ownerState: n }, o)))
    if (r && typeof r == 'object' && Array.isArray(r.variants)) {
      const { variants: s = [] } = r
      let a = (0, Bc.default)(r, P1)
      return (
        s.forEach(l => {
          let c = !0
          typeof l.props == 'function'
            ? (c = l.props((0, qt.default)({ ownerState: n }, o, n)))
            : Object.keys(l.props).forEach(u => {
                ;(n == null ? void 0 : n[u]) !== l.props[u] && o[u] !== l.props[u] && (c = !1)
              }),
            c && (Array.isArray(a) || (a = [a]), a.push(typeof l.style == 'function' ? l.style((0, qt.default)({ ownerState: n }, o, n)) : l.style))
        }),
        a
      )
    }
    return r
  }
  function O1(e = {}) {
    const { themeId: t, defaultTheme: n = z1, rootShouldForwardProp: o = Yi, slotShouldForwardProp: r = Yi } = e,
      s = i => (0, N1.default)((0, qt.default)({}, i, { theme: Hi((0, qt.default)({}, i, { defaultTheme: n, themeId: t })) }))
    return (
      (s.__mui_systemSx = !0),
      (i, a = {}) => {
        ;(0, CA.internal_processStyles)(i, w => w.filter(k => !(k != null && k.__mui_systemSx)))
        const { name: l, slot: c, skipVariantsResolver: u, skipSx: d, overridesResolver: f = R1(Q1(c)) } = a,
          A = (0, Bc.default)(a, L1),
          h = u !== void 0 ? u : (c && c !== 'Root' && c !== 'root') || !1,
          g = d || !1
        let x,
          m = Yi
        c === 'Root' || c === 'root' ? (m = o) : c ? (m = r) : D1(i) && (m = void 0)
        const v = (0, CA.default)(i, (0, qt.default)({ shouldForwardProp: m, label: x }, A)),
          y = w => ((typeof w == 'function' && w.__emotion_real !== w) || (0, I1.isPlainObject)(w) ? k => Ui(w, (0, qt.default)({}, k, { theme: Hi({ theme: k.theme, defaultTheme: n, themeId: t }) })) : w),
          b = (w, ...k) => {
            let E = y(w)
            const P = k ? k.map(y) : []
            l &&
              f &&
              P.push(D => {
                const Q = Hi((0, qt.default)({}, D, { defaultTheme: n, themeId: t }))
                if (!Q.components || !Q.components[l] || !Q.components[l].styleOverrides) return null
                const R = Q.components[l].styleOverrides,
                  S = {}
                return (
                  Object.entries(R).forEach(([L, I]) => {
                    S[L] = Ui(I, (0, qt.default)({}, D, { theme: Q }))
                  }),
                  f(D, S)
                )
              }),
              l &&
                !h &&
                P.push(D => {
                  var Q
                  const R = Hi((0, qt.default)({}, D, { defaultTheme: n, themeId: t })),
                    S = R == null || (Q = R.components) == null || (Q = Q[l]) == null ? void 0 : Q.variants
                  return Ui({ variants: S }, (0, qt.default)({}, D, { theme: R }))
                }),
              g || P.push(s)
            const T = P.length - k.length
            if (Array.isArray(w) && T > 0) {
              const D = new Array(T).fill('')
              ;(E = [...w, ...D]), (E.raw = [...w.raw, ...D])
            }
            const F = v(E, ...P)
            return i.muiName && (F.muiName = i.muiName), F
          }
        return v.withConfig && (b.withConfig = v.withConfig), b
      }
    )
  }
  function Ki(e) {
    return e !== 'ownerState' && e !== 'theme' && e !== 'sx' && e !== 'as'
  }
  const Ot = e => Ki(e) && e !== 'classes',
    j = B1({ themeId: Jo, defaultTheme: Ec, rootShouldForwardProp: Ot }),
    j1 = ['theme']
  function W1(e) {
    let { theme: t } = e,
      n = he(e, j1)
    const o = t[Jo]
    return p.jsx(BC, M({}, n, { themeId: o ? Jo : void 0, theme: o || t }))
  }
  const EA = e => {
    let t
    return e < 1 ? (t = 5.11916 * e ** 2) : (t = 4.5 * Math.log(e + 1) + 2), (t / 100).toFixed(2)
  }
  function me(e) {
    if (typeof e != 'string') throw new Error(Zo(7))
    return e.charAt(0).toUpperCase() + e.slice(1)
  }
  function Ic(...e) {
    return e.reduce(
      (t, n) =>
        n == null
          ? t
          : function (...r) {
              t.apply(this, r), n.apply(this, r)
            },
      () => {}
    )
  }
  function qi(e, t = 166) {
    let n
    function o(...r) {
      const s = () => {
        e.apply(this, r)
      }
      clearTimeout(n), (n = setTimeout(s, t))
    }
    return (
      (o.clear = () => {
        clearTimeout(n)
      }),
      o
    )
  }
  function G1(e, t) {
    return () => null
  }
  function Zi(e, t) {
    var n, o
    return N.isValidElement(e) && t.indexOf((n = e.type.muiName) != null ? n : (o = e.type) == null || (o = o._payload) == null || (o = o.value) == null ? void 0 : o.muiName) !== -1
  }
  function yt(e) {
    return (e && e.ownerDocument) || document
  }
  function vn(e) {
    return yt(e).defaultView || window
  }
  function V1(e, t) {
    return () => null
  }
  function Ji(e, t) {
    typeof e == 'function' ? e(t) : e && (e.current = t)
  }
  const xn = typeof window < 'u' ? N.useLayoutEffect : N.useEffect
  let SA = 0
  function X1(e) {
    const [t, n] = N.useState(e),
      o = e || t
    return (
      N.useEffect(() => {
        t == null && ((SA += 1), n(`mui-${SA}`))
      }, [t]),
      o
    )
  }
  const BA = N.useId
  function _i(e) {
    if (BA !== void 0) {
      const t = BA()
      return e ?? t
    }
    return X1(e)
  }
  function Y1(e, t, n, o, r) {
    return null
  }
  function $i({ controlled: e, default: t, name: n, state: o = 'value' }) {
    const { current: r } = N.useRef(e !== void 0),
      [s, i] = N.useState(t),
      a = r ? e : s,
      l = N.useCallback(c => {
        r || i(c)
      }, [])
    return [a, l]
  }
  function Cn(e) {
    const t = N.useRef(e)
    return (
      xn(() => {
        t.current = e
      }),
      N.useRef((...n) => (0, t.current)(...n)).current
    )
  }
  function ht(...e) {
    return N.useMemo(
      () =>
        e.every(t => t == null)
          ? null
          : t => {
              e.forEach(n => {
                Ji(n, t)
              })
            },
      e
    )
  }
  const IA = {}
  function H1(e, t) {
    const n = N.useRef(IA)
    return n.current === IA && (n.current = e(t)), n
  }
  const U1 = []
  function K1(e) {
    N.useEffect(e, U1)
  }
  class ea {
    constructor() {
      ;(this.currentId = null),
        (this.clear = () => {
          this.currentId !== null && (clearTimeout(this.currentId), (this.currentId = null))
        }),
        (this.disposeEffect = () => this.clear)
    }
    static create() {
      return new ea()
    }
    start(t, n) {
      this.clear(),
        (this.currentId = setTimeout(() => {
          ;(this.currentId = null), n()
        }, t))
    }
  }
  function kA() {
    const e = H1(ea.create).current
    return K1(e.disposeEffect), e
  }
  let ta = !0,
    kc = !1
  const q1 = new ea(),
    Z1 = { text: !0, search: !0, url: !0, tel: !0, email: !0, password: !0, number: !0, date: !0, month: !0, week: !0, time: !0, datetime: !0, 'datetime-local': !0 }
  function J1(e) {
    const { type: t, tagName: n } = e
    return !!((n === 'INPUT' && Z1[t] && !e.readOnly) || (n === 'TEXTAREA' && !e.readOnly) || e.isContentEditable)
  }
  function _1(e) {
    e.metaKey || e.altKey || e.ctrlKey || (ta = !0)
  }
  function Nc() {
    ta = !1
  }
  function $1() {
    this.visibilityState === 'hidden' && kc && (ta = !0)
  }
  function ew(e) {
    e.addEventListener('keydown', _1, !0), e.addEventListener('mousedown', Nc, !0), e.addEventListener('pointerdown', Nc, !0), e.addEventListener('touchstart', Nc, !0), e.addEventListener('visibilitychange', $1, !0)
  }
  function tw(e) {
    const { target: t } = e
    try {
      return t.matches(':focus-visible')
    } catch {}
    return ta || J1(t)
  }
  function Mc() {
    const e = N.useCallback(r => {
        r != null && ew(r.ownerDocument)
      }, []),
      t = N.useRef(!1)
    function n() {
      return t.current
        ? ((kc = !0),
          q1.start(100, () => {
            kc = !1
          }),
          (t.current = !1),
          !0)
        : !1
    }
    function o(r) {
      return tw(r) ? ((t.current = !0), !0) : !1
    }
    return { isFocusVisibleRef: t, onFocus: o, onBlur: n, ref: e }
  }
  function NA(e) {
    const t = e.documentElement.clientWidth
    return Math.abs(window.innerWidth - t)
  }
  const nw = { border: 0, clip: 'rect(0 0 0 0)', height: '1px', margin: '-1px', overflow: 'hidden', padding: 0, position: 'absolute', whiteSpace: 'nowrap', width: '1px' }
  function MA(e, t) {
    const n = M({}, t)
    return (
      Object.keys(e).forEach(o => {
        if (o.toString().match(/^(components|slots)$/)) n[o] = M({}, e[o], n[o])
        else if (o.toString().match(/^(componentsProps|slotProps)$/)) {
          const r = e[o] || {},
            s = t[o]
          ;(n[o] = {}),
            !s || !Object.keys(s)
              ? (n[o] = r)
              : !r || !Object.keys(r)
              ? (n[o] = s)
              : ((n[o] = M({}, s)),
                Object.keys(r).forEach(i => {
                  n[o][i] = MA(r[i], s[i])
                }))
        } else n[o] === void 0 && (n[o] = e[o])
      }),
      n
    )
  }
  function Re(e, t, n = void 0) {
    const o = {}
    return (
      Object.keys(e).forEach(r => {
        o[r] = e[r]
          .reduce((s, i) => {
            if (i) {
              const a = t(i)
              a !== '' && s.push(a), n && n[i] && s.push(n[i])
            }
            return s
          }, [])
          .join(' ')
      }),
      o
    )
  }
  function Pe(e, t, n = 'Mui') {
    const o = {}
    return (
      t.forEach(r => {
        o[r] = Fe(e, r, n)
      }),
      o
    )
  }
  function _r(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, n))
  }
  function Kn(e) {
    return typeof e == 'string'
  }
  function ow(e, t, n) {
    return e === void 0 || Kn(e) ? t : M({}, t, { ownerState: M({}, t.ownerState, n) })
  }
  function $r(e, t = []) {
    if (e === void 0) return {}
    const n = {}
    return (
      Object.keys(e)
        .filter(o => o.match(/^on[A-Z]/) && typeof e[o] == 'function' && !t.includes(o))
        .forEach(o => {
          n[o] = e[o]
        }),
      n
    )
  }
  function PA(e) {
    if (e === void 0) return {}
    const t = {}
    return (
      Object.keys(e)
        .filter(n => !(n.match(/^on[A-Z]/) && typeof e[n] == 'function'))
        .forEach(n => {
          t[n] = e[n]
        }),
      t
    )
  }
  function rw(e) {
    const { getSlotProps: t, additionalProps: n, externalSlotProps: o, externalForwardedProps: r, className: s } = e
    if (!t) {
      const A = fe(n == null ? void 0 : n.className, s, r == null ? void 0 : r.className, o == null ? void 0 : o.className),
        h = M({}, n == null ? void 0 : n.style, r == null ? void 0 : r.style, o == null ? void 0 : o.style),
        g = M({}, n, r, o)
      return A.length > 0 && (g.className = A), Object.keys(h).length > 0 && (g.style = h), { props: g, internalRef: void 0 }
    }
    const i = $r(M({}, r, o)),
      a = PA(o),
      l = PA(r),
      c = t(i),
      u = fe(c == null ? void 0 : c.className, n == null ? void 0 : n.className, s, r == null ? void 0 : r.className, o == null ? void 0 : o.className),
      d = M({}, c == null ? void 0 : c.style, n == null ? void 0 : n.style, r == null ? void 0 : r.style, o == null ? void 0 : o.style),
      f = M({}, c, n, l, a)
    return u.length > 0 && (f.className = u), Object.keys(d).length > 0 && (f.style = d), { props: f, internalRef: c.ref }
  }
  function sw(e, t, n) {
    return typeof e == 'function' ? e(t, n) : e
  }
  const iw = ['elementType', 'externalSlotProps', 'ownerState', 'skipResolvingSlotProps']
  function Lt(e) {
    var t
    const { elementType: n, externalSlotProps: o, ownerState: r, skipResolvingSlotProps: s = !1 } = e,
      i = he(e, iw),
      a = s ? {} : sw(o, r),
      { props: l, internalRef: c } = rw(M({}, i, { externalSlotProps: a })),
      u = ht(c, a == null ? void 0 : a.ref, (t = e.additionalProps) == null ? void 0 : t.ref)
    return ow(n, M({}, l, { ref: u }), r)
  }
  function ar(e) {
    if (parseInt(N.version, 10) >= 19) {
      var t
      return (e == null || (t = e.props) == null ? void 0 : t.ref) || null
    }
    return (e == null ? void 0 : e.ref) || null
  }
  function Le(e) {
    return SC(e)
  }
  function aw(e) {
    return Fe('MuiSvgIcon', e)
  }
  Pe('MuiSvgIcon', ['root', 'colorPrimary', 'colorSecondary', 'colorAction', 'colorError', 'colorDisabled', 'fontSizeInherit', 'fontSizeSmall', 'fontSizeMedium', 'fontSizeLarge'])
  const lw = ['children', 'className', 'color', 'component', 'fontSize', 'htmlColor', 'inheritViewBox', 'titleAccess', 'viewBox'],
    cw = e => {
      const { color: t, fontSize: n, classes: o } = e,
        r = { root: ['root', t !== 'inherit' && `color${me(t)}`, `fontSize${me(n)}`] }
      return Re(r, aw, o)
    },
    uw = j('svg', {
      name: 'MuiSvgIcon',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, n.color !== 'inherit' && t[`color${me(n.color)}`], t[`fontSize${me(n.fontSize)}`]]
      },
    })(({ theme: e, ownerState: t }) => {
      var n, o, r, s, i, a, l, c, u, d, f, A, h
      return {
        userSelect: 'none',
        width: '1em',
        height: '1em',
        display: 'inline-block',
        fill: t.hasSvgAsChild ? void 0 : 'currentColor',
        flexShrink: 0,
        transition: (n = e.transitions) == null || (o = n.create) == null ? void 0 : o.call(n, 'fill', { duration: (r = e.transitions) == null || (r = r.duration) == null ? void 0 : r.shorter }),
        fontSize: { inherit: 'inherit', small: ((s = e.typography) == null || (i = s.pxToRem) == null ? void 0 : i.call(s, 20)) || '1.25rem', medium: ((a = e.typography) == null || (l = a.pxToRem) == null ? void 0 : l.call(a, 24)) || '1.5rem', large: ((c = e.typography) == null || (u = c.pxToRem) == null ? void 0 : u.call(c, 35)) || '2.1875rem' }[
          t.fontSize
        ],
        color: (d = (f = (e.vars || e).palette) == null || (f = f[t.color]) == null ? void 0 : f.main) != null ? d : { action: (A = (e.vars || e).palette) == null || (A = A.action) == null ? void 0 : A.active, disabled: (h = (e.vars || e).palette) == null || (h = h.action) == null ? void 0 : h.disabled, inherit: void 0 }[t.color],
      }
    }),
    Pc = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiSvgIcon' }),
        { children: r, className: s, color: i = 'inherit', component: a = 'svg', fontSize: l = 'medium', htmlColor: c, inheritViewBox: u = !1, titleAccess: d, viewBox: f = '0 0 24 24' } = o,
        A = he(o, lw),
        h = N.isValidElement(r) && r.type === 'svg',
        g = M({}, o, { color: i, component: a, fontSize: l, instanceFontSize: t.fontSize, inheritViewBox: u, viewBox: f, hasSvgAsChild: h }),
        x = {}
      u || (x.viewBox = f)
      const m = cw(g)
      return p.jsxs(uw, M({ as: a, className: fe(m.root, s), focusable: 'false', color: c, 'aria-hidden': d ? void 0 : !0, role: d ? 'img' : void 0, ref: n }, x, A, h && r.props, { ownerState: g, children: [h ? r.props.children : r, d ? p.jsx('title', { children: d }) : null] }))
    })
  Pc.muiName = 'SvgIcon'
  function Lc(e, t) {
    function n(o, r) {
      return p.jsx(Pc, M({ 'data-testid': `${t}Icon`, ref: r }, o, { children: e }))
    }
    return (n.muiName = Pc.muiName), N.memo(N.forwardRef(n))
  }
  const dw = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        capitalize: me,
        createChainedFunction: Ic,
        createSvgIcon: Lc,
        debounce: qi,
        deprecatedPropType: G1,
        isMuiElement: Zi,
        ownerDocument: yt,
        ownerWindow: vn,
        requirePropFactory: V1,
        setRef: Ji,
        unstable_ClassNameGenerator: {
          configure: e => {
            gc.configure(e)
          },
        },
        unstable_useEnhancedEffect: xn,
        unstable_useId: _i,
        unsupportedProp: Y1,
        useControlled: $i,
        useEventCallback: Cn,
        useForkRef: ht,
        useIsFocusVisible: Mc,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
  function Tc(e, t) {
    return (
      (Tc = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (n, o) {
            return (n.__proto__ = o), n
          }),
      Tc(e, t)
    )
  }
  function LA(e, t) {
    ;(e.prototype = Object.create(t.prototype)), (e.prototype.constructor = e), Tc(e, t)
  }
  const TA = { disabled: !1 },
    na = C.createContext(null)
  var fw = function (t) {
      return t.scrollTop
    },
    es = 'unmounted',
    go = 'exited',
    mo = 'entering',
    lr = 'entered',
    Fc = 'exiting',
    rn = (function (e) {
      LA(t, e)
      function t(o, r) {
        var s
        s = e.call(this, o, r) || this
        var i = r,
          a = i && !i.isMounting ? o.enter : o.appear,
          l
        return (s.appearStatus = null), o.in ? (a ? ((l = go), (s.appearStatus = mo)) : (l = lr)) : o.unmountOnExit || o.mountOnEnter ? (l = es) : (l = go), (s.state = { status: l }), (s.nextCallback = null), s
      }
      t.getDerivedStateFromProps = function (r, s) {
        var i = r.in
        return i && s.status === es ? { status: go } : null
      }
      var n = t.prototype
      return (
        (n.componentDidMount = function () {
          this.updateStatus(!0, this.appearStatus)
        }),
        (n.componentDidUpdate = function (r) {
          var s = null
          if (r !== this.props) {
            var i = this.state.status
            this.props.in ? i !== mo && i !== lr && (s = mo) : (i === mo || i === lr) && (s = Fc)
          }
          this.updateStatus(!1, s)
        }),
        (n.componentWillUnmount = function () {
          this.cancelNextCallback()
        }),
        (n.getTimeouts = function () {
          var r = this.props.timeout,
            s,
            i,
            a
          return (s = i = a = r), r != null && typeof r != 'number' && ((s = r.exit), (i = r.enter), (a = r.appear !== void 0 ? r.appear : i)), { exit: s, enter: i, appear: a }
        }),
        (n.updateStatus = function (r, s) {
          if ((r === void 0 && (r = !1), s !== null))
            if ((this.cancelNextCallback(), s === mo)) {
              if (this.props.unmountOnExit || this.props.mountOnEnter) {
                var i = this.props.nodeRef ? this.props.nodeRef.current : pt.findDOMNode(this)
                i && fw(i)
              }
              this.performEnter(r)
            } else this.performExit()
          else this.props.unmountOnExit && this.state.status === go && this.setState({ status: es })
        }),
        (n.performEnter = function (r) {
          var s = this,
            i = this.props.enter,
            a = this.context ? this.context.isMounting : r,
            l = this.props.nodeRef ? [a] : [pt.findDOMNode(this), a],
            c = l[0],
            u = l[1],
            d = this.getTimeouts(),
            f = a ? d.appear : d.enter
          if ((!r && !i) || TA.disabled) {
            this.safeSetState({ status: lr }, function () {
              s.props.onEntered(c)
            })
            return
          }
          this.props.onEnter(c, u),
            this.safeSetState({ status: mo }, function () {
              s.props.onEntering(c, u),
                s.onTransitionEnd(f, function () {
                  s.safeSetState({ status: lr }, function () {
                    s.props.onEntered(c, u)
                  })
                })
            })
        }),
        (n.performExit = function () {
          var r = this,
            s = this.props.exit,
            i = this.getTimeouts(),
            a = this.props.nodeRef ? void 0 : pt.findDOMNode(this)
          if (!s || TA.disabled) {
            this.safeSetState({ status: go }, function () {
              r.props.onExited(a)
            })
            return
          }
          this.props.onExit(a),
            this.safeSetState({ status: Fc }, function () {
              r.props.onExiting(a),
                r.onTransitionEnd(i.exit, function () {
                  r.safeSetState({ status: go }, function () {
                    r.props.onExited(a)
                  })
                })
            })
        }),
        (n.cancelNextCallback = function () {
          this.nextCallback !== null && (this.nextCallback.cancel(), (this.nextCallback = null))
        }),
        (n.safeSetState = function (r, s) {
          ;(s = this.setNextCallback(s)), this.setState(r, s)
        }),
        (n.setNextCallback = function (r) {
          var s = this,
            i = !0
          return (
            (this.nextCallback = function (a) {
              i && ((i = !1), (s.nextCallback = null), r(a))
            }),
            (this.nextCallback.cancel = function () {
              i = !1
            }),
            this.nextCallback
          )
        }),
        (n.onTransitionEnd = function (r, s) {
          this.setNextCallback(s)
          var i = this.props.nodeRef ? this.props.nodeRef.current : pt.findDOMNode(this),
            a = r == null && !this.props.addEndListener
          if (!i || a) {
            setTimeout(this.nextCallback, 0)
            return
          }
          if (this.props.addEndListener) {
            var l = this.props.nodeRef ? [this.nextCallback] : [i, this.nextCallback],
              c = l[0],
              u = l[1]
            this.props.addEndListener(c, u)
          }
          r != null && setTimeout(this.nextCallback, r)
        }),
        (n.render = function () {
          var r = this.state.status
          if (r === es) return null
          var s = this.props,
            i = s.children
          s.in, s.mountOnEnter, s.unmountOnExit, s.appear, s.enter, s.exit, s.timeout, s.addEndListener, s.onEnter, s.onEntering, s.onEntered, s.onExit, s.onExiting, s.onExited, s.nodeRef
          var a = he(s, ['children', 'in', 'mountOnEnter', 'unmountOnExit', 'appear', 'enter', 'exit', 'timeout', 'addEndListener', 'onEnter', 'onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited', 'nodeRef'])
          return C.createElement(na.Provider, { value: null }, typeof i == 'function' ? i(r, a) : C.cloneElement(C.Children.only(i), a))
        }),
        t
      )
    })(C.Component)
  ;(rn.contextType = na), (rn.propTypes = {})
  function cr() {}
  ;(rn.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: cr, onEntering: cr, onEntered: cr, onExit: cr, onExiting: cr, onExited: cr }), (rn.UNMOUNTED = es), (rn.EXITED = go), (rn.ENTERING = mo), (rn.ENTERED = lr), (rn.EXITING = Fc)
  function Aw(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
    return e
  }
  function Dc(e, t) {
    var n = function (s) {
        return t && C.isValidElement(s) ? t(s) : s
      },
      o = Object.create(null)
    return (
      e &&
        C.Children.map(e, function (r) {
          return r
        }).forEach(function (r) {
          o[r.key] = n(r)
        }),
      o
    )
  }
  function pw(e, t) {
    ;(e = e || {}), (t = t || {})
    function n(u) {
      return u in t ? t[u] : e[u]
    }
    var o = Object.create(null),
      r = []
    for (var s in e) s in t ? r.length && ((o[s] = r), (r = [])) : r.push(s)
    var i,
      a = {}
    for (var l in t) {
      if (o[l])
        for (i = 0; i < o[l].length; i++) {
          var c = o[l][i]
          a[o[l][i]] = n(c)
        }
      a[l] = n(l)
    }
    for (i = 0; i < r.length; i++) a[r[i]] = n(r[i])
    return a
  }
  function yo(e, t, n) {
    return n[t] != null ? n[t] : e.props[t]
  }
  function hw(e, t) {
    return Dc(e.children, function (n) {
      return C.cloneElement(n, { onExited: t.bind(null, n), in: !0, appear: yo(n, 'appear', e), enter: yo(n, 'enter', e), exit: yo(n, 'exit', e) })
    })
  }
  function gw(e, t, n) {
    var o = Dc(e.children),
      r = pw(t, o)
    return (
      Object.keys(r).forEach(function (s) {
        var i = r[s]
        if (C.isValidElement(i)) {
          var a = s in t,
            l = s in o,
            c = t[s],
            u = C.isValidElement(c) && !c.props.in
          l && (!a || u)
            ? (r[s] = C.cloneElement(i, { onExited: n.bind(null, i), in: !0, exit: yo(i, 'exit', e), enter: yo(i, 'enter', e) }))
            : !l && a && !u
            ? (r[s] = C.cloneElement(i, { in: !1 }))
            : l && a && C.isValidElement(c) && (r[s] = C.cloneElement(i, { onExited: n.bind(null, i), in: c.props.in, exit: yo(i, 'exit', e), enter: yo(i, 'enter', e) }))
        }
      }),
      r
    )
  }
  var mw =
      Object.values ||
      function (e) {
        return Object.keys(e).map(function (t) {
          return e[t]
        })
      },
    yw = {
      component: 'div',
      childFactory: function (t) {
        return t
      },
    },
    zc = (function (e) {
      LA(t, e)
      function t(o, r) {
        var s
        s = e.call(this, o, r) || this
        var i = s.handleExited.bind(Aw(s))
        return (s.state = { contextValue: { isMounting: !0 }, handleExited: i, firstRender: !0 }), s
      }
      var n = t.prototype
      return (
        (n.componentDidMount = function () {
          ;(this.mounted = !0), this.setState({ contextValue: { isMounting: !1 } })
        }),
        (n.componentWillUnmount = function () {
          this.mounted = !1
        }),
        (t.getDerivedStateFromProps = function (r, s) {
          var i = s.children,
            a = s.handleExited,
            l = s.firstRender
          return { children: l ? hw(r, a) : gw(r, i, a), firstRender: !1 }
        }),
        (n.handleExited = function (r, s) {
          var i = Dc(this.props.children)
          r.key in i ||
            (r.props.onExited && r.props.onExited(s),
            this.mounted &&
              this.setState(function (a) {
                var l = M({}, a.children)
                return delete l[r.key], { children: l }
              }))
        }),
        (n.render = function () {
          var r = this.props,
            s = r.component,
            i = r.childFactory,
            a = he(r, ['component', 'childFactory']),
            l = this.state.contextValue,
            c = mw(this.state.children).map(i)
          return delete a.appear, delete a.enter, delete a.exit, s === null ? C.createElement(na.Provider, { value: l }, c) : C.createElement(na.Provider, { value: l }, C.createElement(s, a, c))
        }),
        t
      )
    })(C.Component)
  ;(zc.propTypes = {}), (zc.defaultProps = yw)
  const Qc = e => e.scrollTop
  function ur(e, t) {
    var n, o
    const { timeout: r, easing: s, style: i = {} } = e
    return { duration: (n = i.transitionDuration) != null ? n : typeof r == 'number' ? r : r[t.mode] || 0, easing: (o = i.transitionTimingFunction) != null ? o : typeof s == 'object' ? s[t.mode] : s, delay: i.transitionDelay }
  }
  function bw(e) {
    return Fe('MuiPaper', e)
  }
  Pe('MuiPaper', [
    'root',
    'rounded',
    'outlined',
    'elevation',
    'elevation0',
    'elevation1',
    'elevation2',
    'elevation3',
    'elevation4',
    'elevation5',
    'elevation6',
    'elevation7',
    'elevation8',
    'elevation9',
    'elevation10',
    'elevation11',
    'elevation12',
    'elevation13',
    'elevation14',
    'elevation15',
    'elevation16',
    'elevation17',
    'elevation18',
    'elevation19',
    'elevation20',
    'elevation21',
    'elevation22',
    'elevation23',
    'elevation24',
  ])
  const vw = ['className', 'component', 'elevation', 'square', 'variant'],
    xw = e => {
      const { square: t, elevation: n, variant: o, classes: r } = e,
        s = { root: ['root', o, !t && 'rounded', o === 'elevation' && `elevation${n}`] }
      return Re(s, bw, r)
    },
    Cw = j('div', {
      name: 'MuiPaper',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, t[n.variant], !n.square && t.rounded, n.variant === 'elevation' && t[`elevation${n.elevation}`]]
      },
    })(({ theme: e, ownerState: t }) => {
      var n
      return M(
        { backgroundColor: (e.vars || e).palette.background.paper, color: (e.vars || e).palette.text.primary, transition: e.transitions.create('box-shadow') },
        !t.square && { borderRadius: e.shape.borderRadius },
        t.variant === 'outlined' && { border: `1px solid ${(e.vars || e).palette.divider}` },
        t.variant === 'elevation' && M({ boxShadow: (e.vars || e).shadows[t.elevation] }, !e.vars && e.palette.mode === 'dark' && { backgroundImage: `linear-gradient(${Bt('#fff', EA(t.elevation))}, ${Bt('#fff', EA(t.elevation))})` }, e.vars && { backgroundImage: (n = e.vars.overlays) == null ? void 0 : n[t.elevation] })
      )
    }),
    ts = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiPaper' }),
        { className: r, component: s = 'div', elevation: i = 1, square: a = !1, variant: l = 'elevation' } = o,
        c = he(o, vw),
        u = M({}, o, { component: s, elevation: i, square: a, variant: l }),
        d = xw(u)
      return p.jsx(Cw, M({ as: s, ownerState: u, className: fe(d.root, r), ref: n }, c))
    })
  function ww(e) {
    const { className: t, classes: n, pulsate: o = !1, rippleX: r, rippleY: s, rippleSize: i, in: a, onExited: l, timeout: c } = e,
      [u, d] = N.useState(!1),
      f = fe(t, n.ripple, n.rippleVisible, o && n.ripplePulsate),
      A = { width: i, height: i, top: -(i / 2) + s, left: -(i / 2) + r },
      h = fe(n.child, u && n.childLeaving, o && n.childPulsate)
    return (
      !a && !u && d(!0),
      N.useEffect(() => {
        if (!a && l != null) {
          const g = setTimeout(l, c)
          return () => {
            clearTimeout(g)
          }
        }
      }, [l, a, c]),
      p.jsx('span', { className: f, style: A, children: p.jsx('span', { className: h }) })
    )
  }
  const Zt = Pe('MuiTouchRipple', ['root', 'ripple', 'rippleVisible', 'ripplePulsate', 'child', 'childLeaving', 'childPulsate']),
    Ew = ['center', 'classes', 'className']
  let oa = e => e,
    FA,
    DA,
    zA,
    QA
  const Rc = 550,
    Sw = 80,
    Bw = xi(
      FA ||
        (FA = oa`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)
    ),
    Iw = xi(
      DA ||
        (DA = oa`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)
    ),
    kw = xi(
      zA ||
        (zA = oa`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)
    ),
    Nw = j('span', { name: 'MuiTouchRipple', slot: 'Root' })({ overflow: 'hidden', pointerEvents: 'none', position: 'absolute', zIndex: 0, top: 0, right: 0, bottom: 0, left: 0, borderRadius: 'inherit' }),
    Mw = j(ww, { name: 'MuiTouchRipple', slot: 'Ripple' })(
      QA ||
        (QA = oa`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),
      Zt.rippleVisible,
      Bw,
      Rc,
      ({ theme: e }) => e.transitions.easing.easeInOut,
      Zt.ripplePulsate,
      ({ theme: e }) => e.transitions.duration.shorter,
      Zt.child,
      Zt.childLeaving,
      Iw,
      Rc,
      ({ theme: e }) => e.transitions.easing.easeInOut,
      Zt.childPulsate,
      kw,
      ({ theme: e }) => e.transitions.easing.easeInOut
    ),
    Pw = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiTouchRipple' }),
        { center: r = !1, classes: s = {}, className: i } = o,
        a = he(o, Ew),
        [l, c] = N.useState([]),
        u = N.useRef(0),
        d = N.useRef(null)
      N.useEffect(() => {
        d.current && (d.current(), (d.current = null))
      }, [l])
      const f = N.useRef(!1),
        A = kA(),
        h = N.useRef(null),
        g = N.useRef(null),
        x = N.useCallback(
          b => {
            const { pulsate: w, rippleX: k, rippleY: E, rippleSize: P, cb: T } = b
            c(F => [
              ...F,
              p.jsx(
                Mw,
                {
                  classes: { ripple: fe(s.ripple, Zt.ripple), rippleVisible: fe(s.rippleVisible, Zt.rippleVisible), ripplePulsate: fe(s.ripplePulsate, Zt.ripplePulsate), child: fe(s.child, Zt.child), childLeaving: fe(s.childLeaving, Zt.childLeaving), childPulsate: fe(s.childPulsate, Zt.childPulsate) },
                  timeout: Rc,
                  pulsate: w,
                  rippleX: k,
                  rippleY: E,
                  rippleSize: P,
                },
                u.current
              ),
            ]),
              (u.current += 1),
              (d.current = T)
          },
          [s]
        ),
        m = N.useCallback(
          (b = {}, w = {}, k = () => {}) => {
            const { pulsate: E = !1, center: P = r || w.pulsate, fakeElement: T = !1 } = w
            if ((b == null ? void 0 : b.type) === 'mousedown' && f.current) {
              f.current = !1
              return
            }
            ;(b == null ? void 0 : b.type) === 'touchstart' && (f.current = !0)
            const F = T ? null : g.current,
              D = F ? F.getBoundingClientRect() : { width: 0, height: 0, left: 0, top: 0 }
            let Q, R, S
            if (P || b === void 0 || (b.clientX === 0 && b.clientY === 0) || (!b.clientX && !b.touches)) (Q = Math.round(D.width / 2)), (R = Math.round(D.height / 2))
            else {
              const { clientX: L, clientY: I } = b.touches && b.touches.length > 0 ? b.touches[0] : b
              ;(Q = Math.round(L - D.left)), (R = Math.round(I - D.top))
            }
            if (P) (S = Math.sqrt((2 * D.width ** 2 + D.height ** 2) / 3)), S % 2 === 0 && (S += 1)
            else {
              const L = Math.max(Math.abs((F ? F.clientWidth : 0) - Q), Q) * 2 + 2,
                I = Math.max(Math.abs((F ? F.clientHeight : 0) - R), R) * 2 + 2
              S = Math.sqrt(L ** 2 + I ** 2)
            }
            b != null && b.touches
              ? h.current === null &&
                ((h.current = () => {
                  x({ pulsate: E, rippleX: Q, rippleY: R, rippleSize: S, cb: k })
                }),
                A.start(Sw, () => {
                  h.current && (h.current(), (h.current = null))
                }))
              : x({ pulsate: E, rippleX: Q, rippleY: R, rippleSize: S, cb: k })
          },
          [r, x, A]
        ),
        v = N.useCallback(() => {
          m({}, { pulsate: !0 })
        }, [m]),
        y = N.useCallback(
          (b, w) => {
            if ((A.clear(), (b == null ? void 0 : b.type) === 'touchend' && h.current)) {
              h.current(),
                (h.current = null),
                A.start(0, () => {
                  y(b, w)
                })
              return
            }
            ;(h.current = null), c(k => (k.length > 0 ? k.slice(1) : k)), (d.current = w)
          },
          [A]
        )
      return N.useImperativeHandle(n, () => ({ pulsate: v, start: m, stop: y }), [v, m, y]), p.jsx(Nw, M({ className: fe(Zt.root, s.root, i), ref: g }, a, { children: p.jsx(zc, { component: null, exit: !0, children: l }) }))
    })
  function Lw(e) {
    return Fe('MuiButtonBase', e)
  }
  const Tw = Pe('MuiButtonBase', ['root', 'disabled', 'focusVisible']),
    Fw = [
      'action',
      'centerRipple',
      'children',
      'className',
      'component',
      'disabled',
      'disableRipple',
      'disableTouchRipple',
      'focusRipple',
      'focusVisibleClassName',
      'LinkComponent',
      'onBlur',
      'onClick',
      'onContextMenu',
      'onDragLeave',
      'onFocus',
      'onFocusVisible',
      'onKeyDown',
      'onKeyUp',
      'onMouseDown',
      'onMouseLeave',
      'onMouseUp',
      'onTouchEnd',
      'onTouchMove',
      'onTouchStart',
      'tabIndex',
      'TouchRippleProps',
      'touchRippleRef',
      'type',
    ],
    Dw = e => {
      const { disabled: t, focusVisible: n, focusVisibleClassName: o, classes: r } = e,
        i = Re({ root: ['root', t && 'disabled', n && 'focusVisible'] }, Lw, r)
      return n && o && (i.root += ` ${o}`), i
    },
    zw = j('button', { name: 'MuiButtonBase', slot: 'Root', overridesResolver: (e, t) => t.root })({
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'relative',
      boxSizing: 'border-box',
      WebkitTapHighlightColor: 'transparent',
      backgroundColor: 'transparent',
      outline: 0,
      border: 0,
      margin: 0,
      borderRadius: 0,
      padding: 0,
      cursor: 'pointer',
      userSelect: 'none',
      verticalAlign: 'middle',
      MozAppearance: 'none',
      WebkitAppearance: 'none',
      textDecoration: 'none',
      color: 'inherit',
      '&::-moz-focus-inner': { borderStyle: 'none' },
      [`&.${Tw.disabled}`]: { pointerEvents: 'none', cursor: 'default' },
      '@media print': { colorAdjust: 'exact' },
    }),
    Oc = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiButtonBase' }),
        {
          action: r,
          centerRipple: s = !1,
          children: i,
          className: a,
          component: l = 'button',
          disabled: c = !1,
          disableRipple: u = !1,
          disableTouchRipple: d = !1,
          focusRipple: f = !1,
          LinkComponent: A = 'a',
          onBlur: h,
          onClick: g,
          onContextMenu: x,
          onDragLeave: m,
          onFocus: v,
          onFocusVisible: y,
          onKeyDown: b,
          onKeyUp: w,
          onMouseDown: k,
          onMouseLeave: E,
          onMouseUp: P,
          onTouchEnd: T,
          onTouchMove: F,
          onTouchStart: D,
          tabIndex: Q = 0,
          TouchRippleProps: R,
          touchRippleRef: S,
          type: L,
        } = o,
        I = he(o, Fw),
        z = N.useRef(null),
        B = N.useRef(null),
        O = ht(B, S),
        { isFocusVisibleRef: W, onFocus: K, onBlur: Z, ref: oe } = Mc(),
        [V, q] = N.useState(!1)
      c && V && q(!1),
        N.useImperativeHandle(
          r,
          () => ({
            focusVisible: () => {
              q(!0), z.current.focus()
            },
          }),
          []
        )
      const [ee, re] = N.useState(!1)
      N.useEffect(() => {
        re(!0)
      }, [])
      const J = ee && !u && !c
      N.useEffect(() => {
        V && f && !u && ee && B.current.pulsate()
      }, [u, f, V, ee])
      function ie(G, ce, ne = d) {
        return Cn(ue => (ce && ce(ue), !ne && B.current && B.current[G](ue), !0))
      }
      const Ae = ie('start', k),
        ae = ie('stop', x),
        se = ie('stop', m),
        H = ie('stop', P),
        U = ie('stop', G => {
          V && G.preventDefault(), E && E(G)
        }),
        te = ie('start', D),
        be = ie('stop', T),
        Ne = ie('stop', F),
        Me = ie(
          'stop',
          G => {
            Z(G), W.current === !1 && q(!1), h && h(G)
          },
          !1
        ),
        Ue = Cn(G => {
          z.current || (z.current = G.currentTarget), K(G), W.current === !0 && (q(!0), y && y(G)), v && v(G)
        }),
        we = () => {
          const G = z.current
          return l && l !== 'button' && !(G.tagName === 'A' && G.href)
        },
        Se = N.useRef(!1),
        et = Cn(G => {
          f &&
            !Se.current &&
            V &&
            B.current &&
            G.key === ' ' &&
            ((Se.current = !0),
            B.current.stop(G, () => {
              B.current.start(G)
            })),
            G.target === G.currentTarget && we() && G.key === ' ' && G.preventDefault(),
            b && b(G),
            G.target === G.currentTarget && we() && G.key === 'Enter' && !c && (G.preventDefault(), g && g(G))
        }),
        We = Cn(G => {
          f &&
            G.key === ' ' &&
            B.current &&
            V &&
            !G.defaultPrevented &&
            ((Se.current = !1),
            B.current.stop(G, () => {
              B.current.pulsate(G)
            })),
            w && w(G),
            g && G.target === G.currentTarget && we() && G.key === ' ' && !G.defaultPrevented && g(G)
        })
      let Ie = l
      Ie === 'button' && (I.href || I.to) && (Ie = A)
      const Ze = {}
      Ie === 'button' ? ((Ze.type = L === void 0 ? 'button' : L), (Ze.disabled = c)) : (!I.href && !I.to && (Ze.role = 'button'), c && (Ze['aria-disabled'] = c))
      const Ke = ht(n, oe, z),
        Ve = M({}, o, { centerRipple: s, component: l, disabled: c, disableRipple: u, disableTouchRipple: d, focusRipple: f, tabIndex: Q, focusVisible: V }),
        X = Dw(Ve)
      return p.jsxs(
        zw,
        M({ as: Ie, className: fe(X.root, a), ownerState: Ve, onBlur: Me, onClick: g, onContextMenu: ae, onFocus: Ue, onKeyDown: et, onKeyUp: We, onMouseDown: Ae, onMouseLeave: U, onMouseUp: H, onDragLeave: se, onTouchEnd: be, onTouchMove: Ne, onTouchStart: te, ref: Ke, tabIndex: c ? -1 : Q, type: L }, Ze, I, {
          children: [i, J ? p.jsx(Pw, M({ ref: O, center: s }, R)) : null],
        })
      )
    })
  function Qw(e) {
    return Fe('MuiIconButton', e)
  }
  const Rw = Pe('MuiIconButton', ['root', 'disabled', 'colorInherit', 'colorPrimary', 'colorSecondary', 'colorError', 'colorInfo', 'colorSuccess', 'colorWarning', 'edgeStart', 'edgeEnd', 'sizeSmall', 'sizeMedium', 'sizeLarge']),
    Ow = ['edge', 'children', 'className', 'color', 'disabled', 'disableFocusRipple', 'size'],
    jw = e => {
      const { classes: t, disabled: n, color: o, edge: r, size: s } = e,
        i = { root: ['root', n && 'disabled', o !== 'default' && `color${me(o)}`, r && `edge${me(r)}`, `size${me(s)}`] }
      return Re(i, Qw, t)
    },
    Ww = j(Oc, {
      name: 'MuiIconButton',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, n.color !== 'default' && t[`color${me(n.color)}`], n.edge && t[`edge${me(n.edge)}`], t[`size${me(n.size)}`]]
      },
    })(
      ({ theme: e, ownerState: t }) =>
        M(
          { textAlign: 'center', flex: '0 0 auto', fontSize: e.typography.pxToRem(24), padding: 8, borderRadius: '50%', overflow: 'visible', color: (e.vars || e).palette.action.active, transition: e.transitions.create('background-color', { duration: e.transitions.duration.shortest }) },
          !t.disableRipple && { '&:hover': { backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Bt(e.palette.action.active, e.palette.action.hoverOpacity), '@media (hover: none)': { backgroundColor: 'transparent' } } },
          t.edge === 'start' && { marginLeft: t.size === 'small' ? -3 : -12 },
          t.edge === 'end' && { marginRight: t.size === 'small' ? -3 : -12 }
        ),
      ({ theme: e, ownerState: t }) => {
        var n
        const o = (n = (e.vars || e).palette) == null ? void 0 : n[t.color]
        return M(
          {},
          t.color === 'inherit' && { color: 'inherit' },
          t.color !== 'inherit' &&
            t.color !== 'default' &&
            M({ color: o == null ? void 0 : o.main }, !t.disableRipple && { '&:hover': M({}, o && { backgroundColor: e.vars ? `rgba(${o.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Bt(o.main, e.palette.action.hoverOpacity) }, { '@media (hover: none)': { backgroundColor: 'transparent' } }) }),
          t.size === 'small' && { padding: 5, fontSize: e.typography.pxToRem(18) },
          t.size === 'large' && { padding: 12, fontSize: e.typography.pxToRem(28) },
          { [`&.${Rw.disabled}`]: { backgroundColor: 'transparent', color: (e.vars || e).palette.action.disabled } }
        )
      }
    ),
    RA = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiIconButton' }),
        { edge: r = !1, children: s, className: i, color: a = 'default', disabled: l = !1, disableFocusRipple: c = !1, size: u = 'medium' } = o,
        d = he(o, Ow),
        f = M({}, o, { edge: r, color: a, disabled: l, disableFocusRipple: c, size: u }),
        A = jw(f)
      return p.jsx(Ww, M({ className: fe(A.root, i), centerRipple: !0, focusRipple: !c, disabled: l, ref: n }, d, { ownerState: f, children: s }))
    })
  function Gw(e) {
    return Fe('MuiTypography', e)
  }
  Pe('MuiTypography', ['root', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'inherit', 'button', 'caption', 'overline', 'alignLeft', 'alignRight', 'alignCenter', 'alignJustify', 'noWrap', 'gutterBottom', 'paragraph'])
  const Vw = ['align', 'className', 'component', 'gutterBottom', 'noWrap', 'paragraph', 'variant', 'variantMapping'],
    Xw = e => {
      const { align: t, gutterBottom: n, noWrap: o, paragraph: r, variant: s, classes: i } = e,
        a = { root: ['root', s, e.align !== 'inherit' && `align${me(t)}`, n && 'gutterBottom', o && 'noWrap', r && 'paragraph'] }
      return Re(a, Gw, i)
    },
    Yw = j('span', {
      name: 'MuiTypography',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, n.variant && t[n.variant], n.align !== 'inherit' && t[`align${me(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph]
      },
    })(({ theme: e, ownerState: t }) =>
      M({ margin: 0 }, t.variant === 'inherit' && { font: 'inherit' }, t.variant !== 'inherit' && e.typography[t.variant], t.align !== 'inherit' && { textAlign: t.align }, t.noWrap && { overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }, t.gutterBottom && { marginBottom: '0.35em' }, t.paragraph && { marginBottom: 16 })
    ),
    OA = { h1: 'h1', h2: 'h2', h3: 'h3', h4: 'h4', h5: 'h5', h6: 'h6', subtitle1: 'h6', subtitle2: 'h6', body1: 'p', body2: 'p', inherit: 'p' },
    Hw = { primary: 'primary.main', textPrimary: 'text.primary', secondary: 'secondary.main', textSecondary: 'text.secondary', error: 'error.main' },
    Uw = e => Hw[e] || e,
    bo = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiTypography' }),
        r = Uw(o.color),
        s = Mi(M({}, o, { color: r })),
        { align: i = 'inherit', className: a, component: l, gutterBottom: c = !1, noWrap: u = !1, paragraph: d = !1, variant: f = 'body1', variantMapping: A = OA } = s,
        h = he(s, Vw),
        g = M({}, s, { align: i, color: r, className: a, component: l, gutterBottom: c, noWrap: u, paragraph: d, variant: f, variantMapping: A }),
        x = l || (d ? 'p' : A[f] || OA[f]) || 'span',
        m = Xw(g)
      return p.jsx(Yw, M({ as: x, ref: n, ownerState: g, className: fe(m.root, a) }, h))
    })
  function Kw(e) {
    return typeof e == 'function' ? e() : e
  }
  const qw = N.forwardRef(function (t, n) {
      const { children: o, container: r, disablePortal: s = !1 } = t,
        [i, a] = N.useState(null),
        l = ht(N.isValidElement(o) ? ar(o) : null, n)
      if (
        (xn(() => {
          s || a(Kw(r) || document.body)
        }, [r, s]),
        xn(() => {
          if (i && !s)
            return (
              Ji(n, i),
              () => {
                Ji(n, null)
              }
            )
        }, [n, i, s]),
        s)
      ) {
        if (N.isValidElement(o)) {
          const c = { ref: l }
          return N.cloneElement(o, c)
        }
        return p.jsx(N.Fragment, { children: o })
      }
      return p.jsx(N.Fragment, { children: i && jl.createPortal(o, i) })
    }),
    Zw = ['onChange', 'maxRows', 'minRows', 'style', 'value']
  function ra(e) {
    return parseInt(e, 10) || 0
  }
  const Jw = { shadow: { visibility: 'hidden', position: 'absolute', overflow: 'hidden', height: 0, top: 0, left: 0, transform: 'translateZ(0)' } }
  function _w(e) {
    return e == null || Object.keys(e).length === 0 || (e.outerHeightStyle === 0 && !e.overflowing)
  }
  const $w = N.forwardRef(function (t, n) {
    const { onChange: o, maxRows: r, minRows: s = 1, style: i, value: a } = t,
      l = he(t, Zw),
      { current: c } = N.useRef(a != null),
      u = N.useRef(null),
      d = ht(n, u),
      f = N.useRef(null),
      A = N.useRef(null),
      h = N.useCallback(() => {
        const m = u.current,
          y = vn(m).getComputedStyle(m)
        if (y.width === '0px') return { outerHeightStyle: 0, overflowing: !1 }
        const b = A.current
        ;(b.style.width = y.width),
          (b.value = m.value || t.placeholder || 'x'),
          b.value.slice(-1) ===
            `
` && (b.value += ' ')
        const w = y.boxSizing,
          k = ra(y.paddingBottom) + ra(y.paddingTop),
          E = ra(y.borderBottomWidth) + ra(y.borderTopWidth),
          P = b.scrollHeight
        b.value = 'x'
        const T = b.scrollHeight
        let F = P
        s && (F = Math.max(Number(s) * T, F)), r && (F = Math.min(Number(r) * T, F)), (F = Math.max(F, T))
        const D = F + (w === 'border-box' ? k + E : 0),
          Q = Math.abs(F - P) <= 1
        return { outerHeightStyle: D, overflowing: Q }
      }, [r, s, t.placeholder]),
      g = N.useCallback(() => {
        const m = h()
        if (_w(m)) return
        const v = m.outerHeightStyle,
          y = u.current
        f.current !== v && ((f.current = v), (y.style.height = `${v}px`)), (y.style.overflow = m.overflowing ? 'hidden' : '')
      }, [h])
    xn(() => {
      const m = () => {
        g()
      }
      let v
      const y = qi(m),
        b = u.current,
        w = vn(b)
      w.addEventListener('resize', y)
      let k
      return (
        typeof ResizeObserver < 'u' && ((k = new ResizeObserver(m)), k.observe(b)),
        () => {
          y.clear(), cancelAnimationFrame(v), w.removeEventListener('resize', y), k && k.disconnect()
        }
      )
    }, [h, g]),
      xn(() => {
        g()
      })
    const x = m => {
      c || g(), o && o(m)
    }
    return p.jsxs(N.Fragment, { children: [p.jsx('textarea', M({ value: a, onChange: x, ref: d, rows: s, style: i }, l)), p.jsx('textarea', { 'aria-hidden': !0, className: t.className, readOnly: !0, ref: A, tabIndex: -1, style: M({}, Jw.shadow, i, { paddingTop: 0, paddingBottom: 0 }) })] })
  })
  function dr({ props: e, states: t, muiFormControl: n }) {
    return t.reduce((o, r) => ((o[r] = e[r]), n && typeof e[r] > 'u' && (o[r] = n[r]), o), {})
  }
  const sa = N.createContext(void 0)
  function vo() {
    return N.useContext(sa)
  }
  function jA(e) {
    return p.jsx(Xx, M({}, e, { defaultTheme: Ec, themeId: Jo }))
  }
  function WA(e) {
    return e != null && !(Array.isArray(e) && e.length === 0)
  }
  function ia(e, t = !1) {
    return e && ((WA(e.value) && e.value !== '') || (t && WA(e.defaultValue) && e.defaultValue !== ''))
  }
  function eE(e) {
    return e.startAdornment
  }
  function tE(e) {
    return Fe('MuiInputBase', e)
  }
  const fr = Pe('MuiInputBase', ['root', 'formControl', 'focused', 'disabled', 'adornedStart', 'adornedEnd', 'error', 'sizeSmall', 'multiline', 'colorSecondary', 'fullWidth', 'hiddenLabel', 'readOnly', 'input', 'inputSizeSmall', 'inputMultiline', 'inputTypeSearch', 'inputAdornedStart', 'inputAdornedEnd', 'inputHiddenLabel']),
    nE = [
      'aria-describedby',
      'autoComplete',
      'autoFocus',
      'className',
      'color',
      'components',
      'componentsProps',
      'defaultValue',
      'disabled',
      'disableInjectingGlobalStyles',
      'endAdornment',
      'error',
      'fullWidth',
      'id',
      'inputComponent',
      'inputProps',
      'inputRef',
      'margin',
      'maxRows',
      'minRows',
      'multiline',
      'name',
      'onBlur',
      'onChange',
      'onClick',
      'onFocus',
      'onKeyDown',
      'onKeyUp',
      'placeholder',
      'readOnly',
      'renderSuffix',
      'rows',
      'size',
      'slotProps',
      'slots',
      'startAdornment',
      'type',
      'value',
    ],
    aa = (e, t) => {
      const { ownerState: n } = e
      return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === 'small' && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${me(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel]
    },
    la = (e, t) => {
      const { ownerState: n } = e
      return [t.input, n.size === 'small' && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === 'search' && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel]
    },
    oE = e => {
      const { classes: t, color: n, disabled: o, error: r, endAdornment: s, focused: i, formControl: a, fullWidth: l, hiddenLabel: c, multiline: u, readOnly: d, size: f, startAdornment: A, type: h } = e,
        g = {
          root: ['root', `color${me(n)}`, o && 'disabled', r && 'error', l && 'fullWidth', i && 'focused', a && 'formControl', f && f !== 'medium' && `size${me(f)}`, u && 'multiline', A && 'adornedStart', s && 'adornedEnd', c && 'hiddenLabel', d && 'readOnly'],
          input: ['input', o && 'disabled', h === 'search' && 'inputTypeSearch', u && 'inputMultiline', f === 'small' && 'inputSizeSmall', c && 'inputHiddenLabel', A && 'inputAdornedStart', s && 'inputAdornedEnd', d && 'readOnly'],
        }
      return Re(g, tE, t)
    },
    ca = j('div', { name: 'MuiInputBase', slot: 'Root', overridesResolver: aa })(({ theme: e, ownerState: t }) =>
      M(
        {},
        e.typography.body1,
        { color: (e.vars || e).palette.text.primary, lineHeight: '1.4375em', boxSizing: 'border-box', position: 'relative', cursor: 'text', display: 'inline-flex', alignItems: 'center', [`&.${fr.disabled}`]: { color: (e.vars || e).palette.text.disabled, cursor: 'default' } },
        t.multiline && M({ padding: '4px 0 5px' }, t.size === 'small' && { paddingTop: 1 }),
        t.fullWidth && { width: '100%' }
      )
    ),
    ua = j('input', { name: 'MuiInputBase', slot: 'Input', overridesResolver: la })(({ theme: e, ownerState: t }) => {
      const n = e.palette.mode === 'light',
        o = M({ color: 'currentColor' }, e.vars ? { opacity: e.vars.opacity.inputPlaceholder } : { opacity: n ? 0.42 : 0.5 }, { transition: e.transitions.create('opacity', { duration: e.transitions.duration.shorter }) }),
        r = { opacity: '0 !important' },
        s = e.vars ? { opacity: e.vars.opacity.inputPlaceholder } : { opacity: n ? 0.42 : 0.5 }
      return M(
        {
          font: 'inherit',
          letterSpacing: 'inherit',
          color: 'currentColor',
          padding: '4px 0 5px',
          border: 0,
          boxSizing: 'content-box',
          background: 'none',
          height: '1.4375em',
          margin: 0,
          WebkitTapHighlightColor: 'transparent',
          display: 'block',
          minWidth: 0,
          width: '100%',
          animationName: 'mui-auto-fill-cancel',
          animationDuration: '10ms',
          '&::-webkit-input-placeholder': o,
          '&::-moz-placeholder': o,
          '&:-ms-input-placeholder': o,
          '&::-ms-input-placeholder': o,
          '&:focus': { outline: 0 },
          '&:invalid': { boxShadow: 'none' },
          '&::-webkit-search-decoration': { WebkitAppearance: 'none' },
          [`label[data-shrink=false] + .${fr.formControl} &`]: { '&::-webkit-input-placeholder': r, '&::-moz-placeholder': r, '&:-ms-input-placeholder': r, '&::-ms-input-placeholder': r, '&:focus::-webkit-input-placeholder': s, '&:focus::-moz-placeholder': s, '&:focus:-ms-input-placeholder': s, '&:focus::-ms-input-placeholder': s },
          [`&.${fr.disabled}`]: { opacity: 1, WebkitTextFillColor: (e.vars || e).palette.text.disabled },
          '&:-webkit-autofill': { animationDuration: '5000s', animationName: 'mui-auto-fill' },
        },
        t.size === 'small' && { paddingTop: 1 },
        t.multiline && { height: 'auto', resize: 'none', padding: 0, paddingTop: 0 },
        t.type === 'search' && { MozAppearance: 'textfield' }
      )
    }),
    rE = p.jsx(jA, { styles: { '@keyframes mui-auto-fill': { from: { display: 'block' } }, '@keyframes mui-auto-fill-cancel': { from: { display: 'block' } } } }),
    jc = N.forwardRef(function (t, n) {
      var o
      const r = Le({ props: t, name: 'MuiInputBase' }),
        {
          'aria-describedby': s,
          autoComplete: i,
          autoFocus: a,
          className: l,
          components: c = {},
          componentsProps: u = {},
          defaultValue: d,
          disabled: f,
          disableInjectingGlobalStyles: A,
          endAdornment: h,
          fullWidth: g = !1,
          id: x,
          inputComponent: m = 'input',
          inputProps: v = {},
          inputRef: y,
          maxRows: b,
          minRows: w,
          multiline: k = !1,
          name: E,
          onBlur: P,
          onChange: T,
          onClick: F,
          onFocus: D,
          onKeyDown: Q,
          onKeyUp: R,
          placeholder: S,
          readOnly: L,
          renderSuffix: I,
          rows: z,
          slotProps: B = {},
          slots: O = {},
          startAdornment: W,
          type: K = 'text',
          value: Z,
        } = r,
        oe = he(r, nE),
        V = v.value != null ? v.value : Z,
        { current: q } = N.useRef(V != null),
        ee = N.useRef(),
        re = N.useCallback(X => {}, []),
        J = ht(ee, y, v.ref, re),
        [ie, Ae] = N.useState(!1),
        ae = vo(),
        se = dr({ props: r, muiFormControl: ae, states: ['color', 'disabled', 'error', 'hiddenLabel', 'size', 'required', 'filled'] })
      ;(se.focused = ae ? ae.focused : ie),
        N.useEffect(() => {
          !ae && f && ie && (Ae(!1), P && P())
        }, [ae, f, ie, P])
      const H = ae && ae.onFilled,
        U = ae && ae.onEmpty,
        te = N.useCallback(
          X => {
            ia(X) ? H && H() : U && U()
          },
          [H, U]
        )
      xn(() => {
        q && te({ value: V })
      }, [V, te, q])
      const be = X => {
          if (se.disabled) {
            X.stopPropagation()
            return
          }
          D && D(X), v.onFocus && v.onFocus(X), ae && ae.onFocus ? ae.onFocus(X) : Ae(!0)
        },
        Ne = X => {
          P && P(X), v.onBlur && v.onBlur(X), ae && ae.onBlur ? ae.onBlur(X) : Ae(!1)
        },
        Me = (X, ...G) => {
          if (!q) {
            const ce = X.target || ee.current
            if (ce == null) throw new Error(Zo(1))
            te({ value: ce.value })
          }
          v.onChange && v.onChange(X, ...G), T && T(X, ...G)
        }
      N.useEffect(() => {
        te(ee.current)
      }, [])
      const Ue = X => {
        ee.current && X.currentTarget === X.target && ee.current.focus(), F && F(X)
      }
      let we = m,
        Se = v
      k && we === 'input' && (z ? (Se = M({ type: void 0, minRows: z, maxRows: z }, Se)) : (Se = M({ type: void 0, maxRows: b, minRows: w }, Se)), (we = $w))
      const et = X => {
        te(X.animationName === 'mui-auto-fill-cancel' ? ee.current : { value: 'x' })
      }
      N.useEffect(() => {
        ae && ae.setAdornedStart(!!W)
      }, [ae, W])
      const We = M({}, r, { color: se.color || 'primary', disabled: se.disabled, endAdornment: h, error: se.error, focused: se.focused, formControl: ae, fullWidth: g, hiddenLabel: se.hiddenLabel, multiline: k, size: se.size, startAdornment: W, type: K }),
        Ie = oE(We),
        Ze = O.root || c.Root || ca,
        Ke = B.root || u.root || {},
        Ve = O.input || c.Input || ua
      return (
        (Se = M({}, Se, (o = B.input) != null ? o : u.input)),
        p.jsxs(N.Fragment, {
          children: [
            !A && rE,
            p.jsxs(
              Ze,
              M({}, Ke, !Kn(Ze) && { ownerState: M({}, We, Ke.ownerState) }, { ref: n, onClick: Ue }, oe, {
                className: fe(Ie.root, Ke.className, l, L && 'MuiInputBase-readOnly'),
                children: [
                  W,
                  p.jsx(sa.Provider, {
                    value: null,
                    children: p.jsx(
                      Ve,
                      M(
                        { ownerState: We, 'aria-invalid': se.error, 'aria-describedby': s, autoComplete: i, autoFocus: a, defaultValue: d, disabled: se.disabled, id: x, onAnimationStart: et, name: E, placeholder: S, readOnly: L, required: se.required, rows: z, value: V, onKeyDown: Q, onKeyUp: R, type: K },
                        Se,
                        !Kn(Ve) && { as: we, ownerState: M({}, We, Se.ownerState) },
                        { ref: J, className: fe(Ie.input, Se.className, L && 'MuiInputBase-readOnly'), onBlur: Ne, onChange: Me, onFocus: be }
                      )
                    ),
                  }),
                  h,
                  I ? I(M({}, se, { startAdornment: W })) : null,
                ],
              })
            ),
          ],
        })
      )
    })
  function sE(e) {
    return Fe('MuiInput', e)
  }
  const ns = M({}, fr, Pe('MuiInput', ['root', 'underline', 'input']))
  function iE(e) {
    return Fe('MuiOutlinedInput', e)
  }
  const qn = M({}, fr, Pe('MuiOutlinedInput', ['root', 'notchedOutline', 'input']))
  function aE(e) {
    return Fe('MuiFilledInput', e)
  }
  const xo = M({}, fr, Pe('MuiFilledInput', ['root', 'underline', 'input'])),
    lE = Lc(p.jsx('path', { d: 'M7 10l5 5 5-5z' }), 'ArrowDropDown'),
    cE = ['addEndListener', 'appear', 'children', 'easing', 'in', 'onEnter', 'onEntered', 'onEntering', 'onExit', 'onExited', 'onExiting', 'style', 'timeout', 'TransitionComponent'],
    uE = { entering: { opacity: 1 }, entered: { opacity: 1 } },
    GA = N.forwardRef(function (t, n) {
      const o = Zr(),
        r = { enter: o.transitions.duration.enteringScreen, exit: o.transitions.duration.leavingScreen },
        { addEndListener: s, appear: i = !0, children: a, easing: l, in: c, onEnter: u, onEntered: d, onEntering: f, onExit: A, onExited: h, onExiting: g, style: x, timeout: m = r, TransitionComponent: v = rn } = t,
        y = he(t, cE),
        b = N.useRef(null),
        w = ht(b, ar(a), n),
        k = S => L => {
          if (S) {
            const I = b.current
            L === void 0 ? S(I) : S(I, L)
          }
        },
        E = k(f),
        P = k((S, L) => {
          Qc(S)
          const I = ur({ style: x, timeout: m, easing: l }, { mode: 'enter' })
          ;(S.style.webkitTransition = o.transitions.create('opacity', I)), (S.style.transition = o.transitions.create('opacity', I)), u && u(S, L)
        }),
        T = k(d),
        F = k(g),
        D = k(S => {
          const L = ur({ style: x, timeout: m, easing: l }, { mode: 'exit' })
          ;(S.style.webkitTransition = o.transitions.create('opacity', L)), (S.style.transition = o.transitions.create('opacity', L)), A && A(S)
        }),
        Q = k(h),
        R = S => {
          s && s(b.current, S)
        }
      return p.jsx(v, M({ appear: i, in: c, nodeRef: b, onEnter: P, onEntered: T, onEntering: E, onExit: D, onExited: Q, onExiting: F, addEndListener: R, timeout: m }, y, { children: (S, L) => N.cloneElement(a, M({ style: M({ opacity: 0, visibility: S === 'exited' && !c ? 'hidden' : void 0 }, uE[S], x, a.props.style), ref: w }, L)) }))
    })
  function dE(e) {
    return Fe('MuiBackdrop', e)
  }
  Pe('MuiBackdrop', ['root', 'invisible'])
  const fE = ['children', 'className', 'component', 'components', 'componentsProps', 'invisible', 'open', 'slotProps', 'slots', 'TransitionComponent', 'transitionDuration'],
    AE = e => {
      const { classes: t, invisible: n } = e
      return Re({ root: ['root', n && 'invisible'] }, dE, t)
    },
    pE = j('div', {
      name: 'MuiBackdrop',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, n.invisible && t.invisible]
      },
    })(({ ownerState: e }) => M({ position: 'fixed', display: 'flex', alignItems: 'center', justifyContent: 'center', right: 0, bottom: 0, top: 0, left: 0, backgroundColor: 'rgba(0, 0, 0, 0.5)', WebkitTapHighlightColor: 'transparent' }, e.invisible && { backgroundColor: 'transparent' })),
    VA = N.forwardRef(function (t, n) {
      var o, r, s
      const i = Le({ props: t, name: 'MuiBackdrop' }),
        { children: a, className: l, component: c = 'div', components: u = {}, componentsProps: d = {}, invisible: f = !1, open: A, slotProps: h = {}, slots: g = {}, TransitionComponent: x = GA, transitionDuration: m } = i,
        v = he(i, fE),
        y = M({}, i, { component: c, invisible: f }),
        b = AE(y),
        w = (o = h.root) != null ? o : d.root
      return p.jsx(x, M({ in: A, timeout: m }, v, { children: p.jsx(pE, M({ 'aria-hidden': !0 }, w, { as: (r = (s = g.root) != null ? s : u.Root) != null ? r : c, className: fe(b.root, l, w == null ? void 0 : w.className), ownerState: M({}, y, w == null ? void 0 : w.ownerState), classes: b, ref: n, children: a })) }))
    }),
    hE = Pe('MuiBox', ['root']),
    gE = wc(),
    Wc = Zx({ themeId: Jo, defaultTheme: gE, defaultClassName: hE.root, generateClassName: gc.generate })
  function mE(e) {
    return Fe('MuiButton', e)
  }
  const da = Pe('MuiButton', [
      'root',
      'text',
      'textInherit',
      'textPrimary',
      'textSecondary',
      'textSuccess',
      'textError',
      'textInfo',
      'textWarning',
      'outlined',
      'outlinedInherit',
      'outlinedPrimary',
      'outlinedSecondary',
      'outlinedSuccess',
      'outlinedError',
      'outlinedInfo',
      'outlinedWarning',
      'contained',
      'containedInherit',
      'containedPrimary',
      'containedSecondary',
      'containedSuccess',
      'containedError',
      'containedInfo',
      'containedWarning',
      'disableElevation',
      'focusVisible',
      'disabled',
      'colorInherit',
      'colorPrimary',
      'colorSecondary',
      'colorSuccess',
      'colorError',
      'colorInfo',
      'colorWarning',
      'textSizeSmall',
      'textSizeMedium',
      'textSizeLarge',
      'outlinedSizeSmall',
      'outlinedSizeMedium',
      'outlinedSizeLarge',
      'containedSizeSmall',
      'containedSizeMedium',
      'containedSizeLarge',
      'sizeMedium',
      'sizeSmall',
      'sizeLarge',
      'fullWidth',
      'startIcon',
      'endIcon',
      'icon',
      'iconSizeSmall',
      'iconSizeMedium',
      'iconSizeLarge',
    ]),
    yE = N.createContext({}),
    bE = N.createContext(void 0),
    vE = ['children', 'color', 'component', 'className', 'disabled', 'disableElevation', 'disableFocusRipple', 'endIcon', 'focusVisibleClassName', 'fullWidth', 'size', 'startIcon', 'type', 'variant'],
    xE = e => {
      const { color: t, disableElevation: n, fullWidth: o, size: r, variant: s, classes: i } = e,
        a = { root: ['root', s, `${s}${me(t)}`, `size${me(r)}`, `${s}Size${me(r)}`, `color${me(t)}`, n && 'disableElevation', o && 'fullWidth'], label: ['label'], startIcon: ['icon', 'startIcon', `iconSize${me(r)}`], endIcon: ['icon', 'endIcon', `iconSize${me(r)}`] },
        l = Re(a, mE, i)
      return M({}, i, l)
    },
    XA = e => M({}, e.size === 'small' && { '& > *:nth-of-type(1)': { fontSize: 18 } }, e.size === 'medium' && { '& > *:nth-of-type(1)': { fontSize: 20 } }, e.size === 'large' && { '& > *:nth-of-type(1)': { fontSize: 22 } }),
    CE = j(Oc, {
      shouldForwardProp: e => Ot(e) || e === 'classes',
      name: 'MuiButton',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, t[n.variant], t[`${n.variant}${me(n.color)}`], t[`size${me(n.size)}`], t[`${n.variant}Size${me(n.size)}`], n.color === 'inherit' && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth]
      },
    })(
      ({ theme: e, ownerState: t }) => {
        var n, o
        const r = e.palette.mode === 'light' ? e.palette.grey[300] : e.palette.grey[800],
          s = e.palette.mode === 'light' ? e.palette.grey.A100 : e.palette.grey[700]
        return M(
          {},
          e.typography.button,
          {
            minWidth: 64,
            padding: '6px 16px',
            borderRadius: (e.vars || e).shape.borderRadius,
            transition: e.transitions.create(['background-color', 'box-shadow', 'border-color', 'color'], { duration: e.transitions.duration.short }),
            '&:hover': M(
              { textDecoration: 'none', backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : Bt(e.palette.text.primary, e.palette.action.hoverOpacity), '@media (hover: none)': { backgroundColor: 'transparent' } },
              t.variant === 'text' && t.color !== 'inherit' && { backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Bt(e.palette[t.color].main, e.palette.action.hoverOpacity), '@media (hover: none)': { backgroundColor: 'transparent' } },
              t.variant === 'outlined' &&
                t.color !== 'inherit' && { border: `1px solid ${(e.vars || e).palette[t.color].main}`, backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Bt(e.palette[t.color].main, e.palette.action.hoverOpacity), '@media (hover: none)': { backgroundColor: 'transparent' } },
              t.variant === 'contained' && { backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedHoverBg : s, boxShadow: (e.vars || e).shadows[4], '@media (hover: none)': { boxShadow: (e.vars || e).shadows[2], backgroundColor: (e.vars || e).palette.grey[300] } },
              t.variant === 'contained' && t.color !== 'inherit' && { backgroundColor: (e.vars || e).palette[t.color].dark, '@media (hover: none)': { backgroundColor: (e.vars || e).palette[t.color].main } }
            ),
            '&:active': M({}, t.variant === 'contained' && { boxShadow: (e.vars || e).shadows[8] }),
            [`&.${da.focusVisible}`]: M({}, t.variant === 'contained' && { boxShadow: (e.vars || e).shadows[6] }),
            [`&.${da.disabled}`]: M(
              { color: (e.vars || e).palette.action.disabled },
              t.variant === 'outlined' && { border: `1px solid ${(e.vars || e).palette.action.disabledBackground}` },
              t.variant === 'contained' && { color: (e.vars || e).palette.action.disabled, boxShadow: (e.vars || e).shadows[0], backgroundColor: (e.vars || e).palette.action.disabledBackground }
            ),
          },
          t.variant === 'text' && { padding: '6px 8px' },
          t.variant === 'text' && t.color !== 'inherit' && { color: (e.vars || e).palette[t.color].main },
          t.variant === 'outlined' && { padding: '5px 15px', border: '1px solid currentColor' },
          t.variant === 'outlined' && t.color !== 'inherit' && { color: (e.vars || e).palette[t.color].main, border: e.vars ? `1px solid rgba(${e.vars.palette[t.color].mainChannel} / 0.5)` : `1px solid ${Bt(e.palette[t.color].main, 0.5)}` },
          t.variant === 'contained' && { color: e.vars ? e.vars.palette.text.primary : (n = (o = e.palette).getContrastText) == null ? void 0 : n.call(o, e.palette.grey[300]), backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedBg : r, boxShadow: (e.vars || e).shadows[2] },
          t.variant === 'contained' && t.color !== 'inherit' && { color: (e.vars || e).palette[t.color].contrastText, backgroundColor: (e.vars || e).palette[t.color].main },
          t.color === 'inherit' && { color: 'inherit', borderColor: 'currentColor' },
          t.size === 'small' && t.variant === 'text' && { padding: '4px 5px', fontSize: e.typography.pxToRem(13) },
          t.size === 'large' && t.variant === 'text' && { padding: '8px 11px', fontSize: e.typography.pxToRem(15) },
          t.size === 'small' && t.variant === 'outlined' && { padding: '3px 9px', fontSize: e.typography.pxToRem(13) },
          t.size === 'large' && t.variant === 'outlined' && { padding: '7px 21px', fontSize: e.typography.pxToRem(15) },
          t.size === 'small' && t.variant === 'contained' && { padding: '4px 10px', fontSize: e.typography.pxToRem(13) },
          t.size === 'large' && t.variant === 'contained' && { padding: '8px 22px', fontSize: e.typography.pxToRem(15) },
          t.fullWidth && { width: '100%' }
        )
      },
      ({ ownerState: e }) => e.disableElevation && { boxShadow: 'none', '&:hover': { boxShadow: 'none' }, [`&.${da.focusVisible}`]: { boxShadow: 'none' }, '&:active': { boxShadow: 'none' }, [`&.${da.disabled}`]: { boxShadow: 'none' } }
    ),
    wE = j('span', {
      name: 'MuiButton',
      slot: 'StartIcon',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.startIcon, t[`iconSize${me(n.size)}`]]
      },
    })(({ ownerState: e }) => M({ display: 'inherit', marginRight: 8, marginLeft: -4 }, e.size === 'small' && { marginLeft: -2 }, XA(e))),
    EE = j('span', {
      name: 'MuiButton',
      slot: 'EndIcon',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.endIcon, t[`iconSize${me(n.size)}`]]
      },
    })(({ ownerState: e }) => M({ display: 'inherit', marginRight: -4, marginLeft: 8 }, e.size === 'small' && { marginRight: -2 }, XA(e))),
    YA = N.forwardRef(function (t, n) {
      const o = N.useContext(yE),
        r = N.useContext(bE),
        s = MA(o, t),
        i = Le({ props: s, name: 'MuiButton' }),
        { children: a, color: l = 'primary', component: c = 'button', className: u, disabled: d = !1, disableElevation: f = !1, disableFocusRipple: A = !1, endIcon: h, focusVisibleClassName: g, fullWidth: x = !1, size: m = 'medium', startIcon: v, type: y, variant: b = 'text' } = i,
        w = he(i, vE),
        k = M({}, i, { color: l, component: c, disabled: d, disableElevation: f, disableFocusRipple: A, fullWidth: x, size: m, type: y, variant: b }),
        E = xE(k),
        P = v && p.jsx(wE, { className: E.startIcon, ownerState: k, children: v }),
        T = h && p.jsx(EE, { className: E.endIcon, ownerState: k, children: h }),
        F = r || ''
      return p.jsxs(CE, M({ ownerState: k, className: fe(o.className, E.root, u, F), component: c, disabled: d, focusRipple: !A, focusVisibleClassName: fe(E.focusVisible, g), ref: n, type: y }, w, { classes: E, children: [P, a, T] }))
    }),
    SE = (e, t) => M({ WebkitFontSmoothing: 'antialiased', MozOsxFontSmoothing: 'grayscale', boxSizing: 'border-box', WebkitTextSizeAdjust: '100%' }, t && !e.vars && { colorScheme: e.palette.mode }),
    BE = e => M({ color: (e.vars || e).palette.text.primary }, e.typography.body1, { backgroundColor: (e.vars || e).palette.background.default, '@media print': { backgroundColor: (e.vars || e).palette.common.white } }),
    IE = (e, t = !1) => {
      var n
      const o = {}
      t &&
        e.colorSchemes &&
        Object.entries(e.colorSchemes).forEach(([i, a]) => {
          var l
          o[e.getColorSchemeSelector(i).replace(/\s*&/, '')] = { colorScheme: (l = a.palette) == null ? void 0 : l.mode }
        })
      let r = M({ html: SE(e, t), '*, *::before, *::after': { boxSizing: 'inherit' }, 'strong, b': { fontWeight: e.typography.fontWeightBold }, body: M({ margin: 0 }, BE(e), { '&::backdrop': { backgroundColor: (e.vars || e).palette.background.default } }) }, o)
      const s = (n = e.components) == null || (n = n.MuiCssBaseline) == null ? void 0 : n.styleOverrides
      return s && (r = [r, s]), r
    }
  function kE(e) {
    const t = Le({ props: e, name: 'MuiCssBaseline' }),
      { children: n, enableColorScheme: o = !1 } = t
    return p.jsxs(N.Fragment, { children: [p.jsx(jA, { styles: r => IE(r, o) }), n] })
  }
  function NE(e) {
    const t = yt(e)
    return t.body === e ? vn(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight
  }
  function os(e, t) {
    t ? e.setAttribute('aria-hidden', 'true') : e.removeAttribute('aria-hidden')
  }
  function HA(e) {
    return parseInt(vn(e).getComputedStyle(e).paddingRight, 10) || 0
  }
  function ME(e) {
    const n = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'].indexOf(e.tagName) !== -1,
      o = e.tagName === 'INPUT' && e.getAttribute('type') === 'hidden'
    return n || o
  }
  function UA(e, t, n, o, r) {
    const s = [t, n, ...o]
    ;[].forEach.call(e.children, i => {
      const a = s.indexOf(i) === -1,
        l = !ME(i)
      a && l && os(i, r)
    })
  }
  function Gc(e, t) {
    let n = -1
    return e.some((o, r) => (t(o) ? ((n = r), !0) : !1)), n
  }
  function PE(e, t) {
    const n = [],
      o = e.container
    if (!t.disableScrollLock) {
      if (NE(o)) {
        const i = NA(yt(o))
        n.push({ value: o.style.paddingRight, property: 'padding-right', el: o }), (o.style.paddingRight = `${HA(o) + i}px`)
        const a = yt(o).querySelectorAll('.mui-fixed')
        ;[].forEach.call(a, l => {
          n.push({ value: l.style.paddingRight, property: 'padding-right', el: l }), (l.style.paddingRight = `${HA(l) + i}px`)
        })
      }
      let s
      if (o.parentNode instanceof DocumentFragment) s = yt(o).body
      else {
        const i = o.parentElement,
          a = vn(o)
        s = (i == null ? void 0 : i.nodeName) === 'HTML' && a.getComputedStyle(i).overflowY === 'scroll' ? i : o
      }
      n.push({ value: s.style.overflow, property: 'overflow', el: s }, { value: s.style.overflowX, property: 'overflow-x', el: s }, { value: s.style.overflowY, property: 'overflow-y', el: s }), (s.style.overflow = 'hidden')
    }
    return () => {
      n.forEach(({ value: s, el: i, property: a }) => {
        s ? i.style.setProperty(a, s) : i.style.removeProperty(a)
      })
    }
  }
  function LE(e) {
    const t = []
    return (
      [].forEach.call(e.children, n => {
        n.getAttribute('aria-hidden') === 'true' && t.push(n)
      }),
      t
    )
  }
  class TE {
    constructor() {
      ;(this.containers = void 0), (this.modals = void 0), (this.modals = []), (this.containers = [])
    }
    add(t, n) {
      let o = this.modals.indexOf(t)
      if (o !== -1) return o
      ;(o = this.modals.length), this.modals.push(t), t.modalRef && os(t.modalRef, !1)
      const r = LE(n)
      UA(n, t.mount, t.modalRef, r, !0)
      const s = Gc(this.containers, i => i.container === n)
      return s !== -1 ? (this.containers[s].modals.push(t), o) : (this.containers.push({ modals: [t], container: n, restore: null, hiddenSiblings: r }), o)
    }
    mount(t, n) {
      const o = Gc(this.containers, s => s.modals.indexOf(t) !== -1),
        r = this.containers[o]
      r.restore || (r.restore = PE(r, n))
    }
    remove(t, n = !0) {
      const o = this.modals.indexOf(t)
      if (o === -1) return o
      const r = Gc(this.containers, i => i.modals.indexOf(t) !== -1),
        s = this.containers[r]
      if ((s.modals.splice(s.modals.indexOf(t), 1), this.modals.splice(o, 1), s.modals.length === 0)) s.restore && s.restore(), t.modalRef && os(t.modalRef, n), UA(s.container, t.mount, t.modalRef, s.hiddenSiblings, !1), this.containers.splice(r, 1)
      else {
        const i = s.modals[s.modals.length - 1]
        i.modalRef && os(i.modalRef, !1)
      }
      return o
    }
    isTopModal(t) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === t
    }
  }
  const FE = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'].join(',')
  function DE(e) {
    const t = parseInt(e.getAttribute('tabindex') || '', 10)
    return Number.isNaN(t) ? (e.contentEditable === 'true' || ((e.nodeName === 'AUDIO' || e.nodeName === 'VIDEO' || e.nodeName === 'DETAILS') && e.getAttribute('tabindex') === null) ? 0 : e.tabIndex) : t
  }
  function zE(e) {
    if (e.tagName !== 'INPUT' || e.type !== 'radio' || !e.name) return !1
    const t = o => e.ownerDocument.querySelector(`input[type="radio"]${o}`)
    let n = t(`[name="${e.name}"]:checked`)
    return n || (n = t(`[name="${e.name}"]`)), n !== e
  }
  function QE(e) {
    return !(e.disabled || (e.tagName === 'INPUT' && e.type === 'hidden') || zE(e))
  }
  function RE(e) {
    const t = [],
      n = []
    return (
      Array.from(e.querySelectorAll(FE)).forEach((o, r) => {
        const s = DE(o)
        s === -1 || !QE(o) || (s === 0 ? t.push(o) : n.push({ documentOrder: r, tabIndex: s, node: o }))
      }),
      n
        .sort((o, r) => (o.tabIndex === r.tabIndex ? o.documentOrder - r.documentOrder : o.tabIndex - r.tabIndex))
        .map(o => o.node)
        .concat(t)
    )
  }
  function OE() {
    return !0
  }
  function jE(e) {
    const { children: t, disableAutoFocus: n = !1, disableEnforceFocus: o = !1, disableRestoreFocus: r = !1, getTabbable: s = RE, isEnabled: i = OE, open: a } = e,
      l = N.useRef(!1),
      c = N.useRef(null),
      u = N.useRef(null),
      d = N.useRef(null),
      f = N.useRef(null),
      A = N.useRef(!1),
      h = N.useRef(null),
      g = ht(ar(t), h),
      x = N.useRef(null)
    N.useEffect(() => {
      !a || !h.current || (A.current = !n)
    }, [n, a]),
      N.useEffect(() => {
        if (!a || !h.current) return
        const y = yt(h.current)
        return (
          h.current.contains(y.activeElement) || (h.current.hasAttribute('tabIndex') || h.current.setAttribute('tabIndex', '-1'), A.current && h.current.focus()),
          () => {
            r || (d.current && d.current.focus && ((l.current = !0), d.current.focus()), (d.current = null))
          }
        )
      }, [a]),
      N.useEffect(() => {
        if (!a || !h.current) return
        const y = yt(h.current),
          b = E => {
            ;(x.current = E), !(o || !i() || E.key !== 'Tab') && y.activeElement === h.current && E.shiftKey && ((l.current = !0), u.current && u.current.focus())
          },
          w = () => {
            const E = h.current
            if (E === null) return
            if (!y.hasFocus() || !i() || l.current) {
              l.current = !1
              return
            }
            if (E.contains(y.activeElement) || (o && y.activeElement !== c.current && y.activeElement !== u.current)) return
            if (y.activeElement !== f.current) f.current = null
            else if (f.current !== null) return
            if (!A.current) return
            let P = []
            if (((y.activeElement === c.current || y.activeElement === u.current) && (P = s(h.current)), P.length > 0)) {
              var T, F
              const D = !!((T = x.current) != null && T.shiftKey && ((F = x.current) == null ? void 0 : F.key) === 'Tab'),
                Q = P[0],
                R = P[P.length - 1]
              typeof Q != 'string' && typeof R != 'string' && (D ? R.focus() : Q.focus())
            } else E.focus()
          }
        y.addEventListener('focusin', w), y.addEventListener('keydown', b, !0)
        const k = setInterval(() => {
          y.activeElement && y.activeElement.tagName === 'BODY' && w()
        }, 50)
        return () => {
          clearInterval(k), y.removeEventListener('focusin', w), y.removeEventListener('keydown', b, !0)
        }
      }, [n, o, r, i, a, s])
    const m = y => {
        d.current === null && (d.current = y.relatedTarget), (A.current = !0), (f.current = y.target)
        const b = t.props.onFocus
        b && b(y)
      },
      v = y => {
        d.current === null && (d.current = y.relatedTarget), (A.current = !0)
      }
    return p.jsxs(N.Fragment, { children: [p.jsx('div', { tabIndex: a ? 0 : -1, onFocus: v, ref: c, 'data-testid': 'sentinelStart' }), N.cloneElement(t, { ref: g, onFocus: m }), p.jsx('div', { tabIndex: a ? 0 : -1, onFocus: v, ref: u, 'data-testid': 'sentinelEnd' })] })
  }
  function WE(e) {
    return typeof e == 'function' ? e() : e
  }
  function GE(e) {
    return e ? e.props.hasOwnProperty('in') : !1
  }
  const VE = new TE()
  function XE(e) {
    const { container: t, disableEscapeKeyDown: n = !1, disableScrollLock: o = !1, manager: r = VE, closeAfterTransition: s = !1, onTransitionEnter: i, onTransitionExited: a, children: l, onClose: c, open: u, rootRef: d } = e,
      f = N.useRef({}),
      A = N.useRef(null),
      h = N.useRef(null),
      g = ht(h, d),
      [x, m] = N.useState(!u),
      v = GE(l)
    let y = !0
    ;(e['aria-hidden'] === 'false' || e['aria-hidden'] === !1) && (y = !1)
    const b = () => yt(A.current),
      w = () => ((f.current.modalRef = h.current), (f.current.mount = A.current), f.current),
      k = () => {
        r.mount(w(), { disableScrollLock: o }), h.current && (h.current.scrollTop = 0)
      },
      E = Cn(() => {
        const I = WE(t) || b().body
        r.add(w(), I), h.current && k()
      }),
      P = N.useCallback(() => r.isTopModal(w()), [r]),
      T = Cn(I => {
        ;(A.current = I), I && (u && P() ? k() : h.current && os(h.current, y))
      }),
      F = N.useCallback(() => {
        r.remove(w(), y)
      }, [y, r])
    N.useEffect(
      () => () => {
        F()
      },
      [F]
    ),
      N.useEffect(() => {
        u ? E() : (!v || !s) && F()
      }, [u, F, v, s, E])
    const D = I => z => {
        var B
        ;(B = I.onKeyDown) == null || B.call(I, z), !(z.key !== 'Escape' || z.which === 229 || !P()) && (n || (z.stopPropagation(), c && c(z, 'escapeKeyDown')))
      },
      Q = I => z => {
        var B
        ;(B = I.onClick) == null || B.call(I, z), z.target === z.currentTarget && c && c(z, 'backdropClick')
      }
    return {
      getRootProps: (I = {}) => {
        const z = $r(e)
        delete z.onTransitionEnter, delete z.onTransitionExited
        const B = M({}, z, I)
        return M({ role: 'presentation' }, B, { onKeyDown: D(B), ref: g })
      },
      getBackdropProps: (I = {}) => {
        const z = I
        return M({ 'aria-hidden': !0 }, z, { onClick: Q(z), open: u })
      },
      getTransitionProps: () => {
        const I = () => {
            m(!1), i && i()
          },
          z = () => {
            m(!0), a && a(), s && F()
          }
        return { onEnter: Ic(I, l == null ? void 0 : l.props.onEnter), onExited: Ic(z, l == null ? void 0 : l.props.onExited) }
      },
      rootRef: g,
      portalRef: T,
      isTopModal: P,
      exited: x,
      hasTransition: v,
    }
  }
  function YE(e) {
    return Fe('MuiModal', e)
  }
  Pe('MuiModal', ['root', 'hidden', 'backdrop'])
  const HE = [
      'BackdropComponent',
      'BackdropProps',
      'classes',
      'className',
      'closeAfterTransition',
      'children',
      'container',
      'component',
      'components',
      'componentsProps',
      'disableAutoFocus',
      'disableEnforceFocus',
      'disableEscapeKeyDown',
      'disablePortal',
      'disableRestoreFocus',
      'disableScrollLock',
      'hideBackdrop',
      'keepMounted',
      'onBackdropClick',
      'onClose',
      'onTransitionEnter',
      'onTransitionExited',
      'open',
      'slotProps',
      'slots',
      'theme',
    ],
    UE = e => {
      const { open: t, exited: n, classes: o } = e
      return Re({ root: ['root', !t && n && 'hidden'], backdrop: ['backdrop'] }, YE, o)
    },
    KE = j('div', {
      name: 'MuiModal',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, !n.open && n.exited && t.hidden]
      },
    })(({ theme: e, ownerState: t }) => M({ position: 'fixed', zIndex: (e.vars || e).zIndex.modal, right: 0, bottom: 0, top: 0, left: 0 }, !t.open && t.exited && { visibility: 'hidden' })),
    qE = j(VA, { name: 'MuiModal', slot: 'Backdrop', overridesResolver: (e, t) => t.backdrop })({ zIndex: -1 }),
    Vc = N.forwardRef(function (t, n) {
      var o, r, s, i, a, l
      const c = Le({ name: 'MuiModal', props: t }),
        {
          BackdropComponent: u = qE,
          BackdropProps: d,
          className: f,
          closeAfterTransition: A = !1,
          children: h,
          container: g,
          component: x,
          components: m = {},
          componentsProps: v = {},
          disableAutoFocus: y = !1,
          disableEnforceFocus: b = !1,
          disableEscapeKeyDown: w = !1,
          disablePortal: k = !1,
          disableRestoreFocus: E = !1,
          disableScrollLock: P = !1,
          hideBackdrop: T = !1,
          keepMounted: F = !1,
          onBackdropClick: D,
          open: Q,
          slotProps: R,
          slots: S,
        } = c,
        L = he(c, HE),
        I = M({}, c, { closeAfterTransition: A, disableAutoFocus: y, disableEnforceFocus: b, disableEscapeKeyDown: w, disablePortal: k, disableRestoreFocus: E, disableScrollLock: P, hideBackdrop: T, keepMounted: F }),
        { getRootProps: z, getBackdropProps: B, getTransitionProps: O, portalRef: W, isTopModal: K, exited: Z, hasTransition: oe } = XE(M({}, I, { rootRef: n })),
        V = M({}, I, { exited: Z }),
        q = UE(V),
        ee = {}
      if ((h.props.tabIndex === void 0 && (ee.tabIndex = '-1'), oe)) {
        const { onEnter: H, onExited: U } = O()
        ;(ee.onEnter = H), (ee.onExited = U)
      }
      const re = (o = (r = S == null ? void 0 : S.root) != null ? r : m.Root) != null ? o : KE,
        J = (s = (i = S == null ? void 0 : S.backdrop) != null ? i : m.Backdrop) != null ? s : u,
        ie = (a = R == null ? void 0 : R.root) != null ? a : v.root,
        Ae = (l = R == null ? void 0 : R.backdrop) != null ? l : v.backdrop,
        ae = Lt({ elementType: re, externalSlotProps: ie, externalForwardedProps: L, getSlotProps: z, additionalProps: { ref: n, as: x }, ownerState: V, className: fe(f, ie == null ? void 0 : ie.className, q == null ? void 0 : q.root, !V.open && V.exited && (q == null ? void 0 : q.hidden)) }),
        se = Lt({
          elementType: J,
          externalSlotProps: Ae,
          additionalProps: d,
          getSlotProps: H =>
            B(
              M({}, H, {
                onClick: U => {
                  D && D(U), H != null && H.onClick && H.onClick(U)
                },
              })
            ),
          className: fe(Ae == null ? void 0 : Ae.className, d == null ? void 0 : d.className, q == null ? void 0 : q.backdrop),
          ownerState: V,
        })
      return !F && !Q && (!oe || Z) ? null : p.jsx(qw, { ref: W, container: g, disablePortal: k, children: p.jsxs(re, M({}, ae, { children: [!T && u ? p.jsx(J, M({}, se)) : null, p.jsx(jE, { disableEnforceFocus: b, disableAutoFocus: y, disableRestoreFocus: E, isEnabled: K, open: Q, children: N.cloneElement(h, ee) })] })) })
    })
  function ZE(e) {
    return Fe('MuiDialog', e)
  }
  const Xc = Pe('MuiDialog', ['root', 'scrollPaper', 'scrollBody', 'container', 'paper', 'paperScrollPaper', 'paperScrollBody', 'paperWidthFalse', 'paperWidthXs', 'paperWidthSm', 'paperWidthMd', 'paperWidthLg', 'paperWidthXl', 'paperFullWidth', 'paperFullScreen']),
    KA = N.createContext({}),
    JE = ['aria-describedby', 'aria-labelledby', 'BackdropComponent', 'BackdropProps', 'children', 'className', 'disableEscapeKeyDown', 'fullScreen', 'fullWidth', 'maxWidth', 'onBackdropClick', 'onClick', 'onClose', 'open', 'PaperComponent', 'PaperProps', 'scroll', 'TransitionComponent', 'transitionDuration', 'TransitionProps'],
    _E = j(VA, { name: 'MuiDialog', slot: 'Backdrop', overrides: (e, t) => t.backdrop })({ zIndex: -1 }),
    $E = e => {
      const { classes: t, scroll: n, maxWidth: o, fullWidth: r, fullScreen: s } = e,
        i = { root: ['root'], container: ['container', `scroll${me(n)}`], paper: ['paper', `paperScroll${me(n)}`, `paperWidth${me(String(o))}`, r && 'paperFullWidth', s && 'paperFullScreen'] }
      return Re(i, ZE, t)
    },
    eS = j(Vc, { name: 'MuiDialog', slot: 'Root', overridesResolver: (e, t) => t.root })({ '@media print': { position: 'absolute !important' } }),
    tS = j('div', {
      name: 'MuiDialog',
      slot: 'Container',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.container, t[`scroll${me(n.scroll)}`]]
      },
    })(({ ownerState: e }) =>
      M(
        { height: '100%', '@media print': { height: 'auto' }, outline: 0 },
        e.scroll === 'paper' && { display: 'flex', justifyContent: 'center', alignItems: 'center' },
        e.scroll === 'body' && { overflowY: 'auto', overflowX: 'hidden', textAlign: 'center', '&::after': { content: '""', display: 'inline-block', verticalAlign: 'middle', height: '100%', width: '0' } }
      )
    ),
    nS = j(ts, {
      name: 'MuiDialog',
      slot: 'Paper',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.paper, t[`scrollPaper${me(n.scroll)}`], t[`paperWidth${me(String(n.maxWidth))}`], n.fullWidth && t.paperFullWidth, n.fullScreen && t.paperFullScreen]
      },
    })(({ theme: e, ownerState: t }) =>
      M(
        { margin: 32, position: 'relative', overflowY: 'auto', '@media print': { overflowY: 'visible', boxShadow: 'none' } },
        t.scroll === 'paper' && { display: 'flex', flexDirection: 'column', maxHeight: 'calc(100% - 64px)' },
        t.scroll === 'body' && { display: 'inline-block', verticalAlign: 'middle', textAlign: 'left' },
        !t.maxWidth && { maxWidth: 'calc(100% - 64px)' },
        t.maxWidth === 'xs' && { maxWidth: e.breakpoints.unit === 'px' ? Math.max(e.breakpoints.values.xs, 444) : `max(${e.breakpoints.values.xs}${e.breakpoints.unit}, 444px)`, [`&.${Xc.paperScrollBody}`]: { [e.breakpoints.down(Math.max(e.breakpoints.values.xs, 444) + 32 * 2)]: { maxWidth: 'calc(100% - 64px)' } } },
        t.maxWidth && t.maxWidth !== 'xs' && { maxWidth: `${e.breakpoints.values[t.maxWidth]}${e.breakpoints.unit}`, [`&.${Xc.paperScrollBody}`]: { [e.breakpoints.down(e.breakpoints.values[t.maxWidth] + 32 * 2)]: { maxWidth: 'calc(100% - 64px)' } } },
        t.fullWidth && { width: 'calc(100% - 64px)' },
        t.fullScreen && { margin: 0, width: '100%', maxWidth: '100%', height: '100%', maxHeight: 'none', borderRadius: 0, [`&.${Xc.paperScrollBody}`]: { margin: 0, maxWidth: '100%' } }
      )
    ),
    oS = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiDialog' }),
        r = Zr(),
        s = { enter: r.transitions.duration.enteringScreen, exit: r.transitions.duration.leavingScreen },
        {
          'aria-describedby': i,
          'aria-labelledby': a,
          BackdropComponent: l,
          BackdropProps: c,
          children: u,
          className: d,
          disableEscapeKeyDown: f = !1,
          fullScreen: A = !1,
          fullWidth: h = !1,
          maxWidth: g = 'sm',
          onBackdropClick: x,
          onClick: m,
          onClose: v,
          open: y,
          PaperComponent: b = ts,
          PaperProps: w = {},
          scroll: k = 'paper',
          TransitionComponent: E = GA,
          transitionDuration: P = s,
          TransitionProps: T,
        } = o,
        F = he(o, JE),
        D = M({}, o, { disableEscapeKeyDown: f, fullScreen: A, fullWidth: h, maxWidth: g, scroll: k }),
        Q = $E(D),
        R = N.useRef(),
        S = B => {
          R.current = B.target === B.currentTarget
        },
        L = B => {
          m && m(B), R.current && ((R.current = null), x && x(B), v && v(B, 'backdropClick'))
        },
        I = _i(a),
        z = N.useMemo(() => ({ titleId: I }), [I])
      return p.jsx(
        eS,
        M({ className: fe(Q.root, d), closeAfterTransition: !0, components: { Backdrop: _E }, componentsProps: { backdrop: M({ transitionDuration: P, as: l }, c) }, disableEscapeKeyDown: f, onClose: v, open: y, ref: n, onClick: L, ownerState: D }, F, {
          children: p.jsx(
            E,
            M({ appear: !0, in: y, timeout: P, role: 'presentation' }, T, {
              children: p.jsx(tS, { className: fe(Q.container), onMouseDown: S, ownerState: D, children: p.jsx(nS, M({ as: b, elevation: 24, role: 'dialog', 'aria-describedby': i, 'aria-labelledby': I }, w, { className: fe(Q.paper, w.className), ownerState: D, children: p.jsx(KA.Provider, { value: z, children: u }) })) }),
            })
          ),
        })
      )
    })
  function rS(e) {
    return Fe('MuiDialogTitle', e)
  }
  Pe('MuiDialogTitle', ['root'])
  const sS = ['className', 'id'],
    iS = e => {
      const { classes: t } = e
      return Re({ root: ['root'] }, rS, t)
    },
    aS = j(bo, { name: 'MuiDialogTitle', slot: 'Root', overridesResolver: (e, t) => t.root })({ padding: '16px 24px', flex: '0 0 auto' }),
    lS = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiDialogTitle' }),
        { className: r, id: s } = o,
        i = he(o, sS),
        a = o,
        l = iS(a),
        { titleId: c = s } = N.useContext(KA)
      return p.jsx(aS, M({ component: 'h2', className: fe(l.root, r), ownerState: a, ref: n, variant: 'h6', id: s ?? c }, i))
    })
  function cS(e) {
    return Fe('MuiDivider', e)
  }
  const qA = Pe('MuiDivider', ['root', 'absolute', 'fullWidth', 'inset', 'middle', 'flexItem', 'light', 'vertical', 'withChildren', 'withChildrenVertical', 'textAlignRight', 'textAlignLeft', 'wrapper', 'wrapperVertical']),
    uS = ['absolute', 'children', 'className', 'component', 'flexItem', 'light', 'orientation', 'role', 'textAlign', 'variant'],
    dS = e => {
      const { absolute: t, children: n, classes: o, flexItem: r, light: s, orientation: i, textAlign: a, variant: l } = e
      return Re(
        { root: ['root', t && 'absolute', l, s && 'light', i === 'vertical' && 'vertical', r && 'flexItem', n && 'withChildren', n && i === 'vertical' && 'withChildrenVertical', a === 'right' && i !== 'vertical' && 'textAlignRight', a === 'left' && i !== 'vertical' && 'textAlignLeft'], wrapper: ['wrapper', i === 'vertical' && 'wrapperVertical'] },
        cS,
        o
      )
    },
    fS = j('div', {
      name: 'MuiDivider',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [
          t.root,
          n.absolute && t.absolute,
          t[n.variant],
          n.light && t.light,
          n.orientation === 'vertical' && t.vertical,
          n.flexItem && t.flexItem,
          n.children && t.withChildren,
          n.children && n.orientation === 'vertical' && t.withChildrenVertical,
          n.textAlign === 'right' && n.orientation !== 'vertical' && t.textAlignRight,
          n.textAlign === 'left' && n.orientation !== 'vertical' && t.textAlignLeft,
        ]
      },
    })(
      ({ theme: e, ownerState: t }) =>
        M(
          { margin: 0, flexShrink: 0, borderWidth: 0, borderStyle: 'solid', borderColor: (e.vars || e).palette.divider, borderBottomWidth: 'thin' },
          t.absolute && { position: 'absolute', bottom: 0, left: 0, width: '100%' },
          t.light && { borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : Bt(e.palette.divider, 0.08) },
          t.variant === 'inset' && { marginLeft: 72 },
          t.variant === 'middle' && t.orientation === 'horizontal' && { marginLeft: e.spacing(2), marginRight: e.spacing(2) },
          t.variant === 'middle' && t.orientation === 'vertical' && { marginTop: e.spacing(1), marginBottom: e.spacing(1) },
          t.orientation === 'vertical' && { height: '100%', borderBottomWidth: 0, borderRightWidth: 'thin' },
          t.flexItem && { alignSelf: 'stretch', height: 'auto' }
        ),
      ({ ownerState: e }) => M({}, e.children && { display: 'flex', whiteSpace: 'nowrap', textAlign: 'center', border: 0, borderTopStyle: 'solid', borderLeftStyle: 'solid', '&::before, &::after': { content: '""', alignSelf: 'center' } }),
      ({ theme: e, ownerState: t }) => M({}, t.children && t.orientation !== 'vertical' && { '&::before, &::after': { width: '100%', borderTop: `thin solid ${(e.vars || e).palette.divider}`, borderTopStyle: 'inherit' } }),
      ({ theme: e, ownerState: t }) => M({}, t.children && t.orientation === 'vertical' && { flexDirection: 'column', '&::before, &::after': { height: '100%', borderLeft: `thin solid ${(e.vars || e).palette.divider}`, borderLeftStyle: 'inherit' } }),
      ({ ownerState: e }) => M({}, e.textAlign === 'right' && e.orientation !== 'vertical' && { '&::before': { width: '90%' }, '&::after': { width: '10%' } }, e.textAlign === 'left' && e.orientation !== 'vertical' && { '&::before': { width: '10%' }, '&::after': { width: '90%' } })
    ),
    AS = j('span', {
      name: 'MuiDivider',
      slot: 'Wrapper',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.wrapper, n.orientation === 'vertical' && t.wrapperVertical]
      },
    })(({ theme: e, ownerState: t }) => M({ display: 'inline-block', paddingLeft: `calc(${e.spacing(1)} * 1.2)`, paddingRight: `calc(${e.spacing(1)} * 1.2)` }, t.orientation === 'vertical' && { paddingTop: `calc(${e.spacing(1)} * 1.2)`, paddingBottom: `calc(${e.spacing(1)} * 1.2)` })),
    ZA = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiDivider' }),
        { absolute: r = !1, children: s, className: i, component: a = s ? 'div' : 'hr', flexItem: l = !1, light: c = !1, orientation: u = 'horizontal', role: d = a !== 'hr' ? 'separator' : void 0, textAlign: f = 'center', variant: A = 'fullWidth' } = o,
        h = he(o, uS),
        g = M({}, o, { absolute: r, component: a, flexItem: l, light: c, orientation: u, role: d, textAlign: f, variant: A }),
        x = dS(g)
      return p.jsx(fS, M({ as: a, className: fe(x.root, i), role: d, ref: n, ownerState: g }, h, { children: s ? p.jsx(AS, { className: x.wrapper, ownerState: g, children: s }) : null }))
    })
  ZA.muiSkipListHighlight = !0
  const pS = ['addEndListener', 'appear', 'children', 'container', 'direction', 'easing', 'in', 'onEnter', 'onEntered', 'onEntering', 'onExit', 'onExited', 'onExiting', 'style', 'timeout', 'TransitionComponent']
  function hS(e, t, n) {
    const o = t.getBoundingClientRect(),
      r = n && n.getBoundingClientRect(),
      s = vn(t)
    let i
    if (t.fakeTransform) i = t.fakeTransform
    else {
      const c = s.getComputedStyle(t)
      i = c.getPropertyValue('-webkit-transform') || c.getPropertyValue('transform')
    }
    let a = 0,
      l = 0
    if (i && i !== 'none' && typeof i == 'string') {
      const c = i.split('(')[1].split(')')[0].split(',')
      ;(a = parseInt(c[4], 10)), (l = parseInt(c[5], 10))
    }
    return e === 'left'
      ? r
        ? `translateX(${r.right + a - o.left}px)`
        : `translateX(${s.innerWidth + a - o.left}px)`
      : e === 'right'
      ? r
        ? `translateX(-${o.right - r.left - a}px)`
        : `translateX(-${o.left + o.width - a}px)`
      : e === 'up'
      ? r
        ? `translateY(${r.bottom + l - o.top}px)`
        : `translateY(${s.innerHeight + l - o.top}px)`
      : r
      ? `translateY(-${o.top - r.top + o.height - l}px)`
      : `translateY(-${o.top + o.height - l}px)`
  }
  function gS(e) {
    return typeof e == 'function' ? e() : e
  }
  function fa(e, t, n) {
    const o = gS(n),
      r = hS(e, t, o)
    r && ((t.style.webkitTransform = r), (t.style.transform = r))
  }
  const mS = N.forwardRef(function (t, n) {
    const o = Zr(),
      r = { enter: o.transitions.easing.easeOut, exit: o.transitions.easing.sharp },
      s = { enter: o.transitions.duration.enteringScreen, exit: o.transitions.duration.leavingScreen },
      { addEndListener: i, appear: a = !0, children: l, container: c, direction: u = 'down', easing: d = r, in: f, onEnter: A, onEntered: h, onEntering: g, onExit: x, onExited: m, onExiting: v, style: y, timeout: b = s, TransitionComponent: w = rn } = t,
      k = he(t, pS),
      E = N.useRef(null),
      P = ht(ar(l), E, n),
      T = B => O => {
        B && (O === void 0 ? B(E.current) : B(E.current, O))
      },
      F = T((B, O) => {
        fa(u, B, c), Qc(B), A && A(B, O)
      }),
      D = T((B, O) => {
        const W = ur({ timeout: b, style: y, easing: d }, { mode: 'enter' })
        ;(B.style.webkitTransition = o.transitions.create('-webkit-transform', M({}, W))), (B.style.transition = o.transitions.create('transform', M({}, W))), (B.style.webkitTransform = 'none'), (B.style.transform = 'none'), g && g(B, O)
      }),
      Q = T(h),
      R = T(v),
      S = T(B => {
        const O = ur({ timeout: b, style: y, easing: d }, { mode: 'exit' })
        ;(B.style.webkitTransition = o.transitions.create('-webkit-transform', O)), (B.style.transition = o.transitions.create('transform', O)), fa(u, B, c), x && x(B)
      }),
      L = T(B => {
        ;(B.style.webkitTransition = ''), (B.style.transition = ''), m && m(B)
      }),
      I = B => {
        i && i(E.current, B)
      },
      z = N.useCallback(() => {
        E.current && fa(u, E.current, c)
      }, [u, c])
    return (
      N.useEffect(() => {
        if (f || u === 'down' || u === 'right') return
        const B = qi(() => {
            E.current && fa(u, E.current, c)
          }),
          O = vn(E.current)
        return (
          O.addEventListener('resize', B),
          () => {
            B.clear(), O.removeEventListener('resize', B)
          }
        )
      }, [u, f, c]),
      N.useEffect(() => {
        f || z()
      }, [f, z]),
      p.jsx(w, M({ nodeRef: E, onEnter: F, onEntered: Q, onEntering: D, onExit: S, onExited: L, onExiting: R, addEndListener: I, appear: a, in: f, timeout: b }, k, { children: (B, O) => N.cloneElement(l, M({ ref: P, style: M({ visibility: B === 'exited' && !f ? 'hidden' : void 0 }, y, l.props.style) }, O)) }))
    )
  })
  function yS(e) {
    return Fe('MuiDrawer', e)
  }
  Pe('MuiDrawer', ['root', 'docked', 'paper', 'paperAnchorLeft', 'paperAnchorRight', 'paperAnchorTop', 'paperAnchorBottom', 'paperAnchorDockedLeft', 'paperAnchorDockedRight', 'paperAnchorDockedTop', 'paperAnchorDockedBottom', 'modal'])
  const bS = ['BackdropProps'],
    vS = ['anchor', 'BackdropProps', 'children', 'className', 'elevation', 'hideBackdrop', 'ModalProps', 'onClose', 'open', 'PaperProps', 'SlideProps', 'TransitionComponent', 'transitionDuration', 'variant'],
    JA = (e, t) => {
      const { ownerState: n } = e
      return [t.root, (n.variant === 'permanent' || n.variant === 'persistent') && t.docked, t.modal]
    },
    xS = e => {
      const { classes: t, anchor: n, variant: o } = e,
        r = { root: ['root'], docked: [(o === 'permanent' || o === 'persistent') && 'docked'], modal: ['modal'], paper: ['paper', `paperAnchor${me(n)}`, o !== 'temporary' && `paperAnchorDocked${me(n)}`] }
      return Re(r, yS, t)
    },
    CS = j(Vc, { name: 'MuiDrawer', slot: 'Root', overridesResolver: JA })(({ theme: e }) => ({ zIndex: (e.vars || e).zIndex.drawer })),
    _A = j('div', { shouldForwardProp: Ot, name: 'MuiDrawer', slot: 'Docked', skipVariantsResolver: !1, overridesResolver: JA })({ flex: '0 0 auto' }),
    wS = j(ts, {
      name: 'MuiDrawer',
      slot: 'Paper',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.paper, t[`paperAnchor${me(n.anchor)}`], n.variant !== 'temporary' && t[`paperAnchorDocked${me(n.anchor)}`]]
      },
    })(({ theme: e, ownerState: t }) =>
      M(
        { overflowY: 'auto', display: 'flex', flexDirection: 'column', height: '100%', flex: '1 0 auto', zIndex: (e.vars || e).zIndex.drawer, WebkitOverflowScrolling: 'touch', position: 'fixed', top: 0, outline: 0 },
        t.anchor === 'left' && { left: 0 },
        t.anchor === 'top' && { top: 0, left: 0, right: 0, height: 'auto', maxHeight: '100%' },
        t.anchor === 'right' && { right: 0 },
        t.anchor === 'bottom' && { top: 'auto', left: 0, bottom: 0, right: 0, height: 'auto', maxHeight: '100%' },
        t.anchor === 'left' && t.variant !== 'temporary' && { borderRight: `1px solid ${(e.vars || e).palette.divider}` },
        t.anchor === 'top' && t.variant !== 'temporary' && { borderBottom: `1px solid ${(e.vars || e).palette.divider}` },
        t.anchor === 'right' && t.variant !== 'temporary' && { borderLeft: `1px solid ${(e.vars || e).palette.divider}` },
        t.anchor === 'bottom' && t.variant !== 'temporary' && { borderTop: `1px solid ${(e.vars || e).palette.divider}` }
      )
    ),
    $A = { left: 'right', right: 'left', top: 'down', bottom: 'up' }
  function ES(e) {
    return ['left', 'right'].indexOf(e) !== -1
  }
  function SS({ direction: e }, t) {
    return e === 'rtl' && ES(t) ? $A[t] : t
  }
  const BS = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiDrawer' }),
        r = Zr(),
        s = hc(),
        i = { enter: r.transitions.duration.enteringScreen, exit: r.transitions.duration.leavingScreen },
        { anchor: a = 'left', BackdropProps: l, children: c, className: u, elevation: d = 16, hideBackdrop: f = !1, ModalProps: { BackdropProps: A } = {}, onClose: h, open: g = !1, PaperProps: x = {}, SlideProps: m, TransitionComponent: v = mS, transitionDuration: y = i, variant: b = 'temporary' } = o,
        w = he(o.ModalProps, bS),
        k = he(o, vS),
        E = N.useRef(!1)
      N.useEffect(() => {
        E.current = !0
      }, [])
      const P = SS({ direction: s ? 'rtl' : 'ltr' }, a),
        F = M({}, o, { anchor: a, elevation: d, open: g, variant: b }, k),
        D = xS(F),
        Q = p.jsx(wS, M({ elevation: b === 'temporary' ? d : 0, square: !0 }, x, { className: fe(D.paper, x.className), ownerState: F, children: c }))
      if (b === 'permanent') return p.jsx(_A, M({ className: fe(D.root, D.docked, u), ownerState: F, ref: n }, k, { children: Q }))
      const R = p.jsx(v, M({ in: g, direction: $A[P], timeout: y, appear: E.current }, m, { children: Q }))
      return b === 'persistent' ? p.jsx(_A, M({ className: fe(D.root, D.docked, u), ownerState: F, ref: n }, k, { children: R })) : p.jsx(CS, M({ BackdropProps: M({}, l, A, { transitionDuration: y }), className: fe(D.root, D.modal, u), open: g, ownerState: F, onClose: h, hideBackdrop: f, ref: n }, k, w, { children: R }))
    }),
    IS = ['disableUnderline', 'components', 'componentsProps', 'fullWidth', 'hiddenLabel', 'inputComponent', 'multiline', 'slotProps', 'slots', 'type'],
    kS = e => {
      const { classes: t, disableUnderline: n } = e,
        r = Re({ root: ['root', !n && 'underline'], input: ['input'] }, aE, t)
      return M({}, t, r)
    },
    NS = j(ca, {
      shouldForwardProp: e => Ot(e) || e === 'classes',
      name: 'MuiFilledInput',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [...aa(e, t), !n.disableUnderline && t.underline]
      },
    })(({ theme: e, ownerState: t }) => {
      var n
      const o = e.palette.mode === 'light',
        r = o ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)',
        s = o ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.09)',
        i = o ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.13)',
        a = o ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'
      return M(
        {
          position: 'relative',
          backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s,
          borderTopLeftRadius: (e.vars || e).shape.borderRadius,
          borderTopRightRadius: (e.vars || e).shape.borderRadius,
          transition: e.transitions.create('background-color', { duration: e.transitions.duration.shorter, easing: e.transitions.easing.easeOut }),
          '&:hover': { backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : i, '@media (hover: none)': { backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s } },
          [`&.${xo.focused}`]: { backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s },
          [`&.${xo.disabled}`]: { backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : a },
        },
        !t.disableUnderline && {
          '&::after': {
            borderBottom: `2px solid ${(n = (e.vars || e).palette[t.color || 'primary']) == null ? void 0 : n.main}`,
            left: 0,
            bottom: 0,
            content: '""',
            position: 'absolute',
            right: 0,
            transform: 'scaleX(0)',
            transition: e.transitions.create('transform', { duration: e.transitions.duration.shorter, easing: e.transitions.easing.easeOut }),
            pointerEvents: 'none',
          },
          [`&.${xo.focused}:after`]: { transform: 'scaleX(1) translateX(0)' },
          [`&.${xo.error}`]: { '&::before, &::after': { borderBottomColor: (e.vars || e).palette.error.main } },
          '&::before': {
            borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : r}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: 'absolute',
            right: 0,
            transition: e.transitions.create('border-bottom-color', { duration: e.transitions.duration.shorter }),
            pointerEvents: 'none',
          },
          [`&:hover:not(.${xo.disabled}, .${xo.error}):before`]: { borderBottom: `1px solid ${(e.vars || e).palette.text.primary}` },
          [`&.${xo.disabled}:before`]: { borderBottomStyle: 'dotted' },
        },
        t.startAdornment && { paddingLeft: 12 },
        t.endAdornment && { paddingRight: 12 },
        t.multiline && M({ padding: '25px 12px 8px' }, t.size === 'small' && { paddingTop: 21, paddingBottom: 4 }, t.hiddenLabel && { paddingTop: 16, paddingBottom: 17 }, t.hiddenLabel && t.size === 'small' && { paddingTop: 8, paddingBottom: 9 })
      )
    }),
    MS = j(ua, { name: 'MuiFilledInput', slot: 'Input', overridesResolver: la })(({ theme: e, ownerState: t }) =>
      M(
        { paddingTop: 25, paddingRight: 12, paddingBottom: 8, paddingLeft: 12 },
        !e.vars && { '&:-webkit-autofill': { WebkitBoxShadow: e.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset', WebkitTextFillColor: e.palette.mode === 'light' ? null : '#fff', caretColor: e.palette.mode === 'light' ? null : '#fff', borderTopLeftRadius: 'inherit', borderTopRightRadius: 'inherit' } },
        e.vars && { '&:-webkit-autofill': { borderTopLeftRadius: 'inherit', borderTopRightRadius: 'inherit' }, [e.getColorSchemeSelector('dark')]: { '&:-webkit-autofill': { WebkitBoxShadow: '0 0 0 100px #266798 inset', WebkitTextFillColor: '#fff', caretColor: '#fff' } } },
        t.size === 'small' && { paddingTop: 21, paddingBottom: 4 },
        t.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
        t.startAdornment && { paddingLeft: 0 },
        t.endAdornment && { paddingRight: 0 },
        t.hiddenLabel && t.size === 'small' && { paddingTop: 8, paddingBottom: 9 },
        t.multiline && { paddingTop: 0, paddingBottom: 0, paddingLeft: 0, paddingRight: 0 }
      )
    ),
    Yc = N.forwardRef(function (t, n) {
      var o, r, s, i
      const a = Le({ props: t, name: 'MuiFilledInput' }),
        { components: l = {}, componentsProps: c, fullWidth: u = !1, inputComponent: d = 'input', multiline: f = !1, slotProps: A, slots: h = {}, type: g = 'text' } = a,
        x = he(a, IS),
        m = M({}, a, { fullWidth: u, inputComponent: d, multiline: f, type: g }),
        v = kS(a),
        y = { root: { ownerState: m }, input: { ownerState: m } },
        b = A ?? c ? Ln(y, A ?? c) : y,
        w = (o = (r = h.root) != null ? r : l.Root) != null ? o : NS,
        k = (s = (i = h.input) != null ? i : l.Input) != null ? s : MS
      return p.jsx(jc, M({ slots: { root: w, input: k }, componentsProps: b, fullWidth: u, inputComponent: d, multiline: f, ref: n, type: g }, x, { classes: v }))
    })
  Yc.muiName = 'Input'
  function PS(e) {
    return Fe('MuiFormControl', e)
  }
  Pe('MuiFormControl', ['root', 'marginNone', 'marginNormal', 'marginDense', 'fullWidth', 'disabled'])
  const LS = ['children', 'className', 'color', 'component', 'disabled', 'error', 'focused', 'fullWidth', 'hiddenLabel', 'margin', 'required', 'size', 'variant'],
    TS = e => {
      const { classes: t, margin: n, fullWidth: o } = e,
        r = { root: ['root', n !== 'none' && `margin${me(n)}`, o && 'fullWidth'] }
      return Re(r, PS, t)
    },
    FS = j('div', { name: 'MuiFormControl', slot: 'Root', overridesResolver: ({ ownerState: e }, t) => M({}, t.root, t[`margin${me(e.margin)}`], e.fullWidth && t.fullWidth) })(({ ownerState: e }) =>
      M({ display: 'inline-flex', flexDirection: 'column', position: 'relative', minWidth: 0, padding: 0, margin: 0, border: 0, verticalAlign: 'top' }, e.margin === 'normal' && { marginTop: 16, marginBottom: 8 }, e.margin === 'dense' && { marginTop: 8, marginBottom: 4 }, e.fullWidth && { width: '100%' })
    ),
    ep = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiFormControl' }),
        { children: r, className: s, color: i = 'primary', component: a = 'div', disabled: l = !1, error: c = !1, focused: u, fullWidth: d = !1, hiddenLabel: f = !1, margin: A = 'none', required: h = !1, size: g = 'medium', variant: x = 'outlined' } = o,
        m = he(o, LS),
        v = M({}, o, { color: i, component: a, disabled: l, error: c, fullWidth: d, hiddenLabel: f, margin: A, required: h, size: g, variant: x }),
        y = TS(v),
        [b, w] = N.useState(() => {
          let R = !1
          return (
            r &&
              N.Children.forEach(r, S => {
                if (!Zi(S, ['Input', 'Select'])) return
                const L = Zi(S, ['Select']) ? S.props.input : S
                L && eE(L.props) && (R = !0)
              }),
            R
          )
        }),
        [k, E] = N.useState(() => {
          let R = !1
          return (
            r &&
              N.Children.forEach(r, S => {
                Zi(S, ['Input', 'Select']) && (ia(S.props, !0) || ia(S.props.inputProps, !0)) && (R = !0)
              }),
            R
          )
        }),
        [P, T] = N.useState(!1)
      l && P && T(!1)
      const F = u !== void 0 && !l ? u : P
      let D
      const Q = N.useMemo(
        () => ({
          adornedStart: b,
          setAdornedStart: w,
          color: i,
          disabled: l,
          error: c,
          filled: k,
          focused: F,
          fullWidth: d,
          hiddenLabel: f,
          size: g,
          onBlur: () => {
            T(!1)
          },
          onEmpty: () => {
            E(!1)
          },
          onFilled: () => {
            E(!0)
          },
          onFocus: () => {
            T(!0)
          },
          registerEffect: D,
          required: h,
          variant: x,
        }),
        [b, i, l, c, k, F, d, f, D, h, g, x]
      )
      return p.jsx(sa.Provider, { value: Q, children: p.jsx(FS, M({ as: a, ownerState: v, className: fe(y.root, s), ref: n }, m, { children: r })) })
    }),
    DS = DC({ createStyledComponent: j('div', { name: 'MuiStack', slot: 'Root', overridesResolver: (e, t) => t.root }), useThemeProps: e => Le({ props: e, name: 'MuiStack' }) })
  function zS(e) {
    return Fe('MuiFormHelperText', e)
  }
  const tp = Pe('MuiFormHelperText', ['root', 'error', 'disabled', 'sizeSmall', 'sizeMedium', 'contained', 'focused', 'filled', 'required'])
  var np
  const QS = ['children', 'className', 'component', 'disabled', 'error', 'filled', 'focused', 'margin', 'required', 'variant'],
    RS = e => {
      const { classes: t, contained: n, size: o, disabled: r, error: s, filled: i, focused: a, required: l } = e,
        c = { root: ['root', r && 'disabled', s && 'error', o && `size${me(o)}`, n && 'contained', a && 'focused', i && 'filled', l && 'required'] }
      return Re(c, zS, t)
    },
    OS = j('p', {
      name: 'MuiFormHelperText',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, n.size && t[`size${me(n.size)}`], n.contained && t.contained, n.filled && t.filled]
      },
    })(({ theme: e, ownerState: t }) =>
      M(
        { color: (e.vars || e).palette.text.secondary },
        e.typography.caption,
        { textAlign: 'left', marginTop: 3, marginRight: 0, marginBottom: 0, marginLeft: 0, [`&.${tp.disabled}`]: { color: (e.vars || e).palette.text.disabled }, [`&.${tp.error}`]: { color: (e.vars || e).palette.error.main } },
        t.size === 'small' && { marginTop: 4 },
        t.contained && { marginLeft: 14, marginRight: 14 }
      )
    ),
    op = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiFormHelperText' }),
        { children: r, className: s, component: i = 'p' } = o,
        a = he(o, QS),
        l = vo(),
        c = dr({ props: o, muiFormControl: l, states: ['variant', 'size', 'disabled', 'error', 'filled', 'focused', 'required'] }),
        u = M({}, o, { component: i, contained: c.variant === 'filled' || c.variant === 'outlined', variant: c.variant, size: c.size, disabled: c.disabled, error: c.error, filled: c.filled, focused: c.focused, required: c.required }),
        d = RS(u)
      return p.jsx(OS, M({ as: i, ownerState: u, className: fe(d.root, s), ref: n }, a, { children: r === ' ' ? np || (np = p.jsx('span', { className: 'notranslate', children: '​' })) : r }))
    })
  function jS(e) {
    return Fe('MuiFormLabel', e)
  }
  const rs = Pe('MuiFormLabel', ['root', 'colorSecondary', 'focused', 'disabled', 'error', 'filled', 'required', 'asterisk']),
    WS = ['children', 'className', 'color', 'component', 'disabled', 'error', 'filled', 'focused', 'required'],
    GS = e => {
      const { classes: t, color: n, focused: o, disabled: r, error: s, filled: i, required: a } = e,
        l = { root: ['root', `color${me(n)}`, r && 'disabled', s && 'error', i && 'filled', o && 'focused', a && 'required'], asterisk: ['asterisk', s && 'error'] }
      return Re(l, jS, t)
    },
    VS = j('label', { name: 'MuiFormLabel', slot: 'Root', overridesResolver: ({ ownerState: e }, t) => M({}, t.root, e.color === 'secondary' && t.colorSecondary, e.filled && t.filled) })(({ theme: e, ownerState: t }) =>
      M({ color: (e.vars || e).palette.text.secondary }, e.typography.body1, { lineHeight: '1.4375em', padding: 0, position: 'relative', [`&.${rs.focused}`]: { color: (e.vars || e).palette[t.color].main }, [`&.${rs.disabled}`]: { color: (e.vars || e).palette.text.disabled }, [`&.${rs.error}`]: { color: (e.vars || e).palette.error.main } })
    ),
    XS = j('span', { name: 'MuiFormLabel', slot: 'Asterisk', overridesResolver: (e, t) => t.asterisk })(({ theme: e }) => ({ [`&.${rs.error}`]: { color: (e.vars || e).palette.error.main } })),
    YS = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiFormLabel' }),
        { children: r, className: s, component: i = 'label' } = o,
        a = he(o, WS),
        l = vo(),
        c = dr({ props: o, muiFormControl: l, states: ['color', 'required', 'focused', 'disabled', 'error', 'filled'] }),
        u = M({}, o, { color: c.color || 'primary', component: i, disabled: c.disabled, error: c.error, filled: c.filled, focused: c.focused, required: c.required }),
        d = GS(u)
      return p.jsxs(VS, M({ as: i, ownerState: u, className: fe(d.root, s), ref: n }, a, { children: [r, c.required && p.jsxs(XS, { ownerState: u, 'aria-hidden': !0, className: d.asterisk, children: [' ', '*'] })] }))
    }),
    HS = ['addEndListener', 'appear', 'children', 'easing', 'in', 'onEnter', 'onEntered', 'onEntering', 'onExit', 'onExited', 'onExiting', 'style', 'timeout', 'TransitionComponent']
  function Hc(e) {
    return `scale(${e}, ${e ** 2})`
  }
  const US = { entering: { opacity: 1, transform: Hc(1) }, entered: { opacity: 1, transform: 'none' } },
    Uc = typeof navigator < 'u' && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
    rp = N.forwardRef(function (t, n) {
      const { addEndListener: o, appear: r = !0, children: s, easing: i, in: a, onEnter: l, onEntered: c, onEntering: u, onExit: d, onExited: f, onExiting: A, style: h, timeout: g = 'auto', TransitionComponent: x = rn } = t,
        m = he(t, HS),
        v = kA(),
        y = N.useRef(),
        b = Zr(),
        w = N.useRef(null),
        k = ht(w, ar(s), n),
        E = L => I => {
          if (L) {
            const z = w.current
            I === void 0 ? L(z) : L(z, I)
          }
        },
        P = E(u),
        T = E((L, I) => {
          Qc(L)
          const { duration: z, delay: B, easing: O } = ur({ style: h, timeout: g, easing: i }, { mode: 'enter' })
          let W
          g === 'auto' ? ((W = b.transitions.getAutoHeightDuration(L.clientHeight)), (y.current = W)) : (W = z), (L.style.transition = [b.transitions.create('opacity', { duration: W, delay: B }), b.transitions.create('transform', { duration: Uc ? W : W * 0.666, delay: B, easing: O })].join(',')), l && l(L, I)
        }),
        F = E(c),
        D = E(A),
        Q = E(L => {
          const { duration: I, delay: z, easing: B } = ur({ style: h, timeout: g, easing: i }, { mode: 'exit' })
          let O
          g === 'auto' ? ((O = b.transitions.getAutoHeightDuration(L.clientHeight)), (y.current = O)) : (O = I),
            (L.style.transition = [b.transitions.create('opacity', { duration: O, delay: z }), b.transitions.create('transform', { duration: Uc ? O : O * 0.666, delay: Uc ? z : z || O * 0.333, easing: B })].join(',')),
            (L.style.opacity = 0),
            (L.style.transform = Hc(0.75)),
            d && d(L)
        }),
        R = E(f),
        S = L => {
          g === 'auto' && v.start(y.current || 0, L), o && o(w.current, L)
        }
      return p.jsx(
        x,
        M({ appear: r, in: a, nodeRef: w, onEnter: T, onEntered: F, onEntering: P, onExit: Q, onExited: R, onExiting: D, addEndListener: S, timeout: g === 'auto' ? null : g }, m, {
          children: (L, I) => N.cloneElement(s, M({ style: M({ opacity: 0, transform: Hc(0.75), visibility: L === 'exited' && !a ? 'hidden' : void 0 }, US[L], h, s.props.style), ref: k }, I)),
        })
      )
    })
  rp.muiSupportAuto = !0
  const KS = ['disableUnderline', 'components', 'componentsProps', 'fullWidth', 'inputComponent', 'multiline', 'slotProps', 'slots', 'type'],
    qS = e => {
      const { classes: t, disableUnderline: n } = e,
        r = Re({ root: ['root', !n && 'underline'], input: ['input'] }, sE, t)
      return M({}, t, r)
    },
    ZS = j(ca, {
      shouldForwardProp: e => Ot(e) || e === 'classes',
      name: 'MuiInput',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [...aa(e, t), !n.disableUnderline && t.underline]
      },
    })(({ theme: e, ownerState: t }) => {
      let o = e.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)'
      return (
        e.vars && (o = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`),
        M(
          { position: 'relative' },
          t.formControl && { 'label + &': { marginTop: 16 } },
          !t.disableUnderline && {
            '&::after': { borderBottom: `2px solid ${(e.vars || e).palette[t.color].main}`, left: 0, bottom: 0, content: '""', position: 'absolute', right: 0, transform: 'scaleX(0)', transition: e.transitions.create('transform', { duration: e.transitions.duration.shorter, easing: e.transitions.easing.easeOut }), pointerEvents: 'none' },
            [`&.${ns.focused}:after`]: { transform: 'scaleX(1) translateX(0)' },
            [`&.${ns.error}`]: { '&::before, &::after': { borderBottomColor: (e.vars || e).palette.error.main } },
            '&::before': { borderBottom: `1px solid ${o}`, left: 0, bottom: 0, content: '"\\00a0"', position: 'absolute', right: 0, transition: e.transitions.create('border-bottom-color', { duration: e.transitions.duration.shorter }), pointerEvents: 'none' },
            [`&:hover:not(.${ns.disabled}, .${ns.error}):before`]: { borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`, '@media (hover: none)': { borderBottom: `1px solid ${o}` } },
            [`&.${ns.disabled}:before`]: { borderBottomStyle: 'dotted' },
          }
        )
      )
    }),
    JS = j(ua, { name: 'MuiInput', slot: 'Input', overridesResolver: la })({}),
    Kc = N.forwardRef(function (t, n) {
      var o, r, s, i
      const a = Le({ props: t, name: 'MuiInput' }),
        { disableUnderline: l, components: c = {}, componentsProps: u, fullWidth: d = !1, inputComponent: f = 'input', multiline: A = !1, slotProps: h, slots: g = {}, type: x = 'text' } = a,
        m = he(a, KS),
        v = qS(a),
        b = { root: { ownerState: { disableUnderline: l } } },
        w = h ?? u ? Ln(h ?? u, b) : b,
        k = (o = (r = g.root) != null ? r : c.Root) != null ? o : ZS,
        E = (s = (i = g.input) != null ? i : c.Input) != null ? s : JS
      return p.jsx(jc, M({ slots: { root: k, input: E }, slotProps: w, fullWidth: d, inputComponent: f, multiline: A, ref: n, type: x }, m, { classes: v }))
    })
  Kc.muiName = 'Input'
  function _S(e) {
    return Fe('MuiInputAdornment', e)
  }
  const sp = Pe('MuiInputAdornment', ['root', 'filled', 'standard', 'outlined', 'positionStart', 'positionEnd', 'disablePointerEvents', 'hiddenLabel', 'sizeSmall'])
  var ip
  const $S = ['children', 'className', 'component', 'disablePointerEvents', 'disableTypography', 'position', 'variant'],
    eB = (e, t) => {
      const { ownerState: n } = e
      return [t.root, t[`position${me(n.position)}`], n.disablePointerEvents === !0 && t.disablePointerEvents, t[n.variant]]
    },
    tB = e => {
      const { classes: t, disablePointerEvents: n, hiddenLabel: o, position: r, size: s, variant: i } = e,
        a = { root: ['root', n && 'disablePointerEvents', r && `position${me(r)}`, i, o && 'hiddenLabel', s && `size${me(s)}`] }
      return Re(a, _S, t)
    },
    nB = j('div', { name: 'MuiInputAdornment', slot: 'Root', overridesResolver: eB })(({ theme: e, ownerState: t }) =>
      M(
        { display: 'flex', height: '0.01em', maxHeight: '2em', alignItems: 'center', whiteSpace: 'nowrap', color: (e.vars || e).palette.action.active },
        t.variant === 'filled' && { [`&.${sp.positionStart}&:not(.${sp.hiddenLabel})`]: { marginTop: 16 } },
        t.position === 'start' && { marginRight: 8 },
        t.position === 'end' && { marginLeft: 8 },
        t.disablePointerEvents === !0 && { pointerEvents: 'none' }
      )
    ),
    oB = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiInputAdornment' }),
        { children: r, className: s, component: i = 'div', disablePointerEvents: a = !1, disableTypography: l = !1, position: c, variant: u } = o,
        d = he(o, $S),
        f = vo() || {}
      let A = u
      u && f.variant, A || (A = f.variant)
      const h = M({}, o, { hiddenLabel: f.hiddenLabel, size: f.size, disablePointerEvents: a, position: c, variant: A }),
        g = tB(h)
      return p.jsx(sa.Provider, {
        value: null,
        children: p.jsx(nB, M({ as: i, ownerState: h, className: fe(g.root, s), ref: n }, d, { children: typeof r == 'string' && !l ? p.jsx(bo, { color: 'text.secondary', children: r }) : p.jsxs(N.Fragment, { children: [c === 'start' ? ip || (ip = p.jsx('span', { className: 'notranslate', children: '​' })) : null, r] }) })),
      })
    })
  function rB(e) {
    return Fe('MuiInputLabel', e)
  }
  Pe('MuiInputLabel', ['root', 'focused', 'disabled', 'error', 'required', 'asterisk', 'formControl', 'sizeSmall', 'shrink', 'animated', 'standard', 'filled', 'outlined'])
  const sB = ['disableAnimation', 'margin', 'shrink', 'variant', 'className'],
    iB = e => {
      const { classes: t, formControl: n, size: o, shrink: r, disableAnimation: s, variant: i, required: a } = e,
        l = { root: ['root', n && 'formControl', !s && 'animated', r && 'shrink', o && o !== 'normal' && `size${me(o)}`, i], asterisk: [a && 'asterisk'] },
        c = Re(l, rB, t)
      return M({}, t, c)
    },
    aB = j(YS, {
      shouldForwardProp: e => Ot(e) || e === 'classes',
      name: 'MuiInputLabel',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [{ [`& .${rs.asterisk}`]: t.asterisk }, t.root, n.formControl && t.formControl, n.size === 'small' && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]]
      },
    })(({ theme: e, ownerState: t }) =>
      M(
        { display: 'block', transformOrigin: 'top left', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', maxWidth: '100%' },
        t.formControl && { position: 'absolute', left: 0, top: 0, transform: 'translate(0, 20px) scale(1)' },
        t.size === 'small' && { transform: 'translate(0, 17px) scale(1)' },
        t.shrink && { transform: 'translate(0, -1.5px) scale(0.75)', transformOrigin: 'top left', maxWidth: '133%' },
        !t.disableAnimation && { transition: e.transitions.create(['color', 'transform', 'max-width'], { duration: e.transitions.duration.shorter, easing: e.transitions.easing.easeOut }) },
        t.variant === 'filled' &&
          M(
            { zIndex: 1, pointerEvents: 'none', transform: 'translate(12px, 16px) scale(1)', maxWidth: 'calc(100% - 24px)' },
            t.size === 'small' && { transform: 'translate(12px, 13px) scale(1)' },
            t.shrink && M({ userSelect: 'none', pointerEvents: 'auto', transform: 'translate(12px, 7px) scale(0.75)', maxWidth: 'calc(133% - 24px)' }, t.size === 'small' && { transform: 'translate(12px, 4px) scale(0.75)' })
          ),
        t.variant === 'outlined' &&
          M({ zIndex: 1, pointerEvents: 'none', transform: 'translate(14px, 16px) scale(1)', maxWidth: 'calc(100% - 24px)' }, t.size === 'small' && { transform: 'translate(14px, 9px) scale(1)' }, t.shrink && { userSelect: 'none', pointerEvents: 'auto', maxWidth: 'calc(133% - 32px)', transform: 'translate(14px, -9px) scale(0.75)' })
      )
    ),
    ap = N.forwardRef(function (t, n) {
      const o = Le({ name: 'MuiInputLabel', props: t }),
        { disableAnimation: r = !1, shrink: s, className: i } = o,
        a = he(o, sB),
        l = vo()
      let c = s
      typeof c > 'u' && l && (c = l.filled || l.focused || l.adornedStart)
      const u = dr({ props: o, muiFormControl: l, states: ['size', 'variant', 'required', 'focused'] }),
        d = M({}, o, { disableAnimation: r, formControl: l, shrink: c, size: u.size, variant: u.variant, required: u.required, focused: u.focused }),
        f = iB(d)
      return p.jsx(aB, M({ 'data-shrink': c, ownerState: d, ref: n, className: fe(f.root, i) }, a, { classes: f }))
    }),
    ss = N.createContext({})
  function lB(e) {
    return Fe('MuiList', e)
  }
  Pe('MuiList', ['root', 'padding', 'dense', 'subheader'])
  const cB = ['children', 'className', 'component', 'dense', 'disablePadding', 'subheader'],
    uB = e => {
      const { classes: t, disablePadding: n, dense: o, subheader: r } = e
      return Re({ root: ['root', !n && 'padding', o && 'dense', r && 'subheader'] }, lB, t)
    },
    dB = j('ul', {
      name: 'MuiList',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader]
      },
    })(({ ownerState: e }) => M({ listStyle: 'none', margin: 0, padding: 0, position: 'relative' }, !e.disablePadding && { paddingTop: 8, paddingBottom: 8 }, e.subheader && { paddingTop: 0 })),
    fB = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiList' }),
        { children: r, className: s, component: i = 'ul', dense: a = !1, disablePadding: l = !1, subheader: c } = o,
        u = he(o, cB),
        d = N.useMemo(() => ({ dense: a }), [a]),
        f = M({}, o, { component: i, dense: a, disablePadding: l }),
        A = uB(f)
      return p.jsx(ss.Provider, { value: d, children: p.jsxs(dB, M({ as: i, className: fe(A.root, s), ref: n, ownerState: f }, u, { children: [c, r] })) })
    })
  function AB(e) {
    return Fe('MuiListItemIcon', e)
  }
  const lp = Pe('MuiListItemIcon', ['root', 'alignItemsFlexStart']),
    pB = ['className'],
    hB = e => {
      const { alignItems: t, classes: n } = e
      return Re({ root: ['root', t === 'flex-start' && 'alignItemsFlexStart'] }, AB, n)
    },
    gB = j('div', {
      name: 'MuiListItemIcon',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, n.alignItems === 'flex-start' && t.alignItemsFlexStart]
      },
    })(({ theme: e, ownerState: t }) => M({ minWidth: 56, color: (e.vars || e).palette.action.active, flexShrink: 0, display: 'inline-flex' }, t.alignItems === 'flex-start' && { marginTop: 8 })),
    mB = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiListItemIcon' }),
        { className: r } = o,
        s = he(o, pB),
        i = N.useContext(ss),
        a = M({}, o, { alignItems: i.alignItems }),
        l = hB(a)
      return p.jsx(gB, M({ className: fe(l.root, r), ownerState: a, ref: n }, s))
    })
  function yB(e) {
    return Fe('MuiListItemText', e)
  }
  const Aa = Pe('MuiListItemText', ['root', 'multiline', 'dense', 'inset', 'primary', 'secondary']),
    bB = ['children', 'className', 'disableTypography', 'inset', 'primary', 'primaryTypographyProps', 'secondary', 'secondaryTypographyProps'],
    vB = e => {
      const { classes: t, inset: n, primary: o, secondary: r, dense: s } = e
      return Re({ root: ['root', n && 'inset', s && 'dense', o && r && 'multiline'], primary: ['primary'], secondary: ['secondary'] }, yB, t)
    },
    xB = j('div', {
      name: 'MuiListItemText',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [{ [`& .${Aa.primary}`]: t.primary }, { [`& .${Aa.secondary}`]: t.secondary }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense]
      },
    })(({ ownerState: e }) => M({ flex: '1 1 auto', minWidth: 0, marginTop: 4, marginBottom: 4 }, e.primary && e.secondary && { marginTop: 6, marginBottom: 6 }, e.inset && { paddingLeft: 56 })),
    CB = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiListItemText' }),
        { children: r, className: s, disableTypography: i = !1, inset: a = !1, primary: l, primaryTypographyProps: c, secondary: u, secondaryTypographyProps: d } = o,
        f = he(o, bB),
        { dense: A } = N.useContext(ss)
      let h = l ?? r,
        g = u
      const x = M({}, o, { disableTypography: i, inset: a, primary: !!h, secondary: !!g, dense: A }),
        m = vB(x)
      return (
        h != null && h.type !== bo && !i && (h = p.jsx(bo, M({ variant: A ? 'body2' : 'body1', className: m.primary, component: c != null && c.variant ? void 0 : 'span', display: 'block' }, c, { children: h }))),
        g != null && g.type !== bo && !i && (g = p.jsx(bo, M({ variant: 'body2', className: m.secondary, color: 'text.secondary', display: 'block' }, d, { children: g }))),
        p.jsxs(xB, M({ className: fe(m.root, s), ownerState: x, ref: n }, f, { children: [h, g] }))
      )
    }),
    wB = ['actions', 'autoFocus', 'autoFocusItem', 'children', 'className', 'disabledItemsFocusable', 'disableListWrap', 'onKeyDown', 'variant']
  function qc(e, t, n) {
    return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild
  }
  function cp(e, t, n) {
    return e === t ? (n ? e.firstChild : e.lastChild) : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild
  }
  function up(e, t) {
    if (t === void 0) return !0
    let n = e.innerText
    return n === void 0 && (n = e.textContent), (n = n.trim().toLowerCase()), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.indexOf(t.keys.join('')) === 0
  }
  function is(e, t, n, o, r, s) {
    let i = !1,
      a = r(e, t, t ? n : !1)
    for (; a; ) {
      if (a === e.firstChild) {
        if (i) return !1
        i = !0
      }
      const l = o ? !1 : a.disabled || a.getAttribute('aria-disabled') === 'true'
      if (!a.hasAttribute('tabindex') || !up(a, s) || l) a = r(e, a, n)
      else return a.focus(), !0
    }
    return !1
  }
  const dp = N.forwardRef(function (t, n) {
    const { actions: o, autoFocus: r = !1, autoFocusItem: s = !1, children: i, className: a, disabledItemsFocusable: l = !1, disableListWrap: c = !1, onKeyDown: u, variant: d = 'selectedMenu' } = t,
      f = he(t, wB),
      A = N.useRef(null),
      h = N.useRef({ keys: [], repeating: !0, previousKeyMatched: !0, lastTime: null })
    xn(() => {
      r && A.current.focus()
    }, [r]),
      N.useImperativeHandle(
        o,
        () => ({
          adjustStyleForScrollbar: (y, { direction: b }) => {
            const w = !A.current.style.width
            if (y.clientHeight < A.current.clientHeight && w) {
              const k = `${NA(yt(y))}px`
              ;(A.current.style[b === 'rtl' ? 'paddingLeft' : 'paddingRight'] = k), (A.current.style.width = `calc(100% + ${k})`)
            }
            return A.current
          },
        }),
        []
      )
    const g = y => {
        const b = A.current,
          w = y.key,
          k = yt(b).activeElement
        if (w === 'ArrowDown') y.preventDefault(), is(b, k, c, l, qc)
        else if (w === 'ArrowUp') y.preventDefault(), is(b, k, c, l, cp)
        else if (w === 'Home') y.preventDefault(), is(b, null, c, l, qc)
        else if (w === 'End') y.preventDefault(), is(b, null, c, l, cp)
        else if (w.length === 1) {
          const E = h.current,
            P = w.toLowerCase(),
            T = performance.now()
          E.keys.length > 0 && (T - E.lastTime > 500 ? ((E.keys = []), (E.repeating = !0), (E.previousKeyMatched = !0)) : E.repeating && P !== E.keys[0] && (E.repeating = !1)), (E.lastTime = T), E.keys.push(P)
          const F = k && !E.repeating && up(k, E)
          E.previousKeyMatched && (F || is(b, k, !1, l, qc, E)) ? y.preventDefault() : (E.previousKeyMatched = !1)
        }
        u && u(y)
      },
      x = ht(A, n)
    let m = -1
    N.Children.forEach(i, (y, b) => {
      if (!N.isValidElement(y)) {
        m === b && ((m += 1), m >= i.length && (m = -1))
        return
      }
      y.props.disabled || (((d === 'selectedMenu' && y.props.selected) || m === -1) && (m = b)), m === b && (y.props.disabled || y.props.muiSkipListHighlight || y.type.muiSkipListHighlight) && ((m += 1), m >= i.length && (m = -1))
    })
    const v = N.Children.map(i, (y, b) => {
      if (b === m) {
        const w = {}
        return s && (w.autoFocus = !0), y.props.tabIndex === void 0 && d === 'selectedMenu' && (w.tabIndex = 0), N.cloneElement(y, w)
      }
      return y
    })
    return p.jsx(fB, M({ role: 'menu', ref: x, className: a, onKeyDown: g, tabIndex: r ? 0 : -1 }, f, { children: v }))
  })
  function EB(e) {
    return Fe('MuiPopover', e)
  }
  Pe('MuiPopover', ['root', 'paper'])
  const SB = ['onEntering'],
    BB = ['action', 'anchorEl', 'anchorOrigin', 'anchorPosition', 'anchorReference', 'children', 'className', 'container', 'elevation', 'marginThreshold', 'open', 'PaperProps', 'slots', 'slotProps', 'transformOrigin', 'TransitionComponent', 'transitionDuration', 'TransitionProps', 'disableScrollLock'],
    IB = ['slotProps']
  function fp(e, t) {
    let n = 0
    return typeof t == 'number' ? (n = t) : t === 'center' ? (n = e.height / 2) : t === 'bottom' && (n = e.height), n
  }
  function Ap(e, t) {
    let n = 0
    return typeof t == 'number' ? (n = t) : t === 'center' ? (n = e.width / 2) : t === 'right' && (n = e.width), n
  }
  function pp(e) {
    return [e.horizontal, e.vertical].map(t => (typeof t == 'number' ? `${t}px` : t)).join(' ')
  }
  function Zc(e) {
    return typeof e == 'function' ? e() : e
  }
  const kB = e => {
      const { classes: t } = e
      return Re({ root: ['root'], paper: ['paper'] }, EB, t)
    },
    NB = j(Vc, { name: 'MuiPopover', slot: 'Root', overridesResolver: (e, t) => t.root })({}),
    hp = j(ts, { name: 'MuiPopover', slot: 'Paper', overridesResolver: (e, t) => t.paper })({ position: 'absolute', overflowY: 'auto', overflowX: 'hidden', minWidth: 16, minHeight: 16, maxWidth: 'calc(100% - 32px)', maxHeight: 'calc(100% - 32px)', outline: 0 }),
    gp = N.forwardRef(function (t, n) {
      var o, r, s
      const i = Le({ props: t, name: 'MuiPopover' }),
        {
          action: a,
          anchorEl: l,
          anchorOrigin: c = { vertical: 'top', horizontal: 'left' },
          anchorPosition: u,
          anchorReference: d = 'anchorEl',
          children: f,
          className: A,
          container: h,
          elevation: g = 8,
          marginThreshold: x = 16,
          open: m,
          PaperProps: v = {},
          slots: y,
          slotProps: b,
          transformOrigin: w = { vertical: 'top', horizontal: 'left' },
          TransitionComponent: k = rp,
          transitionDuration: E = 'auto',
          TransitionProps: { onEntering: P } = {},
          disableScrollLock: T = !1,
        } = i,
        F = he(i.TransitionProps, SB),
        D = he(i, BB),
        Q = (o = b == null ? void 0 : b.paper) != null ? o : v,
        R = N.useRef(),
        S = ht(R, Q.ref),
        L = M({}, i, { anchorOrigin: c, anchorReference: d, elevation: g, marginThreshold: x, externalPaperSlotProps: Q, transformOrigin: w, TransitionComponent: k, transitionDuration: E, TransitionProps: F }),
        I = kB(L),
        z = N.useCallback(() => {
          if (d === 'anchorPosition') return u
          const H = Zc(l),
            te = (H && H.nodeType === 1 ? H : yt(R.current).body).getBoundingClientRect()
          return { top: te.top + fp(te, c.vertical), left: te.left + Ap(te, c.horizontal) }
        }, [l, c.horizontal, c.vertical, u, d]),
        B = N.useCallback(H => ({ vertical: fp(H, w.vertical), horizontal: Ap(H, w.horizontal) }), [w.horizontal, w.vertical]),
        O = N.useCallback(
          H => {
            const U = { width: H.offsetWidth, height: H.offsetHeight },
              te = B(U)
            if (d === 'none') return { top: null, left: null, transformOrigin: pp(te) }
            const be = z()
            let Ne = be.top - te.vertical,
              Me = be.left - te.horizontal
            const Ue = Ne + U.height,
              we = Me + U.width,
              Se = vn(Zc(l)),
              et = Se.innerHeight - x,
              We = Se.innerWidth - x
            if (x !== null && Ne < x) {
              const Ie = Ne - x
              ;(Ne -= Ie), (te.vertical += Ie)
            } else if (x !== null && Ue > et) {
              const Ie = Ue - et
              ;(Ne -= Ie), (te.vertical += Ie)
            }
            if (x !== null && Me < x) {
              const Ie = Me - x
              ;(Me -= Ie), (te.horizontal += Ie)
            } else if (we > We) {
              const Ie = we - We
              ;(Me -= Ie), (te.horizontal += Ie)
            }
            return { top: `${Math.round(Ne)}px`, left: `${Math.round(Me)}px`, transformOrigin: pp(te) }
          },
          [l, d, z, B, x]
        ),
        [W, K] = N.useState(m),
        Z = N.useCallback(() => {
          const H = R.current
          if (!H) return
          const U = O(H)
          U.top !== null && (H.style.top = U.top), U.left !== null && (H.style.left = U.left), (H.style.transformOrigin = U.transformOrigin), K(!0)
        }, [O])
      N.useEffect(() => (T && window.addEventListener('scroll', Z), () => window.removeEventListener('scroll', Z)), [l, T, Z])
      const oe = (H, U) => {
          P && P(H, U), Z()
        },
        V = () => {
          K(!1)
        }
      N.useEffect(() => {
        m && Z()
      }),
        N.useImperativeHandle(
          a,
          () =>
            m
              ? {
                  updatePosition: () => {
                    Z()
                  },
                }
              : null,
          [m, Z]
        ),
        N.useEffect(() => {
          if (!m) return
          const H = qi(() => {
              Z()
            }),
            U = vn(l)
          return (
            U.addEventListener('resize', H),
            () => {
              H.clear(), U.removeEventListener('resize', H)
            }
          )
        }, [l, m, Z])
      let q = E
      E === 'auto' && !k.muiSupportAuto && (q = void 0)
      const ee = h || (l ? yt(Zc(l)).body : void 0),
        re = (r = y == null ? void 0 : y.root) != null ? r : NB,
        J = (s = y == null ? void 0 : y.paper) != null ? s : hp,
        ie = Lt({ elementType: J, externalSlotProps: M({}, Q, { style: W ? Q.style : M({}, Q.style, { opacity: 0 }) }), additionalProps: { elevation: g, ref: S }, ownerState: L, className: fe(I.paper, Q == null ? void 0 : Q.className) }),
        Ae = Lt({ elementType: re, externalSlotProps: (b == null ? void 0 : b.root) || {}, externalForwardedProps: D, additionalProps: { ref: n, slotProps: { backdrop: { invisible: !0 } }, container: ee, open: m }, ownerState: L, className: fe(I.root, A) }),
        { slotProps: ae } = Ae,
        se = he(Ae, IB)
      return p.jsx(re, M({}, se, !Kn(re) && { slotProps: ae, disableScrollLock: T }, { children: p.jsx(k, M({ appear: !0, in: m, onEntering: oe, onExited: V, timeout: q }, F, { children: p.jsx(J, M({}, ie, { children: f })) })) }))
    })
  function MB(e) {
    return Fe('MuiMenu', e)
  }
  Pe('MuiMenu', ['root', 'paper', 'list'])
  const PB = ['onEntering'],
    LB = ['autoFocus', 'children', 'className', 'disableAutoFocusItem', 'MenuListProps', 'onClose', 'open', 'PaperProps', 'PopoverClasses', 'transitionDuration', 'TransitionProps', 'variant', 'slots', 'slotProps'],
    TB = { vertical: 'top', horizontal: 'right' },
    FB = { vertical: 'top', horizontal: 'left' },
    DB = e => {
      const { classes: t } = e
      return Re({ root: ['root'], paper: ['paper'], list: ['list'] }, MB, t)
    },
    zB = j(gp, { shouldForwardProp: e => Ot(e) || e === 'classes', name: 'MuiMenu', slot: 'Root', overridesResolver: (e, t) => t.root })({}),
    QB = j(hp, { name: 'MuiMenu', slot: 'Paper', overridesResolver: (e, t) => t.paper })({ maxHeight: 'calc(100% - 96px)', WebkitOverflowScrolling: 'touch' }),
    RB = j(dp, { name: 'MuiMenu', slot: 'List', overridesResolver: (e, t) => t.list })({ outline: 0 }),
    OB = N.forwardRef(function (t, n) {
      var o, r
      const s = Le({ props: t, name: 'MuiMenu' }),
        { autoFocus: i = !0, children: a, className: l, disableAutoFocusItem: c = !1, MenuListProps: u = {}, onClose: d, open: f, PaperProps: A = {}, PopoverClasses: h, transitionDuration: g = 'auto', TransitionProps: { onEntering: x } = {}, variant: m = 'selectedMenu', slots: v = {}, slotProps: y = {} } = s,
        b = he(s.TransitionProps, PB),
        w = he(s, LB),
        k = hc(),
        E = M({}, s, { autoFocus: i, disableAutoFocusItem: c, MenuListProps: u, onEntering: x, PaperProps: A, transitionDuration: g, TransitionProps: b, variant: m }),
        P = DB(E),
        T = i && !c && f,
        F = N.useRef(null),
        D = (B, O) => {
          F.current && F.current.adjustStyleForScrollbar(B, { direction: k ? 'rtl' : 'ltr' }), x && x(B, O)
        },
        Q = B => {
          B.key === 'Tab' && (B.preventDefault(), d && d(B, 'tabKeyDown'))
        }
      let R = -1
      N.Children.map(a, (B, O) => {
        N.isValidElement(B) && (B.props.disabled || (((m === 'selectedMenu' && B.props.selected) || R === -1) && (R = O)))
      })
      const S = (o = v.paper) != null ? o : QB,
        L = (r = y.paper) != null ? r : A,
        I = Lt({ elementType: v.root, externalSlotProps: y.root, ownerState: E, className: [P.root, l] }),
        z = Lt({ elementType: S, externalSlotProps: L, ownerState: E, className: P.paper })
      return p.jsx(
        zB,
        M({ onClose: d, anchorOrigin: { vertical: 'bottom', horizontal: k ? 'right' : 'left' }, transformOrigin: k ? TB : FB, slots: { paper: S, root: v.root }, slotProps: { root: I, paper: z }, open: f, ref: n, transitionDuration: g, TransitionProps: M({ onEntering: D }, b), ownerState: E }, w, {
          classes: h,
          children: p.jsx(RB, M({ onKeyDown: Q, actions: F, autoFocus: i && (R === -1 || c), autoFocusItem: T, variant: m }, u, { className: fe(P.list, u.className), children: a })),
        })
      )
    })
  function jB(e) {
    return Fe('MuiMenuItem', e)
  }
  const as = Pe('MuiMenuItem', ['root', 'focusVisible', 'dense', 'disabled', 'divider', 'gutters', 'selected']),
    WB = ['autoFocus', 'component', 'dense', 'divider', 'disableGutters', 'focusVisibleClassName', 'role', 'tabIndex', 'className'],
    GB = (e, t) => {
      const { ownerState: n } = e
      return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters]
    },
    VB = e => {
      const { disabled: t, dense: n, divider: o, disableGutters: r, selected: s, classes: i } = e,
        l = Re({ root: ['root', n && 'dense', t && 'disabled', !r && 'gutters', o && 'divider', s && 'selected'] }, jB, i)
      return M({}, i, l)
    },
    XB = j(Oc, { shouldForwardProp: e => Ot(e) || e === 'classes', name: 'MuiMenuItem', slot: 'Root', overridesResolver: GB })(({ theme: e, ownerState: t }) =>
      M(
        {},
        e.typography.body1,
        { display: 'flex', justifyContent: 'flex-start', alignItems: 'center', position: 'relative', textDecoration: 'none', minHeight: 48, paddingTop: 6, paddingBottom: 6, boxSizing: 'border-box', whiteSpace: 'nowrap' },
        !t.disableGutters && { paddingLeft: 16, paddingRight: 16 },
        t.divider && { borderBottom: `1px solid ${(e.vars || e).palette.divider}`, backgroundClip: 'padding-box' },
        {
          '&:hover': { textDecoration: 'none', backgroundColor: (e.vars || e).palette.action.hover, '@media (hover: none)': { backgroundColor: 'transparent' } },
          [`&.${as.selected}`]: {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Bt(e.palette.primary.main, e.palette.action.selectedOpacity),
            [`&.${as.focusVisible}`]: { backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Bt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity) },
          },
          [`&.${as.selected}:hover`]: {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Bt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
            '@media (hover: none)': { backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Bt(e.palette.primary.main, e.palette.action.selectedOpacity) },
          },
          [`&.${as.focusVisible}`]: { backgroundColor: (e.vars || e).palette.action.focus },
          [`&.${as.disabled}`]: { opacity: (e.vars || e).palette.action.disabledOpacity },
          [`& + .${qA.root}`]: { marginTop: e.spacing(1), marginBottom: e.spacing(1) },
          [`& + .${qA.inset}`]: { marginLeft: 52 },
          [`& .${Aa.root}`]: { marginTop: 0, marginBottom: 0 },
          [`& .${Aa.inset}`]: { paddingLeft: 36 },
          [`& .${lp.root}`]: { minWidth: 36 },
        },
        !t.dense && { [e.breakpoints.up('sm')]: { minHeight: 'auto' } },
        t.dense && M({ minHeight: 32, paddingTop: 4, paddingBottom: 4 }, e.typography.body2, { [`& .${lp.root} svg`]: { fontSize: '1.25rem' } })
      )
    ),
    YB = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiMenuItem' }),
        { autoFocus: r = !1, component: s = 'li', dense: i = !1, divider: a = !1, disableGutters: l = !1, focusVisibleClassName: c, role: u = 'menuitem', tabIndex: d, className: f } = o,
        A = he(o, WB),
        h = N.useContext(ss),
        g = N.useMemo(() => ({ dense: i || h.dense || !1, disableGutters: l }), [h.dense, i, l]),
        x = N.useRef(null)
      xn(() => {
        r && x.current && x.current.focus()
      }, [r])
      const m = M({}, o, { dense: g.dense, divider: a, disableGutters: l }),
        v = VB(o),
        y = ht(x, n)
      let b
      return o.disabled || (b = d !== void 0 ? d : -1), p.jsx(ss.Provider, { value: g, children: p.jsx(XB, M({ ref: y, role: u, tabIndex: b, component: s, focusVisibleClassName: fe(v.focusVisible, c), className: fe(v.root, f) }, A, { ownerState: m, classes: v })) })
    })
  function HB(e) {
    return Fe('MuiNativeSelect', e)
  }
  const Jc = Pe('MuiNativeSelect', ['root', 'select', 'multiple', 'filled', 'outlined', 'standard', 'disabled', 'icon', 'iconOpen', 'iconFilled', 'iconOutlined', 'iconStandard', 'nativeInput', 'error']),
    UB = ['className', 'disabled', 'error', 'IconComponent', 'inputRef', 'variant'],
    KB = e => {
      const { classes: t, variant: n, disabled: o, multiple: r, open: s, error: i } = e,
        a = { select: ['select', n, o && 'disabled', r && 'multiple', i && 'error'], icon: ['icon', `icon${me(n)}`, s && 'iconOpen', o && 'disabled'] }
      return Re(a, HB, t)
    },
    mp = ({ ownerState: e, theme: t }) =>
      M(
        {
          MozAppearance: 'none',
          WebkitAppearance: 'none',
          userSelect: 'none',
          borderRadius: 0,
          cursor: 'pointer',
          '&:focus': M({}, t.vars ? { backgroundColor: `rgba(${t.vars.palette.common.onBackgroundChannel} / 0.05)` } : { backgroundColor: t.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)' }, { borderRadius: 0 }),
          '&::-ms-expand': { display: 'none' },
          [`&.${Jc.disabled}`]: { cursor: 'default' },
          '&[multiple]': { height: 'auto' },
          '&:not([multiple]) option, &:not([multiple]) optgroup': { backgroundColor: (t.vars || t).palette.background.paper },
          '&&&': { paddingRight: 24, minWidth: 16 },
        },
        e.variant === 'filled' && { '&&&': { paddingRight: 32 } },
        e.variant === 'outlined' && { borderRadius: (t.vars || t).shape.borderRadius, '&:focus': { borderRadius: (t.vars || t).shape.borderRadius }, '&&&': { paddingRight: 32 } }
      ),
    qB = j('select', {
      name: 'MuiNativeSelect',
      slot: 'Select',
      shouldForwardProp: Ot,
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.select, t[n.variant], n.error && t.error, { [`&.${Jc.multiple}`]: t.multiple }]
      },
    })(mp),
    yp = ({ ownerState: e, theme: t }) =>
      M({ position: 'absolute', right: 0, top: 'calc(50% - .5em)', pointerEvents: 'none', color: (t.vars || t).palette.action.active, [`&.${Jc.disabled}`]: { color: (t.vars || t).palette.action.disabled } }, e.open && { transform: 'rotate(180deg)' }, e.variant === 'filled' && { right: 7 }, e.variant === 'outlined' && { right: 7 }),
    ZB = j('svg', {
      name: 'MuiNativeSelect',
      slot: 'Icon',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.icon, n.variant && t[`icon${me(n.variant)}`], n.open && t.iconOpen]
      },
    })(yp),
    JB = N.forwardRef(function (t, n) {
      const { className: o, disabled: r, error: s, IconComponent: i, inputRef: a, variant: l = 'standard' } = t,
        c = he(t, UB),
        u = M({}, t, { disabled: r, variant: l, error: s }),
        d = KB(u)
      return p.jsxs(N.Fragment, { children: [p.jsx(qB, M({ ownerState: u, className: fe(d.select, o), disabled: r, ref: a || n }, c)), t.multiple ? null : p.jsx(ZB, { as: i, ownerState: u, className: d.icon })] })
    })
  var bp
  const _B = ['children', 'classes', 'className', 'label', 'notched'],
    $B = j('fieldset', { shouldForwardProp: Ot })({ textAlign: 'left', position: 'absolute', bottom: 0, right: 0, top: -5, left: 0, margin: 0, padding: '0 8px', pointerEvents: 'none', borderRadius: 'inherit', borderStyle: 'solid', borderWidth: 1, overflow: 'hidden', minWidth: '0%' }),
    eI = j('legend', { shouldForwardProp: Ot })(({ ownerState: e, theme: t }) =>
      M(
        { float: 'unset', width: 'auto', overflow: 'hidden' },
        !e.withLabel && { padding: 0, lineHeight: '11px', transition: t.transitions.create('width', { duration: 150, easing: t.transitions.easing.easeOut }) },
        e.withLabel &&
          M(
            { display: 'block', padding: 0, height: 11, fontSize: '0.75em', visibility: 'hidden', maxWidth: 0.01, transition: t.transitions.create('max-width', { duration: 50, easing: t.transitions.easing.easeOut }), whiteSpace: 'nowrap', '& > span': { paddingLeft: 5, paddingRight: 5, display: 'inline-block', opacity: 0, visibility: 'visible' } },
            e.notched && { maxWidth: '100%', transition: t.transitions.create('max-width', { duration: 100, easing: t.transitions.easing.easeOut, delay: 50 }) }
          )
      )
    )
  function tI(e) {
    const { className: t, label: n, notched: o } = e,
      r = he(e, _B),
      s = n != null && n !== '',
      i = M({}, e, { notched: o, withLabel: s })
    return p.jsx($B, M({ 'aria-hidden': !0, className: t, ownerState: i }, r, { children: p.jsx(eI, { ownerState: i, children: s ? p.jsx('span', { children: n }) : bp || (bp = p.jsx('span', { className: 'notranslate', children: '​' })) }) }))
  }
  const nI = ['components', 'fullWidth', 'inputComponent', 'label', 'multiline', 'notched', 'slots', 'type'],
    oI = e => {
      const { classes: t } = e,
        o = Re({ root: ['root'], notchedOutline: ['notchedOutline'], input: ['input'] }, iE, t)
      return M({}, t, o)
    },
    rI = j(ca, { shouldForwardProp: e => Ot(e) || e === 'classes', name: 'MuiOutlinedInput', slot: 'Root', overridesResolver: aa })(({ theme: e, ownerState: t }) => {
      const n = e.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'
      return M(
        {
          position: 'relative',
          borderRadius: (e.vars || e).shape.borderRadius,
          [`&:hover .${qn.notchedOutline}`]: { borderColor: (e.vars || e).palette.text.primary },
          '@media (hover: none)': { [`&:hover .${qn.notchedOutline}`]: { borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : n } },
          [`&.${qn.focused} .${qn.notchedOutline}`]: { borderColor: (e.vars || e).palette[t.color].main, borderWidth: 2 },
          [`&.${qn.error} .${qn.notchedOutline}`]: { borderColor: (e.vars || e).palette.error.main },
          [`&.${qn.disabled} .${qn.notchedOutline}`]: { borderColor: (e.vars || e).palette.action.disabled },
        },
        t.startAdornment && { paddingLeft: 14 },
        t.endAdornment && { paddingRight: 14 },
        t.multiline && M({ padding: '16.5px 14px' }, t.size === 'small' && { padding: '8.5px 14px' })
      )
    }),
    sI = j(tI, { name: 'MuiOutlinedInput', slot: 'NotchedOutline', overridesResolver: (e, t) => t.notchedOutline })(({ theme: e }) => {
      const t = e.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'
      return { borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t }
    }),
    iI = j(ua, { name: 'MuiOutlinedInput', slot: 'Input', overridesResolver: la })(({ theme: e, ownerState: t }) =>
      M(
        { padding: '16.5px 14px' },
        !e.vars && { '&:-webkit-autofill': { WebkitBoxShadow: e.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset', WebkitTextFillColor: e.palette.mode === 'light' ? null : '#fff', caretColor: e.palette.mode === 'light' ? null : '#fff', borderRadius: 'inherit' } },
        e.vars && { '&:-webkit-autofill': { borderRadius: 'inherit' }, [e.getColorSchemeSelector('dark')]: { '&:-webkit-autofill': { WebkitBoxShadow: '0 0 0 100px #266798 inset', WebkitTextFillColor: '#fff', caretColor: '#fff' } } },
        t.size === 'small' && { padding: '8.5px 14px' },
        t.multiline && { padding: 0 },
        t.startAdornment && { paddingLeft: 0 },
        t.endAdornment && { paddingRight: 0 }
      )
    ),
    _c = N.forwardRef(function (t, n) {
      var o, r, s, i, a
      const l = Le({ props: t, name: 'MuiOutlinedInput' }),
        { components: c = {}, fullWidth: u = !1, inputComponent: d = 'input', label: f, multiline: A = !1, notched: h, slots: g = {}, type: x = 'text' } = l,
        m = he(l, nI),
        v = oI(l),
        y = vo(),
        b = dr({ props: l, muiFormControl: y, states: ['color', 'disabled', 'error', 'focused', 'hiddenLabel', 'size', 'required'] }),
        w = M({}, l, { color: b.color || 'primary', disabled: b.disabled, error: b.error, focused: b.focused, formControl: y, fullWidth: u, hiddenLabel: b.hiddenLabel, multiline: A, size: b.size, type: x }),
        k = (o = (r = g.root) != null ? r : c.Root) != null ? o : rI,
        E = (s = (i = g.input) != null ? i : c.Input) != null ? s : iI
      return p.jsx(
        jc,
        M(
          {
            slots: { root: k, input: E },
            renderSuffix: P => p.jsx(sI, { ownerState: w, className: v.notchedOutline, label: f != null && f !== '' && b.required ? a || (a = p.jsxs(N.Fragment, { children: [f, ' ', '*'] })) : f, notched: typeof h < 'u' ? h : !!(P.startAdornment || P.filled || P.focused) }),
            fullWidth: u,
            inputComponent: d,
            multiline: A,
            ref: n,
            type: x,
          },
          m,
          { classes: M({}, v, { notchedOutline: null }) }
        )
      )
    })
  _c.muiName = 'Input'
  function aI(e) {
    return Fe('MuiSelect', e)
  }
  const ls = Pe('MuiSelect', ['root', 'select', 'multiple', 'filled', 'outlined', 'standard', 'disabled', 'focused', 'icon', 'iconOpen', 'iconFilled', 'iconOutlined', 'iconStandard', 'nativeInput', 'error'])
  var vp
  const lI = [
      'aria-describedby',
      'aria-label',
      'autoFocus',
      'autoWidth',
      'children',
      'className',
      'defaultOpen',
      'defaultValue',
      'disabled',
      'displayEmpty',
      'error',
      'IconComponent',
      'inputRef',
      'labelId',
      'MenuProps',
      'multiple',
      'name',
      'onBlur',
      'onChange',
      'onClose',
      'onFocus',
      'onOpen',
      'open',
      'readOnly',
      'renderValue',
      'SelectDisplayProps',
      'tabIndex',
      'type',
      'value',
      'variant',
    ],
    cI = j('div', {
      name: 'MuiSelect',
      slot: 'Select',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [{ [`&.${ls.select}`]: t.select }, { [`&.${ls.select}`]: t[n.variant] }, { [`&.${ls.error}`]: t.error }, { [`&.${ls.multiple}`]: t.multiple }]
      },
    })(mp, { [`&.${ls.select}`]: { height: 'auto', minHeight: '1.4375em', textOverflow: 'ellipsis', whiteSpace: 'nowrap', overflow: 'hidden' } }),
    uI = j('svg', {
      name: 'MuiSelect',
      slot: 'Icon',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.icon, n.variant && t[`icon${me(n.variant)}`], n.open && t.iconOpen]
      },
    })(yp),
    dI = j('input', { shouldForwardProp: e => Ki(e) && e !== 'classes', name: 'MuiSelect', slot: 'NativeInput', overridesResolver: (e, t) => t.nativeInput })({ bottom: 0, left: 0, position: 'absolute', opacity: 0, pointerEvents: 'none', width: '100%', boxSizing: 'border-box' })
  function xp(e, t) {
    return typeof t == 'object' && t !== null ? e === t : String(e) === String(t)
  }
  function fI(e) {
    return e == null || (typeof e == 'string' && !e.trim())
  }
  const AI = e => {
      const { classes: t, variant: n, disabled: o, multiple: r, open: s, error: i } = e,
        a = { select: ['select', n, o && 'disabled', r && 'multiple', i && 'error'], icon: ['icon', `icon${me(n)}`, s && 'iconOpen', o && 'disabled'], nativeInput: ['nativeInput'] }
      return Re(a, aI, t)
    },
    pI = N.forwardRef(function (t, n) {
      var o
      const {
          'aria-describedby': r,
          'aria-label': s,
          autoFocus: i,
          autoWidth: a,
          children: l,
          className: c,
          defaultOpen: u,
          defaultValue: d,
          disabled: f,
          displayEmpty: A,
          error: h = !1,
          IconComponent: g,
          inputRef: x,
          labelId: m,
          MenuProps: v = {},
          multiple: y,
          name: b,
          onBlur: w,
          onChange: k,
          onClose: E,
          onFocus: P,
          onOpen: T,
          open: F,
          readOnly: D,
          renderValue: Q,
          SelectDisplayProps: R = {},
          tabIndex: S,
          value: L,
          variant: I = 'standard',
        } = t,
        z = he(t, lI),
        [B, O] = $i({ controlled: L, default: d, name: 'Select' }),
        [W, K] = $i({ controlled: F, default: u, name: 'Select' }),
        Z = N.useRef(null),
        oe = N.useRef(null),
        [V, q] = N.useState(null),
        { current: ee } = N.useRef(F != null),
        [re, J] = N.useState(),
        ie = ht(n, x),
        Ae = N.useCallback(_ => {
          ;(oe.current = _), _ && q(_)
        }, []),
        ae = V == null ? void 0 : V.parentNode
      N.useImperativeHandle(
        ie,
        () => ({
          focus: () => {
            oe.current.focus()
          },
          node: Z.current,
          value: B,
        }),
        [B]
      ),
        N.useEffect(() => {
          u && W && V && !ee && (J(a ? null : ae.clientWidth), oe.current.focus())
        }, [V, a]),
        N.useEffect(() => {
          i && oe.current.focus()
        }, [i]),
        N.useEffect(() => {
          if (!m) return
          const _ = yt(oe.current).getElementById(m)
          if (_) {
            const pe = () => {
              getSelection().isCollapsed && oe.current.focus()
            }
            return (
              _.addEventListener('click', pe),
              () => {
                _.removeEventListener('click', pe)
              }
            )
          }
        }, [m])
      const se = (_, pe) => {
          _ ? T && T(pe) : E && E(pe), ee || (J(a ? null : ae.clientWidth), K(_))
        },
        H = _ => {
          _.button === 0 && (_.preventDefault(), oe.current.focus(), se(!0, _))
        },
        U = _ => {
          se(!1, _)
        },
        te = N.Children.toArray(l),
        be = _ => {
          const pe = te.find(xe => xe.props.value === _.target.value)
          pe !== void 0 && (O(pe.props.value), k && k(_, pe))
        },
        Ne = _ => pe => {
          let xe
          if (pe.currentTarget.hasAttribute('tabindex')) {
            if (y) {
              xe = Array.isArray(B) ? B.slice() : []
              const Ee = B.indexOf(_.props.value)
              Ee === -1 ? xe.push(_.props.value) : xe.splice(Ee, 1)
            } else xe = _.props.value
            if ((_.props.onClick && _.props.onClick(pe), B !== xe && (O(xe), k))) {
              const Ee = pe.nativeEvent || pe,
                nt = new Ee.constructor(Ee.type, Ee)
              Object.defineProperty(nt, 'target', { writable: !0, value: { value: xe, name: b } }), k(nt, _)
            }
            y || se(!1, pe)
          }
        },
        Me = _ => {
          D || ([' ', 'ArrowUp', 'ArrowDown', 'Enter'].indexOf(_.key) !== -1 && (_.preventDefault(), se(!0, _)))
        },
        Ue = V !== null && W,
        we = _ => {
          !Ue && w && (Object.defineProperty(_, 'target', { writable: !0, value: { value: B, name: b } }), w(_))
        }
      delete z['aria-invalid']
      let Se, et
      const We = []
      let Ie = !1
      ;(ia({ value: B }) || A) && (Q ? (Se = Q(B)) : (Ie = !0))
      const Ze = te.map(_ => {
        if (!N.isValidElement(_)) return null
        let pe
        if (y) {
          if (!Array.isArray(B)) throw new Error(Zo(2))
          ;(pe = B.some(xe => xp(xe, _.props.value))), pe && Ie && We.push(_.props.children)
        } else (pe = xp(B, _.props.value)), pe && Ie && (et = _.props.children)
        return N.cloneElement(_, {
          'aria-selected': pe ? 'true' : 'false',
          onClick: Ne(_),
          onKeyUp: xe => {
            xe.key === ' ' && xe.preventDefault(), _.props.onKeyUp && _.props.onKeyUp(xe)
          },
          role: 'option',
          selected: pe,
          value: void 0,
          'data-value': _.props.value,
        })
      })
      Ie && (y ? (We.length === 0 ? (Se = null) : (Se = We.reduce((_, pe, xe) => (_.push(pe), xe < We.length - 1 && _.push(', '), _), []))) : (Se = et))
      let Ke = re
      !a && ee && V && (Ke = ae.clientWidth)
      let Ve
      typeof S < 'u' ? (Ve = S) : (Ve = f ? null : 0)
      const X = R.id || (b ? `mui-component-select-${b}` : void 0),
        G = M({}, t, { variant: I, value: B, open: Ue, error: h }),
        ce = AI(G),
        ne = M({}, v.PaperProps, (o = v.slotProps) == null ? void 0 : o.paper),
        ue = _i()
      return p.jsxs(N.Fragment, {
        children: [
          p.jsx(
            cI,
            M(
              {
                ref: Ae,
                tabIndex: Ve,
                role: 'combobox',
                'aria-controls': ue,
                'aria-disabled': f ? 'true' : void 0,
                'aria-expanded': Ue ? 'true' : 'false',
                'aria-haspopup': 'listbox',
                'aria-label': s,
                'aria-labelledby': [m, X].filter(Boolean).join(' ') || void 0,
                'aria-describedby': r,
                onKeyDown: Me,
                onMouseDown: f || D ? null : H,
                onBlur: we,
                onFocus: P,
              },
              R,
              { ownerState: G, className: fe(R.className, ce.select, c), id: X, children: fI(Se) ? vp || (vp = p.jsx('span', { className: 'notranslate', children: '​' })) : Se }
            )
          ),
          p.jsx(dI, M({ 'aria-invalid': h, value: Array.isArray(B) ? B.join(',') : B, name: b, ref: Z, 'aria-hidden': !0, onChange: be, tabIndex: -1, disabled: f, className: ce.nativeInput, autoFocus: i, ownerState: G }, z)),
          p.jsx(uI, { as: g, className: ce.icon, ownerState: G }),
          p.jsx(
            OB,
            M({ id: `menu-${b || ''}`, anchorEl: ae, open: Ue, onClose: U, anchorOrigin: { vertical: 'bottom', horizontal: 'center' }, transformOrigin: { vertical: 'top', horizontal: 'center' } }, v, {
              MenuListProps: M({ 'aria-labelledby': m, role: 'listbox', 'aria-multiselectable': y ? 'true' : void 0, disableListWrap: !0, id: ue }, v.MenuListProps),
              slotProps: M({}, v.slotProps, { paper: M({}, ne, { style: M({ minWidth: Ke }, ne != null ? ne.style : null) }) }),
              children: Ze,
            })
          ),
        ],
      })
    }),
    hI = ['autoWidth', 'children', 'classes', 'className', 'defaultOpen', 'displayEmpty', 'IconComponent', 'id', 'input', 'inputProps', 'label', 'labelId', 'MenuProps', 'multiple', 'native', 'onClose', 'onOpen', 'open', 'renderValue', 'SelectDisplayProps', 'variant'],
    gI = ['root'],
    mI = e => {
      const { classes: t } = e
      return t
    },
    $c = { name: 'MuiSelect', overridesResolver: (e, t) => t.root, shouldForwardProp: e => Ot(e) && e !== 'variant', slot: 'Root' },
    yI = j(Kc, $c)(''),
    bI = j(_c, $c)(''),
    vI = j(Yc, $c)(''),
    eu = N.forwardRef(function (t, n) {
      const o = Le({ name: 'MuiSelect', props: t }),
        { autoWidth: r = !1, children: s, classes: i = {}, className: a, defaultOpen: l = !1, displayEmpty: c = !1, IconComponent: u = lE, id: d, input: f, inputProps: A, label: h, labelId: g, MenuProps: x, multiple: m = !1, native: v = !1, onClose: y, onOpen: b, open: w, renderValue: k, SelectDisplayProps: E, variant: P = 'outlined' } = o,
        T = he(o, hI),
        F = v ? JB : pI,
        D = vo(),
        Q = dr({ props: o, muiFormControl: D, states: ['variant', 'error'] }),
        R = Q.variant || P,
        S = M({}, o, { variant: R, classes: i }),
        L = mI(S),
        I = he(L, gI),
        z = f || { standard: p.jsx(yI, { ownerState: S }), outlined: p.jsx(bI, { label: h, ownerState: S }), filled: p.jsx(vI, { ownerState: S }) }[R],
        B = ht(n, ar(z))
      return p.jsx(N.Fragment, {
        children: N.cloneElement(
          z,
          M(
            {
              inputComponent: F,
              inputProps: M(
                { children: s, error: Q.error, IconComponent: u, variant: R, type: void 0, multiple: m },
                v ? { id: d } : { autoWidth: r, defaultOpen: l, displayEmpty: c, labelId: g, MenuProps: x, onClose: y, onOpen: b, open: w, renderValue: k, SelectDisplayProps: M({ id: d }, E) },
                A,
                { classes: A ? Ln(I, A.classes) : I },
                f ? f.props.inputProps : {}
              ),
            },
            ((m && v) || c) && R === 'outlined' ? { notched: !0 } : {},
            { ref: B, className: fe(z.props.className, a, L.root) },
            !f && { variant: R },
            T
          )
        ),
      })
    })
  eu.muiName = 'Select'
  function xI(e, t, n = (o, r) => o === r) {
    return e.length === t.length && e.every((o, r) => n(o, t[r]))
  }
  const CI = 2
  function Cp(e, t) {
    return e - t
  }
  function wp(e, t) {
    var n
    const { index: o } =
      (n = e.reduce((r, s, i) => {
        const a = Math.abs(t - s)
        return r === null || a < r.distance || a === r.distance ? { distance: a, index: i } : r
      }, null)) != null
        ? n
        : {}
    return o
  }
  function pa(e, t) {
    if (t.current !== void 0 && e.changedTouches) {
      const n = e
      for (let o = 0; o < n.changedTouches.length; o += 1) {
        const r = n.changedTouches[o]
        if (r.identifier === t.current) return { x: r.clientX, y: r.clientY }
      }
      return !1
    }
    return { x: e.clientX, y: e.clientY }
  }
  function ha(e, t, n) {
    return ((e - t) * 100) / (n - t)
  }
  function wI(e, t, n) {
    return (n - t) * e + t
  }
  function EI(e) {
    if (Math.abs(e) < 1) {
      const n = e.toExponential().split('e-'),
        o = n[0].split('.')[1]
      return (o ? o.length : 0) + parseInt(n[1], 10)
    }
    const t = e.toString().split('.')[1]
    return t ? t.length : 0
  }
  function SI(e, t, n) {
    const o = Math.round((e - n) / t) * t + n
    return Number(o.toFixed(EI(t)))
  }
  function Ep({ values: e, newValue: t, index: n }) {
    const o = e.slice()
    return (o[n] = t), o.sort(Cp)
  }
  function ga({ sliderRef: e, activeIndex: t, setActive: n }) {
    var o, r
    const s = yt(e.current)
    if (!((o = e.current) != null && o.contains(s.activeElement)) || Number(s == null || (r = s.activeElement) == null ? void 0 : r.getAttribute('data-index')) !== t) {
      var i
      ;(i = e.current) == null || i.querySelector(`[type="range"][data-index="${t}"]`).focus()
    }
    n && n(t)
  }
  function ma(e, t) {
    return typeof e == 'number' && typeof t == 'number' ? e === t : typeof e == 'object' && typeof t == 'object' ? xI(e, t) : !1
  }
  const BI = { horizontal: { offset: e => ({ left: `${e}%` }), leap: e => ({ width: `${e}%` }) }, 'horizontal-reverse': { offset: e => ({ right: `${e}%` }), leap: e => ({ width: `${e}%` }) }, vertical: { offset: e => ({ bottom: `${e}%` }), leap: e => ({ height: `${e}%` }) } },
    II = e => e
  let ya
  function Sp() {
    return ya === void 0 && (typeof CSS < 'u' && typeof CSS.supports == 'function' ? (ya = CSS.supports('touch-action', 'none')) : (ya = !0)), ya
  }
  function kI(e) {
    const { 'aria-labelledby': t, defaultValue: n, disabled: o = !1, disableSwap: r = !1, isRtl: s = !1, marks: i = !1, max: a = 100, min: l = 0, name: c, onChange: u, onChangeCommitted: d, orientation: f = 'horizontal', rootRef: A, scale: h = II, step: g = 1, shiftStep: x = 10, tabIndex: m, value: v } = e,
      y = N.useRef(void 0),
      [b, w] = N.useState(-1),
      [k, E] = N.useState(-1),
      [P, T] = N.useState(!1),
      F = N.useRef(0),
      [D, Q] = $i({ controlled: v, default: n ?? l, name: 'Slider' }),
      R =
        u &&
        ((X, G, ce) => {
          const ne = X.nativeEvent || X,
            ue = new ne.constructor(ne.type, ne)
          Object.defineProperty(ue, 'target', { writable: !0, value: { value: G, name: c } }), u(ue, G, ce)
        }),
      S = Array.isArray(D)
    let L = S ? D.slice().sort(Cp) : [D]
    L = L.map(X => (X == null ? l : _r(X, l, a)))
    const I = i === !0 && g !== null ? [...Array(Math.floor((a - l) / g) + 1)].map((X, G) => ({ value: l + g * G })) : i || [],
      z = I.map(X => X.value),
      { isFocusVisibleRef: B, onBlur: O, onFocus: W, ref: K } = Mc(),
      [Z, oe] = N.useState(-1),
      V = N.useRef(null),
      q = ht(K, V),
      ee = ht(A, q),
      re = X => G => {
        var ce
        const ne = Number(G.currentTarget.getAttribute('data-index'))
        W(G), B.current === !0 && oe(ne), E(ne), X == null || (ce = X.onFocus) == null || ce.call(X, G)
      },
      J = X => G => {
        var ce
        O(G), B.current === !1 && oe(-1), E(-1), X == null || (ce = X.onBlur) == null || ce.call(X, G)
      },
      ie = (X, G) => {
        const ce = Number(X.currentTarget.getAttribute('data-index')),
          ne = L[ce],
          ue = z.indexOf(ne)
        let _ = G
        if (I && g == null) {
          const pe = z[z.length - 1]
          _ > pe ? (_ = pe) : _ < z[0] ? (_ = z[0]) : (_ = _ < ne ? z[ue - 1] : z[ue + 1])
        }
        if (((_ = _r(_, l, a)), S)) {
          r && (_ = _r(_, L[ce - 1] || -1 / 0, L[ce + 1] || 1 / 0))
          const pe = _
          _ = Ep({ values: L, newValue: _, index: ce })
          let xe = ce
          r || (xe = _.indexOf(pe)), ga({ sliderRef: V, activeIndex: xe })
        }
        Q(_), oe(ce), R && !ma(_, D) && R(X, _, ce), d && d(X, _)
      },
      Ae = X => G => {
        var ce
        if (g !== null) {
          const ne = Number(G.currentTarget.getAttribute('data-index')),
            ue = L[ne]
          let _ = null
          ;((G.key === 'ArrowLeft' || G.key === 'ArrowDown') && G.shiftKey) || G.key === 'PageDown' ? (_ = Math.max(ue - x, l)) : (((G.key === 'ArrowRight' || G.key === 'ArrowUp') && G.shiftKey) || G.key === 'PageUp') && (_ = Math.min(ue + x, a)), _ !== null && (ie(G, _), G.preventDefault())
        }
        X == null || (ce = X.onKeyDown) == null || ce.call(X, G)
      }
    xn(() => {
      if (o && V.current.contains(document.activeElement)) {
        var X
        ;(X = document.activeElement) == null || X.blur()
      }
    }, [o]),
      o && b !== -1 && w(-1),
      o && Z !== -1 && oe(-1)
    const ae = X => G => {
        var ce
        ;(ce = X.onChange) == null || ce.call(X, G), ie(G, G.target.valueAsNumber)
      },
      se = N.useRef(void 0)
    let H = f
    s && f === 'horizontal' && (H += '-reverse')
    const U = ({ finger: X, move: G = !1 }) => {
        const { current: ce } = V,
          { width: ne, height: ue, bottom: _, left: pe } = ce.getBoundingClientRect()
        let xe
        H.indexOf('vertical') === 0 ? (xe = (_ - X.y) / ue) : (xe = (X.x - pe) / ne), H.indexOf('-reverse') !== -1 && (xe = 1 - xe)
        let Ee
        if (((Ee = wI(xe, l, a)), g)) Ee = SI(Ee, g, l)
        else {
          const nn = wp(z, Ee)
          Ee = z[nn]
        }
        Ee = _r(Ee, l, a)
        let nt = 0
        if (S) {
          G ? (nt = se.current) : (nt = wp(L, Ee)), r && (Ee = _r(Ee, L[nt - 1] || -1 / 0, L[nt + 1] || 1 / 0))
          const nn = Ee
          ;(Ee = Ep({ values: L, newValue: Ee, index: nt })), (r && G) || ((nt = Ee.indexOf(nn)), (se.current = nt))
        }
        return { newValue: Ee, activeIndex: nt }
      },
      te = Cn(X => {
        const G = pa(X, y)
        if (!G) return
        if (((F.current += 1), X.type === 'mousemove' && X.buttons === 0)) {
          be(X)
          return
        }
        const { newValue: ce, activeIndex: ne } = U({ finger: G, move: !0 })
        ga({ sliderRef: V, activeIndex: ne, setActive: w }), Q(ce), !P && F.current > CI && T(!0), R && !ma(ce, D) && R(X, ce, ne)
      }),
      be = Cn(X => {
        const G = pa(X, y)
        if ((T(!1), !G)) return
        const { newValue: ce } = U({ finger: G, move: !0 })
        w(-1), X.type === 'touchend' && E(-1), d && d(X, ce), (y.current = void 0), Me()
      }),
      Ne = Cn(X => {
        if (o) return
        Sp() || X.preventDefault()
        const G = X.changedTouches[0]
        G != null && (y.current = G.identifier)
        const ce = pa(X, y)
        if (ce !== !1) {
          const { newValue: ue, activeIndex: _ } = U({ finger: ce })
          ga({ sliderRef: V, activeIndex: _, setActive: w }), Q(ue), R && !ma(ue, D) && R(X, ue, _)
        }
        F.current = 0
        const ne = yt(V.current)
        ne.addEventListener('touchmove', te, { passive: !0 }), ne.addEventListener('touchend', be, { passive: !0 })
      }),
      Me = N.useCallback(() => {
        const X = yt(V.current)
        X.removeEventListener('mousemove', te), X.removeEventListener('mouseup', be), X.removeEventListener('touchmove', te), X.removeEventListener('touchend', be)
      }, [be, te])
    N.useEffect(() => {
      const { current: X } = V
      return (
        X.addEventListener('touchstart', Ne, { passive: Sp() }),
        () => {
          X.removeEventListener('touchstart', Ne), Me()
        }
      )
    }, [Me, Ne]),
      N.useEffect(() => {
        o && Me()
      }, [o, Me])
    const Ue = X => G => {
        var ce
        if (((ce = X.onMouseDown) == null || ce.call(X, G), o || G.defaultPrevented || G.button !== 0)) return
        G.preventDefault()
        const ne = pa(G, y)
        if (ne !== !1) {
          const { newValue: _, activeIndex: pe } = U({ finger: ne })
          ga({ sliderRef: V, activeIndex: pe, setActive: w }), Q(_), R && !ma(_, D) && R(G, _, pe)
        }
        F.current = 0
        const ue = yt(V.current)
        ue.addEventListener('mousemove', te, { passive: !0 }), ue.addEventListener('mouseup', be)
      },
      we = ha(S ? L[0] : l, l, a),
      Se = ha(L[L.length - 1], l, a) - we,
      et = (X = {}) => {
        const G = $r(X),
          ce = { onMouseDown: Ue(G || {}) },
          ne = M({}, G, ce)
        return M({}, X, { ref: ee }, ne)
      },
      We = X => G => {
        var ce
        ;(ce = X.onMouseOver) == null || ce.call(X, G)
        const ne = Number(G.currentTarget.getAttribute('data-index'))
        E(ne)
      },
      Ie = X => G => {
        var ce
        ;(ce = X.onMouseLeave) == null || ce.call(X, G), E(-1)
      }
    return {
      active: b,
      axis: H,
      axisProps: BI,
      dragging: P,
      focusedThumbIndex: Z,
      getHiddenInputProps: (X = {}) => {
        var G
        const ce = $r(X),
          ne = { onChange: ae(ce || {}), onFocus: re(ce || {}), onBlur: J(ce || {}), onKeyDown: Ae(ce || {}) },
          ue = M({}, ce, ne)
        return M({ tabIndex: m, 'aria-labelledby': t, 'aria-orientation': f, 'aria-valuemax': h(a), 'aria-valuemin': h(l), name: c, type: 'range', min: e.min, max: e.max, step: e.step === null && e.marks ? 'any' : (G = e.step) != null ? G : void 0, disabled: o }, X, ue, {
          style: M({}, nw, { direction: s ? 'rtl' : 'ltr', width: '100%', height: '100%' }),
        })
      },
      getRootProps: et,
      getThumbProps: (X = {}) => {
        const G = $r(X),
          ce = { onMouseOver: We(G || {}), onMouseLeave: Ie(G || {}) }
        return M({}, X, G, ce)
      },
      marks: I,
      open: k,
      range: S,
      rootRef: ee,
      trackLeap: Se,
      trackOffset: we,
      values: L,
      getThumbStyle: X => ({ pointerEvents: b !== -1 && b !== X ? 'none' : void 0 }),
    }
  }
  const NI = e => !e || !Kn(e)
  function MI(e) {
    return Fe('MuiSlider', e)
  }
  const Jt = Pe('MuiSlider', [
      'root',
      'active',
      'colorPrimary',
      'colorSecondary',
      'colorError',
      'colorInfo',
      'colorSuccess',
      'colorWarning',
      'disabled',
      'dragging',
      'focusVisible',
      'mark',
      'markActive',
      'marked',
      'markLabel',
      'markLabelActive',
      'rail',
      'sizeSmall',
      'thumb',
      'thumbColorPrimary',
      'thumbColorSecondary',
      'thumbColorError',
      'thumbColorSuccess',
      'thumbColorInfo',
      'thumbColorWarning',
      'track',
      'trackInverted',
      'trackFalse',
      'thumbSizeSmall',
      'valueLabel',
      'valueLabelOpen',
      'valueLabelCircle',
      'valueLabelLabel',
      'vertical',
    ]),
    PI = e => {
      const { open: t } = e
      return { offset: fe(t && Jt.valueLabelOpen), circle: Jt.valueLabelCircle, label: Jt.valueLabelLabel }
    }
  function LI(e) {
    const { children: t, className: n, value: o } = e,
      r = PI(e)
    return t ? N.cloneElement(t, { className: fe(t.props.className) }, p.jsxs(N.Fragment, { children: [t.props.children, p.jsx('span', { className: fe(r.offset, n), 'aria-hidden': !0, children: p.jsx('span', { className: r.circle, children: p.jsx('span', { className: r.label, children: o }) }) })] })) : null
  }
  const TI = [
    'aria-label',
    'aria-valuetext',
    'aria-labelledby',
    'component',
    'components',
    'componentsProps',
    'color',
    'classes',
    'className',
    'disableSwap',
    'disabled',
    'getAriaLabel',
    'getAriaValueText',
    'marks',
    'max',
    'min',
    'name',
    'onChange',
    'onChangeCommitted',
    'orientation',
    'shiftStep',
    'size',
    'step',
    'scale',
    'slotProps',
    'slots',
    'tabIndex',
    'track',
    'value',
    'valueLabelDisplay',
    'valueLabelFormat',
  ]
  function Bp(e) {
    return e
  }
  const FI = j('span', {
      name: 'MuiSlider',
      slot: 'Root',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.root, t[`color${me(n.color)}`], n.size !== 'medium' && t[`size${me(n.size)}`], n.marked && t.marked, n.orientation === 'vertical' && t.vertical, n.track === 'inverted' && t.trackInverted, n.track === !1 && t.trackFalse]
      },
    })(({ theme: e }) => {
      var t
      return {
        borderRadius: 12,
        boxSizing: 'content-box',
        display: 'inline-block',
        position: 'relative',
        cursor: 'pointer',
        touchAction: 'none',
        WebkitTapHighlightColor: 'transparent',
        '@media print': { colorAdjust: 'exact' },
        [`&.${Jt.disabled}`]: { pointerEvents: 'none', cursor: 'default', color: (e.vars || e).palette.grey[400] },
        [`&.${Jt.dragging}`]: { [`& .${Jt.thumb}, & .${Jt.track}`]: { transition: 'none' } },
        variants: [
          ...Object.keys(((t = e.vars) != null ? t : e).palette)
            .filter(n => {
              var o
              return ((o = e.vars) != null ? o : e).palette[n].main
            })
            .map(n => ({ props: { color: n }, style: { color: (e.vars || e).palette[n].main } })),
          { props: { orientation: 'horizontal' }, style: { height: 4, width: '100%', padding: '13px 0', '@media (pointer: coarse)': { padding: '20px 0' } } },
          { props: { orientation: 'horizontal', size: 'small' }, style: { height: 2 } },
          { props: { orientation: 'horizontal', marked: !0 }, style: { marginBottom: 20 } },
          { props: { orientation: 'vertical' }, style: { height: '100%', width: 4, padding: '0 13px', '@media (pointer: coarse)': { padding: '0 20px' } } },
          { props: { orientation: 'vertical', size: 'small' }, style: { width: 2 } },
          { props: { orientation: 'vertical', marked: !0 }, style: { marginRight: 44 } },
        ],
      }
    }),
    DI = j('span', { name: 'MuiSlider', slot: 'Rail', overridesResolver: (e, t) => t.rail })({
      display: 'block',
      position: 'absolute',
      borderRadius: 'inherit',
      backgroundColor: 'currentColor',
      opacity: 0.38,
      variants: [
        { props: { orientation: 'horizontal' }, style: { width: '100%', height: 'inherit', top: '50%', transform: 'translateY(-50%)' } },
        { props: { orientation: 'vertical' }, style: { height: '100%', width: 'inherit', left: '50%', transform: 'translateX(-50%)' } },
        { props: { track: 'inverted' }, style: { opacity: 1 } },
      ],
    }),
    zI = j('span', { name: 'MuiSlider', slot: 'Track', overridesResolver: (e, t) => t.track })(({ theme: e }) => {
      var t
      return {
        display: 'block',
        position: 'absolute',
        borderRadius: 'inherit',
        border: '1px solid currentColor',
        backgroundColor: 'currentColor',
        transition: e.transitions.create(['left', 'width', 'bottom', 'height'], { duration: e.transitions.duration.shortest }),
        variants: [
          { props: { size: 'small' }, style: { border: 'none' } },
          { props: { orientation: 'horizontal' }, style: { height: 'inherit', top: '50%', transform: 'translateY(-50%)' } },
          { props: { orientation: 'vertical' }, style: { width: 'inherit', left: '50%', transform: 'translateX(-50%)' } },
          { props: { track: !1 }, style: { display: 'none' } },
          ...Object.keys(((t = e.vars) != null ? t : e).palette)
            .filter(n => {
              var o
              return ((o = e.vars) != null ? o : e).palette[n].main
            })
            .map(n => ({
              props: { color: n, track: 'inverted' },
              style: M(
                {},
                e.vars
                  ? { backgroundColor: e.vars.palette.Slider[`${n}Track`], borderColor: e.vars.palette.Slider[`${n}Track`] }
                  : M({ backgroundColor: yc(e.palette[n].main, 0.62), borderColor: yc(e.palette[n].main, 0.62) }, e.applyStyles('dark', { backgroundColor: mc(e.palette[n].main, 0.5) }), e.applyStyles('dark', { borderColor: mc(e.palette[n].main, 0.5) }))
              ),
            })),
        ],
      }
    }),
    QI = j('span', {
      name: 'MuiSlider',
      slot: 'Thumb',
      overridesResolver: (e, t) => {
        const { ownerState: n } = e
        return [t.thumb, t[`thumbColor${me(n.color)}`], n.size !== 'medium' && t[`thumbSize${me(n.size)}`]]
      },
    })(({ theme: e }) => {
      var t
      return {
        position: 'absolute',
        width: 20,
        height: 20,
        boxSizing: 'border-box',
        borderRadius: '50%',
        outline: 0,
        backgroundColor: 'currentColor',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        transition: e.transitions.create(['box-shadow', 'left', 'bottom'], { duration: e.transitions.duration.shortest }),
        '&::before': { position: 'absolute', content: '""', borderRadius: 'inherit', width: '100%', height: '100%', boxShadow: (e.vars || e).shadows[2] },
        '&::after': { position: 'absolute', content: '""', borderRadius: '50%', width: 42, height: 42, top: '50%', left: '50%', transform: 'translate(-50%, -50%)' },
        [`&.${Jt.disabled}`]: { '&:hover': { boxShadow: 'none' } },
        variants: [
          { props: { size: 'small' }, style: { width: 12, height: 12, '&::before': { boxShadow: 'none' } } },
          { props: { orientation: 'horizontal' }, style: { top: '50%', transform: 'translate(-50%, -50%)' } },
          { props: { orientation: 'vertical' }, style: { left: '50%', transform: 'translate(-50%, 50%)' } },
          ...Object.keys(((t = e.vars) != null ? t : e).palette)
            .filter(n => {
              var o
              return ((o = e.vars) != null ? o : e).palette[n].main
            })
            .map(n => ({
              props: { color: n },
              style: {
                [`&:hover, &.${Jt.focusVisible}`]: M({}, e.vars ? { boxShadow: `0px 0px 0px 8px rgba(${e.vars.palette[n].mainChannel} / 0.16)` } : { boxShadow: `0px 0px 0px 8px ${Bt(e.palette[n].main, 0.16)}` }, { '@media (hover: none)': { boxShadow: 'none' } }),
                [`&.${Jt.active}`]: M({}, e.vars ? { boxShadow: `0px 0px 0px 14px rgba(${e.vars.palette[n].mainChannel} / 0.16)` } : { boxShadow: `0px 0px 0px 14px ${Bt(e.palette[n].main, 0.16)}` }),
              },
            })),
        ],
      }
    }),
    RI = j(LI, { name: 'MuiSlider', slot: 'ValueLabel', overridesResolver: (e, t) => t.valueLabel })(({ theme: e }) =>
      M({ zIndex: 1, whiteSpace: 'nowrap' }, e.typography.body2, {
        fontWeight: 500,
        transition: e.transitions.create(['transform'], { duration: e.transitions.duration.shortest }),
        position: 'absolute',
        backgroundColor: (e.vars || e).palette.grey[600],
        borderRadius: 2,
        color: (e.vars || e).palette.common.white,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '0.25rem 0.75rem',
        variants: [
          {
            props: { orientation: 'horizontal' },
            style: {
              transform: 'translateY(-100%) scale(0)',
              top: '-10px',
              transformOrigin: 'bottom center',
              '&::before': { position: 'absolute', content: '""', width: 8, height: 8, transform: 'translate(-50%, 50%) rotate(45deg)', backgroundColor: 'inherit', bottom: 0, left: '50%' },
              [`&.${Jt.valueLabelOpen}`]: { transform: 'translateY(-100%) scale(1)' },
            },
          },
          {
            props: { orientation: 'vertical' },
            style: {
              transform: 'translateY(-50%) scale(0)',
              right: '30px',
              top: '50%',
              transformOrigin: 'right center',
              '&::before': { position: 'absolute', content: '""', width: 8, height: 8, transform: 'translate(-50%, -50%) rotate(45deg)', backgroundColor: 'inherit', right: -8, top: '50%' },
              [`&.${Jt.valueLabelOpen}`]: { transform: 'translateY(-50%) scale(1)' },
            },
          },
          { props: { size: 'small' }, style: { fontSize: e.typography.pxToRem(12), padding: '0.25rem 0.5rem' } },
          { props: { orientation: 'vertical', size: 'small' }, style: { right: '20px' } },
        ],
      })
    ),
    OI = j('span', {
      name: 'MuiSlider',
      slot: 'Mark',
      shouldForwardProp: e => Ki(e) && e !== 'markActive',
      overridesResolver: (e, t) => {
        const { markActive: n } = e
        return [t.mark, n && t.markActive]
      },
    })(({ theme: e }) => ({
      position: 'absolute',
      width: 2,
      height: 2,
      borderRadius: 1,
      backgroundColor: 'currentColor',
      variants: [
        { props: { orientation: 'horizontal' }, style: { top: '50%', transform: 'translate(-1px, -50%)' } },
        { props: { orientation: 'vertical' }, style: { left: '50%', transform: 'translate(-50%, 1px)' } },
        { props: { markActive: !0 }, style: { backgroundColor: (e.vars || e).palette.background.paper, opacity: 0.8 } },
      ],
    })),
    jI = j('span', { name: 'MuiSlider', slot: 'MarkLabel', shouldForwardProp: e => Ki(e) && e !== 'markLabelActive', overridesResolver: (e, t) => t.markLabel })(({ theme: e }) =>
      M({}, e.typography.body2, {
        color: (e.vars || e).palette.text.secondary,
        position: 'absolute',
        whiteSpace: 'nowrap',
        variants: [
          { props: { orientation: 'horizontal' }, style: { top: 30, transform: 'translateX(-50%)', '@media (pointer: coarse)': { top: 40 } } },
          { props: { orientation: 'vertical' }, style: { left: 36, transform: 'translateY(50%)', '@media (pointer: coarse)': { left: 44 } } },
          { props: { markLabelActive: !0 }, style: { color: (e.vars || e).palette.text.primary } },
        ],
      })
    ),
    WI = e => {
      const { disabled: t, dragging: n, marked: o, orientation: r, track: s, classes: i, color: a, size: l } = e,
        c = {
          root: ['root', t && 'disabled', n && 'dragging', o && 'marked', r === 'vertical' && 'vertical', s === 'inverted' && 'trackInverted', s === !1 && 'trackFalse', a && `color${me(a)}`, l && `size${me(l)}`],
          rail: ['rail'],
          track: ['track'],
          mark: ['mark'],
          markActive: ['markActive'],
          markLabel: ['markLabel'],
          markLabelActive: ['markLabelActive'],
          valueLabel: ['valueLabel'],
          thumb: ['thumb', t && 'disabled', l && `thumbSize${me(l)}`, a && `thumbColor${me(a)}`],
          active: ['active'],
          disabled: ['disabled'],
          focusVisible: ['focusVisible'],
        }
      return Re(c, MI, i)
    },
    GI = ({ children: e }) => e,
    Ip = N.forwardRef(function (t, n) {
      var o, r, s, i, a, l, c, u, d, f, A, h, g, x, m, v, y, b, w, k, E, P, T, F
      const D = Le({ props: t, name: 'MuiSlider' }),
        Q = hc(),
        {
          'aria-label': R,
          'aria-valuetext': S,
          'aria-labelledby': L,
          component: I = 'span',
          components: z = {},
          componentsProps: B = {},
          color: O = 'primary',
          classes: W,
          className: K,
          disableSwap: Z = !1,
          disabled: oe = !1,
          getAriaLabel: V,
          getAriaValueText: q,
          marks: ee = !1,
          max: re = 100,
          min: J = 0,
          orientation: ie = 'horizontal',
          shiftStep: Ae = 10,
          size: ae = 'medium',
          step: se = 1,
          scale: H = Bp,
          slotProps: U,
          slots: te,
          track: be = 'normal',
          valueLabelDisplay: Ne = 'off',
          valueLabelFormat: Me = Bp,
        } = D,
        Ue = he(D, TI),
        we = M({}, D, { isRtl: Q, max: re, min: J, classes: W, disabled: oe, disableSwap: Z, orientation: ie, marks: ee, color: O, size: ae, step: se, shiftStep: Ae, scale: H, track: be, valueLabelDisplay: Ne, valueLabelFormat: Me }),
        { axisProps: Se, getRootProps: et, getHiddenInputProps: We, getThumbProps: Ie, open: Ze, active: Ke, axis: Ve, focusedThumbIndex: X, range: G, dragging: ce, marks: ne, values: ue, trackOffset: _, trackLeap: pe, getThumbStyle: xe } = kI(M({}, we, { rootRef: n }))
      ;(we.marked = ne.length > 0 && ne.some(Te => Te.label)), (we.dragging = ce), (we.focusedThumbIndex = X)
      const Ee = WI(we),
        nt = (o = (r = te == null ? void 0 : te.root) != null ? r : z.Root) != null ? o : FI,
        nn = (s = (i = te == null ? void 0 : te.rail) != null ? i : z.Rail) != null ? s : DI,
        Hn = (a = (l = te == null ? void 0 : te.track) != null ? l : z.Track) != null ? a : zI,
        Rr = (c = (u = te == null ? void 0 : te.thumb) != null ? u : z.Thumb) != null ? c : QI,
        Or = (d = (f = te == null ? void 0 : te.valueLabel) != null ? f : z.ValueLabel) != null ? d : RI,
        Wo = (A = (h = te == null ? void 0 : te.mark) != null ? h : z.Mark) != null ? A : OI,
        Go = (g = (x = te == null ? void 0 : te.markLabel) != null ? x : z.MarkLabel) != null ? g : jI,
        Vo = (m = (v = te == null ? void 0 : te.input) != null ? v : z.Input) != null ? m : 'input',
        Xo = (y = U == null ? void 0 : U.root) != null ? y : B.root,
        Zs = (b = U == null ? void 0 : U.rail) != null ? b : B.rail,
        Yo = (w = U == null ? void 0 : U.track) != null ? w : B.track,
        Ho = (k = U == null ? void 0 : U.thumb) != null ? k : B.thumb,
        Uo = (E = U == null ? void 0 : U.valueLabel) != null ? E : B.valueLabel,
        Js = (P = U == null ? void 0 : U.mark) != null ? P : B.mark,
        _s = (T = U == null ? void 0 : U.markLabel) != null ? T : B.markLabel,
        $s = (F = U == null ? void 0 : U.input) != null ? F : B.input,
        ei = Lt({ elementType: nt, getSlotProps: et, externalSlotProps: Xo, externalForwardedProps: Ue, additionalProps: M({}, NI(nt) && { as: I }), ownerState: M({}, we, Xo == null ? void 0 : Xo.ownerState), className: [Ee.root, K] }),
        le = Lt({ elementType: nn, externalSlotProps: Zs, ownerState: we, className: Ee.rail }),
        de = Lt({ elementType: Hn, externalSlotProps: Yo, additionalProps: { style: M({}, Se[Ve].offset(_), Se[Ve].leap(pe)) }, ownerState: M({}, we, Yo == null ? void 0 : Yo.ownerState), className: Ee.track }),
        Be = Lt({ elementType: Rr, getSlotProps: Ie, externalSlotProps: Ho, ownerState: M({}, we, Ho == null ? void 0 : Ho.ownerState), className: Ee.thumb }),
        ge = Lt({ elementType: Or, externalSlotProps: Uo, ownerState: M({}, we, Uo == null ? void 0 : Uo.ownerState), className: Ee.valueLabel }),
        Ce = Lt({ elementType: Wo, externalSlotProps: Js, ownerState: we, className: Ee.mark }),
        Je = Lt({ elementType: Go, externalSlotProps: _s, ownerState: we, className: Ee.markLabel }),
        gt = Lt({ elementType: Vo, getSlotProps: We, externalSlotProps: $s, ownerState: we })
      return p.jsxs(
        nt,
        M({}, ei, {
          children: [
            p.jsx(nn, M({}, le)),
            p.jsx(Hn, M({}, de)),
            ne
              .filter(Te => Te.value >= J && Te.value <= re)
              .map((Te, tt) => {
                const io = ha(Te.value, J, re),
                  Un = Se[Ve].offset(io)
                let Dt
                return (
                  be === !1 ? (Dt = ue.indexOf(Te.value) !== -1) : (Dt = (be === 'normal' && (G ? Te.value >= ue[0] && Te.value <= ue[ue.length - 1] : Te.value <= ue[0])) || (be === 'inverted' && (G ? Te.value <= ue[0] || Te.value >= ue[ue.length - 1] : Te.value >= ue[0]))),
                  p.jsxs(
                    N.Fragment,
                    {
                      children: [
                        p.jsx(Wo, M({ 'data-index': tt }, Ce, !Kn(Wo) && { markActive: Dt }, { style: M({}, Un, Ce.style), className: fe(Ce.className, Dt && Ee.markActive) })),
                        Te.label != null ? p.jsx(Go, M({ 'aria-hidden': !0, 'data-index': tt }, Je, !Kn(Go) && { markLabelActive: Dt }, { style: M({}, Un, Je.style), className: fe(Ee.markLabel, Je.className, Dt && Ee.markLabelActive), children: Te.label })) : null,
                      ],
                    },
                    tt
                  )
                )
              }),
            ue.map((Te, tt) => {
              const io = ha(Te, J, re),
                Un = Se[Ve].offset(io),
                Dt = Ne === 'off' ? GI : Or
              return p.jsx(
                Dt,
                M({}, !Kn(Dt) && { valueLabelFormat: Me, valueLabelDisplay: Ne, value: typeof Me == 'function' ? Me(H(Te), tt) : Me, index: tt, open: Ze === tt || Ke === tt || Ne === 'on', disabled: oe }, ge, {
                  children: p.jsx(
                    Rr,
                    M({ 'data-index': tt }, Be, {
                      className: fe(Ee.thumb, Be.className, Ke === tt && Ee.active, X === tt && Ee.focusVisible),
                      style: M({}, Un, xe(tt), Be.style),
                      children: p.jsx(Vo, M({ 'data-index': tt, 'aria-label': V ? V(tt) : R, 'aria-valuenow': H(Te), 'aria-labelledby': L, 'aria-valuetext': q ? q(H(Te), tt) : S, value: ue[tt] }, gt)),
                    })
                  ),
                }),
                tt
              )
            }),
          ],
        })
      )
    })
  function VI(e) {
    return Fe('MuiTextField', e)
  }
  Pe('MuiTextField', ['root'])
  const XI = [
      'autoComplete',
      'autoFocus',
      'children',
      'className',
      'color',
      'defaultValue',
      'disabled',
      'error',
      'FormHelperTextProps',
      'fullWidth',
      'helperText',
      'id',
      'InputLabelProps',
      'inputProps',
      'InputProps',
      'inputRef',
      'label',
      'maxRows',
      'minRows',
      'multiline',
      'name',
      'onBlur',
      'onChange',
      'onFocus',
      'placeholder',
      'required',
      'rows',
      'select',
      'SelectProps',
      'type',
      'value',
      'variant',
    ],
    YI = { standard: Kc, filled: Yc, outlined: _c },
    HI = e => {
      const { classes: t } = e
      return Re({ root: ['root'] }, VI, t)
    },
    UI = j(ep, { name: 'MuiTextField', slot: 'Root', overridesResolver: (e, t) => t.root })({}),
    kp = N.forwardRef(function (t, n) {
      const o = Le({ props: t, name: 'MuiTextField' }),
        {
          autoComplete: r,
          autoFocus: s = !1,
          children: i,
          className: a,
          color: l = 'primary',
          defaultValue: c,
          disabled: u = !1,
          error: d = !1,
          FormHelperTextProps: f,
          fullWidth: A = !1,
          helperText: h,
          id: g,
          InputLabelProps: x,
          inputProps: m,
          InputProps: v,
          inputRef: y,
          label: b,
          maxRows: w,
          minRows: k,
          multiline: E = !1,
          name: P,
          onBlur: T,
          onChange: F,
          onFocus: D,
          placeholder: Q,
          required: R = !1,
          rows: S,
          select: L = !1,
          SelectProps: I,
          type: z,
          value: B,
          variant: O = 'outlined',
        } = o,
        W = he(o, XI),
        K = M({}, o, { autoFocus: s, color: l, disabled: u, error: d, fullWidth: A, multiline: E, required: R, select: L, variant: O }),
        Z = HI(K),
        oe = {}
      O === 'outlined' && (x && typeof x.shrink < 'u' && (oe.notched = x.shrink), (oe.label = b)), L && ((!I || !I.native) && (oe.id = void 0), (oe['aria-describedby'] = void 0))
      const V = _i(g),
        q = h && V ? `${V}-helper-text` : void 0,
        ee = b && V ? `${V}-label` : void 0,
        re = YI[O],
        J = p.jsx(re, M({ 'aria-describedby': q, autoComplete: r, autoFocus: s, defaultValue: c, fullWidth: A, multiline: E, name: P, rows: S, maxRows: w, minRows: k, type: z, value: B, id: V, inputRef: y, onBlur: T, onChange: F, onFocus: D, placeholder: Q, inputProps: m }, oe, v))
      return p.jsxs(
        UI,
        M({ className: fe(Z.root, a), disabled: u, error: d, fullWidth: A, ref: n, required: R, color: l, variant: O, ownerState: K }, W, {
          children: [b != null && b !== '' && p.jsx(ap, M({ htmlFor: V, id: ee }, x, { children: b })), L ? p.jsx(eu, M({ 'aria-describedby': q, id: V, labelId: ee, value: B, input: J }, I, { children: i })) : J, h && p.jsx(op, M({ id: q }, f, { children: h }))],
        })
      )
    }),
    KI = { appEnvironment: 'local' },
    qI = C.createContext(KI),
    ba = {
      appName: 'React Flow App',
      appVersion: '0.0.0',
      appEnvironment: 'local',
      apiUrl: '',
      historyDeepness: 256,
      edgeParameters: {
        minEdgeDiameterInches: 1,
        maxEdgeDiameterInches: 100,
        edgeDiameterIncrementStep: 0.5,
        edgeDiameterDecrementStep: 0.5,
        minEdgeLengthFeet: 5,
        maxEdgeLengthFeet: 500,
        edgeLengthFeetIncrementStep: 5,
        edgeLengthFeetDecrementStep: 5,
        minEdgeParallelSets: 1,
        maxEdgeParallelSets: 20,
        edgeParallelSetsIncrementStep: 1,
        edgeParallelSetsDecrementStep: 1,
        maxEdgeConductors: 4,
        minEdgeConductorAmount: 1,
        maxEdgeConductorAmount: 100,
        edgeConductorAmountIncrementStep: 1,
        edgeConductorAmountDecrementStep: 1,
      },
      subNodeParameters: { minAmpereRating: 0, maxAmpereRating: 1e3, defaultAmpereRating: 1, minPoles: 1, maxPoles: 10, defaultPoles: 3, polesIncrementStep: 1, polesDecrementStep: 1, minCopies: 1, maxCopies: 8 },
    },
    ZI = C.createContext(ba),
    JI = ({ config: e, children: t }) => p.jsx(ZI.Provider, { value: e, children: t }),
    tu = e => ({ x: e.clientX, y: e.clientY }),
    nu = (e, t) => ({ top: e.clientY < t.height - 200 ? e.clientY : void 0, left: e.clientX < t.width - 200 ? e.clientX : void 0, right: e.clientX >= t.width - 200 ? t.width - e.clientX : void 0, bottom: e.clientY >= t.height - 200 ? t.height - e.clientY : void 0 }),
    _I = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i
  function $I(e) {
    return typeof e == 'string' && _I.test(e)
  }
  for (var xt = [], ou = 0; ou < 256; ++ou) xt.push((ou + 256).toString(16).slice(1))
  function ek(e, t = 0) {
    return (xt[e[t + 0]] + xt[e[t + 1]] + xt[e[t + 2]] + xt[e[t + 3]] + '-' + xt[e[t + 4]] + xt[e[t + 5]] + '-' + xt[e[t + 6]] + xt[e[t + 7]] + '-' + xt[e[t + 8]] + xt[e[t + 9]] + '-' + xt[e[t + 10]] + xt[e[t + 11]] + xt[e[t + 12]] + xt[e[t + 13]] + xt[e[t + 14]] + xt[e[t + 15]]).toLowerCase()
  }
  var va,
    tk = new Uint8Array(16)
  function nk() {
    if (!va && ((va = typeof crypto < 'u' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)), !va)) throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported')
    return va(tk)
  }
  var ok = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  const Np = { randomUUID: ok }
  function rk(e, t, n) {
    if (Np.randomUUID && !t && !e) return Np.randomUUID()
    e = e || {}
    var o = e.random || (e.rng || nk)()
    return (o[6] = (o[6] & 15) | 64), (o[8] = (o[8] & 63) | 128), ek(o)
  }
  const Co = e => rk(e),
    ru = e => {
      if (!$I(e)) return e
      const t = e.split('-')
      return t[t.length - 1]
    },
    sk = (e, { filename: t } = {}) => {
      const n = document.createElement('a')
      ;(n.href = e), t && (n.download = t), document.body.appendChild(n), n.click(), document.body.removeChild(n)
    }
  function ik(e) {
    if (!e || typeof e != 'object') throw new TypeError('Passed json is not an object')
  }
  function ak(e) {
    if ((ik(e), !('nodes' in e) || !('edges' in e))) throw new Error('nodes and/or edges property are missing in the save file')
    if (!Array.isArray(e.nodes) || !Array.isArray(e.edges)) throw new TypeError('nodes and/or edges are not of an array type')
  }
  const st = (e = {}) => ({ ...e }),
    lk = e => Object.entries(e).reduce((t, n) => ({ ...t, [n[1]]: n[0] }), {}),
    ck = () => {
      const e = new Date(),
        t = e.toDateString(),
        n = e.toTimeString().slice(0, 8)
      return `Flow ${t} ${n}.json`
    }
  function uk(e, t, n = 5) {
    var l, c, u, d
    const o = { horizontal: void 0, vertical: void 0, snapPosition: { x: void 0, y: void 0 } },
      r = t.find(f => f.id === e.id)
    if (!r || !e.position) return o
    const s = { left: e.position.x, right: e.position.x + (((l = r.measured) == null ? void 0 : l.width) ?? 0), top: e.position.y, bottom: e.position.y + (((c = r.measured) == null ? void 0 : c.height) ?? 0), width: ((u = r.measured) == null ? void 0 : u.width) ?? 0, height: ((d = r.measured) == null ? void 0 : d.height) ?? 0 }
    let i = n,
      a = n
    return t
      .filter(f => f.id !== r.id)
      .reduce((f, A) => {
        var E, P, T, F
        const h = { left: A.position.x, right: A.position.x + (((E = A.measured) == null ? void 0 : E.width) ?? 0), top: A.position.y, bottom: A.position.y + (((P = A.measured) == null ? void 0 : P.height) ?? 0), width: ((T = A.measured) == null ? void 0 : T.width) ?? 0, height: ((F = A.measured) == null ? void 0 : F.height) ?? 0 },
          g = Math.abs(s.left - h.left)
        g < a && ((f.snapPosition.x = h.left), (f.vertical = h.left), (a = g))
        const x = Math.abs(s.right - h.right)
        x < a && ((f.snapPosition.x = h.right - s.width), (f.vertical = h.right), (a = x))
        const m = Math.abs(s.left - h.right)
        m < a && ((f.snapPosition.x = h.right), (f.vertical = h.right), (a = m))
        const v = Math.abs(s.right - h.left)
        v < a && ((f.snapPosition.x = h.left - s.width), (f.vertical = h.left), (a = v))
        const y = Math.abs(s.top - h.top)
        y < i && ((f.snapPosition.y = h.top), (f.horizontal = h.top), (i = y))
        const b = Math.abs(s.bottom - h.top)
        b < i && ((f.snapPosition.y = h.top - s.height), (f.horizontal = h.top), (i = b))
        const w = Math.abs(s.bottom - h.bottom)
        w < i && ((f.snapPosition.y = h.bottom - s.height), (f.horizontal = h.bottom), (i = w))
        const k = Math.abs(s.top - h.bottom)
        return k < i && ((f.snapPosition.y = h.bottom), (f.horizontal = h.bottom), (i = k)), f
      }, o)
  }
  const su = (e, t) => t.filter(n => n.parentId === e.id),
    Mp = e => ('label' in e.data && typeof e.data.label == 'string' && e.data.label) || void 0,
    Ar = e => Mp(e) ?? ru(e.id) ?? e.id
  function dt(e) {
    if (typeof e == 'string' || typeof e == 'number') return '' + e
    let t = ''
    if (Array.isArray(e)) for (let n = 0, o; n < e.length; n++) (o = dt(e[n])) !== '' && (t += (t && ' ') + o)
    else for (let n in e) e[n] && (t += (t && ' ') + n)
    return t
  }
  var dk = { value: () => {} }
  function xa() {
    for (var e = 0, t = arguments.length, n = {}, o; e < t; ++e) {
      if (!(o = arguments[e] + '') || o in n || /[\s.]/.test(o)) throw new Error('illegal type: ' + o)
      n[o] = []
    }
    return new Ca(n)
  }
  function Ca(e) {
    this._ = e
  }
  function fk(e, t) {
    return e
      .trim()
      .split(/^|\s+/)
      .map(function (n) {
        var o = '',
          r = n.indexOf('.')
        if ((r >= 0 && ((o = n.slice(r + 1)), (n = n.slice(0, r))), n && !t.hasOwnProperty(n))) throw new Error('unknown type: ' + n)
        return { type: n, name: o }
      })
  }
  Ca.prototype = xa.prototype = {
    constructor: Ca,
    on: function (e, t) {
      var n = this._,
        o = fk(e + '', n),
        r,
        s = -1,
        i = o.length
      if (arguments.length < 2) {
        for (; ++s < i; ) if ((r = (e = o[s]).type) && (r = Ak(n[r], e.name))) return r
        return
      }
      if (t != null && typeof t != 'function') throw new Error('invalid callback: ' + t)
      for (; ++s < i; )
        if ((r = (e = o[s]).type)) n[r] = Pp(n[r], e.name, t)
        else if (t == null) for (r in n) n[r] = Pp(n[r], e.name, null)
      return this
    },
    copy: function () {
      var e = {},
        t = this._
      for (var n in t) e[n] = t[n].slice()
      return new Ca(e)
    },
    call: function (e, t) {
      if ((r = arguments.length - 2) > 0) for (var n = new Array(r), o = 0, r, s; o < r; ++o) n[o] = arguments[o + 2]
      if (!this._.hasOwnProperty(e)) throw new Error('unknown type: ' + e)
      for (s = this._[e], o = 0, r = s.length; o < r; ++o) s[o].value.apply(t, n)
    },
    apply: function (e, t, n) {
      if (!this._.hasOwnProperty(e)) throw new Error('unknown type: ' + e)
      for (var o = this._[e], r = 0, s = o.length; r < s; ++r) o[r].value.apply(t, n)
    },
  }
  function Ak(e, t) {
    for (var n = 0, o = e.length, r; n < o; ++n) if ((r = e[n]).name === t) return r.value
  }
  function Pp(e, t, n) {
    for (var o = 0, r = e.length; o < r; ++o)
      if (e[o].name === t) {
        ;(e[o] = dk), (e = e.slice(0, o).concat(e.slice(o + 1)))
        break
      }
    return n != null && e.push({ name: t, value: n }), e
  }
  var iu = 'http://www.w3.org/1999/xhtml'
  const Lp = { svg: 'http://www.w3.org/2000/svg', xhtml: iu, xlink: 'http://www.w3.org/1999/xlink', xml: 'http://www.w3.org/XML/1998/namespace', xmlns: 'http://www.w3.org/2000/xmlns/' }
  function wa(e) {
    var t = (e += ''),
      n = t.indexOf(':')
    return n >= 0 && (t = e.slice(0, n)) !== 'xmlns' && (e = e.slice(n + 1)), Lp.hasOwnProperty(t) ? { space: Lp[t], local: e } : e
  }
  function pk(e) {
    return function () {
      var t = this.ownerDocument,
        n = this.namespaceURI
      return n === iu && t.documentElement.namespaceURI === iu ? t.createElement(e) : t.createElementNS(n, e)
    }
  }
  function hk(e) {
    return function () {
      return this.ownerDocument.createElementNS(e.space, e.local)
    }
  }
  function Tp(e) {
    var t = wa(e)
    return (t.local ? hk : pk)(t)
  }
  function gk() {}
  function au(e) {
    return e == null
      ? gk
      : function () {
          return this.querySelector(e)
        }
  }
  function mk(e) {
    typeof e != 'function' && (e = au(e))
    for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r) for (var s = t[r], i = s.length, a = (o[r] = new Array(i)), l, c, u = 0; u < i; ++u) (l = s[u]) && (c = e.call(l, l.__data__, u, s)) && ('__data__' in l && (c.__data__ = l.__data__), (a[u] = c))
    return new jt(o, this._parents)
  }
  function yk(e) {
    return e == null ? [] : Array.isArray(e) ? e : Array.from(e)
  }
  function bk() {
    return []
  }
  function Fp(e) {
    return e == null
      ? bk
      : function () {
          return this.querySelectorAll(e)
        }
  }
  function vk(e) {
    return function () {
      return yk(e.apply(this, arguments))
    }
  }
  function xk(e) {
    typeof e == 'function' ? (e = vk(e)) : (e = Fp(e))
    for (var t = this._groups, n = t.length, o = [], r = [], s = 0; s < n; ++s) for (var i = t[s], a = i.length, l, c = 0; c < a; ++c) (l = i[c]) && (o.push(e.call(l, l.__data__, c, i)), r.push(l))
    return new jt(o, r)
  }
  function Dp(e) {
    return function () {
      return this.matches(e)
    }
  }
  function zp(e) {
    return function (t) {
      return t.matches(e)
    }
  }
  var Ck = Array.prototype.find
  function wk(e) {
    return function () {
      return Ck.call(this.children, e)
    }
  }
  function Ek() {
    return this.firstElementChild
  }
  function Sk(e) {
    return this.select(e == null ? Ek : wk(typeof e == 'function' ? e : zp(e)))
  }
  var Bk = Array.prototype.filter
  function Ik() {
    return Array.from(this.children)
  }
  function kk(e) {
    return function () {
      return Bk.call(this.children, e)
    }
  }
  function Nk(e) {
    return this.selectAll(e == null ? Ik : kk(typeof e == 'function' ? e : zp(e)))
  }
  function Mk(e) {
    typeof e != 'function' && (e = Dp(e))
    for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r) for (var s = t[r], i = s.length, a = (o[r] = []), l, c = 0; c < i; ++c) (l = s[c]) && e.call(l, l.__data__, c, s) && a.push(l)
    return new jt(o, this._parents)
  }
  function Qp(e) {
    return new Array(e.length)
  }
  function Pk() {
    return new jt(this._enter || this._groups.map(Qp), this._parents)
  }
  function Ea(e, t) {
    ;(this.ownerDocument = e.ownerDocument), (this.namespaceURI = e.namespaceURI), (this._next = null), (this._parent = e), (this.__data__ = t)
  }
  Ea.prototype = {
    constructor: Ea,
    appendChild: function (e) {
      return this._parent.insertBefore(e, this._next)
    },
    insertBefore: function (e, t) {
      return this._parent.insertBefore(e, t)
    },
    querySelector: function (e) {
      return this._parent.querySelector(e)
    },
    querySelectorAll: function (e) {
      return this._parent.querySelectorAll(e)
    },
  }
  function Lk(e) {
    return function () {
      return e
    }
  }
  function Tk(e, t, n, o, r, s) {
    for (var i = 0, a, l = t.length, c = s.length; i < c; ++i) (a = t[i]) ? ((a.__data__ = s[i]), (o[i] = a)) : (n[i] = new Ea(e, s[i]))
    for (; i < l; ++i) (a = t[i]) && (r[i] = a)
  }
  function Fk(e, t, n, o, r, s, i) {
    var a,
      l,
      c = new Map(),
      u = t.length,
      d = s.length,
      f = new Array(u),
      A
    for (a = 0; a < u; ++a) (l = t[a]) && ((f[a] = A = i.call(l, l.__data__, a, t) + ''), c.has(A) ? (r[a] = l) : c.set(A, l))
    for (a = 0; a < d; ++a) (A = i.call(e, s[a], a, s) + ''), (l = c.get(A)) ? ((o[a] = l), (l.__data__ = s[a]), c.delete(A)) : (n[a] = new Ea(e, s[a]))
    for (a = 0; a < u; ++a) (l = t[a]) && c.get(f[a]) === l && (r[a] = l)
  }
  function Dk(e) {
    return e.__data__
  }
  function zk(e, t) {
    if (!arguments.length) return Array.from(this, Dk)
    var n = t ? Fk : Tk,
      o = this._parents,
      r = this._groups
    typeof e != 'function' && (e = Lk(e))
    for (var s = r.length, i = new Array(s), a = new Array(s), l = new Array(s), c = 0; c < s; ++c) {
      var u = o[c],
        d = r[c],
        f = d.length,
        A = Qk(e.call(u, u && u.__data__, c, o)),
        h = A.length,
        g = (a[c] = new Array(h)),
        x = (i[c] = new Array(h)),
        m = (l[c] = new Array(f))
      n(u, d, g, x, m, A, t)
      for (var v = 0, y = 0, b, w; v < h; ++v)
        if ((b = g[v])) {
          for (v >= y && (y = v + 1); !(w = x[y]) && ++y < h; );
          b._next = w || null
        }
    }
    return (i = new jt(i, o)), (i._enter = a), (i._exit = l), i
  }
  function Qk(e) {
    return typeof e == 'object' && 'length' in e ? e : Array.from(e)
  }
  function Rk() {
    return new jt(this._exit || this._groups.map(Qp), this._parents)
  }
  function Ok(e, t, n) {
    var o = this.enter(),
      r = this,
      s = this.exit()
    return typeof e == 'function' ? ((o = e(o)), o && (o = o.selection())) : (o = o.append(e + '')), t != null && ((r = t(r)), r && (r = r.selection())), n == null ? s.remove() : n(s), o && r ? o.merge(r).order() : r
  }
  function jk(e) {
    for (var t = e.selection ? e.selection() : e, n = this._groups, o = t._groups, r = n.length, s = o.length, i = Math.min(r, s), a = new Array(r), l = 0; l < i; ++l) for (var c = n[l], u = o[l], d = c.length, f = (a[l] = new Array(d)), A, h = 0; h < d; ++h) (A = c[h] || u[h]) && (f[h] = A)
    for (; l < r; ++l) a[l] = n[l]
    return new jt(a, this._parents)
  }
  function Wk() {
    for (var e = this._groups, t = -1, n = e.length; ++t < n; ) for (var o = e[t], r = o.length - 1, s = o[r], i; --r >= 0; ) (i = o[r]) && (s && i.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(i, s), (s = i))
    return this
  }
  function Gk(e) {
    e || (e = Vk)
    function t(d, f) {
      return d && f ? e(d.__data__, f.__data__) : !d - !f
    }
    for (var n = this._groups, o = n.length, r = new Array(o), s = 0; s < o; ++s) {
      for (var i = n[s], a = i.length, l = (r[s] = new Array(a)), c, u = 0; u < a; ++u) (c = i[u]) && (l[u] = c)
      l.sort(t)
    }
    return new jt(r, this._parents).order()
  }
  function Vk(e, t) {
    return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
  }
  function Xk() {
    var e = arguments[0]
    return (arguments[0] = this), e.apply(null, arguments), this
  }
  function Yk() {
    return Array.from(this)
  }
  function Hk() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
      for (var o = e[t], r = 0, s = o.length; r < s; ++r) {
        var i = o[r]
        if (i) return i
      }
    return null
  }
  function Uk() {
    let e = 0
    for (const t of this) ++e
    return e
  }
  function Kk() {
    return !this.node()
  }
  function qk(e) {
    for (var t = this._groups, n = 0, o = t.length; n < o; ++n) for (var r = t[n], s = 0, i = r.length, a; s < i; ++s) (a = r[s]) && e.call(a, a.__data__, s, r)
    return this
  }
  function Zk(e) {
    return function () {
      this.removeAttribute(e)
    }
  }
  function Jk(e) {
    return function () {
      this.removeAttributeNS(e.space, e.local)
    }
  }
  function _k(e, t) {
    return function () {
      this.setAttribute(e, t)
    }
  }
  function $k(e, t) {
    return function () {
      this.setAttributeNS(e.space, e.local, t)
    }
  }
  function eN(e, t) {
    return function () {
      var n = t.apply(this, arguments)
      n == null ? this.removeAttribute(e) : this.setAttribute(e, n)
    }
  }
  function tN(e, t) {
    return function () {
      var n = t.apply(this, arguments)
      n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n)
    }
  }
  function nN(e, t) {
    var n = wa(e)
    if (arguments.length < 2) {
      var o = this.node()
      return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n)
    }
    return this.each((t == null ? (n.local ? Jk : Zk) : typeof t == 'function' ? (n.local ? tN : eN) : n.local ? $k : _k)(n, t))
  }
  function Rp(e) {
    return (e.ownerDocument && e.ownerDocument.defaultView) || (e.document && e) || e.defaultView
  }
  function oN(e) {
    return function () {
      this.style.removeProperty(e)
    }
  }
  function rN(e, t, n) {
    return function () {
      this.style.setProperty(e, t, n)
    }
  }
  function sN(e, t, n) {
    return function () {
      var o = t.apply(this, arguments)
      o == null ? this.style.removeProperty(e) : this.style.setProperty(e, o, n)
    }
  }
  function iN(e, t, n) {
    return arguments.length > 1 ? this.each((t == null ? oN : typeof t == 'function' ? sN : rN)(e, t, n ?? '')) : pr(this.node(), e)
  }
  function pr(e, t) {
    return e.style.getPropertyValue(t) || Rp(e).getComputedStyle(e, null).getPropertyValue(t)
  }
  function aN(e) {
    return function () {
      delete this[e]
    }
  }
  function lN(e, t) {
    return function () {
      this[e] = t
    }
  }
  function cN(e, t) {
    return function () {
      var n = t.apply(this, arguments)
      n == null ? delete this[e] : (this[e] = n)
    }
  }
  function uN(e, t) {
    return arguments.length > 1 ? this.each((t == null ? aN : typeof t == 'function' ? cN : lN)(e, t)) : this.node()[e]
  }
  function Op(e) {
    return e.trim().split(/^|\s+/)
  }
  function lu(e) {
    return e.classList || new jp(e)
  }
  function jp(e) {
    ;(this._node = e), (this._names = Op(e.getAttribute('class') || ''))
  }
  jp.prototype = {
    add: function (e) {
      var t = this._names.indexOf(e)
      t < 0 && (this._names.push(e), this._node.setAttribute('class', this._names.join(' ')))
    },
    remove: function (e) {
      var t = this._names.indexOf(e)
      t >= 0 && (this._names.splice(t, 1), this._node.setAttribute('class', this._names.join(' ')))
    },
    contains: function (e) {
      return this._names.indexOf(e) >= 0
    },
  }
  function Wp(e, t) {
    for (var n = lu(e), o = -1, r = t.length; ++o < r; ) n.add(t[o])
  }
  function Gp(e, t) {
    for (var n = lu(e), o = -1, r = t.length; ++o < r; ) n.remove(t[o])
  }
  function dN(e) {
    return function () {
      Wp(this, e)
    }
  }
  function fN(e) {
    return function () {
      Gp(this, e)
    }
  }
  function AN(e, t) {
    return function () {
      ;(t.apply(this, arguments) ? Wp : Gp)(this, e)
    }
  }
  function pN(e, t) {
    var n = Op(e + '')
    if (arguments.length < 2) {
      for (var o = lu(this.node()), r = -1, s = n.length; ++r < s; ) if (!o.contains(n[r])) return !1
      return !0
    }
    return this.each((typeof t == 'function' ? AN : t ? dN : fN)(n, t))
  }
  function hN() {
    this.textContent = ''
  }
  function gN(e) {
    return function () {
      this.textContent = e
    }
  }
  function mN(e) {
    return function () {
      var t = e.apply(this, arguments)
      this.textContent = t ?? ''
    }
  }
  function yN(e) {
    return arguments.length ? this.each(e == null ? hN : (typeof e == 'function' ? mN : gN)(e)) : this.node().textContent
  }
  function bN() {
    this.innerHTML = ''
  }
  function vN(e) {
    return function () {
      this.innerHTML = e
    }
  }
  function xN(e) {
    return function () {
      var t = e.apply(this, arguments)
      this.innerHTML = t ?? ''
    }
  }
  function CN(e) {
    return arguments.length ? this.each(e == null ? bN : (typeof e == 'function' ? xN : vN)(e)) : this.node().innerHTML
  }
  function wN() {
    this.nextSibling && this.parentNode.appendChild(this)
  }
  function EN() {
    return this.each(wN)
  }
  function SN() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
  }
  function BN() {
    return this.each(SN)
  }
  function IN(e) {
    var t = typeof e == 'function' ? e : Tp(e)
    return this.select(function () {
      return this.appendChild(t.apply(this, arguments))
    })
  }
  function kN() {
    return null
  }
  function NN(e, t) {
    var n = typeof e == 'function' ? e : Tp(e),
      o = t == null ? kN : typeof t == 'function' ? t : au(t)
    return this.select(function () {
      return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null)
    })
  }
  function MN() {
    var e = this.parentNode
    e && e.removeChild(this)
  }
  function PN() {
    return this.each(MN)
  }
  function LN() {
    var e = this.cloneNode(!1),
      t = this.parentNode
    return t ? t.insertBefore(e, this.nextSibling) : e
  }
  function TN() {
    var e = this.cloneNode(!0),
      t = this.parentNode
    return t ? t.insertBefore(e, this.nextSibling) : e
  }
  function FN(e) {
    return this.select(e ? TN : LN)
  }
  function DN(e) {
    return arguments.length ? this.property('__data__', e) : this.node().__data__
  }
  function zN(e) {
    return function (t) {
      e.call(this, t, this.__data__)
    }
  }
  function QN(e) {
    return e
      .trim()
      .split(/^|\s+/)
      .map(function (t) {
        var n = '',
          o = t.indexOf('.')
        return o >= 0 && ((n = t.slice(o + 1)), (t = t.slice(0, o))), { type: t, name: n }
      })
  }
  function RN(e) {
    return function () {
      var t = this.__on
      if (t) {
        for (var n = 0, o = -1, r = t.length, s; n < r; ++n) (s = t[n]), (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : (t[++o] = s)
        ++o ? (t.length = o) : delete this.__on
      }
    }
  }
  function ON(e, t, n) {
    return function () {
      var o = this.__on,
        r,
        s = zN(t)
      if (o) {
        for (var i = 0, a = o.length; i < a; ++i)
          if ((r = o[i]).type === e.type && r.name === e.name) {
            this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, (r.listener = s), (r.options = n)), (r.value = t)
            return
          }
      }
      this.addEventListener(e.type, s, n), (r = { type: e.type, name: e.name, value: t, listener: s, options: n }), o ? o.push(r) : (this.__on = [r])
    }
  }
  function jN(e, t, n) {
    var o = QN(e + ''),
      r,
      s = o.length,
      i
    if (arguments.length < 2) {
      var a = this.node().__on
      if (a) {
        for (var l = 0, c = a.length, u; l < c; ++l) for (r = 0, u = a[l]; r < s; ++r) if ((i = o[r]).type === u.type && i.name === u.name) return u.value
      }
      return
    }
    for (a = t ? ON : RN, r = 0; r < s; ++r) this.each(a(o[r], t, n))
    return this
  }
  function Vp(e, t, n) {
    var o = Rp(e),
      r = o.CustomEvent
    typeof r == 'function' ? (r = new r(t, n)) : ((r = o.document.createEvent('Event')), n ? (r.initEvent(t, n.bubbles, n.cancelable), (r.detail = n.detail)) : r.initEvent(t, !1, !1)), e.dispatchEvent(r)
  }
  function WN(e, t) {
    return function () {
      return Vp(this, e, t)
    }
  }
  function GN(e, t) {
    return function () {
      return Vp(this, e, t.apply(this, arguments))
    }
  }
  function VN(e, t) {
    return this.each((typeof t == 'function' ? GN : WN)(e, t))
  }
  function* XN() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t) for (var o = e[t], r = 0, s = o.length, i; r < s; ++r) (i = o[r]) && (yield i)
  }
  var Xp = [null]
  function jt(e, t) {
    ;(this._groups = e), (this._parents = t)
  }
  function cs() {
    return new jt([[document.documentElement]], Xp)
  }
  function YN() {
    return this
  }
  jt.prototype = cs.prototype = {
    constructor: jt,
    select: mk,
    selectAll: xk,
    selectChild: Sk,
    selectChildren: Nk,
    filter: Mk,
    data: zk,
    enter: Pk,
    exit: Rk,
    join: Ok,
    merge: jk,
    selection: YN,
    order: Wk,
    sort: Gk,
    call: Xk,
    nodes: Yk,
    node: Hk,
    size: Uk,
    empty: Kk,
    each: qk,
    attr: nN,
    style: iN,
    property: uN,
    classed: pN,
    text: yN,
    html: CN,
    raise: EN,
    lower: BN,
    append: IN,
    insert: NN,
    remove: PN,
    clone: FN,
    datum: DN,
    on: jN,
    dispatch: VN,
    [Symbol.iterator]: XN,
  }
  function Tt(e) {
    return typeof e == 'string' ? new jt([[document.querySelector(e)]], [document.documentElement]) : new jt([[e]], Xp)
  }
  function HN(e) {
    let t
    for (; (t = e.sourceEvent); ) e = t
    return e
  }
  function sn(e, t) {
    if (((e = HN(e)), t === void 0 && (t = e.currentTarget), t)) {
      var n = t.ownerSVGElement || t
      if (n.createSVGPoint) {
        var o = n.createSVGPoint()
        return (o.x = e.clientX), (o.y = e.clientY), (o = o.matrixTransform(t.getScreenCTM().inverse())), [o.x, o.y]
      }
      if (t.getBoundingClientRect) {
        var r = t.getBoundingClientRect()
        return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop]
      }
    }
    return [e.pageX, e.pageY]
  }
  const UN = { passive: !1 },
    us = { capture: !0, passive: !1 }
  function cu(e) {
    e.stopImmediatePropagation()
  }
  function hr(e) {
    e.preventDefault(), e.stopImmediatePropagation()
  }
  function Yp(e) {
    var t = e.document.documentElement,
      n = Tt(e).on('dragstart.drag', hr, us)
    'onselectstart' in t ? n.on('selectstart.drag', hr, us) : ((t.__noselect = t.style.MozUserSelect), (t.style.MozUserSelect = 'none'))
  }
  function Hp(e, t) {
    var n = e.document.documentElement,
      o = Tt(e).on('dragstart.drag', null)
    t &&
      (o.on('click.drag', hr, us),
      setTimeout(function () {
        o.on('click.drag', null)
      }, 0)),
      'onselectstart' in n ? o.on('selectstart.drag', null) : ((n.style.MozUserSelect = n.__noselect), delete n.__noselect)
  }
  const Sa = e => () => e
  function uu(e, { sourceEvent: t, subject: n, target: o, identifier: r, active: s, x: i, y: a, dx: l, dy: c, dispatch: u }) {
    Object.defineProperties(this, {
      type: { value: e, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      subject: { value: n, enumerable: !0, configurable: !0 },
      target: { value: o, enumerable: !0, configurable: !0 },
      identifier: { value: r, enumerable: !0, configurable: !0 },
      active: { value: s, enumerable: !0, configurable: !0 },
      x: { value: i, enumerable: !0, configurable: !0 },
      y: { value: a, enumerable: !0, configurable: !0 },
      dx: { value: l, enumerable: !0, configurable: !0 },
      dy: { value: c, enumerable: !0, configurable: !0 },
      _: { value: u },
    })
  }
  uu.prototype.on = function () {
    var e = this._.on.apply(this._, arguments)
    return e === this._ ? this : e
  }
  function KN(e) {
    return !e.ctrlKey && !e.button
  }
  function qN() {
    return this.parentNode
  }
  function ZN(e, t) {
    return t ?? { x: e.x, y: e.y }
  }
  function JN() {
    return navigator.maxTouchPoints || 'ontouchstart' in this
  }
  function du() {
    var e = KN,
      t = qN,
      n = ZN,
      o = JN,
      r = {},
      s = xa('start', 'drag', 'end'),
      i = 0,
      a,
      l,
      c,
      u,
      d = 0
    function f(b) {
      b.on('mousedown.drag', A).filter(o).on('touchstart.drag', x).on('touchmove.drag', m, UN).on('touchend.drag touchcancel.drag', v).style('touch-action', 'none').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')
    }
    function A(b, w) {
      if (!(u || !e.call(this, b, w))) {
        var k = y(this, t.call(this, b, w), b, w, 'mouse')
        k && (Tt(b.view).on('mousemove.drag', h, us).on('mouseup.drag', g, us), Yp(b.view), cu(b), (c = !1), (a = b.clientX), (l = b.clientY), k('start', b))
      }
    }
    function h(b) {
      if ((hr(b), !c)) {
        var w = b.clientX - a,
          k = b.clientY - l
        c = w * w + k * k > d
      }
      r.mouse('drag', b)
    }
    function g(b) {
      Tt(b.view).on('mousemove.drag mouseup.drag', null), Hp(b.view, c), hr(b), r.mouse('end', b)
    }
    function x(b, w) {
      if (e.call(this, b, w)) {
        var k = b.changedTouches,
          E = t.call(this, b, w),
          P = k.length,
          T,
          F
        for (T = 0; T < P; ++T) (F = y(this, E, b, w, k[T].identifier, k[T])) && (cu(b), F('start', b, k[T]))
      }
    }
    function m(b) {
      var w = b.changedTouches,
        k = w.length,
        E,
        P
      for (E = 0; E < k; ++E) (P = r[w[E].identifier]) && (hr(b), P('drag', b, w[E]))
    }
    function v(b) {
      var w = b.changedTouches,
        k = w.length,
        E,
        P
      for (
        u && clearTimeout(u),
          u = setTimeout(function () {
            u = null
          }, 500),
          E = 0;
        E < k;
        ++E
      )
        (P = r[w[E].identifier]) && (cu(b), P('end', b, w[E]))
    }
    function y(b, w, k, E, P, T) {
      var F = s.copy(),
        D = sn(T || k, w),
        Q,
        R,
        S
      if ((S = n.call(b, new uu('beforestart', { sourceEvent: k, target: f, identifier: P, active: i, x: D[0], y: D[1], dx: 0, dy: 0, dispatch: F }), E)) != null)
        return (
          (Q = S.x - D[0] || 0),
          (R = S.y - D[1] || 0),
          function L(I, z, B) {
            var O = D,
              W
            switch (I) {
              case 'start':
                ;(r[P] = L), (W = i++)
                break
              case 'end':
                delete r[P], --i
              case 'drag':
                ;(D = sn(B || z, w)), (W = i)
                break
            }
            F.call(I, b, new uu(I, { sourceEvent: z, subject: S, target: f, identifier: P, active: W, x: D[0] + Q, y: D[1] + R, dx: D[0] - O[0], dy: D[1] - O[1], dispatch: F }), E)
          }
        )
    }
    return (
      (f.filter = function (b) {
        return arguments.length ? ((e = typeof b == 'function' ? b : Sa(!!b)), f) : e
      }),
      (f.container = function (b) {
        return arguments.length ? ((t = typeof b == 'function' ? b : Sa(b)), f) : t
      }),
      (f.subject = function (b) {
        return arguments.length ? ((n = typeof b == 'function' ? b : Sa(b)), f) : n
      }),
      (f.touchable = function (b) {
        return arguments.length ? ((o = typeof b == 'function' ? b : Sa(!!b)), f) : o
      }),
      (f.on = function () {
        var b = s.on.apply(s, arguments)
        return b === s ? f : b
      }),
      (f.clickDistance = function (b) {
        return arguments.length ? ((d = (b = +b) * b), f) : Math.sqrt(d)
      }),
      f
    )
  }
  function fu(e, t, n) {
    ;(e.prototype = t.prototype = n), (n.constructor = e)
  }
  function Up(e, t) {
    var n = Object.create(e.prototype)
    for (var o in t) n[o] = t[o]
    return n
  }
  function ds() {}
  var fs = 0.7,
    Ba = 1 / fs,
    gr = '\\s*([+-]?\\d+)\\s*',
    As = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*',
    wn = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
    _N = /^#([0-9a-f]{3,8})$/,
    $N = new RegExp(`^rgb\\(${gr},${gr},${gr}\\)$`),
    eM = new RegExp(`^rgb\\(${wn},${wn},${wn}\\)$`),
    tM = new RegExp(`^rgba\\(${gr},${gr},${gr},${As}\\)$`),
    nM = new RegExp(`^rgba\\(${wn},${wn},${wn},${As}\\)$`),
    oM = new RegExp(`^hsl\\(${As},${wn},${wn}\\)$`),
    rM = new RegExp(`^hsla\\(${As},${wn},${wn},${As}\\)$`),
    Kp = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    }
  fu(ds, ps, {
    copy(e) {
      return Object.assign(new this.constructor(), this, e)
    },
    displayable() {
      return this.rgb().displayable()
    },
    hex: qp,
    formatHex: qp,
    formatHex8: sM,
    formatHsl: iM,
    formatRgb: Zp,
    toString: Zp,
  })
  function qp() {
    return this.rgb().formatHex()
  }
  function sM() {
    return this.rgb().formatHex8()
  }
  function iM() {
    return th(this).formatHsl()
  }
  function Zp() {
    return this.rgb().formatRgb()
  }
  function ps(e) {
    var t, n
    return (
      (e = (e + '').trim().toLowerCase()),
      (t = _N.exec(e))
        ? ((n = t[1].length),
          (t = parseInt(t[1], 16)),
          n === 6
            ? Jp(t)
            : n === 3
            ? new Ft(((t >> 8) & 15) | ((t >> 4) & 240), ((t >> 4) & 15) | (t & 240), ((t & 15) << 4) | (t & 15), 1)
            : n === 8
            ? Ia((t >> 24) & 255, (t >> 16) & 255, (t >> 8) & 255, (t & 255) / 255)
            : n === 4
            ? Ia(((t >> 12) & 15) | ((t >> 8) & 240), ((t >> 8) & 15) | ((t >> 4) & 240), ((t >> 4) & 15) | (t & 240), (((t & 15) << 4) | (t & 15)) / 255)
            : null)
        : (t = $N.exec(e))
        ? new Ft(t[1], t[2], t[3], 1)
        : (t = eM.exec(e))
        ? new Ft((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, 1)
        : (t = tM.exec(e))
        ? Ia(t[1], t[2], t[3], t[4])
        : (t = nM.exec(e))
        ? Ia((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, t[4])
        : (t = oM.exec(e))
        ? eh(t[1], t[2] / 100, t[3] / 100, 1)
        : (t = rM.exec(e))
        ? eh(t[1], t[2] / 100, t[3] / 100, t[4])
        : Kp.hasOwnProperty(e)
        ? Jp(Kp[e])
        : e === 'transparent'
        ? new Ft(NaN, NaN, NaN, 0)
        : null
    )
  }
  function Jp(e) {
    return new Ft((e >> 16) & 255, (e >> 8) & 255, e & 255, 1)
  }
  function Ia(e, t, n, o) {
    return o <= 0 && (e = t = n = NaN), new Ft(e, t, n, o)
  }
  function aM(e) {
    return e instanceof ds || (e = ps(e)), e ? ((e = e.rgb()), new Ft(e.r, e.g, e.b, e.opacity)) : new Ft()
  }
  function Au(e, t, n, o) {
    return arguments.length === 1 ? aM(e) : new Ft(e, t, n, o ?? 1)
  }
  function Ft(e, t, n, o) {
    ;(this.r = +e), (this.g = +t), (this.b = +n), (this.opacity = +o)
  }
  fu(
    Ft,
    Au,
    Up(ds, {
      brighter(e) {
        return (e = e == null ? Ba : Math.pow(Ba, e)), new Ft(this.r * e, this.g * e, this.b * e, this.opacity)
      },
      darker(e) {
        return (e = e == null ? fs : Math.pow(fs, e)), new Ft(this.r * e, this.g * e, this.b * e, this.opacity)
      },
      rgb() {
        return this
      },
      clamp() {
        return new Ft(wo(this.r), wo(this.g), wo(this.b), ka(this.opacity))
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
      },
      hex: _p,
      formatHex: _p,
      formatHex8: lM,
      formatRgb: $p,
      toString: $p,
    })
  )
  function _p() {
    return `#${Eo(this.r)}${Eo(this.g)}${Eo(this.b)}`
  }
  function lM() {
    return `#${Eo(this.r)}${Eo(this.g)}${Eo(this.b)}${Eo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
  }
  function $p() {
    const e = ka(this.opacity)
    return `${e === 1 ? 'rgb(' : 'rgba('}${wo(this.r)}, ${wo(this.g)}, ${wo(this.b)}${e === 1 ? ')' : `, ${e})`}`
  }
  function ka(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
  }
  function wo(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0))
  }
  function Eo(e) {
    return (e = wo(e)), (e < 16 ? '0' : '') + e.toString(16)
  }
  function eh(e, t, n, o) {
    return o <= 0 ? (e = t = n = NaN) : n <= 0 || n >= 1 ? (e = t = NaN) : t <= 0 && (e = NaN), new an(e, t, n, o)
  }
  function th(e) {
    if (e instanceof an) return new an(e.h, e.s, e.l, e.opacity)
    if ((e instanceof ds || (e = ps(e)), !e)) return new an()
    if (e instanceof an) return e
    e = e.rgb()
    var t = e.r / 255,
      n = e.g / 255,
      o = e.b / 255,
      r = Math.min(t, n, o),
      s = Math.max(t, n, o),
      i = NaN,
      a = s - r,
      l = (s + r) / 2
    return a ? (t === s ? (i = (n - o) / a + (n < o) * 6) : n === s ? (i = (o - t) / a + 2) : (i = (t - n) / a + 4), (a /= l < 0.5 ? s + r : 2 - s - r), (i *= 60)) : (a = l > 0 && l < 1 ? 0 : i), new an(i, a, l, e.opacity)
  }
  function cM(e, t, n, o) {
    return arguments.length === 1 ? th(e) : new an(e, t, n, o ?? 1)
  }
  function an(e, t, n, o) {
    ;(this.h = +e), (this.s = +t), (this.l = +n), (this.opacity = +o)
  }
  fu(
    an,
    cM,
    Up(ds, {
      brighter(e) {
        return (e = e == null ? Ba : Math.pow(Ba, e)), new an(this.h, this.s, this.l * e, this.opacity)
      },
      darker(e) {
        return (e = e == null ? fs : Math.pow(fs, e)), new an(this.h, this.s, this.l * e, this.opacity)
      },
      rgb() {
        var e = (this.h % 360) + (this.h < 0) * 360,
          t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
          n = this.l,
          o = n + (n < 0.5 ? n : 1 - n) * t,
          r = 2 * n - o
        return new Ft(pu(e >= 240 ? e - 240 : e + 120, r, o), pu(e, r, o), pu(e < 120 ? e + 240 : e - 120, r, o), this.opacity)
      },
      clamp() {
        return new an(nh(this.h), Na(this.s), Na(this.l), ka(this.opacity))
      },
      displayable() {
        return ((0 <= this.s && this.s <= 1) || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
      },
      formatHsl() {
        const e = ka(this.opacity)
        return `${e === 1 ? 'hsl(' : 'hsla('}${nh(this.h)}, ${Na(this.s) * 100}%, ${Na(this.l) * 100}%${e === 1 ? ')' : `, ${e})`}`
      },
    })
  )
  function nh(e) {
    return (e = (e || 0) % 360), e < 0 ? e + 360 : e
  }
  function Na(e) {
    return Math.max(0, Math.min(1, e || 0))
  }
  function pu(e, t, n) {
    return (e < 60 ? t + ((n - t) * e) / 60 : e < 180 ? n : e < 240 ? t + ((n - t) * (240 - e)) / 60 : t) * 255
  }
  const oh = e => () => e
  function uM(e, t) {
    return function (n) {
      return e + n * t
    }
  }
  function dM(e, t, n) {
    return (
      (e = Math.pow(e, n)),
      (t = Math.pow(t, n) - e),
      (n = 1 / n),
      function (o) {
        return Math.pow(e + o * t, n)
      }
    )
  }
  function fM(e) {
    return (e = +e) == 1
      ? rh
      : function (t, n) {
          return n - t ? dM(t, n, e) : oh(isNaN(t) ? n : t)
        }
  }
  function rh(e, t) {
    var n = t - e
    return n ? uM(e, n) : oh(isNaN(e) ? t : e)
  }
  const sh = (function e(t) {
    var n = fM(t)
    function o(r, s) {
      var i = n((r = Au(r)).r, (s = Au(s)).r),
        a = n(r.g, s.g),
        l = n(r.b, s.b),
        c = rh(r.opacity, s.opacity)
      return function (u) {
        return (r.r = i(u)), (r.g = a(u)), (r.b = l(u)), (r.opacity = c(u)), r + ''
      }
    }
    return (o.gamma = e), o
  })(1)
  function Zn(e, t) {
    return (
      (e = +e),
      (t = +t),
      function (n) {
        return e * (1 - n) + t * n
      }
    )
  }
  var hu = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    gu = new RegExp(hu.source, 'g')
  function AM(e) {
    return function () {
      return e
    }
  }
  function pM(e) {
    return function (t) {
      return e(t) + ''
    }
  }
  function hM(e, t) {
    var n = (hu.lastIndex = gu.lastIndex = 0),
      o,
      r,
      s,
      i = -1,
      a = [],
      l = []
    for (e = e + '', t = t + ''; (o = hu.exec(e)) && (r = gu.exec(t)); ) (s = r.index) > n && ((s = t.slice(n, s)), a[i] ? (a[i] += s) : (a[++i] = s)), (o = o[0]) === (r = r[0]) ? (a[i] ? (a[i] += r) : (a[++i] = r)) : ((a[++i] = null), l.push({ i, x: Zn(o, r) })), (n = gu.lastIndex)
    return (
      n < t.length && ((s = t.slice(n)), a[i] ? (a[i] += s) : (a[++i] = s)),
      a.length < 2
        ? l[0]
          ? pM(l[0].x)
          : AM(t)
        : ((t = l.length),
          function (c) {
            for (var u = 0, d; u < t; ++u) a[(d = l[u]).i] = d.x(c)
            return a.join('')
          })
    )
  }
  var ih = 180 / Math.PI,
    mu = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }
  function ah(e, t, n, o, r, s) {
    var i, a, l
    return (
      (i = Math.sqrt(e * e + t * t)) && ((e /= i), (t /= i)),
      (l = e * n + t * o) && ((n -= e * l), (o -= t * l)),
      (a = Math.sqrt(n * n + o * o)) && ((n /= a), (o /= a), (l /= a)),
      e * o < t * n && ((e = -e), (t = -t), (l = -l), (i = -i)),
      { translateX: r, translateY: s, rotate: Math.atan2(t, e) * ih, skewX: Math.atan(l) * ih, scaleX: i, scaleY: a }
    )
  }
  var Ma
  function gM(e) {
    const t = new (typeof DOMMatrix == 'function' ? DOMMatrix : WebKitCSSMatrix)(e + '')
    return t.isIdentity ? mu : ah(t.a, t.b, t.c, t.d, t.e, t.f)
  }
  function mM(e) {
    return e == null || (Ma || (Ma = document.createElementNS('http://www.w3.org/2000/svg', 'g')), Ma.setAttribute('transform', e), !(e = Ma.transform.baseVal.consolidate())) ? mu : ((e = e.matrix), ah(e.a, e.b, e.c, e.d, e.e, e.f))
  }
  function lh(e, t, n, o) {
    function r(c) {
      return c.length ? c.pop() + ' ' : ''
    }
    function s(c, u, d, f, A, h) {
      if (c !== d || u !== f) {
        var g = A.push('translate(', null, t, null, n)
        h.push({ i: g - 4, x: Zn(c, d) }, { i: g - 2, x: Zn(u, f) })
      } else (d || f) && A.push('translate(' + d + t + f + n)
    }
    function i(c, u, d, f) {
      c !== u ? (c - u > 180 ? (u += 360) : u - c > 180 && (c += 360), f.push({ i: d.push(r(d) + 'rotate(', null, o) - 2, x: Zn(c, u) })) : u && d.push(r(d) + 'rotate(' + u + o)
    }
    function a(c, u, d, f) {
      c !== u ? f.push({ i: d.push(r(d) + 'skewX(', null, o) - 2, x: Zn(c, u) }) : u && d.push(r(d) + 'skewX(' + u + o)
    }
    function l(c, u, d, f, A, h) {
      if (c !== d || u !== f) {
        var g = A.push(r(A) + 'scale(', null, ',', null, ')')
        h.push({ i: g - 4, x: Zn(c, d) }, { i: g - 2, x: Zn(u, f) })
      } else (d !== 1 || f !== 1) && A.push(r(A) + 'scale(' + d + ',' + f + ')')
    }
    return function (c, u) {
      var d = [],
        f = []
      return (
        (c = e(c)),
        (u = e(u)),
        s(c.translateX, c.translateY, u.translateX, u.translateY, d, f),
        i(c.rotate, u.rotate, d, f),
        a(c.skewX, u.skewX, d, f),
        l(c.scaleX, c.scaleY, u.scaleX, u.scaleY, d, f),
        (c = u = null),
        function (A) {
          for (var h = -1, g = f.length, x; ++h < g; ) d[(x = f[h]).i] = x.x(A)
          return d.join('')
        }
      )
    }
  }
  var yM = lh(gM, 'px, ', 'px)', 'deg)'),
    bM = lh(mM, ', ', ')', ')'),
    vM = 1e-12
  function ch(e) {
    return ((e = Math.exp(e)) + 1 / e) / 2
  }
  function xM(e) {
    return ((e = Math.exp(e)) - 1 / e) / 2
  }
  function CM(e) {
    return ((e = Math.exp(2 * e)) - 1) / (e + 1)
  }
  const wM = (function e(t, n, o) {
    function r(s, i) {
      var a = s[0],
        l = s[1],
        c = s[2],
        u = i[0],
        d = i[1],
        f = i[2],
        A = u - a,
        h = d - l,
        g = A * A + h * h,
        x,
        m
      if (g < vM)
        (m = Math.log(f / c) / t),
          (x = function (E) {
            return [a + E * A, l + E * h, c * Math.exp(t * E * m)]
          })
      else {
        var v = Math.sqrt(g),
          y = (f * f - c * c + o * g) / (2 * c * n * v),
          b = (f * f - c * c - o * g) / (2 * f * n * v),
          w = Math.log(Math.sqrt(y * y + 1) - y),
          k = Math.log(Math.sqrt(b * b + 1) - b)
        ;(m = (k - w) / t),
          (x = function (E) {
            var P = E * m,
              T = ch(w),
              F = (c / (n * v)) * (T * CM(t * P + w) - xM(w))
            return [a + F * A, l + F * h, (c * T) / ch(t * P + w)]
          })
      }
      return (x.duration = (m * 1e3 * t) / Math.SQRT2), x
    }
    return (
      (r.rho = function (s) {
        var i = Math.max(0.001, +s),
          a = i * i,
          l = a * a
        return e(i, a, l)
      }),
      r
    )
  })(Math.SQRT2, 2, 4)
  var mr = 0,
    hs = 0,
    gs = 0,
    uh = 1e3,
    Pa,
    ms,
    La = 0,
    So = 0,
    Ta = 0,
    ys = typeof performance == 'object' && performance.now ? performance : Date,
    dh =
      typeof window == 'object' && window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : function (e) {
            setTimeout(e, 17)
          }
  function yu() {
    return So || (dh(EM), (So = ys.now() + Ta))
  }
  function EM() {
    So = 0
  }
  function Fa() {
    this._call = this._time = this._next = null
  }
  Fa.prototype = fh.prototype = {
    constructor: Fa,
    restart: function (e, t, n) {
      if (typeof e != 'function') throw new TypeError('callback is not a function')
      ;(n = (n == null ? yu() : +n) + (t == null ? 0 : +t)), !this._next && ms !== this && (ms ? (ms._next = this) : (Pa = this), (ms = this)), (this._call = e), (this._time = n), bu()
    },
    stop: function () {
      this._call && ((this._call = null), (this._time = 1 / 0), bu())
    },
  }
  function fh(e, t, n) {
    var o = new Fa()
    return o.restart(e, t, n), o
  }
  function SM() {
    yu(), ++mr
    for (var e = Pa, t; e; ) (t = So - e._time) >= 0 && e._call.call(void 0, t), (e = e._next)
    --mr
  }
  function Ah() {
    ;(So = (La = ys.now()) + Ta), (mr = hs = 0)
    try {
      SM()
    } finally {
      ;(mr = 0), IM(), (So = 0)
    }
  }
  function BM() {
    var e = ys.now(),
      t = e - La
    t > uh && ((Ta -= t), (La = e))
  }
  function IM() {
    for (var e, t = Pa, n, o = 1 / 0; t; ) t._call ? (o > t._time && (o = t._time), (e = t), (t = t._next)) : ((n = t._next), (t._next = null), (t = e ? (e._next = n) : (Pa = n)))
    ;(ms = e), bu(o)
  }
  function bu(e) {
    if (!mr) {
      hs && (hs = clearTimeout(hs))
      var t = e - So
      t > 24 ? (e < 1 / 0 && (hs = setTimeout(Ah, e - ys.now() - Ta)), gs && (gs = clearInterval(gs))) : (gs || ((La = ys.now()), (gs = setInterval(BM, uh))), (mr = 1), dh(Ah))
    }
  }
  function ph(e, t, n) {
    var o = new Fa()
    return (
      (t = t == null ? 0 : +t),
      o.restart(
        r => {
          o.stop(), e(r + t)
        },
        t,
        n
      ),
      o
    )
  }
  var kM = xa('start', 'end', 'cancel', 'interrupt'),
    NM = [],
    hh = 0,
    gh = 1,
    vu = 2,
    Da = 3,
    mh = 4,
    xu = 5,
    za = 6
  function Qa(e, t, n, o, r, s) {
    var i = e.__transition
    if (!i) e.__transition = {}
    else if (n in i) return
    MM(e, n, { name: t, index: o, group: r, on: kM, tween: NM, time: s.time, delay: s.delay, duration: s.duration, ease: s.ease, timer: null, state: hh })
  }
  function Cu(e, t) {
    var n = ln(e, t)
    if (n.state > hh) throw new Error('too late; already scheduled')
    return n
  }
  function En(e, t) {
    var n = ln(e, t)
    if (n.state > Da) throw new Error('too late; already running')
    return n
  }
  function ln(e, t) {
    var n = e.__transition
    if (!n || !(n = n[t])) throw new Error('transition not found')
    return n
  }
  function MM(e, t, n) {
    var o = e.__transition,
      r
    ;(o[t] = n), (n.timer = fh(s, 0, n.time))
    function s(c) {
      ;(n.state = gh), n.timer.restart(i, n.delay, n.time), n.delay <= c && i(c - n.delay)
    }
    function i(c) {
      var u, d, f, A
      if (n.state !== gh) return l()
      for (u in o)
        if (((A = o[u]), A.name === n.name)) {
          if (A.state === Da) return ph(i)
          A.state === mh ? ((A.state = za), A.timer.stop(), A.on.call('interrupt', e, e.__data__, A.index, A.group), delete o[u]) : +u < t && ((A.state = za), A.timer.stop(), A.on.call('cancel', e, e.__data__, A.index, A.group), delete o[u])
        }
      if (
        (ph(function () {
          n.state === Da && ((n.state = mh), n.timer.restart(a, n.delay, n.time), a(c))
        }),
        (n.state = vu),
        n.on.call('start', e, e.__data__, n.index, n.group),
        n.state === vu)
      ) {
        for (n.state = Da, r = new Array((f = n.tween.length)), u = 0, d = -1; u < f; ++u) (A = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (r[++d] = A)
        r.length = d + 1
      }
    }
    function a(c) {
      for (var u = c < n.duration ? n.ease.call(null, c / n.duration) : (n.timer.restart(l), (n.state = xu), 1), d = -1, f = r.length; ++d < f; ) r[d].call(e, u)
      n.state === xu && (n.on.call('end', e, e.__data__, n.index, n.group), l())
    }
    function l() {
      ;(n.state = za), n.timer.stop(), delete o[t]
      for (var c in o) return
      delete e.__transition
    }
  }
  function Ra(e, t) {
    var n = e.__transition,
      o,
      r,
      s = !0,
      i
    if (n) {
      t = t == null ? null : t + ''
      for (i in n) {
        if ((o = n[i]).name !== t) {
          s = !1
          continue
        }
        ;(r = o.state > vu && o.state < xu), (o.state = za), o.timer.stop(), o.on.call(r ? 'interrupt' : 'cancel', e, e.__data__, o.index, o.group), delete n[i]
      }
      s && delete e.__transition
    }
  }
  function PM(e) {
    return this.each(function () {
      Ra(this, e)
    })
  }
  function LM(e, t) {
    var n, o
    return function () {
      var r = En(this, e),
        s = r.tween
      if (s !== n) {
        o = n = s
        for (var i = 0, a = o.length; i < a; ++i)
          if (o[i].name === t) {
            ;(o = o.slice()), o.splice(i, 1)
            break
          }
      }
      r.tween = o
    }
  }
  function TM(e, t, n) {
    var o, r
    if (typeof n != 'function') throw new Error()
    return function () {
      var s = En(this, e),
        i = s.tween
      if (i !== o) {
        r = (o = i).slice()
        for (var a = { name: t, value: n }, l = 0, c = r.length; l < c; ++l)
          if (r[l].name === t) {
            r[l] = a
            break
          }
        l === c && r.push(a)
      }
      s.tween = r
    }
  }
  function FM(e, t) {
    var n = this._id
    if (((e += ''), arguments.length < 2)) {
      for (var o = ln(this.node(), n).tween, r = 0, s = o.length, i; r < s; ++r) if ((i = o[r]).name === e) return i.value
      return null
    }
    return this.each((t == null ? LM : TM)(n, e, t))
  }
  function wu(e, t, n) {
    var o = e._id
    return (
      e.each(function () {
        var r = En(this, o)
        ;(r.value || (r.value = {}))[t] = n.apply(this, arguments)
      }),
      function (r) {
        return ln(r, o).value[t]
      }
    )
  }
  function yh(e, t) {
    var n
    return (typeof t == 'number' ? Zn : t instanceof ps ? sh : (n = ps(t)) ? ((t = n), sh) : hM)(e, t)
  }
  function DM(e) {
    return function () {
      this.removeAttribute(e)
    }
  }
  function zM(e) {
    return function () {
      this.removeAttributeNS(e.space, e.local)
    }
  }
  function QM(e, t, n) {
    var o,
      r = n + '',
      s
    return function () {
      var i = this.getAttribute(e)
      return i === r ? null : i === o ? s : (s = t((o = i), n))
    }
  }
  function RM(e, t, n) {
    var o,
      r = n + '',
      s
    return function () {
      var i = this.getAttributeNS(e.space, e.local)
      return i === r ? null : i === o ? s : (s = t((o = i), n))
    }
  }
  function OM(e, t, n) {
    var o, r, s
    return function () {
      var i,
        a = n(this),
        l
      return a == null ? void this.removeAttribute(e) : ((i = this.getAttribute(e)), (l = a + ''), i === l ? null : i === o && l === r ? s : ((r = l), (s = t((o = i), a))))
    }
  }
  function jM(e, t, n) {
    var o, r, s
    return function () {
      var i,
        a = n(this),
        l
      return a == null ? void this.removeAttributeNS(e.space, e.local) : ((i = this.getAttributeNS(e.space, e.local)), (l = a + ''), i === l ? null : i === o && l === r ? s : ((r = l), (s = t((o = i), a))))
    }
  }
  function WM(e, t) {
    var n = wa(e),
      o = n === 'transform' ? bM : yh
    return this.attrTween(e, typeof t == 'function' ? (n.local ? jM : OM)(n, o, wu(this, 'attr.' + e, t)) : t == null ? (n.local ? zM : DM)(n) : (n.local ? RM : QM)(n, o, t))
  }
  function GM(e, t) {
    return function (n) {
      this.setAttribute(e, t.call(this, n))
    }
  }
  function VM(e, t) {
    return function (n) {
      this.setAttributeNS(e.space, e.local, t.call(this, n))
    }
  }
  function XM(e, t) {
    var n, o
    function r() {
      var s = t.apply(this, arguments)
      return s !== o && (n = (o = s) && VM(e, s)), n
    }
    return (r._value = t), r
  }
  function YM(e, t) {
    var n, o
    function r() {
      var s = t.apply(this, arguments)
      return s !== o && (n = (o = s) && GM(e, s)), n
    }
    return (r._value = t), r
  }
  function HM(e, t) {
    var n = 'attr.' + e
    if (arguments.length < 2) return (n = this.tween(n)) && n._value
    if (t == null) return this.tween(n, null)
    if (typeof t != 'function') throw new Error()
    var o = wa(e)
    return this.tween(n, (o.local ? XM : YM)(o, t))
  }
  function UM(e, t) {
    return function () {
      Cu(this, e).delay = +t.apply(this, arguments)
    }
  }
  function KM(e, t) {
    return (
      (t = +t),
      function () {
        Cu(this, e).delay = t
      }
    )
  }
  function qM(e) {
    var t = this._id
    return arguments.length ? this.each((typeof e == 'function' ? UM : KM)(t, e)) : ln(this.node(), t).delay
  }
  function ZM(e, t) {
    return function () {
      En(this, e).duration = +t.apply(this, arguments)
    }
  }
  function JM(e, t) {
    return (
      (t = +t),
      function () {
        En(this, e).duration = t
      }
    )
  }
  function _M(e) {
    var t = this._id
    return arguments.length ? this.each((typeof e == 'function' ? ZM : JM)(t, e)) : ln(this.node(), t).duration
  }
  function $M(e, t) {
    if (typeof t != 'function') throw new Error()
    return function () {
      En(this, e).ease = t
    }
  }
  function eP(e) {
    var t = this._id
    return arguments.length ? this.each($M(t, e)) : ln(this.node(), t).ease
  }
  function tP(e, t) {
    return function () {
      var n = t.apply(this, arguments)
      if (typeof n != 'function') throw new Error()
      En(this, e).ease = n
    }
  }
  function nP(e) {
    if (typeof e != 'function') throw new Error()
    return this.each(tP(this._id, e))
  }
  function oP(e) {
    typeof e != 'function' && (e = Dp(e))
    for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r) for (var s = t[r], i = s.length, a = (o[r] = []), l, c = 0; c < i; ++c) (l = s[c]) && e.call(l, l.__data__, c, s) && a.push(l)
    return new Tn(o, this._parents, this._name, this._id)
  }
  function rP(e) {
    if (e._id !== this._id) throw new Error()
    for (var t = this._groups, n = e._groups, o = t.length, r = n.length, s = Math.min(o, r), i = new Array(o), a = 0; a < s; ++a) for (var l = t[a], c = n[a], u = l.length, d = (i[a] = new Array(u)), f, A = 0; A < u; ++A) (f = l[A] || c[A]) && (d[A] = f)
    for (; a < o; ++a) i[a] = t[a]
    return new Tn(i, this._parents, this._name, this._id)
  }
  function sP(e) {
    return (e + '')
      .trim()
      .split(/^|\s+/)
      .every(function (t) {
        var n = t.indexOf('.')
        return n >= 0 && (t = t.slice(0, n)), !t || t === 'start'
      })
  }
  function iP(e, t, n) {
    var o,
      r,
      s = sP(t) ? Cu : En
    return function () {
      var i = s(this, e),
        a = i.on
      a !== o && (r = (o = a).copy()).on(t, n), (i.on = r)
    }
  }
  function aP(e, t) {
    var n = this._id
    return arguments.length < 2 ? ln(this.node(), n).on.on(e) : this.each(iP(n, e, t))
  }
  function lP(e) {
    return function () {
      var t = this.parentNode
      for (var n in this.__transition) if (+n !== e) return
      t && t.removeChild(this)
    }
  }
  function cP() {
    return this.on('end.remove', lP(this._id))
  }
  function uP(e) {
    var t = this._name,
      n = this._id
    typeof e != 'function' && (e = au(e))
    for (var o = this._groups, r = o.length, s = new Array(r), i = 0; i < r; ++i) for (var a = o[i], l = a.length, c = (s[i] = new Array(l)), u, d, f = 0; f < l; ++f) (u = a[f]) && (d = e.call(u, u.__data__, f, a)) && ('__data__' in u && (d.__data__ = u.__data__), (c[f] = d), Qa(c[f], t, n, f, c, ln(u, n)))
    return new Tn(s, this._parents, t, n)
  }
  function dP(e) {
    var t = this._name,
      n = this._id
    typeof e != 'function' && (e = Fp(e))
    for (var o = this._groups, r = o.length, s = [], i = [], a = 0; a < r; ++a)
      for (var l = o[a], c = l.length, u, d = 0; d < c; ++d)
        if ((u = l[d])) {
          for (var f = e.call(u, u.__data__, d, l), A, h = ln(u, n), g = 0, x = f.length; g < x; ++g) (A = f[g]) && Qa(A, t, n, g, f, h)
          s.push(f), i.push(u)
        }
    return new Tn(s, i, t, n)
  }
  var fP = cs.prototype.constructor
  function AP() {
    return new fP(this._groups, this._parents)
  }
  function pP(e, t) {
    var n, o, r
    return function () {
      var s = pr(this, e),
        i = (this.style.removeProperty(e), pr(this, e))
      return s === i ? null : s === n && i === o ? r : (r = t((n = s), (o = i)))
    }
  }
  function bh(e) {
    return function () {
      this.style.removeProperty(e)
    }
  }
  function hP(e, t, n) {
    var o,
      r = n + '',
      s
    return function () {
      var i = pr(this, e)
      return i === r ? null : i === o ? s : (s = t((o = i), n))
    }
  }
  function gP(e, t, n) {
    var o, r, s
    return function () {
      var i = pr(this, e),
        a = n(this),
        l = a + ''
      return a == null && (l = a = (this.style.removeProperty(e), pr(this, e))), i === l ? null : i === o && l === r ? s : ((r = l), (s = t((o = i), a)))
    }
  }
  function mP(e, t) {
    var n,
      o,
      r,
      s = 'style.' + t,
      i = 'end.' + s,
      a
    return function () {
      var l = En(this, e),
        c = l.on,
        u = l.value[s] == null ? a || (a = bh(t)) : void 0
      ;(c !== n || r !== u) && (o = (n = c).copy()).on(i, (r = u)), (l.on = o)
    }
  }
  function yP(e, t, n) {
    var o = (e += '') == 'transform' ? yM : yh
    return t == null ? this.styleTween(e, pP(e, o)).on('end.style.' + e, bh(e)) : typeof t == 'function' ? this.styleTween(e, gP(e, o, wu(this, 'style.' + e, t))).each(mP(this._id, e)) : this.styleTween(e, hP(e, o, t), n).on('end.style.' + e, null)
  }
  function bP(e, t, n) {
    return function (o) {
      this.style.setProperty(e, t.call(this, o), n)
    }
  }
  function vP(e, t, n) {
    var o, r
    function s() {
      var i = t.apply(this, arguments)
      return i !== r && (o = (r = i) && bP(e, i, n)), o
    }
    return (s._value = t), s
  }
  function xP(e, t, n) {
    var o = 'style.' + (e += '')
    if (arguments.length < 2) return (o = this.tween(o)) && o._value
    if (t == null) return this.tween(o, null)
    if (typeof t != 'function') throw new Error()
    return this.tween(o, vP(e, t, n ?? ''))
  }
  function CP(e) {
    return function () {
      this.textContent = e
    }
  }
  function wP(e) {
    return function () {
      var t = e(this)
      this.textContent = t ?? ''
    }
  }
  function EP(e) {
    return this.tween('text', typeof e == 'function' ? wP(wu(this, 'text', e)) : CP(e == null ? '' : e + ''))
  }
  function SP(e) {
    return function (t) {
      this.textContent = e.call(this, t)
    }
  }
  function BP(e) {
    var t, n
    function o() {
      var r = e.apply(this, arguments)
      return r !== n && (t = (n = r) && SP(r)), t
    }
    return (o._value = e), o
  }
  function IP(e) {
    var t = 'text'
    if (arguments.length < 1) return (t = this.tween(t)) && t._value
    if (e == null) return this.tween(t, null)
    if (typeof e != 'function') throw new Error()
    return this.tween(t, BP(e))
  }
  function kP() {
    for (var e = this._name, t = this._id, n = vh(), o = this._groups, r = o.length, s = 0; s < r; ++s)
      for (var i = o[s], a = i.length, l, c = 0; c < a; ++c)
        if ((l = i[c])) {
          var u = ln(l, t)
          Qa(l, e, n, c, i, { time: u.time + u.delay + u.duration, delay: 0, duration: u.duration, ease: u.ease })
        }
    return new Tn(o, this._parents, e, n)
  }
  function NP() {
    var e,
      t,
      n = this,
      o = n._id,
      r = n.size()
    return new Promise(function (s, i) {
      var a = { value: i },
        l = {
          value: function () {
            --r === 0 && s()
          },
        }
      n.each(function () {
        var c = En(this, o),
          u = c.on
        u !== e && ((t = (e = u).copy()), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(l)), (c.on = t)
      }),
        r === 0 && s()
    })
  }
  var MP = 0
  function Tn(e, t, n, o) {
    ;(this._groups = e), (this._parents = t), (this._name = n), (this._id = o)
  }
  function vh() {
    return ++MP
  }
  var Fn = cs.prototype
  Tn.prototype = {
    constructor: Tn,
    select: uP,
    selectAll: dP,
    selectChild: Fn.selectChild,
    selectChildren: Fn.selectChildren,
    filter: oP,
    merge: rP,
    selection: AP,
    transition: kP,
    call: Fn.call,
    nodes: Fn.nodes,
    node: Fn.node,
    size: Fn.size,
    empty: Fn.empty,
    each: Fn.each,
    on: aP,
    attr: WM,
    attrTween: HM,
    style: yP,
    styleTween: xP,
    text: EP,
    textTween: IP,
    remove: cP,
    tween: FM,
    delay: qM,
    duration: _M,
    ease: eP,
    easeVarying: nP,
    end: NP,
    [Symbol.iterator]: Fn[Symbol.iterator],
  }
  function PP(e) {
    return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2
  }
  var LP = { time: null, delay: 0, duration: 250, ease: PP }
  function TP(e, t) {
    for (var n; !(n = e.__transition) || !(n = n[t]); ) if (!(e = e.parentNode)) throw new Error(`transition ${t} not found`)
    return n
  }
  function FP(e) {
    var t, n
    e instanceof Tn ? ((t = e._id), (e = e._name)) : ((t = vh()), ((n = LP).time = yu()), (e = e == null ? null : e + ''))
    for (var o = this._groups, r = o.length, s = 0; s < r; ++s) for (var i = o[s], a = i.length, l, c = 0; c < a; ++c) (l = i[c]) && Qa(l, e, t, c, i, n || TP(l, t))
    return new Tn(o, this._parents, e, t)
  }
  ;(cs.prototype.interrupt = PM), (cs.prototype.transition = FP)
  const Oa = e => () => e
  function DP(e, { sourceEvent: t, target: n, transform: o, dispatch: r }) {
    Object.defineProperties(this, { type: { value: e, enumerable: !0, configurable: !0 }, sourceEvent: { value: t, enumerable: !0, configurable: !0 }, target: { value: n, enumerable: !0, configurable: !0 }, transform: { value: o, enumerable: !0, configurable: !0 }, _: { value: r } })
  }
  function Dn(e, t, n) {
    ;(this.k = e), (this.x = t), (this.y = n)
  }
  Dn.prototype = {
    constructor: Dn,
    scale: function (e) {
      return e === 1 ? this : new Dn(this.k * e, this.x, this.y)
    },
    translate: function (e, t) {
      return (e === 0) & (t === 0) ? this : new Dn(this.k, this.x + this.k * e, this.y + this.k * t)
    },
    apply: function (e) {
      return [e[0] * this.k + this.x, e[1] * this.k + this.y]
    },
    applyX: function (e) {
      return e * this.k + this.x
    },
    applyY: function (e) {
      return e * this.k + this.y
    },
    invert: function (e) {
      return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k]
    },
    invertX: function (e) {
      return (e - this.x) / this.k
    },
    invertY: function (e) {
      return (e - this.y) / this.k
    },
    rescaleX: function (e) {
      return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e))
    },
    rescaleY: function (e) {
      return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e))
    },
    toString: function () {
      return 'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')'
    },
  }
  var ja = new Dn(1, 0, 0)
  xh.prototype = Dn.prototype
  function xh(e) {
    for (; !e.__zoom; ) if (!(e = e.parentNode)) return ja
    return e.__zoom
  }
  function Eu(e) {
    e.stopImmediatePropagation()
  }
  function bs(e) {
    e.preventDefault(), e.stopImmediatePropagation()
  }
  function zP(e) {
    return (!e.ctrlKey || e.type === 'wheel') && !e.button
  }
  function QP() {
    var e = this
    return e instanceof SVGElement
      ? ((e = e.ownerSVGElement || e),
        e.hasAttribute('viewBox')
          ? ((e = e.viewBox.baseVal),
            [
              [e.x, e.y],
              [e.x + e.width, e.y + e.height],
            ])
          : [
              [0, 0],
              [e.width.baseVal.value, e.height.baseVal.value],
            ])
      : [
          [0, 0],
          [e.clientWidth, e.clientHeight],
        ]
  }
  function Ch() {
    return this.__zoom || ja
  }
  function RP(e) {
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 0.002) * (e.ctrlKey ? 10 : 1)
  }
  function OP() {
    return navigator.maxTouchPoints || 'ontouchstart' in this
  }
  function jP(e, t, n) {
    var o = e.invertX(t[0][0]) - n[0][0],
      r = e.invertX(t[1][0]) - n[1][0],
      s = e.invertY(t[0][1]) - n[0][1],
      i = e.invertY(t[1][1]) - n[1][1]
    return e.translate(r > o ? (o + r) / 2 : Math.min(0, o) || Math.max(0, r), i > s ? (s + i) / 2 : Math.min(0, s) || Math.max(0, i))
  }
  function wh() {
    var e = zP,
      t = QP,
      n = jP,
      o = RP,
      r = OP,
      s = [0, 1 / 0],
      i = [
        [-1 / 0, -1 / 0],
        [1 / 0, 1 / 0],
      ],
      a = 250,
      l = wM,
      c = xa('start', 'zoom', 'end'),
      u,
      d,
      f,
      A = 500,
      h = 150,
      g = 0,
      x = 10
    function m(S) {
      S.property('__zoom', Ch).on('wheel.zoom', P, { passive: !1 }).on('mousedown.zoom', T).on('dblclick.zoom', F).filter(r).on('touchstart.zoom', D).on('touchmove.zoom', Q).on('touchend.zoom touchcancel.zoom', R).style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')
    }
    ;(m.transform = function (S, L, I, z) {
      var B = S.selection ? S.selection() : S
      B.property('__zoom', Ch),
        S !== B
          ? w(S, L, I, z)
          : B.interrupt().each(function () {
              k(this, arguments)
                .event(z)
                .start()
                .zoom(null, typeof L == 'function' ? L.apply(this, arguments) : L)
                .end()
            })
    }),
      (m.scaleBy = function (S, L, I, z) {
        m.scaleTo(
          S,
          function () {
            var B = this.__zoom.k,
              O = typeof L == 'function' ? L.apply(this, arguments) : L
            return B * O
          },
          I,
          z
        )
      }),
      (m.scaleTo = function (S, L, I, z) {
        m.transform(
          S,
          function () {
            var B = t.apply(this, arguments),
              O = this.__zoom,
              W = I == null ? b(B) : typeof I == 'function' ? I.apply(this, arguments) : I,
              K = O.invert(W),
              Z = typeof L == 'function' ? L.apply(this, arguments) : L
            return n(y(v(O, Z), W, K), B, i)
          },
          I,
          z
        )
      }),
      (m.translateBy = function (S, L, I, z) {
        m.transform(
          S,
          function () {
            return n(this.__zoom.translate(typeof L == 'function' ? L.apply(this, arguments) : L, typeof I == 'function' ? I.apply(this, arguments) : I), t.apply(this, arguments), i)
          },
          null,
          z
        )
      }),
      (m.translateTo = function (S, L, I, z, B) {
        m.transform(
          S,
          function () {
            var O = t.apply(this, arguments),
              W = this.__zoom,
              K = z == null ? b(O) : typeof z == 'function' ? z.apply(this, arguments) : z
            return n(
              ja
                .translate(K[0], K[1])
                .scale(W.k)
                .translate(typeof L == 'function' ? -L.apply(this, arguments) : -L, typeof I == 'function' ? -I.apply(this, arguments) : -I),
              O,
              i
            )
          },
          z,
          B
        )
      })
    function v(S, L) {
      return (L = Math.max(s[0], Math.min(s[1], L))), L === S.k ? S : new Dn(L, S.x, S.y)
    }
    function y(S, L, I) {
      var z = L[0] - I[0] * S.k,
        B = L[1] - I[1] * S.k
      return z === S.x && B === S.y ? S : new Dn(S.k, z, B)
    }
    function b(S) {
      return [(+S[0][0] + +S[1][0]) / 2, (+S[0][1] + +S[1][1]) / 2]
    }
    function w(S, L, I, z) {
      S.on('start.zoom', function () {
        k(this, arguments).event(z).start()
      })
        .on('interrupt.zoom end.zoom', function () {
          k(this, arguments).event(z).end()
        })
        .tween('zoom', function () {
          var B = this,
            O = arguments,
            W = k(B, O).event(z),
            K = t.apply(B, O),
            Z = I == null ? b(K) : typeof I == 'function' ? I.apply(B, O) : I,
            oe = Math.max(K[1][0] - K[0][0], K[1][1] - K[0][1]),
            V = B.__zoom,
            q = typeof L == 'function' ? L.apply(B, O) : L,
            ee = l(V.invert(Z).concat(oe / V.k), q.invert(Z).concat(oe / q.k))
          return function (re) {
            if (re === 1) re = q
            else {
              var J = ee(re),
                ie = oe / J[2]
              re = new Dn(ie, Z[0] - J[0] * ie, Z[1] - J[1] * ie)
            }
            W.zoom(null, re)
          }
        })
    }
    function k(S, L, I) {
      return (!I && S.__zooming) || new E(S, L)
    }
    function E(S, L) {
      ;(this.that = S), (this.args = L), (this.active = 0), (this.sourceEvent = null), (this.extent = t.apply(S, L)), (this.taps = 0)
    }
    E.prototype = {
      event: function (S) {
        return S && (this.sourceEvent = S), this
      },
      start: function () {
        return ++this.active === 1 && ((this.that.__zooming = this), this.emit('start')), this
      },
      zoom: function (S, L) {
        return this.mouse && S !== 'mouse' && (this.mouse[1] = L.invert(this.mouse[0])), this.touch0 && S !== 'touch' && (this.touch0[1] = L.invert(this.touch0[0])), this.touch1 && S !== 'touch' && (this.touch1[1] = L.invert(this.touch1[0])), (this.that.__zoom = L), this.emit('zoom'), this
      },
      end: function () {
        return --this.active === 0 && (delete this.that.__zooming, this.emit('end')), this
      },
      emit: function (S) {
        var L = Tt(this.that).datum()
        c.call(S, this.that, new DP(S, { sourceEvent: this.sourceEvent, target: m, type: S, transform: this.that.__zoom, dispatch: c }), L)
      },
    }
    function P(S, ...L) {
      if (!e.apply(this, arguments)) return
      var I = k(this, L).event(S),
        z = this.__zoom,
        B = Math.max(s[0], Math.min(s[1], z.k * Math.pow(2, o.apply(this, arguments)))),
        O = sn(S)
      if (I.wheel) (I.mouse[0][0] !== O[0] || I.mouse[0][1] !== O[1]) && (I.mouse[1] = z.invert((I.mouse[0] = O))), clearTimeout(I.wheel)
      else {
        if (z.k === B) return
        ;(I.mouse = [O, z.invert(O)]), Ra(this), I.start()
      }
      bs(S), (I.wheel = setTimeout(W, h)), I.zoom('mouse', n(y(v(z, B), I.mouse[0], I.mouse[1]), I.extent, i))
      function W() {
        ;(I.wheel = null), I.end()
      }
    }
    function T(S, ...L) {
      if (f || !e.apply(this, arguments)) return
      var I = S.currentTarget,
        z = k(this, L, !0).event(S),
        B = Tt(S.view).on('mousemove.zoom', Z, !0).on('mouseup.zoom', oe, !0),
        O = sn(S, I),
        W = S.clientX,
        K = S.clientY
      Yp(S.view), Eu(S), (z.mouse = [O, this.__zoom.invert(O)]), Ra(this), z.start()
      function Z(V) {
        if ((bs(V), !z.moved)) {
          var q = V.clientX - W,
            ee = V.clientY - K
          z.moved = q * q + ee * ee > g
        }
        z.event(V).zoom('mouse', n(y(z.that.__zoom, (z.mouse[0] = sn(V, I)), z.mouse[1]), z.extent, i))
      }
      function oe(V) {
        B.on('mousemove.zoom mouseup.zoom', null), Hp(V.view, z.moved), bs(V), z.event(V).end()
      }
    }
    function F(S, ...L) {
      if (e.apply(this, arguments)) {
        var I = this.__zoom,
          z = sn(S.changedTouches ? S.changedTouches[0] : S, this),
          B = I.invert(z),
          O = I.k * (S.shiftKey ? 0.5 : 2),
          W = n(y(v(I, O), z, B), t.apply(this, L), i)
        bs(S), a > 0 ? Tt(this).transition().duration(a).call(w, W, z, S) : Tt(this).call(m.transform, W, z, S)
      }
    }
    function D(S, ...L) {
      if (e.apply(this, arguments)) {
        var I = S.touches,
          z = I.length,
          B = k(this, L, S.changedTouches.length === z).event(S),
          O,
          W,
          K,
          Z
        for (Eu(S), W = 0; W < z; ++W) (K = I[W]), (Z = sn(K, this)), (Z = [Z, this.__zoom.invert(Z), K.identifier]), B.touch0 ? !B.touch1 && B.touch0[2] !== Z[2] && ((B.touch1 = Z), (B.taps = 0)) : ((B.touch0 = Z), (O = !0), (B.taps = 1 + !!u))
        u && (u = clearTimeout(u)),
          O &&
            (B.taps < 2 &&
              ((d = Z[0]),
              (u = setTimeout(function () {
                u = null
              }, A))),
            Ra(this),
            B.start())
      }
    }
    function Q(S, ...L) {
      if (this.__zooming) {
        var I = k(this, L).event(S),
          z = S.changedTouches,
          B = z.length,
          O,
          W,
          K,
          Z
        for (bs(S), O = 0; O < B; ++O) (W = z[O]), (K = sn(W, this)), I.touch0 && I.touch0[2] === W.identifier ? (I.touch0[0] = K) : I.touch1 && I.touch1[2] === W.identifier && (I.touch1[0] = K)
        if (((W = I.that.__zoom), I.touch1)) {
          var oe = I.touch0[0],
            V = I.touch0[1],
            q = I.touch1[0],
            ee = I.touch1[1],
            re = (re = q[0] - oe[0]) * re + (re = q[1] - oe[1]) * re,
            J = (J = ee[0] - V[0]) * J + (J = ee[1] - V[1]) * J
          ;(W = v(W, Math.sqrt(re / J))), (K = [(oe[0] + q[0]) / 2, (oe[1] + q[1]) / 2]), (Z = [(V[0] + ee[0]) / 2, (V[1] + ee[1]) / 2])
        } else if (I.touch0) (K = I.touch0[0]), (Z = I.touch0[1])
        else return
        I.zoom('touch', n(y(W, K, Z), I.extent, i))
      }
    }
    function R(S, ...L) {
      if (this.__zooming) {
        var I = k(this, L).event(S),
          z = S.changedTouches,
          B = z.length,
          O,
          W
        for (
          Eu(S),
            f && clearTimeout(f),
            f = setTimeout(function () {
              f = null
            }, A),
            O = 0;
          O < B;
          ++O
        )
          (W = z[O]), I.touch0 && I.touch0[2] === W.identifier ? delete I.touch0 : I.touch1 && I.touch1[2] === W.identifier && delete I.touch1
        if ((I.touch1 && !I.touch0 && ((I.touch0 = I.touch1), delete I.touch1), I.touch0)) I.touch0[1] = this.__zoom.invert(I.touch0[0])
        else if ((I.end(), I.taps === 2 && ((W = sn(W, this)), Math.hypot(d[0] - W[0], d[1] - W[1]) < x))) {
          var K = Tt(this).on('dblclick.zoom')
          K && K.apply(this, arguments)
        }
      }
    }
    return (
      (m.wheelDelta = function (S) {
        return arguments.length ? ((o = typeof S == 'function' ? S : Oa(+S)), m) : o
      }),
      (m.filter = function (S) {
        return arguments.length ? ((e = typeof S == 'function' ? S : Oa(!!S)), m) : e
      }),
      (m.touchable = function (S) {
        return arguments.length ? ((r = typeof S == 'function' ? S : Oa(!!S)), m) : r
      }),
      (m.extent = function (S) {
        return arguments.length
          ? ((t =
              typeof S == 'function'
                ? S
                : Oa([
                    [+S[0][0], +S[0][1]],
                    [+S[1][0], +S[1][1]],
                  ])),
            m)
          : t
      }),
      (m.scaleExtent = function (S) {
        return arguments.length ? ((s[0] = +S[0]), (s[1] = +S[1]), m) : [s[0], s[1]]
      }),
      (m.translateExtent = function (S) {
        return arguments.length
          ? ((i[0][0] = +S[0][0]), (i[1][0] = +S[1][0]), (i[0][1] = +S[0][1]), (i[1][1] = +S[1][1]), m)
          : [
              [i[0][0], i[0][1]],
              [i[1][0], i[1][1]],
            ]
      }),
      (m.constrain = function (S) {
        return arguments.length ? ((n = S), m) : n
      }),
      (m.duration = function (S) {
        return arguments.length ? ((a = +S), m) : a
      }),
      (m.interpolate = function (S) {
        return arguments.length ? ((l = S), m) : l
      }),
      (m.on = function () {
        var S = c.on.apply(c, arguments)
        return S === c ? m : S
      }),
      (m.clickDistance = function (S) {
        return arguments.length ? ((g = (S = +S) * S), m) : Math.sqrt(g)
      }),
      (m.tapDistance = function (S) {
        return arguments.length ? ((x = +S), m) : x
      }),
      m
    )
  }
  const zn = {
      error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',
      error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
      error003: e => `Node type "${e}" not found. Using fallback type "default".`,
      error004: () => 'The React Flow parent container needs a width and a height to render the graph.',
      error005: () => 'Only child nodes can use a parent extent.',
      error006: () => "Can't create edge. An edge needs a source and a target.",
      error007: e => `The old edge with id=${e} does not exist.`,
      error009: e => `Marker type "${e}" doesn't exist.`,
      error008: (e, { id: t, sourceHandle: n, targetHandle: o }) => `Couldn't create edge for ${e} handle id: "${e === 'source' ? n : o}", edge id: ${t}.`,
      error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',
      error011: e => `Edge type "${e}" not found. Using fallback type "default".`,
      error012: e => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
      error013: (e = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
    },
    vs = [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
    ],
    Eh = ['Enter', ' ', 'Escape']
  var yr
  ;(function (e) {
    ;(e.Strict = 'strict'), (e.Loose = 'loose')
  })(yr || (yr = {}))
  var Bo
  ;(function (e) {
    ;(e.Free = 'free'), (e.Vertical = 'vertical'), (e.Horizontal = 'horizontal')
  })(Bo || (Bo = {}))
  var xs
  ;(function (e) {
    ;(e.Partial = 'partial'), (e.Full = 'full')
  })(xs || (xs = {}))
  const Sh = { inProgress: !1, isValid: null, from: null, fromHandle: null, fromPosition: null, fromNode: null, to: null, toHandle: null, toPosition: null, toNode: null }
  var Sn
  ;(function (e) {
    ;(e.Bezier = 'default'), (e.Straight = 'straight'), (e.Step = 'step'), (e.SmoothStep = 'smoothstep'), (e.SimpleBezier = 'simplebezier')
  })(Sn || (Sn = {}))
  var Wa
  ;(function (e) {
    ;(e.Arrow = 'arrow'), (e.ArrowClosed = 'arrowclosed')
  })(Wa || (Wa = {}))
  var ye
  ;(function (e) {
    ;(e.Left = 'left'), (e.Top = 'top'), (e.Right = 'right'), (e.Bottom = 'bottom')
  })(ye || (ye = {}))
  const Bh = { [ye.Left]: ye.Right, [ye.Right]: ye.Left, [ye.Top]: ye.Bottom, [ye.Bottom]: ye.Top }
  function Ih(e) {
    return e === null ? null : e ? 'valid' : 'invalid'
  }
  const kh = e => 'id' in e && 'source' in e && 'target' in e,
    WP = e => 'id' in e && 'position' in e && !('source' in e) && !('target' in e),
    Su = e => 'id' in e && 'internals' in e && !('source' in e) && !('target' in e),
    Cs = (e, t = [0, 0]) => {
      const { width: n, height: o } = Qn(e),
        r = e.origin ?? t,
        s = n * r[0],
        i = o * r[1]
      return { x: e.position.x - s, y: e.position.y - i }
    },
    GP = (e, t = { nodeOrigin: [0, 0], nodeLookup: void 0 }) => {
      if (e.length === 0) return { x: 0, y: 0, width: 0, height: 0 }
      const n = e.reduce(
        (o, r) => {
          const s = typeof r == 'string'
          let i = !t.nodeLookup && !s ? r : void 0
          t.nodeLookup && (i = s ? t.nodeLookup.get(r) : Su(r) ? r : t.nodeLookup.get(r.id))
          const a = i ? Xa(i, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 }
          return Ga(o, a)
        },
        { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }
      )
      return Va(n)
    },
    ws = (e, t = {}) => {
      if (e.size === 0) return { x: 0, y: 0, width: 0, height: 0 }
      let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }
      return (
        e.forEach(o => {
          if (t.filter === void 0 || t.filter(o)) {
            const r = Xa(o)
            n = Ga(n, r)
          }
        }),
        Va(n)
      )
    },
    Nh = (e, t, [n, o, r] = [0, 0, 1], s = !1, i = !1) => {
      const a = { ...Ss(t, [n, o, r]), width: t.width / r, height: t.height / r },
        l = []
      for (const c of e.values()) {
        const { measured: u, selectable: d = !0, hidden: f = !1 } = c
        if ((i && !d) || f) continue
        const A = u.width ?? c.width ?? c.initialWidth ?? null,
          h = u.height ?? c.height ?? c.initialHeight ?? null,
          g = Es(a, vr(c)),
          x = (A ?? 0) * (h ?? 0),
          m = s && g > 0
        ;(!c.internals.handleBounds || m || g >= x || c.dragging) && l.push(c)
      }
      return l
    },
    Bu = (e, t) => {
      const n = new Set()
      return (
        e.forEach(o => {
          n.add(o.id)
        }),
        t.filter(o => n.has(o.source) || n.has(o.target))
      )
    }
  function Iu(e, t) {
    const n = new Map(),
      o = t != null && t.nodes ? new Set(t.nodes.map(r => r.id)) : null
    return (
      e.forEach(r => {
        r.measured.width && r.measured.height && ((t == null ? void 0 : t.includeHiddenNodes) || !r.hidden) && (!o || o.has(r.id)) && n.set(r.id, r)
      }),
      n
    )
  }
  async function ku({ nodes: e, width: t, height: n, panZoom: o, minZoom: r, maxZoom: s }, i) {
    if (e.size === 0) return Promise.resolve(!1)
    const a = ws(e),
      l = Mu(a, t, n, (i == null ? void 0 : i.minZoom) ?? r, (i == null ? void 0 : i.maxZoom) ?? s, (i == null ? void 0 : i.padding) ?? 0.1)
    return await o.setViewport(l, { duration: i == null ? void 0 : i.duration }), Promise.resolve(!0)
  }
  function Mh({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: o = [0, 0], nodeExtent: r, onError: s }) {
    const i = n.get(e),
      a = i.parentId ? n.get(i.parentId) : void 0,
      { x: l, y: c } = a ? a.internals.positionAbsolute : { x: 0, y: 0 },
      u = i.origin ?? o
    let d = r
    if (i.extent === 'parent' && !i.expandParent)
      if (!a) s == null || s('005', zn.error005())
      else {
        const A = a.measured.width,
          h = a.measured.height
        A &&
          h &&
          (d = [
            [l, c],
            [l + A, c + h],
          ])
      }
    else
      a &&
        xr(i.extent) &&
        (d = [
          [i.extent[0][0] + l, i.extent[0][1] + c],
          [i.extent[1][0] + l, i.extent[1][1] + c],
        ])
    const f = xr(d) ? Io(t, d, i.measured) : t
    return { position: { x: f.x - l + i.measured.width * u[0], y: f.y - c + i.measured.height * u[1] }, positionAbsolute: f }
  }
  async function VP({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: o, onBeforeDelete: r }) {
    const s = new Set(e.map(f => f.id)),
      i = []
    for (const f of n) {
      if (f.deletable === !1) continue
      const A = s.has(f.id),
        h = !A && f.parentId && i.find(g => g.id === f.parentId)
      ;(A || h) && i.push(f)
    }
    const a = new Set(t.map(f => f.id)),
      l = o.filter(f => f.deletable !== !1),
      u = Bu(i, l)
    for (const f of l) a.has(f.id) && !u.find(h => h.id === f.id) && u.push(f)
    if (!r) return { edges: u, nodes: i }
    const d = await r({ nodes: i, edges: u })
    return typeof d == 'boolean' ? (d ? { edges: u, nodes: i } : { edges: [], nodes: [] }) : d
  }
  const br = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n),
    Io = (e = { x: 0, y: 0 }, t, n) => ({ x: br(e.x, t[0][0], t[1][0] - ((n == null ? void 0 : n.width) ?? 0)), y: br(e.y, t[0][1], t[1][1] - ((n == null ? void 0 : n.height) ?? 0)) })
  function Ph(e, t, n) {
    const { width: o, height: r } = Qn(n),
      { x: s, y: i } = n.internals.positionAbsolute
    return Io(
      e,
      [
        [s, i],
        [s + o, i + r],
      ],
      t
    )
  }
  const Lh = (e, t, n) => (e < t ? br(Math.abs(e - t), 1, t) / t : e > n ? -br(Math.abs(e - n), 1, t) / t : 0),
    Th = (e, t, n = 15, o = 40) => {
      const r = Lh(e.x, o, t.width - o) * n,
        s = Lh(e.y, o, t.height - o) * n
      return [r, s]
    },
    Ga = (e, t) => ({ x: Math.min(e.x, t.x), y: Math.min(e.y, t.y), x2: Math.max(e.x2, t.x2), y2: Math.max(e.y2, t.y2) }),
    Nu = ({ x: e, y: t, width: n, height: o }) => ({ x: e, y: t, x2: e + n, y2: t + o }),
    Va = ({ x: e, y: t, x2: n, y2: o }) => ({ x: e, y: t, width: n - e, height: o - t }),
    vr = (e, t = [0, 0]) => {
      var r, s
      const { x: n, y: o } = Su(e) ? e.internals.positionAbsolute : Cs(e, t)
      return { x: n, y: o, width: ((r = e.measured) == null ? void 0 : r.width) ?? e.width ?? e.initialWidth ?? 0, height: ((s = e.measured) == null ? void 0 : s.height) ?? e.height ?? e.initialHeight ?? 0 }
    },
    Xa = (e, t = [0, 0]) => {
      var r, s
      const { x: n, y: o } = Su(e) ? e.internals.positionAbsolute : Cs(e, t)
      return { x: n, y: o, x2: n + (((r = e.measured) == null ? void 0 : r.width) ?? e.width ?? e.initialWidth ?? 0), y2: o + (((s = e.measured) == null ? void 0 : s.height) ?? e.height ?? e.initialHeight ?? 0) }
    },
    Fh = (e, t) => Va(Ga(Nu(e), Nu(t))),
    Es = (e, t) => {
      const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)),
        o = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y))
      return Math.ceil(n * o)
    },
    Dh = e => cn(e.width) && cn(e.height) && cn(e.x) && cn(e.y),
    cn = e => !isNaN(e) && isFinite(e),
    XP = (e, t) => {},
    Ya = (e, t = [1, 1]) => ({ x: t[0] * Math.round(e.x / t[0]), y: t[1] * Math.round(e.y / t[1]) }),
    Ss = ({ x: e, y: t }, [n, o, r], s = !1, i = [1, 1]) => {
      const a = { x: (e - n) / r, y: (t - o) / r }
      return s ? Ya(a, i) : a
    },
    zh = ({ x: e, y: t }, [n, o, r]) => ({ x: e * r + n, y: t * r + o }),
    Mu = (e, t, n, o, r, s) => {
      const i = t / (e.width * (1 + s)),
        a = n / (e.height * (1 + s)),
        l = Math.min(i, a),
        c = br(l, o, r),
        u = e.x + e.width / 2,
        d = e.y + e.height / 2,
        f = t / 2 - u * c,
        A = n / 2 - d * c
      return { x: f, y: A, zoom: c }
    },
    Ha = () => {
      var e
      return typeof navigator < 'u' && ((e = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : e.indexOf('Mac')) >= 0
    }
  function xr(e) {
    return e !== void 0 && e !== 'parent'
  }
  function Qn(e) {
    var t, n
    return { width: ((t = e.measured) == null ? void 0 : t.width) ?? e.width ?? e.initialWidth ?? 0, height: ((n = e.measured) == null ? void 0 : n.height) ?? e.height ?? e.initialHeight ?? 0 }
  }
  function Qh(e) {
    var t, n
    return (((t = e.measured) == null ? void 0 : t.width) ?? e.width ?? e.initialWidth) !== void 0 && (((n = e.measured) == null ? void 0 : n.height) ?? e.height ?? e.initialHeight) !== void 0
  }
  function Rh(e, t = { width: 0, height: 0 }, n, o, r) {
    const s = { ...e },
      i = o.get(n)
    if (i) {
      const a = i.origin || r
      ;(s.x += i.internals.positionAbsolute.x - (t.width ?? 0) * a[0]), (s.y += i.internals.positionAbsolute.y - (t.height ?? 0) * a[1])
    }
    return s
  }
  function Bs(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: o, containerBounds: r }) {
    const { x: s, y: i } = Rn(e),
      a = Ss({ x: s - ((r == null ? void 0 : r.left) ?? 0), y: i - ((r == null ? void 0 : r.top) ?? 0) }, o),
      { x: l, y: c } = n ? Ya(a, t) : a
    return { xSnapped: l, ySnapped: c, ...a }
  }
  const Ua = e => ({ width: e.offsetWidth, height: e.offsetHeight }),
    Oh = e => {
      var t
      return ((t = e.getRootNode) == null ? void 0 : t.call(e)) || (window == null ? void 0 : window.document)
    },
    YP = ['INPUT', 'SELECT', 'TEXTAREA']
  function Pu(e) {
    var o, r, s
    const t = ((r = (o = e.composedPath) == null ? void 0 : o.call(e)) == null ? void 0 : r[0]) || e.target
    return YP.includes(t == null ? void 0 : t.nodeName) || ((s = t == null ? void 0 : t.hasAttribute) == null ? void 0 : s.call(t, 'contenteditable')) || !!(t != null && t.closest('.nokey'))
  }
  const jh = e => 'clientX' in e,
    Rn = (e, t) => {
      var s, i
      const n = jh(e),
        o = n ? e.clientX : (s = e.touches) == null ? void 0 : s[0].clientX,
        r = n ? e.clientY : (i = e.touches) == null ? void 0 : i[0].clientY
      return { x: o - ((t == null ? void 0 : t.left) ?? 0), y: r - ((t == null ? void 0 : t.top) ?? 0) }
    },
    Wh = (e, t, n, o, r) => {
      const s = t.querySelectorAll(`.${e}`)
      return !s || !s.length
        ? null
        : Array.from(s).map(i => {
            const a = i.getBoundingClientRect()
            return { id: i.getAttribute('data-handleid'), type: e, nodeId: r, position: i.getAttribute('data-handlepos'), x: (a.left - n.left) / o, y: (a.top - n.top) / o, ...Ua(i) }
          })
    }
  function Gh({ sourceX: e, sourceY: t, targetX: n, targetY: o, sourceControlX: r, sourceControlY: s, targetControlX: i, targetControlY: a }) {
    const l = e * 0.125 + r * 0.375 + i * 0.375 + n * 0.125,
      c = t * 0.125 + s * 0.375 + a * 0.375 + o * 0.125,
      u = Math.abs(l - e),
      d = Math.abs(c - t)
    return [l, c, u, d]
  }
  function Ka(e, t) {
    return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e)
  }
  function Vh({ pos: e, x1: t, y1: n, x2: o, y2: r, c: s }) {
    switch (e) {
      case ye.Left:
        return [t - Ka(t - o, s), n]
      case ye.Right:
        return [t + Ka(o - t, s), n]
      case ye.Top:
        return [t, n - Ka(n - r, s)]
      case ye.Bottom:
        return [t, n + Ka(r - n, s)]
    }
  }
  function Xh({ sourceX: e, sourceY: t, sourcePosition: n = ye.Bottom, targetX: o, targetY: r, targetPosition: s = ye.Top, curvature: i = 0.25 }) {
    const [a, l] = Vh({ pos: n, x1: e, y1: t, x2: o, y2: r, c: i }),
      [c, u] = Vh({ pos: s, x1: o, y1: r, x2: e, y2: t, c: i }),
      [d, f, A, h] = Gh({ sourceX: e, sourceY: t, targetX: o, targetY: r, sourceControlX: a, sourceControlY: l, targetControlX: c, targetControlY: u })
    return [`M${e},${t} C${a},${l} ${c},${u} ${o},${r}`, d, f, A, h]
  }
  function Yh({ sourceX: e, sourceY: t, targetX: n, targetY: o }) {
    const r = Math.abs(n - e) / 2,
      s = n < e ? n + r : n - r,
      i = Math.abs(o - t) / 2,
      a = o < t ? o + i : o - i
    return [s, a, r, i]
  }
  function HP({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: o = 0, elevateOnSelect: r = !1 }) {
    if (!r) return o
    const s = n || t.selected || e.selected,
      i = Math.max(e.internals.z || 0, t.internals.z || 0, 1e3)
    return o + (s ? i : 0)
  }
  function UP({ sourceNode: e, targetNode: t, width: n, height: o, transform: r }) {
    const s = Ga(Xa(e), Xa(t))
    s.x === s.x2 && (s.x2 += 1), s.y === s.y2 && (s.y2 += 1)
    const i = { x: -r[0] / r[2], y: -r[1] / r[2], width: n / r[2], height: o / r[2] }
    return Es(i, Va(s)) > 0
  }
  const KP = ({ source: e, sourceHandle: t, target: n, targetHandle: o }) => `xy-edge__${e}${t || ''}-${n}${o || ''}`,
    qP = (e, t) => t.some(n => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || (!n.sourceHandle && !e.sourceHandle)) && (n.targetHandle === e.targetHandle || (!n.targetHandle && !e.targetHandle))),
    Lu = (e, t) => {
      if (!e.source || !e.target) return t
      let n
      return kh(e) ? (n = { ...e }) : (n = { ...e, id: KP(e) }), qP(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n))
    }
  function Hh({ sourceX: e, sourceY: t, targetX: n, targetY: o }) {
    const [r, s, i, a] = Yh({ sourceX: e, sourceY: t, targetX: n, targetY: o })
    return [`M ${e},${t}L ${n},${o}`, r, s, i, a]
  }
  const Uh = { [ye.Left]: { x: -1, y: 0 }, [ye.Right]: { x: 1, y: 0 }, [ye.Top]: { x: 0, y: -1 }, [ye.Bottom]: { x: 0, y: 1 } },
    ZP = ({ source: e, sourcePosition: t = ye.Bottom, target: n }) => (t === ye.Left || t === ye.Right ? (e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 }) : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }),
    Kh = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
  function JP({ source: e, sourcePosition: t = ye.Bottom, target: n, targetPosition: o = ye.Top, center: r, offset: s }) {
    const i = Uh[t],
      a = Uh[o],
      l = { x: e.x + i.x * s, y: e.y + i.y * s },
      c = { x: n.x + a.x * s, y: n.y + a.y * s },
      u = ZP({ source: l, sourcePosition: t, target: c }),
      d = u.x !== 0 ? 'x' : 'y',
      f = u[d]
    let A = [],
      h,
      g
    const x = { x: 0, y: 0 },
      m = { x: 0, y: 0 },
      [v, y, b, w] = Yh({ sourceX: e.x, sourceY: e.y, targetX: n.x, targetY: n.y })
    if (i[d] * a[d] === -1) {
      ;(h = r.x ?? v), (g = r.y ?? y)
      const E = [
          { x: h, y: l.y },
          { x: h, y: c.y },
        ],
        P = [
          { x: l.x, y: g },
          { x: c.x, y: g },
        ]
      i[d] === f ? (A = d === 'x' ? E : P) : (A = d === 'x' ? P : E)
    } else {
      const E = [{ x: l.x, y: c.y }],
        P = [{ x: c.x, y: l.y }]
      if ((d === 'x' ? (A = i.x === f ? P : E) : (A = i.y === f ? E : P), t === o)) {
        const R = Math.abs(e[d] - n[d])
        if (R <= s) {
          const S = Math.min(s - 1, s - R)
          i[d] === f ? (x[d] = (l[d] > e[d] ? -1 : 1) * S) : (m[d] = (c[d] > n[d] ? -1 : 1) * S)
        }
      }
      if (t !== o) {
        const R = d === 'x' ? 'y' : 'x',
          S = i[d] === a[R],
          L = l[R] > c[R],
          I = l[R] < c[R]
        ;((i[d] === 1 && ((!S && L) || (S && I))) || (i[d] !== 1 && ((!S && I) || (S && L)))) && (A = d === 'x' ? E : P)
      }
      const T = { x: l.x + x.x, y: l.y + x.y },
        F = { x: c.x + m.x, y: c.y + m.y },
        D = Math.max(Math.abs(T.x - A[0].x), Math.abs(F.x - A[0].x)),
        Q = Math.max(Math.abs(T.y - A[0].y), Math.abs(F.y - A[0].y))
      D >= Q ? ((h = (T.x + F.x) / 2), (g = A[0].y)) : ((h = A[0].x), (g = (T.y + F.y) / 2))
    }
    return [[e, { x: l.x + x.x, y: l.y + x.y }, ...A, { x: c.x + m.x, y: c.y + m.y }, n], h, g, b, w]
  }
  function _P(e, t, n, o) {
    const r = Math.min(Kh(e, t) / 2, Kh(t, n) / 2, o),
      { x: s, y: i } = t
    if ((e.x === s && s === n.x) || (e.y === i && i === n.y)) return `L${s} ${i}`
    if (e.y === i) {
      const c = e.x < n.x ? -1 : 1,
        u = e.y < n.y ? 1 : -1
      return `L ${s + r * c},${i}Q ${s},${i} ${s},${i + r * u}`
    }
    const a = e.x < n.x ? 1 : -1,
      l = e.y < n.y ? -1 : 1
    return `L ${s},${i + r * l}Q ${s},${i} ${s + r * a},${i}`
  }
  function qa({ sourceX: e, sourceY: t, sourcePosition: n = ye.Bottom, targetX: o, targetY: r, targetPosition: s = ye.Top, borderRadius: i = 5, centerX: a, centerY: l, offset: c = 20 }) {
    const [u, d, f, A, h] = JP({ source: { x: e, y: t }, sourcePosition: n, target: { x: o, y: r }, targetPosition: s, center: { x: a, y: l }, offset: c })
    return [
      u.reduce((x, m, v) => {
        let y = ''
        return v > 0 && v < u.length - 1 ? (y = _P(u[v - 1], m, u[v + 1], i)) : (y = `${v === 0 ? 'M' : 'L'}${m.x} ${m.y}`), (x += y), x
      }, ''),
      d,
      f,
      A,
      h,
    ]
  }
  function qh(e) {
    var t
    return e && !!(e.internals.handleBounds || ((t = e.handles) != null && t.length)) && !!(e.measured.width || e.width || e.initialWidth)
  }
  function $P(e) {
    var d
    const { sourceNode: t, targetNode: n } = e
    if (!qh(t) || !qh(n)) return null
    const o = t.internals.handleBounds || Zh(t.handles),
      r = n.internals.handleBounds || Zh(n.handles),
      s = Jh((o == null ? void 0 : o.source) ?? [], e.sourceHandle),
      i = Jh(e.connectionMode === yr.Strict ? (r == null ? void 0 : r.target) ?? [] : ((r == null ? void 0 : r.target) ?? []).concat((r == null ? void 0 : r.source) ?? []), e.targetHandle)
    if (!s || !i) return (d = e.onError) == null || d.call(e, '008', zn.error008(s ? 'target' : 'source', { id: e.id, sourceHandle: e.sourceHandle, targetHandle: e.targetHandle })), null
    const a = (s == null ? void 0 : s.position) || ye.Bottom,
      l = (i == null ? void 0 : i.position) || ye.Top,
      c = Is(t, s, a),
      u = Is(n, i, l)
    return { sourceX: c.x, sourceY: c.y, targetX: u.x, targetY: u.y, sourcePosition: a, targetPosition: l }
  }
  function Zh(e) {
    if (!e) return null
    const t = [],
      n = []
    for (const o of e) (o.width = o.width ?? 1), (o.height = o.height ?? 1), o.type === 'source' ? t.push(o) : o.type === 'target' && n.push(o)
    return { source: t, target: n }
  }
  function Is(e, t, n = ye.Left, o = !1) {
    const r = ((t == null ? void 0 : t.x) ?? 0) + e.internals.positionAbsolute.x,
      s = ((t == null ? void 0 : t.y) ?? 0) + e.internals.positionAbsolute.y,
      { width: i, height: a } = t ?? Qn(e)
    if (o) return { x: r + i / 2, y: s + a / 2 }
    switch ((t == null ? void 0 : t.position) ?? n) {
      case ye.Top:
        return { x: r + i / 2, y: s }
      case ye.Right:
        return { x: r + i, y: s + a / 2 }
      case ye.Bottom:
        return { x: r + i / 2, y: s + a }
      case ye.Left:
        return { x: r, y: s + a / 2 }
    }
  }
  function Jh(e, t) {
    return (e && (t ? e.find(n => n.id === t) : e[0])) || null
  }
  function Tu(e, t) {
    return e
      ? typeof e == 'string'
        ? e
        : `${t ? `${t}__` : ''}${Object.keys(e)
            .sort()
            .map(o => `${o}=${e[o]}`)
            .join('&')}`
      : ''
  }
  function e2(e, { id: t, defaultColor: n, defaultMarkerStart: o, defaultMarkerEnd: r }) {
    const s = new Set()
    return e
      .reduce(
        (i, a) => (
          [a.markerStart || o, a.markerEnd || r].forEach(l => {
            if (l && typeof l == 'object') {
              const c = Tu(l, t)
              s.has(c) || (i.push({ id: c, color: l.color || n, ...l }), s.add(c))
            }
          }),
          i
        ),
        []
      )
      .sort((i, a) => i.id.localeCompare(a.id))
  }
  const Fu = { nodeOrigin: [0, 0], nodeExtent: vs, elevateNodesOnSelect: !0, defaults: {} },
    t2 = { ...Fu, checkEquality: !0 }
  function Du(e, t) {
    const n = { ...e }
    for (const o in t) t[o] !== void 0 && (n[o] = t[o])
    return n
  }
  function n2(e, t, n) {
    const o = Du(Fu, n)
    for (const r of e.values())
      if (r.parentId) Qu(r, e, t, o)
      else {
        const s = Cs(r, o.nodeOrigin),
          i = xr(r.extent) ? r.extent : o.nodeExtent,
          a = Io(s, i, Qn(r))
        r.internals.positionAbsolute = a
      }
  }
  function zu(e, t, n, o) {
    var a, l
    const r = Du(t2, o),
      s = new Map(t),
      i = r != null && r.elevateNodesOnSelect ? 1e3 : 0
    t.clear(), n.clear()
    for (const c of e) {
      let u = s.get(c.id)
      if (r.checkEquality && c === (u == null ? void 0 : u.internals.userNode)) t.set(c.id, u)
      else {
        const d = Cs(c, r.nodeOrigin),
          f = xr(c.extent) ? c.extent : r.nodeExtent,
          A = Io(d, f, Qn(c))
        ;(u = { ...r.defaults, ...c, measured: { width: (a = c.measured) == null ? void 0 : a.width, height: (l = c.measured) == null ? void 0 : l.height }, internals: { positionAbsolute: A, handleBounds: c.measured ? (u == null ? void 0 : u.internals.handleBounds) : void 0, z: _h(c, i), userNode: c } }), t.set(c.id, u)
      }
      c.parentId && Qu(u, t, n, o)
    }
  }
  function o2(e, t) {
    if (!e.parentId) return
    const n = t.get(e.parentId)
    n ? n.set(e.id, e) : t.set(e.parentId, new Map([[e.id, e]]))
  }
  function Qu(e, t, n, o) {
    const { elevateNodesOnSelect: r, nodeOrigin: s, nodeExtent: i } = Du(Fu, o),
      a = e.parentId,
      l = t.get(a)
    if (!l) {
      console.warn(`Parent node ${a} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`)
      return
    }
    o2(e, n)
    const c = r ? 1e3 : 0,
      { x: u, y: d, z: f } = r2(e, l, s, i, c),
      { positionAbsolute: A } = e.internals,
      h = u !== A.x || d !== A.y
    ;(h || f !== e.internals.z) && (e.internals = { ...e.internals, positionAbsolute: h ? { x: u, y: d } : A, z: f })
  }
  function _h(e, t) {
    return (cn(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0)
  }
  function r2(e, t, n, o, r) {
    const { x: s, y: i } = t.internals.positionAbsolute,
      a = Qn(e),
      l = Cs(e, n),
      c = xr(e.extent) ? Io(l, e.extent, a) : l
    let u = Io({ x: s + c.x, y: i + c.y }, o, a)
    e.extent === 'parent' && (u = Ph(u, a, t))
    const d = _h(e, r),
      f = t.internals.z ?? 0
    return { x: u.x, y: u.y, z: f > d ? f : d }
  }
  function Ru(e, t, n, o = [0, 0]) {
    var i
    const r = [],
      s = new Map()
    for (const a of e) {
      const l = t.get(a.parentId)
      if (!l) continue
      const c = ((i = s.get(a.parentId)) == null ? void 0 : i.expandedRect) ?? vr(l),
        u = Fh(c, a.rect)
      s.set(a.parentId, { expandedRect: u, parent: l })
    }
    return (
      s.size > 0 &&
        s.forEach(({ expandedRect: a, parent: l }, c) => {
          var y
          const u = l.internals.positionAbsolute,
            d = Qn(l),
            f = l.origin ?? o,
            A = a.x < u.x ? Math.round(Math.abs(u.x - a.x)) : 0,
            h = a.y < u.y ? Math.round(Math.abs(u.y - a.y)) : 0,
            g = Math.max(d.width, Math.round(a.width)),
            x = Math.max(d.height, Math.round(a.height)),
            m = (g - d.width) * f[0],
            v = (x - d.height) * f[1]
          ;(A > 0 || h > 0 || m || v) &&
            (r.push({ id: c, type: 'position', position: { x: l.position.x - A + m, y: l.position.y - h + v } }),
            (y = n.get(c)) == null ||
              y.forEach(b => {
                e.some(w => w.id === b.id) || r.push({ id: b.id, type: 'position', position: { x: b.position.x + A, y: b.position.y + h } })
              })),
            (d.width < a.width || d.height < a.height || A || h) && r.push({ id: c, type: 'dimensions', setAttributes: !0, dimensions: { width: g + (A ? f[0] * A - m : 0), height: x + (h ? f[1] * h - v : 0) } })
        }),
      r
    )
  }
  function s2(e, t, n, o, r, s) {
    const i = o == null ? void 0 : o.querySelector('.xyflow__viewport')
    let a = !1
    if (!i) return { changes: [], updatedInternals: a }
    const l = [],
      c = window.getComputedStyle(i),
      { m22: u } = new window.DOMMatrixReadOnly(c.transform),
      d = []
    for (const f of e.values()) {
      const A = t.get(f.id)
      if (A)
        if (A.hidden) (A.internals = { ...A.internals, handleBounds: void 0 }), (a = !0)
        else {
          const h = Ua(f.nodeElement),
            g = A.measured.width !== h.width || A.measured.height !== h.height
          if (!!(h.width && h.height && (g || !A.internals.handleBounds || f.force))) {
            const m = f.nodeElement.getBoundingClientRect(),
              v = xr(A.extent) ? A.extent : s
            let { positionAbsolute: y } = A.internals
            A.parentId && A.extent === 'parent' ? (y = Ph(y, h, t.get(A.parentId))) : v && (y = Io(y, v, h)),
              (A.measured = h),
              (A.internals = { ...A.internals, positionAbsolute: y, handleBounds: { source: Wh('source', f.nodeElement, m, u, A.id), target: Wh('target', f.nodeElement, m, u, A.id) } }),
              A.parentId && Qu(A, t, n, { nodeOrigin: r }),
              (a = !0),
              g && (l.push({ id: A.id, type: 'dimensions', dimensions: h }), A.expandParent && A.parentId && d.push({ id: A.id, parentId: A.parentId, rect: vr(A, r) }))
          }
        }
    }
    if (d.length > 0) {
      const f = Ru(d, t, n, r)
      l.push(...f)
    }
    return { changes: l, updatedInternals: a }
  }
  async function i2({ delta: e, panZoom: t, transform: n, translateExtent: o, width: r, height: s }) {
    if (!t || (!e.x && !e.y)) return Promise.resolve(!1)
    const i = await t.setViewportConstrained(
        { x: n[0] + e.x, y: n[1] + e.y, zoom: n[2] },
        [
          [0, 0],
          [r, s],
        ],
        o
      ),
      a = !!i && (i.x !== n[0] || i.y !== n[1] || i.k !== n[2])
    return Promise.resolve(a)
  }
  function $h(e, t, n) {
    e.clear(), t.clear()
    for (const o of n) {
      const { source: r, target: s, sourceHandle: i = null, targetHandle: a = null } = o,
        l = `${r}-source-${i}`,
        c = `${s}-target-${a}`,
        u = e.get(l) || new Map(),
        d = e.get(c) || new Map(),
        f = { edgeId: o.id, source: r, target: s, sourceHandle: i, targetHandle: a }
      t.set(o.id, o), e.set(l, u.set(`${s}-${a}`, f)), e.set(c, d.set(`${r}-${i}`, f))
    }
  }
  function eg(e, t) {
    if (!e.parentId) return !1
    const n = t.get(e.parentId)
    return n ? (n.selected ? !0 : eg(n, t)) : !1
  }
  function tg(e, t, n) {
    let o = e
    do {
      if (o != null && o.matches(t)) return !0
      if (o === n) return !1
      o = o.parentElement
    } while (o)
    return !1
  }
  function a2(e, t, n, o) {
    const r = new Map()
    for (const [s, i] of e)
      if ((i.selected || i.id === o) && (!i.parentId || !eg(i, e)) && (i.draggable || (t && typeof i.draggable > 'u'))) {
        const a = e.get(s)
        a &&
          r.set(s, {
            id: s,
            position: a.position || { x: 0, y: 0 },
            distance: { x: n.x - a.internals.positionAbsolute.x, y: n.y - a.internals.positionAbsolute.y },
            extent: a.extent,
            parentId: a.parentId,
            origin: a.origin,
            expandParent: a.expandParent,
            internals: { positionAbsolute: a.internals.positionAbsolute || { x: 0, y: 0 } },
            measured: { width: a.measured.width ?? 0, height: a.measured.height ?? 0 },
          })
      }
    return r
  }
  function Ou({ nodeId: e, dragItems: t, nodeLookup: n, dragging: o = !0 }) {
    var i, a, l
    const r = []
    for (const [c, u] of t) {
      const d = (i = n.get(c)) == null ? void 0 : i.internals.userNode
      d && r.push({ ...d, position: u.position, dragging: o })
    }
    if (!e) return [r[0], r]
    const s = (a = n.get(e)) == null ? void 0 : a.internals.userNode
    return [s ? { ...s, position: ((l = t.get(e)) == null ? void 0 : l.position) || s.position, dragging: o } : r[0], r]
  }
  function l2({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: o, onDragStop: r }) {
    let s = { x: null, y: null },
      i = 0,
      a = new Map(),
      l = !1,
      c = { x: 0, y: 0 },
      u = null,
      d = !1,
      f = null,
      A = !1
    function h({ noDragClassName: x, handleSelector: m, domNode: v, isSelectable: y, nodeId: b, nodeClickDistance: w = 0 }) {
      f = Tt(v)
      function k({ x: F, y: D }, Q) {
        const { nodeLookup: R, nodeExtent: S, snapGrid: L, snapToGrid: I, nodeOrigin: z, onNodeDrag: B, onSelectionDrag: O, onError: W, updateNodePositions: K } = t()
        s = { x: F, y: D }
        let Z = !1,
          oe = { x: 0, y: 0, x2: 0, y2: 0 }
        if (a.size > 1 && S) {
          const V = ws(a)
          oe = Nu(V)
        }
        for (const [V, q] of a) {
          if (!R.has(V)) continue
          let ee = { x: F - q.distance.x, y: D - q.distance.y }
          I && (ee = Ya(ee, L))
          let re = [
            [S[0][0], S[0][1]],
            [S[1][0], S[1][1]],
          ]
          if (a.size > 1 && S && !q.extent) {
            const { positionAbsolute: Ae } = q.internals,
              ae = Ae.x - oe.x + S[0][0],
              se = Ae.x + q.measured.width - oe.x2 + S[1][0],
              H = Ae.y - oe.y + S[0][1],
              U = Ae.y + q.measured.height - oe.y2 + S[1][1]
            re = [
              [ae, H],
              [se, U],
            ]
          }
          const { position: J, positionAbsolute: ie } = Mh({ nodeId: V, nextPosition: ee, nodeLookup: R, nodeExtent: re, nodeOrigin: z, onError: W })
          ;(Z = Z || q.position.x !== J.x || q.position.y !== J.y), (q.position = J), (q.internals.positionAbsolute = ie)
        }
        if (Z && (K(a, !0), Q && (o || B || (!b && O)))) {
          const [V, q] = Ou({ nodeId: b, dragItems: a, nodeLookup: R })
          o == null || o(Q, a, V, q), B == null || B(Q, V, q), b || O == null || O(Q, q)
        }
      }
      async function E() {
        if (!u) return
        const { transform: F, panBy: D, autoPanSpeed: Q } = t(),
          [R, S] = Th(c, u, Q)
        ;(R !== 0 || S !== 0) && ((s.x = (s.x ?? 0) - R / F[2]), (s.y = (s.y ?? 0) - S / F[2]), (await D({ x: R, y: S })) && k(s, null)), (i = requestAnimationFrame(E))
      }
      function P(F) {
        var Z
        const { nodeLookup: D, multiSelectionActive: Q, nodesDraggable: R, transform: S, snapGrid: L, snapToGrid: I, selectNodesOnDrag: z, onNodeDragStart: B, onSelectionDragStart: O, unselectNodesAndEdges: W } = t()
        ;(d = !0), (!z || !y) && !Q && b && (((Z = D.get(b)) != null && Z.selected) || W()), y && z && b && (e == null || e(b))
        const K = Bs(F.sourceEvent, { transform: S, snapGrid: L, snapToGrid: I, containerBounds: u })
        if (((s = K), (a = a2(D, R, K, b)), a.size > 0 && (n || B || (!b && O)))) {
          const [oe, V] = Ou({ nodeId: b, dragItems: a, nodeLookup: D })
          n == null || n(F.sourceEvent, a, oe, V), B == null || B(F.sourceEvent, oe, V), b || O == null || O(F.sourceEvent, V)
        }
      }
      const T = du()
        .clickDistance(w)
        .on('start', F => {
          const { domNode: D, nodeDragThreshold: Q, transform: R, snapGrid: S, snapToGrid: L } = t()
          ;(u = (D == null ? void 0 : D.getBoundingClientRect()) || null), (A = !1), Q === 0 && P(F), (s = Bs(F.sourceEvent, { transform: R, snapGrid: S, snapToGrid: L, containerBounds: u })), (c = Rn(F.sourceEvent, u))
        })
        .on('drag', F => {
          const { autoPanOnNodeDrag: D, transform: Q, snapGrid: R, snapToGrid: S, nodeDragThreshold: L, nodeLookup: I } = t(),
            z = Bs(F.sourceEvent, { transform: Q, snapGrid: R, snapToGrid: S, containerBounds: u })
          if ((((F.sourceEvent.type === 'touchmove' && F.sourceEvent.touches.length > 1) || (b && !I.has(b))) && (A = !0), !A)) {
            if ((!l && D && d && ((l = !0), E()), !d)) {
              const B = z.xSnapped - (s.x ?? 0),
                O = z.ySnapped - (s.y ?? 0)
              Math.sqrt(B * B + O * O) > L && P(F)
            }
            ;(s.x !== z.xSnapped || s.y !== z.ySnapped) && a && d && ((c = Rn(F.sourceEvent, u)), k(z, F.sourceEvent))
          }
        })
        .on('end', F => {
          if (!(!d || A) && ((l = !1), (d = !1), cancelAnimationFrame(i), a.size > 0)) {
            const { nodeLookup: D, updateNodePositions: Q, onNodeDragStop: R, onSelectionDragStop: S } = t()
            if ((Q(a, !1), r || R || (!b && S))) {
              const [L, I] = Ou({ nodeId: b, dragItems: a, nodeLookup: D, dragging: !1 })
              r == null || r(F.sourceEvent, a, L, I), R == null || R(F.sourceEvent, L, I), b || S == null || S(F.sourceEvent, I)
            }
          }
        })
        .filter(F => {
          const D = F.target
          return !F.button && (!x || !tg(D, `.${x}`, v)) && (!m || tg(D, m, v))
        })
      f.call(T)
    }
    function g() {
      f == null || f.on('.drag', null)
    }
    return { update: h, destroy: g }
  }
  function c2(e, t, n) {
    const o = [],
      r = { x: e.x - n, y: e.y - n, width: n * 2, height: n * 2 }
    for (const s of t.values()) Es(r, vr(s)) > 0 && o.push(s)
    return o
  }
  const u2 = 250
  function d2(e, t, n, o) {
    var a, l
    let r = [],
      s = 1 / 0
    const i = c2(e, n, t + u2)
    for (const c of i) {
      const u = [...(((a = c.internals.handleBounds) == null ? void 0 : a.source) ?? []), ...(((l = c.internals.handleBounds) == null ? void 0 : l.target) ?? [])]
      for (const d of u) {
        if (o.nodeId === d.nodeId && o.type === d.type && o.id === d.id) continue
        const { x: f, y: A } = Is(c, d, d.position, !0),
          h = Math.sqrt(Math.pow(f - e.x, 2) + Math.pow(A - e.y, 2))
        h > t || (h < s ? ((r = [{ ...d, x: f, y: A }]), (s = h)) : h === s && r.push({ ...d, x: f, y: A }))
      }
    }
    if (!r.length) return null
    if (r.length > 1) {
      const c = o.type === 'source' ? 'target' : 'source'
      return r.find(u => u.type === c) ?? r[0]
    }
    return r[0]
  }
  function ng(e, t, n, o, r, s = !1) {
    var c, u, d
    const i = o.get(e)
    if (!i) return null
    const a = r === 'strict' ? ((c = i.internals.handleBounds) == null ? void 0 : c[t]) : [...(((u = i.internals.handleBounds) == null ? void 0 : u.source) ?? []), ...(((d = i.internals.handleBounds) == null ? void 0 : d.target) ?? [])],
      l = (n ? (a == null ? void 0 : a.find(f => f.id === n)) : a == null ? void 0 : a[0]) ?? null
    return l && s ? { ...l, ...Is(i, l, l.position, !0) } : l
  }
  function og(e, t) {
    return e || (t != null && t.classList.contains('target') ? 'target' : t != null && t.classList.contains('source') ? 'source' : null)
  }
  function f2(e, t) {
    let n = null
    return t ? (n = !0) : e && !t && (n = !1), n
  }
  const rg = () => !0
  function A2(
    e,
    {
      connectionMode: t,
      connectionRadius: n,
      handleId: o,
      nodeId: r,
      edgeUpdaterType: s,
      isTarget: i,
      domNode: a,
      nodeLookup: l,
      lib: c,
      autoPanOnConnect: u,
      flowId: d,
      panBy: f,
      cancelConnection: A,
      onConnectStart: h,
      onConnect: g,
      onConnectEnd: x,
      isValidConnection: m = rg,
      onReconnectEnd: v,
      updateConnection: y,
      getTransform: b,
      getFromHandle: w,
      autoPanSpeed: k,
    }
  ) {
    const E = Oh(e.target)
    let P = 0,
      T
    const { x: F, y: D } = Rn(e),
      Q = E == null ? void 0 : E.elementFromPoint(F, D),
      R = og(s, Q),
      S = a == null ? void 0 : a.getBoundingClientRect()
    if (!S || !R) return
    const L = ng(r, R, o, l, t)
    if (!L) return
    let I = Rn(e, S),
      z = !1,
      B = null,
      O = !1,
      W = null
    function K() {
      if (!u || !S) return
      const [ie, Ae] = Th(I, S, k)
      f({ x: ie, y: Ae }), (P = requestAnimationFrame(K))
    }
    const Z = { ...L, nodeId: r, type: R, position: L.position },
      oe = l.get(r),
      q = { inProgress: !0, isValid: null, from: Is(oe, Z, ye.Left, !0), fromHandle: Z, fromPosition: Z.position, fromNode: oe, to: I, toHandle: null, toPosition: Bh[Z.position], toNode: null }
    y(q)
    let ee = q
    h == null || h(e, { nodeId: r, handleId: o, handleType: R })
    function re(ie) {
      if (!w() || !Z) {
        J(ie)
        return
      }
      const Ae = b()
      ;(I = Rn(ie, S)), (T = d2(Ss(I, Ae, !1, [1, 1]), n, l, Z)), z || (K(), (z = !0))
      const ae = sg(ie, { handle: T, connectionMode: t, fromNodeId: r, fromHandleId: o, fromType: i ? 'target' : 'source', isValidConnection: m, doc: E, lib: c, flowId: d, nodeLookup: l })
      ;(W = ae.handleDomNode), (B = ae.connection), (O = f2(!!T, ae.isValid))
      const se = { ...ee, isValid: O, to: T && O ? zh({ x: T.x, y: T.y }, Ae) : I, toHandle: ae.toHandle, toPosition: O && ae.toHandle ? ae.toHandle.position : Bh[Z.position], toNode: ae.toHandle ? l.get(ae.toHandle.nodeId) : null }
      ;(O && T && ee.toHandle && se.toHandle && ee.toHandle.type === se.toHandle.type && ee.toHandle.nodeId === se.toHandle.nodeId && ee.toHandle.id === se.toHandle.id && ee.to.x === se.to.x && ee.to.y === se.to.y) || (y(se), (ee = se))
    }
    function J(ie) {
      ;(T || W) && B && O && (g == null || g(B))
      const { inProgress: Ae, ...ae } = ee,
        se = { ...ae, toPosition: ee.toHandle ? ee.toPosition : null }
      x == null || x(ie, se), s && (v == null || v(ie, se)), A(), cancelAnimationFrame(P), (z = !1), (O = !1), (B = null), (W = null), E.removeEventListener('mousemove', re), E.removeEventListener('mouseup', J), E.removeEventListener('touchmove', re), E.removeEventListener('touchend', J)
    }
    E.addEventListener('mousemove', re), E.addEventListener('mouseup', J), E.addEventListener('touchmove', re), E.addEventListener('touchend', J)
  }
  function sg(e, { handle: t, connectionMode: n, fromNodeId: o, fromHandleId: r, fromType: s, doc: i, lib: a, flowId: l, isValidConnection: c = rg, nodeLookup: u }) {
    const d = s === 'target',
      f = t ? i.querySelector(`.${a}-flow__handle[data-id="${l}-${t == null ? void 0 : t.nodeId}-${t == null ? void 0 : t.id}-${t == null ? void 0 : t.type}"]`) : null,
      { x: A, y: h } = Rn(e),
      g = i.elementFromPoint(A, h),
      x = g != null && g.classList.contains(`${a}-flow__handle`) ? g : f,
      m = { handleDomNode: x, isValid: !1, connection: null, toHandle: null }
    if (x) {
      const v = og(void 0, x),
        y = x.getAttribute('data-nodeid'),
        b = x.getAttribute('data-handleid'),
        w = x.classList.contains('connectable'),
        k = x.classList.contains('connectableend')
      if (!y || !v) return m
      const E = { source: d ? y : o, sourceHandle: d ? b : r, target: d ? o : y, targetHandle: d ? r : b }
      m.connection = E
      const T = w && k && (n === yr.Strict ? (d && v === 'source') || (!d && v === 'target') : y !== o || b !== r)
      ;(m.isValid = T && c(E)), (m.toHandle = ng(y, v, b, u, n, !1))
    }
    return m
  }
  const ju = { onPointerDown: A2, isValid: sg }
  function p2({ domNode: e, panZoom: t, getTransform: n, getViewScale: o }) {
    const r = Tt(e)
    function s({ translateExtent: a, width: l, height: c, zoomStep: u = 10, pannable: d = !0, zoomable: f = !0, inversePan: A = !1 }) {
      const h = y => {
        const b = n()
        if (y.sourceEvent.type !== 'wheel' || !t) return
        const w = -y.sourceEvent.deltaY * (y.sourceEvent.deltaMode === 1 ? 0.05 : y.sourceEvent.deltaMode ? 1 : 0.002) * u,
          k = b[2] * Math.pow(2, w)
        t.scaleTo(k)
      }
      let g = [0, 0]
      const x = y => {
          ;(y.sourceEvent.type === 'mousedown' || y.sourceEvent.type === 'touchstart') && (g = [y.sourceEvent.clientX ?? y.sourceEvent.touches[0].clientX, y.sourceEvent.clientY ?? y.sourceEvent.touches[0].clientY])
        },
        m = y => {
          const b = n()
          if ((y.sourceEvent.type !== 'mousemove' && y.sourceEvent.type !== 'touchmove') || !t) return
          const w = [y.sourceEvent.clientX ?? y.sourceEvent.touches[0].clientX, y.sourceEvent.clientY ?? y.sourceEvent.touches[0].clientY],
            k = [w[0] - g[0], w[1] - g[1]]
          g = w
          const E = o() * Math.max(b[2], Math.log(b[2])) * (A ? -1 : 1),
            P = { x: b[0] - k[0] * E, y: b[1] - k[1] * E },
            T = [
              [0, 0],
              [l, c],
            ]
          t.setViewportConstrained({ x: P.x, y: P.y, zoom: b[2] }, T, a)
        },
        v = wh()
          .on('start', x)
          .on('zoom', d ? m : null)
          .on('zoom.wheel', f ? h : null)
      r.call(v, {})
    }
    function i() {
      r.on('zoom', null)
    }
    return { update: s, destroy: i, pointer: sn }
  }
  const h2 = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k,
    Za = e => ({ x: e.x, y: e.y, zoom: e.k }),
    Wu = ({ x: e, y: t, zoom: n }) => ja.translate(e, t).scale(n),
    Cr = (e, t) => e.target.closest(`.${t}`),
    ig = (e, t) => t === 2 && Array.isArray(e) && e.includes(2),
    Gu = (e, t = 0, n = () => {}) => {
      const o = typeof t == 'number' && t > 0
      return o || n(), o ? e.transition().duration(t).on('end', n) : e
    },
    ag = e => {
      const t = e.ctrlKey && Ha() ? 10 : 1
      return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 0.002) * t
    }
  function g2({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: o, panOnScrollMode: r, panOnScrollSpeed: s, zoomOnPinch: i, onPanZoomStart: a, onPanZoom: l, onPanZoomEnd: c }) {
    return u => {
      if (Cr(u, t)) return !1
      u.preventDefault(), u.stopImmediatePropagation()
      const d = n.property('__zoom').k || 1
      if (u.ctrlKey && i) {
        const x = sn(u),
          m = ag(u),
          v = d * Math.pow(2, m)
        o.scaleTo(n, v, x, u)
        return
      }
      const f = u.deltaMode === 1 ? 20 : 1
      let A = r === Bo.Vertical ? 0 : u.deltaX * f,
        h = r === Bo.Horizontal ? 0 : u.deltaY * f
      !Ha() && u.shiftKey && r !== Bo.Vertical && ((A = u.deltaY * f), (h = 0)), o.translateBy(n, -(A / d) * s, -(h / d) * s, { internal: !0 })
      const g = Za(n.property('__zoom'))
      clearTimeout(e.panScrollTimeout),
        e.isPanScrolling || ((e.isPanScrolling = !0), a == null || a(u, g)),
        e.isPanScrolling &&
          (l == null || l(u, g),
          (e.panScrollTimeout = setTimeout(() => {
            c == null || c(u, g), (e.isPanScrolling = !1)
          }, 150)))
    }
  }
  function m2({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
    return function (o, r) {
      if ((!t && o.type === 'wheel' && !o.ctrlKey) || Cr(o, e)) return null
      o.preventDefault(), n.call(this, o, r)
    }
  }
  function y2({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
    return o => {
      var s, i, a
      if ((s = o.sourceEvent) != null && s.internal) return
      const r = Za(o.transform)
      ;(e.mouseButton = ((i = o.sourceEvent) == null ? void 0 : i.button) || 0), (e.isZoomingOrPanning = !0), (e.prevViewport = r), ((a = o.sourceEvent) == null ? void 0 : a.type) === 'mousedown' && t(!0), n && (n == null || n(o.sourceEvent, r))
    }
  }
  function b2({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: o, onPanZoom: r }) {
    return s => {
      var i, a
      ;(e.usedRightMouseButton = !!(n && ig(t, e.mouseButton ?? 0))), ((i = s.sourceEvent) != null && i.sync) || o([s.transform.x, s.transform.y, s.transform.k]), r && !((a = s.sourceEvent) != null && a.internal) && (r == null || r(s.sourceEvent, Za(s.transform)))
    }
  }
  function v2({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: o, onPanZoomEnd: r, onPaneContextMenu: s }) {
    return i => {
      var a
      if (!((a = i.sourceEvent) != null && a.internal) && ((e.isZoomingOrPanning = !1), s && ig(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && i.sourceEvent && s(i.sourceEvent), (e.usedRightMouseButton = !1), o(!1), r && h2(e.prevViewport, i.transform))) {
        const l = Za(i.transform)
        ;(e.prevViewport = l),
          clearTimeout(e.timerId),
          (e.timerId = setTimeout(
            () => {
              r == null || r(i.sourceEvent, l)
            },
            n ? 150 : 0
          ))
      }
    }
  }
  function x2({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: o, panOnScroll: r, zoomOnDoubleClick: s, userSelectionActive: i, noWheelClassName: a, noPanClassName: l, lib: c }) {
    return u => {
      var h
      const d = e || t,
        f = n && u.ctrlKey
      if (u.button === 1 && u.type === 'mousedown' && (Cr(u, `${c}-flow__node`) || Cr(u, `${c}-flow__edge`))) return !0
      if ((!o && !d && !r && !s && !n) || i || (Cr(u, a) && u.type === 'wheel') || (Cr(u, l) && (u.type !== 'wheel' || (r && u.type === 'wheel' && !e))) || (!n && u.ctrlKey && u.type === 'wheel')) return !1
      if (!n && u.type === 'touchstart' && ((h = u.touches) == null ? void 0 : h.length) > 1) return u.preventDefault(), !1
      if ((!d && !r && !f && u.type === 'wheel') || (!o && (u.type === 'mousedown' || u.type === 'touchstart')) || (Array.isArray(o) && !o.includes(u.button) && u.type === 'mousedown')) return !1
      const A = (Array.isArray(o) && o.includes(u.button)) || !u.button || u.button <= 1
      return (!u.ctrlKey || u.type === 'wheel') && A
    }
  }
  function C2({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: o, translateExtent: r, viewport: s, onPanZoom: i, onPanZoomStart: a, onPanZoomEnd: l, onDraggingChange: c }) {
    const u = { isZoomingOrPanning: !1, usedRightMouseButton: !1, prevViewport: { x: 0, y: 0, zoom: 0 }, mouseButton: 0, timerId: void 0, panScrollTimeout: void 0, isPanScrolling: !1 },
      d = e.getBoundingClientRect(),
      f = wh()
        .clickDistance(!cn(o) || o < 0 ? 0 : o)
        .scaleExtent([t, n])
        .translateExtent(r),
      A = Tt(e).call(f)
    y(
      { x: s.x, y: s.y, zoom: br(s.zoom, t, n) },
      [
        [0, 0],
        [d.width, d.height],
      ],
      r
    )
    const h = A.on('wheel.zoom'),
      g = A.on('dblclick.zoom')
    f.wheelDelta(ag)
    function x(Q, R) {
      return A
        ? new Promise(S => {
            f == null ||
              f.transform(
                Gu(A, R == null ? void 0 : R.duration, () => S(!0)),
                Q
              )
          })
        : Promise.resolve(!1)
    }
    function m({ noWheelClassName: Q, noPanClassName: R, onPaneContextMenu: S, userSelectionActive: L, panOnScroll: I, panOnDrag: z, panOnScrollMode: B, panOnScrollSpeed: O, preventScrolling: W, zoomOnPinch: K, zoomOnScroll: Z, zoomOnDoubleClick: oe, zoomActivationKeyPressed: V, lib: q, onTransformChange: ee }) {
      L && !u.isZoomingOrPanning && v()
      const J = I && !V && !L ? g2({ zoomPanValues: u, noWheelClassName: Q, d3Selection: A, d3Zoom: f, panOnScrollMode: B, panOnScrollSpeed: O, zoomOnPinch: K, onPanZoomStart: a, onPanZoom: i, onPanZoomEnd: l }) : m2({ noWheelClassName: Q, preventScrolling: W, d3ZoomHandler: h })
      if ((A.on('wheel.zoom', J, { passive: !1 }), !L)) {
        const Ae = y2({ zoomPanValues: u, onDraggingChange: c, onPanZoomStart: a })
        f.on('start', Ae)
        const ae = b2({ zoomPanValues: u, panOnDrag: z, onPaneContextMenu: !!S, onPanZoom: i, onTransformChange: ee })
        f.on('zoom', ae)
        const se = v2({ zoomPanValues: u, panOnDrag: z, panOnScroll: I, onPaneContextMenu: S, onPanZoomEnd: l, onDraggingChange: c })
        f.on('end', se)
      }
      const ie = x2({ zoomActivationKeyPressed: V, panOnDrag: z, zoomOnScroll: Z, panOnScroll: I, zoomOnDoubleClick: oe, zoomOnPinch: K, userSelectionActive: L, noPanClassName: R, noWheelClassName: Q, lib: q })
      f.filter(ie), oe ? A.on('dblclick.zoom', g) : A.on('dblclick.zoom', null)
    }
    function v() {
      f.on('zoom', null)
    }
    async function y(Q, R, S) {
      const L = Wu(Q),
        I = f == null ? void 0 : f.constrain()(L, R, S)
      return I && (await x(I)), new Promise(z => z(I))
    }
    async function b(Q, R) {
      const S = Wu(Q)
      return await x(S, R), new Promise(L => L(S))
    }
    function w(Q) {
      if (A) {
        const R = Wu(Q),
          S = A.property('__zoom')
        ;(S.k !== Q.zoom || S.x !== Q.x || S.y !== Q.y) && (f == null || f.transform(A, R, null, { sync: !0 }))
      }
    }
    function k() {
      const Q = A ? xh(A.node()) : { x: 0, y: 0, k: 1 }
      return { x: Q.x, y: Q.y, zoom: Q.k }
    }
    function E(Q, R) {
      return A
        ? new Promise(S => {
            f == null ||
              f.scaleTo(
                Gu(A, R == null ? void 0 : R.duration, () => S(!0)),
                Q
              )
          })
        : Promise.resolve(!1)
    }
    function P(Q, R) {
      return A
        ? new Promise(S => {
            f == null ||
              f.scaleBy(
                Gu(A, R == null ? void 0 : R.duration, () => S(!0)),
                Q
              )
          })
        : Promise.resolve(!1)
    }
    function T(Q) {
      f == null || f.scaleExtent(Q)
    }
    function F(Q) {
      f == null || f.translateExtent(Q)
    }
    function D(Q) {
      const R = !cn(Q) || Q < 0 ? 0 : Q
      f == null || f.clickDistance(R)
    }
    return { update: m, destroy: v, setViewport: b, setViewportConstrained: y, getViewport: k, scaleTo: E, scaleBy: P, setScaleExtent: T, setTranslateExtent: F, syncViewport: w, setClickDistance: D }
  }
  var ks
  ;(function (e) {
    ;(e.Line = 'line'), (e.Handle = 'handle')
  })(ks || (ks = {}))
  function w2({ width: e, prevWidth: t, height: n, prevHeight: o, affectsX: r, affectsY: s }) {
    const i = e - t,
      a = n - o,
      l = [i > 0 ? 1 : i < 0 ? -1 : 0, a > 0 ? 1 : a < 0 ? -1 : 0]
    return i && r && (l[0] = l[0] * -1), a && s && (l[1] = l[1] * -1), l
  }
  function E2(e) {
    const t = e.includes('right') || e.includes('left'),
      n = e.includes('bottom') || e.includes('top'),
      o = e.includes('left'),
      r = e.includes('top')
    return { isHorizontal: t, isVertical: n, affectsX: o, affectsY: r }
  }
  function Jn(e, t) {
    return Math.max(0, t - e)
  }
  function _n(e, t) {
    return Math.max(0, e - t)
  }
  function Ja(e, t, n) {
    return Math.max(0, t - e, e - n)
  }
  function lg(e, t) {
    return e ? !t : t
  }
  function S2(e, t, n, o, r, s, i, a) {
    let { affectsX: l, affectsY: c } = t
    const { isHorizontal: u, isVertical: d } = t,
      f = u && d,
      { xSnapped: A, ySnapped: h } = n,
      { minWidth: g, maxWidth: x, minHeight: m, maxHeight: v } = o,
      { x: y, y: b, width: w, height: k, aspectRatio: E } = e
    let P = Math.floor(u ? A - e.pointerX : 0),
      T = Math.floor(d ? h - e.pointerY : 0)
    const F = w + (l ? -P : P),
      D = k + (c ? -T : T),
      Q = -s[0] * w,
      R = -s[1] * k
    let S = Ja(F, g, x),
      L = Ja(D, m, v)
    if (i) {
      let B = 0,
        O = 0
      l && P < 0 ? (B = Jn(y + P + Q, i[0][0])) : !l && P > 0 && (B = _n(y + F + Q, i[1][0])), c && T < 0 ? (O = Jn(b + T + R, i[0][1])) : !c && T > 0 && (O = _n(b + D + R, i[1][1])), (S = Math.max(S, B)), (L = Math.max(L, O))
    }
    if (a) {
      let B = 0,
        O = 0
      l && P > 0 ? (B = _n(y + P, a[0][0])) : !l && P < 0 && (B = Jn(y + F, a[1][0])), c && T > 0 ? (O = _n(b + T, a[0][1])) : !c && T < 0 && (O = Jn(b + D, a[1][1])), (S = Math.max(S, B)), (L = Math.max(L, O))
    }
    if (r) {
      if (u) {
        const B = Ja(F / E, m, v) * E
        if (((S = Math.max(S, B)), i)) {
          let O = 0
          ;(!l && !c) || (l && !c && f) ? (O = _n(b + R + F / E, i[1][1]) * E) : (O = Jn(b + R + (l ? P : -P) / E, i[0][1]) * E), (S = Math.max(S, O))
        }
        if (a) {
          let O = 0
          ;(!l && !c) || (l && !c && f) ? (O = Jn(b + F / E, a[1][1]) * E) : (O = _n(b + (l ? P : -P) / E, a[0][1]) * E), (S = Math.max(S, O))
        }
      }
      if (d) {
        const B = Ja(D * E, g, x) / E
        if (((L = Math.max(L, B)), i)) {
          let O = 0
          ;(!l && !c) || (c && !l && f) ? (O = _n(y + D * E + Q, i[1][0]) / E) : (O = Jn(y + (c ? T : -T) * E + Q, i[0][0]) / E), (L = Math.max(L, O))
        }
        if (a) {
          let O = 0
          ;(!l && !c) || (c && !l && f) ? (O = Jn(y + D * E, a[1][0]) / E) : (O = _n(y + (c ? T : -T) * E, a[0][0]) / E), (L = Math.max(L, O))
        }
      }
    }
    ;(T = T + (T < 0 ? L : -L)), (P = P + (P < 0 ? S : -S)), r && (f ? (F > D * E ? (T = (lg(l, c) ? -P : P) / E) : (P = (lg(l, c) ? -T : T) * E)) : u ? ((T = P / E), (c = l)) : ((P = T * E), (l = c)))
    const I = l ? y + P : y,
      z = c ? b + T : b
    return { width: w + (l ? -P : P), height: k + (c ? -T : T), x: s[0] * P * (l ? -1 : 1) + I, y: s[1] * T * (c ? -1 : 1) + z }
  }
  const cg = { width: 0, height: 0, x: 0, y: 0 },
    B2 = { ...cg, pointerX: 0, pointerY: 0, aspectRatio: 1 }
  function I2(e) {
    return [
      [0, 0],
      [e.measured.width, e.measured.height],
    ]
  }
  function k2(e, t, n) {
    const o = t.position.x + e.position.x,
      r = t.position.y + e.position.y,
      s = e.measured.width ?? 0,
      i = e.measured.height ?? 0,
      a = n[0] * s,
      l = n[1] * i
    return [
      [o - a, r - l],
      [o + s - a, r + i - l],
    ]
  }
  function N2({ domNode: e, nodeId: t, getStoreItems: n, onChange: o, onEnd: r }) {
    const s = Tt(e)
    function i({ controlPosition: l, boundaries: c, keepAspectRatio: u, onResizeStart: d, onResize: f, onResizeEnd: A, shouldResize: h }) {
      let g = { ...cg },
        x = { ...B2 }
      const m = E2(l)
      let v,
        y = null,
        b = [],
        w,
        k,
        E
      const P = du()
        .on('start', T => {
          const { nodeLookup: F, transform: D, snapGrid: Q, snapToGrid: R, nodeOrigin: S, paneDomNode: L } = n()
          if (((v = F.get(t)), !v)) return
          y = (L == null ? void 0 : L.getBoundingClientRect()) ?? null
          const { xSnapped: I, ySnapped: z } = Bs(T.sourceEvent, { transform: D, snapGrid: Q, snapToGrid: R, containerBounds: y })
          ;(g = { width: v.measured.width ?? 0, height: v.measured.height ?? 0, x: v.position.x ?? 0, y: v.position.y ?? 0 }),
            (x = { ...g, pointerX: I, pointerY: z, aspectRatio: g.width / g.height }),
            (w = void 0),
            v.parentId && (v.extent === 'parent' || v.expandParent) && ((w = F.get(v.parentId)), (k = w && v.extent === 'parent' ? I2(w) : void 0)),
            (b = []),
            (E = void 0)
          for (const [B, O] of F)
            if (O.parentId === t && (b.push({ id: B, position: { ...O.position }, extent: O.extent }), O.extent === 'parent' || O.expandParent)) {
              const W = k2(O, v, O.origin ?? S)
              E
                ? (E = [
                    [Math.min(W[0][0], E[0][0]), Math.min(W[0][1], E[0][1])],
                    [Math.max(W[1][0], E[1][0]), Math.max(W[1][1], E[1][1])],
                  ])
                : (E = W)
            }
          d == null || d(T, { ...g })
        })
        .on('drag', T => {
          const { transform: F, snapGrid: D, snapToGrid: Q, nodeOrigin: R } = n(),
            S = Bs(T.sourceEvent, { transform: F, snapGrid: D, snapToGrid: Q, containerBounds: y }),
            L = []
          if (!v) return
          const { x: I, y: z, width: B, height: O } = g,
            W = {},
            K = v.origin ?? R,
            { width: Z, height: oe, x: V, y: q } = S2(x, m, S, c, u, K, k, E),
            ee = Z !== B,
            re = oe !== O,
            J = V !== I && ee,
            ie = q !== z && re
          if (!J && !ie && !ee && !re) return
          if ((J || ie || K[0] === 1 || K[1] === 1) && ((W.x = J ? V : g.x), (W.y = ie ? q : g.y), (g.x = W.x), (g.y = W.y), b.length > 0)) {
            const H = V - I,
              U = q - z
            for (const te of b) (te.position = { x: te.position.x - H + K[0] * (Z - B), y: te.position.y - U + K[1] * (oe - O) }), L.push(te)
          }
          if (((ee || re) && ((W.width = ee ? Z : g.width), (W.height = re ? oe : g.height), (g.width = W.width), (g.height = W.height)), w && v.expandParent)) {
            const H = K[0] * (W.width ?? 0)
            W.x && W.x < H && ((g.x = H), (x.x = x.x - (W.x - H)))
            const U = K[1] * (W.height ?? 0)
            W.y && W.y < U && ((g.y = U), (x.y = x.y - (W.y - U)))
          }
          const Ae = w2({ width: g.width, prevWidth: B, height: g.height, prevHeight: O, affectsX: m.affectsX, affectsY: m.affectsY }),
            ae = { ...g, direction: Ae }
          ;(h == null ? void 0 : h(T, ae)) !== !1 && (f == null || f(T, ae), o(W, L))
        })
        .on('end', T => {
          A == null || A(T, { ...g }), r == null || r()
        })
      s.call(P)
    }
    function a() {
      s.on('.drag', null)
    }
    return { update: i, destroy: a }
  }
  var ug = { exports: {} },
    dg = {},
    fg = { exports: {} },
    Ag = {}
  /**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var wr = C
  function M2(e, t) {
    return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
  }
  var P2 = typeof Object.is == 'function' ? Object.is : M2,
    L2 = wr.useState,
    T2 = wr.useEffect,
    F2 = wr.useLayoutEffect,
    D2 = wr.useDebugValue
  function z2(e, t) {
    var n = t(),
      o = L2({ inst: { value: n, getSnapshot: t } }),
      r = o[0].inst,
      s = o[1]
    return (
      F2(
        function () {
          ;(r.value = n), (r.getSnapshot = t), Vu(r) && s({ inst: r })
        },
        [e, n, t]
      ),
      T2(
        function () {
          return (
            Vu(r) && s({ inst: r }),
            e(function () {
              Vu(r) && s({ inst: r })
            })
          )
        },
        [e]
      ),
      D2(n),
      n
    )
  }
  function Vu(e) {
    var t = e.getSnapshot
    e = e.value
    try {
      var n = t()
      return !P2(e, n)
    } catch {
      return !0
    }
  }
  function Q2(e, t) {
    return t()
  }
  var R2 = typeof window > 'u' || typeof window.document > 'u' || typeof window.document.createElement > 'u' ? Q2 : z2
  ;(Ag.useSyncExternalStore = wr.useSyncExternalStore !== void 0 ? wr.useSyncExternalStore : R2), (fg.exports = Ag)
  var O2 = fg.exports
  /**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var _a = C,
    j2 = O2
  function W2(e, t) {
    return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
  }
  var G2 = typeof Object.is == 'function' ? Object.is : W2,
    V2 = j2.useSyncExternalStore,
    X2 = _a.useRef,
    Y2 = _a.useEffect,
    H2 = _a.useMemo,
    U2 = _a.useDebugValue
  ;(dg.useSyncExternalStoreWithSelector = function (e, t, n, o, r) {
    var s = X2(null)
    if (s.current === null) {
      var i = { hasValue: !1, value: null }
      s.current = i
    } else i = s.current
    s = H2(
      function () {
        function l(A) {
          if (!c) {
            if (((c = !0), (u = A), (A = o(A)), r !== void 0 && i.hasValue)) {
              var h = i.value
              if (r(h, A)) return (d = h)
            }
            return (d = A)
          }
          if (((h = d), G2(u, A))) return h
          var g = o(A)
          return r !== void 0 && r(h, g) ? h : ((u = A), (d = g))
        }
        var c = !1,
          u,
          d,
          f = n === void 0 ? null : n
        return [
          function () {
            return l(t())
          },
          f === null
            ? void 0
            : function () {
                return l(f())
              },
        ]
      },
      [t, n, o, r]
    )
    var a = V2(e, s[0], s[1])
    return (
      Y2(
        function () {
          ;(i.hasValue = !0), (i.value = a)
        },
        [a]
      ),
      U2(a),
      a
    )
  }),
    (ug.exports = dg)
  var K2 = ug.exports
  const q2 = $d(K2),
    pg = e => {
      let t
      const n = new Set(),
        o = (u, d) => {
          const f = typeof u == 'function' ? u(t) : u
          if (!Object.is(f, t)) {
            const A = t
            ;(t = d ?? (typeof f != 'object' || f === null) ? f : Object.assign({}, t, f)), n.forEach(h => h(t, A))
          }
        },
        r = () => t,
        l = {
          setState: o,
          getState: r,
          getInitialState: () => c,
          subscribe: u => (n.add(u), () => n.delete(u)),
          destroy: () => {
            n.clear()
          },
        },
        c = (t = e(o, r, l))
      return l
    },
    Z2 = e => (e ? pg(e) : pg),
    { useDebugValue: J2 } = C,
    { useSyncExternalStoreWithSelector: _2 } = q2,
    $2 = e => e
  function hg(e, t = $2, n) {
    const o = _2(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n)
    return J2(o), o
  }
  const gg = (e, t) => {
      const n = Z2(e),
        o = (r, s = t) => hg(n, r, s)
      return Object.assign(o, n), o
    },
    eL = (e, t) => (e ? gg(e, t) : gg)
  function it(e, t) {
    if (Object.is(e, t)) return !0
    if (typeof e != 'object' || e === null || typeof t != 'object' || t === null) return !1
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size) return !1
      for (const [o, r] of e) if (!Object.is(r, t.get(o))) return !1
      return !0
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size) return !1
      for (const o of e) if (!t.has(o)) return !1
      return !0
    }
    const n = Object.keys(e)
    if (n.length !== Object.keys(t).length) return !1
    for (const o of n) if (!Object.prototype.hasOwnProperty.call(t, o) || !Object.is(e[o], t[o])) return !1
    return !0
  }
  const $a = C.createContext(null),
    tL = $a.Provider,
    mg = zn.error001()
  function ke(e, t) {
    const n = C.useContext($a)
    if (n === null) throw new Error(mg)
    return hg(n, e, t)
  }
  function qe() {
    const e = C.useContext($a)
    if (e === null) throw new Error(mg)
    return C.useMemo(() => ({ getState: e.getState, setState: e.setState, subscribe: e.subscribe }), [e])
  }
  const yg = { display: 'none' },
    nL = { position: 'absolute', width: 1, height: 1, margin: -1, border: 0, padding: 0, overflow: 'hidden', clip: 'rect(0px, 0px, 0px, 0px)', clipPath: 'inset(100%)' },
    bg = 'react-flow__node-desc',
    vg = 'react-flow__edge-desc',
    oL = 'react-flow__aria-live',
    rL = e => e.ariaLiveMessage
  function sL({ rfId: e }) {
    const t = ke(rL)
    return p.jsx('div', { id: `${oL}-${e}`, 'aria-live': 'assertive', 'aria-atomic': 'true', style: nL, children: t })
  }
  function iL({ rfId: e, disableKeyboardA11y: t }) {
    return p.jsxs(p.Fragment, {
      children: [
        p.jsxs('div', { id: `${bg}-${e}`, style: yg, children: ['Press enter or space to select a node.', !t && 'You can then use the arrow keys to move the node around.', ' Press delete to remove it and escape to cancel.', ' '] }),
        p.jsx('div', { id: `${vg}-${e}`, style: yg, children: 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.' }),
        !t && p.jsx(sL, { rfId: e }),
      ],
    })
  }
  const aL = e => (e.userSelectionActive ? 'none' : 'all'),
    el = C.forwardRef(({ position: e = 'top-left', children: t, className: n, style: o, ...r }, s) => {
      const i = ke(aL),
        a = `${e}`.split('-')
      return p.jsx('div', { className: dt(['react-flow__panel', n, ...a]), style: { ...o, pointerEvents: i }, ref: s, ...r, children: t })
    })
  function lL({ proOptions: e, position: t = 'bottom-right' }) {
    return e != null && e.hideAttribution
      ? null
      : p.jsx(el, {
          position: t,
          className: 'react-flow__attribution',
          'data-message': 'Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev',
          children: p.jsx('a', { href: 'https://reactflow.dev', target: '_blank', rel: 'noopener noreferrer', 'aria-label': 'React Flow attribution', children: 'React Flow' }),
        })
  }
  const cL = e => {
      const t = [],
        n = []
      for (const [, o] of e.nodeLookup) o.selected && t.push(o.internals.userNode)
      for (const [, o] of e.edgeLookup) o.selected && n.push(o)
      return { selectedNodes: t, selectedEdges: n }
    },
    tl = e => e.id
  function uL(e, t) {
    return it(e.selectedNodes.map(tl), t.selectedNodes.map(tl)) && it(e.selectedEdges.map(tl), t.selectedEdges.map(tl))
  }
  function dL({ onSelectionChange: e }) {
    const t = qe(),
      { selectedNodes: n, selectedEdges: o } = ke(cL, uL)
    return (
      C.useEffect(() => {
        const r = { nodes: n, edges: o }
        e == null || e(r), t.getState().onSelectionChangeHandlers.forEach(s => s(r))
      }, [n, o, e]),
      null
    )
  }
  const fL = e => !!e.onSelectionChangeHandlers
  function AL({ onSelectionChange: e }) {
    const t = ke(fL)
    return e || t ? p.jsx(dL, { onSelectionChange: e }) : null
  }
  const xg = [0, 0],
    pL = { x: 0, y: 0, zoom: 1 },
    Cg = [
      ...[
        'nodes',
        'edges',
        'defaultNodes',
        'defaultEdges',
        'onConnect',
        'onConnectStart',
        'onConnectEnd',
        'onClickConnectStart',
        'onClickConnectEnd',
        'nodesDraggable',
        'nodesConnectable',
        'nodesFocusable',
        'edgesFocusable',
        'edgesReconnectable',
        'elevateNodesOnSelect',
        'elevateEdgesOnSelect',
        'minZoom',
        'maxZoom',
        'nodeExtent',
        'onNodesChange',
        'onEdgesChange',
        'elementsSelectable',
        'connectionMode',
        'snapGrid',
        'snapToGrid',
        'translateExtent',
        'connectOnClick',
        'defaultEdgeOptions',
        'fitView',
        'fitViewOptions',
        'onNodesDelete',
        'onEdgesDelete',
        'onDelete',
        'onNodeDrag',
        'onNodeDragStart',
        'onNodeDragStop',
        'onSelectionDrag',
        'onSelectionDragStart',
        'onSelectionDragStop',
        'onMoveStart',
        'onMove',
        'onMoveEnd',
        'noPanClassName',
        'nodeOrigin',
        'autoPanOnConnect',
        'autoPanOnNodeDrag',
        'onError',
        'connectionRadius',
        'isValidConnection',
        'selectNodesOnDrag',
        'nodeDragThreshold',
        'onBeforeDelete',
        'debug',
        'autoPanSpeed',
        'paneClickDistance',
      ],
      'rfId',
    ],
    hL = e => ({ setNodes: e.setNodes, setEdges: e.setEdges, setMinZoom: e.setMinZoom, setMaxZoom: e.setMaxZoom, setTranslateExtent: e.setTranslateExtent, setNodeExtent: e.setNodeExtent, reset: e.reset, setDefaultNodesAndEdges: e.setDefaultNodesAndEdges, setPaneClickDistance: e.setPaneClickDistance }),
    wg = { translateExtent: vs, nodeOrigin: xg, minZoom: 0.5, maxZoom: 2, elementsSelectable: !0, noPanClassName: 'nopan', rfId: '1', paneClickDistance: 0 }
  function gL(e) {
    const { setNodes: t, setEdges: n, setMinZoom: o, setMaxZoom: r, setTranslateExtent: s, setNodeExtent: i, reset: a, setDefaultNodesAndEdges: l, setPaneClickDistance: c } = ke(hL, it),
      u = qe()
    C.useEffect(
      () => (
        l(e.defaultNodes, e.defaultEdges),
        () => {
          ;(d.current = wg), a()
        }
      ),
      []
    )
    const d = C.useRef(wg)
    return (
      C.useEffect(
        () => {
          for (const f of Cg) {
            const A = e[f],
              h = d.current[f]
            A !== h &&
              (typeof e[f] > 'u' ||
                (f === 'nodes'
                  ? t(A)
                  : f === 'edges'
                  ? n(A)
                  : f === 'minZoom'
                  ? o(A)
                  : f === 'maxZoom'
                  ? r(A)
                  : f === 'translateExtent'
                  ? s(A)
                  : f === 'nodeExtent'
                  ? i(A)
                  : f === 'paneClickDistance'
                  ? c(A)
                  : f === 'fitView'
                  ? u.setState({ fitViewOnInit: A })
                  : f === 'fitViewOptions'
                  ? u.setState({ fitViewOnInitOptions: A })
                  : u.setState({ [f]: A })))
          }
          d.current = e
        },
        Cg.map(f => e[f])
      ),
      null
    )
  }
  function Eg() {
    return typeof window > 'u' || !window.matchMedia ? null : window.matchMedia('(prefers-color-scheme: dark)')
  }
  function mL(e) {
    var o
    const [t, n] = C.useState(e === 'system' ? null : e)
    return (
      C.useEffect(() => {
        if (e !== 'system') {
          n(e)
          return
        }
        const r = Eg(),
          s = () => n(r != null && r.matches ? 'dark' : 'light')
        return (
          s(),
          r == null || r.addEventListener('change', s),
          () => {
            r == null || r.removeEventListener('change', s)
          }
        )
      }, [e]),
      t !== null ? t : (o = Eg()) != null && o.matches ? 'dark' : 'light'
    )
  }
  const Sg = typeof document < 'u' ? document : null
  function Er(e = null, t = { target: Sg, actInsideInputWithModifier: !0 }) {
    const [n, o] = C.useState(!1),
      r = C.useRef(!1),
      s = C.useRef(new Set([])),
      [i, a] = C.useMemo(() => {
        if (e !== null) {
          const c = (Array.isArray(e) ? e : [e])
              .filter(d => typeof d == 'string')
              .map(d =>
                d
                  .replace(
                    '+',
                    `
`
                  )
                  .replace(
                    `

`,
                    `
+`
                  ).split(`
`)
              ),
            u = c.reduce((d, f) => d.concat(...f), [])
          return [c, u]
        }
        return [[], []]
      }, [e])
    return (
      C.useEffect(() => {
        const l = (t == null ? void 0 : t.target) || Sg
        if (e !== null) {
          const c = f => {
              if (((r.current = f.ctrlKey || f.metaKey || f.shiftKey), (!r.current || (r.current && !t.actInsideInputWithModifier)) && Pu(f))) return !1
              const h = Ig(f.code, a)
              s.current.add(f[h]), Bg(i, s.current, !1) && (f.preventDefault(), o(!0))
            },
            u = f => {
              if ((!r.current || (r.current && !t.actInsideInputWithModifier)) && Pu(f)) return !1
              const h = Ig(f.code, a)
              Bg(i, s.current, !0) ? (o(!1), s.current.clear()) : s.current.delete(f[h]), f.key === 'Meta' && s.current.clear(), (r.current = !1)
            },
            d = () => {
              s.current.clear(), o(!1)
            }
          return (
            l == null || l.addEventListener('keydown', c),
            l == null || l.addEventListener('keyup', u),
            window.addEventListener('blur', d),
            window.addEventListener('contextmenu', d),
            () => {
              l == null || l.removeEventListener('keydown', c), l == null || l.removeEventListener('keyup', u), window.removeEventListener('blur', d), window.removeEventListener('contextmenu', d)
            }
          )
        }
      }, [e, o]),
      n
    )
  }
  function Bg(e, t, n) {
    return e.filter(o => n || o.length === t.size).some(o => o.every(r => t.has(r)))
  }
  function Ig(e, t) {
    return t.includes(e) ? 'code' : 'key'
  }
  const yL = () => {
    const e = qe()
    return C.useMemo(
      () => ({
        zoomIn: t => {
          const { panZoom: n } = e.getState()
          return n ? n.scaleBy(1.2, { duration: t == null ? void 0 : t.duration }) : Promise.resolve(!1)
        },
        zoomOut: t => {
          const { panZoom: n } = e.getState()
          return n ? n.scaleBy(1 / 1.2, { duration: t == null ? void 0 : t.duration }) : Promise.resolve(!1)
        },
        zoomTo: (t, n) => {
          const { panZoom: o } = e.getState()
          return o ? o.scaleTo(t, { duration: n == null ? void 0 : n.duration }) : Promise.resolve(!1)
        },
        getZoom: () => e.getState().transform[2],
        setViewport: async (t, n) => {
          const {
            transform: [o, r, s],
            panZoom: i,
          } = e.getState()
          return i ? (await i.setViewport({ x: t.x ?? o, y: t.y ?? r, zoom: t.zoom ?? s }, { duration: n == null ? void 0 : n.duration }), Promise.resolve(!0)) : Promise.resolve(!1)
        },
        getViewport: () => {
          const [t, n, o] = e.getState().transform
          return { x: t, y: n, zoom: o }
        },
        fitView: t => {
          const { nodeLookup: n, minZoom: o, maxZoom: r, panZoom: s, domNode: i } = e.getState()
          if (!s || !i) return Promise.resolve(!1)
          const a = Iu(n, t),
            { width: l, height: c } = Ua(i)
          return ku({ nodes: a, width: l, height: c, minZoom: o, maxZoom: r, panZoom: s }, t)
        },
        setCenter: async (t, n, o) => {
          const { width: r, height: s, maxZoom: i, panZoom: a } = e.getState(),
            l = typeof (o == null ? void 0 : o.zoom) < 'u' ? o.zoom : i,
            c = r / 2 - t * l,
            u = s / 2 - n * l
          return a ? (await a.setViewport({ x: c, y: u, zoom: l }, { duration: o == null ? void 0 : o.duration }), Promise.resolve(!0)) : Promise.resolve(!1)
        },
        fitBounds: async (t, n) => {
          const { width: o, height: r, minZoom: s, maxZoom: i, panZoom: a } = e.getState(),
            l = Mu(t, o, r, s, i, (n == null ? void 0 : n.padding) ?? 0.1)
          return a ? (await a.setViewport(l, { duration: n == null ? void 0 : n.duration }), Promise.resolve(!0)) : Promise.resolve(!1)
        },
        screenToFlowPosition: (t, n = { snapToGrid: !0 }) => {
          const { transform: o, snapGrid: r, domNode: s } = e.getState()
          if (!s) return t
          const { x: i, y: a } = s.getBoundingClientRect(),
            l = { x: t.x - i, y: t.y - a }
          return Ss(l, o, n.snapToGrid, r)
        },
        flowToScreenPosition: t => {
          const { transform: n, domNode: o } = e.getState()
          if (!o) return t
          const { x: r, y: s } = o.getBoundingClientRect(),
            i = zh(t, n)
          return { x: i.x + r, y: i.y + s }
        },
      }),
      []
    )
  }
  function kg(e, t) {
    const n = [],
      o = new Map(),
      r = []
    for (const s of e)
      if (s.type === 'add') {
        r.push(s)
        continue
      } else if (s.type === 'remove' || s.type === 'replace') o.set(s.id, [s])
      else {
        const i = o.get(s.id)
        i ? i.push(s) : o.set(s.id, [s])
      }
    for (const s of t) {
      const i = o.get(s.id)
      if (!i) {
        n.push(s)
        continue
      }
      if (i[0].type === 'remove') continue
      if (i[0].type === 'replace') {
        n.push({ ...i[0].item })
        continue
      }
      const a = { ...s }
      for (const l of i) bL(l, a)
      n.push(a)
    }
    return (
      r.length &&
        r.forEach(s => {
          s.index !== void 0 ? n.splice(s.index, 0, { ...s.item }) : n.push({ ...s.item })
        }),
      n
    )
  }
  function bL(e, t) {
    switch (e.type) {
      case 'select': {
        t.selected = e.selected
        break
      }
      case 'position': {
        typeof e.position < 'u' && (t.position = e.position), typeof e.dragging < 'u' && (t.dragging = e.dragging)
        break
      }
      case 'dimensions': {
        typeof e.dimensions < 'u' && (t.measured ?? (t.measured = {}), (t.measured.width = e.dimensions.width), (t.measured.height = e.dimensions.height), e.setAttributes && ((t.width = e.dimensions.width), (t.height = e.dimensions.height))), typeof e.resizing == 'boolean' && (t.resizing = e.resizing)
        break
      }
    }
  }
  function Ng(e, t) {
    return kg(e, t)
  }
  function Mg(e, t) {
    return kg(e, t)
  }
  function ko(e, t) {
    return { id: e, type: 'select', selected: t }
  }
  function Sr(e, t = new Set(), n = !1) {
    const o = []
    for (const [r, s] of e) {
      const i = t.has(r)
      !(s.selected === void 0 && !i) && s.selected !== i && (n && (s.selected = i), o.push(ko(s.id, i)))
    }
    return o
  }
  function Pg({ items: e = [], lookup: t }) {
    var r
    const n = [],
      o = new Map(e.map(s => [s.id, s]))
    for (const [s, i] of e.entries()) {
      const a = t.get(i.id),
        l = ((r = a == null ? void 0 : a.internals) == null ? void 0 : r.userNode) ?? a
      l !== void 0 && l !== i && n.push({ id: i.id, item: i, type: 'replace' }), l === void 0 && n.push({ item: i, type: 'add', index: s })
    }
    for (const [s] of t) o.get(s) === void 0 && n.push({ id: s, type: 'remove' })
    return n
  }
  function Lg(e) {
    return { id: e.id, type: 'remove' }
  }
  const Tg = e => WP(e),
    vL = e => kh(e)
  function Fg(e) {
    return C.forwardRef(e)
  }
  const xL = typeof window < 'u' ? C.useLayoutEffect : C.useEffect
  function Dg(e) {
    const [t, n] = C.useState(BigInt(0)),
      [o] = C.useState(() => CL(() => n(r => r + BigInt(1))))
    return (
      xL(() => {
        const r = o.get()
        r.length && (e(r), o.reset())
      }, [t]),
      o
    )
  }
  function CL(e) {
    let t = []
    return {
      get: () => t,
      reset: () => {
        t = []
      },
      push: n => {
        t.push(n), e()
      },
    }
  }
  const zg = C.createContext(null)
  function wL({ children: e }) {
    const t = qe(),
      n = C.useCallback(a => {
        const { nodes: l = [], setNodes: c, hasDefaultNodes: u, onNodesChange: d, nodeLookup: f } = t.getState()
        let A = l
        for (const h of a) A = typeof h == 'function' ? h(A) : h
        u ? c(A) : d && d(Pg({ items: A, lookup: f }))
      }, []),
      o = Dg(n),
      r = C.useCallback(a => {
        const { edges: l = [], setEdges: c, hasDefaultEdges: u, onEdgesChange: d, edgeLookup: f } = t.getState()
        let A = l
        for (const h of a) A = typeof h == 'function' ? h(A) : h
        u ? c(A) : d && d(Pg({ items: A, lookup: f }))
      }, []),
      s = Dg(r),
      i = C.useMemo(() => ({ nodeQueue: o, edgeQueue: s }), [])
    return p.jsx(zg.Provider, { value: i, children: e })
  }
  function EL() {
    const e = C.useContext(zg)
    if (!e) throw new Error('useBatchContext must be used within a BatchProvider')
    return e
  }
  const SL = e => !!e.panZoom
  function No() {
    const e = yL(),
      t = qe(),
      n = EL(),
      o = ke(SL),
      r = C.useMemo(() => {
        const s = d => t.getState().nodeLookup.get(d),
          i = d => {
            n.nodeQueue.push(d)
          },
          a = d => {
            n.edgeQueue.push(d)
          },
          l = d => {
            var m, v
            const { nodeLookup: f, nodeOrigin: A } = t.getState(),
              h = Tg(d) ? d : f.get(d.id),
              g = h.parentId ? Rh(h.position, h.measured, h.parentId, f, A) : h.position,
              x = { ...h, position: g, width: ((m = h.measured) == null ? void 0 : m.width) ?? h.width, height: ((v = h.measured) == null ? void 0 : v.height) ?? h.height }
            return vr(x)
          },
          c = (d, f, A = { replace: !1 }) => {
            i(h =>
              h.map(g => {
                if (g.id === d) {
                  const x = typeof f == 'function' ? f(g) : f
                  return A.replace && Tg(x) ? x : { ...g, ...x }
                }
                return g
              })
            )
          },
          u = (d, f, A = { replace: !1 }) => {
            a(h =>
              h.map(g => {
                if (g.id === d) {
                  const x = typeof f == 'function' ? f(g) : f
                  return A.replace && vL(x) ? x : { ...g, ...x }
                }
                return g
              })
            )
          }
        return {
          getNodes: () => t.getState().nodes.map(d => ({ ...d })),
          getNode: d => {
            var f
            return (f = s(d)) == null ? void 0 : f.internals.userNode
          },
          getInternalNode: s,
          getEdges: () => {
            const { edges: d = [] } = t.getState()
            return d.map(f => ({ ...f }))
          },
          getEdge: d => t.getState().edgeLookup.get(d),
          setNodes: i,
          setEdges: a,
          addNodes: d => {
            const f = Array.isArray(d) ? d : [d]
            n.nodeQueue.push(A => [...A, ...f])
          },
          addEdges: d => {
            const f = Array.isArray(d) ? d : [d]
            n.edgeQueue.push(A => [...A, ...f])
          },
          toObject: () => {
            const { nodes: d = [], edges: f = [], transform: A } = t.getState(),
              [h, g, x] = A
            return { nodes: d.map(m => ({ ...m })), edges: f.map(m => ({ ...m })), viewport: { x: h, y: g, zoom: x } }
          },
          deleteElements: async ({ nodes: d = [], edges: f = [] }) => {
            const { nodes: A, edges: h, onNodesDelete: g, onEdgesDelete: x, triggerNodeChanges: m, triggerEdgeChanges: v, onDelete: y, onBeforeDelete: b } = t.getState(),
              { nodes: w, edges: k } = await VP({ nodesToRemove: d, edgesToRemove: f, nodes: A, edges: h, onBeforeDelete: b }),
              E = k.length > 0,
              P = w.length > 0
            if (E) {
              const T = k.map(Lg)
              x == null || x(k), v(T)
            }
            if (P) {
              const T = w.map(Lg)
              g == null || g(w), m(T)
            }
            return (P || E) && (y == null || y({ nodes: w, edges: k })), { deletedNodes: w, deletedEdges: k }
          },
          getIntersectingNodes: (d, f = !0, A) => {
            const h = Dh(d),
              g = h ? d : l(d),
              x = A !== void 0
            return g
              ? (A || t.getState().nodes).filter(m => {
                  const v = t.getState().nodeLookup.get(m.id)
                  if (v && !h && (m.id === d.id || !v.internals.positionAbsolute)) return !1
                  const y = vr(x ? m : v),
                    b = Es(y, g)
                  return (f && b > 0) || b >= g.width * g.height
                })
              : []
          },
          isNodeIntersecting: (d, f, A = !0) => {
            const g = Dh(d) ? d : l(d)
            if (!g) return !1
            const x = Es(g, f)
            return (A && x > 0) || x >= g.width * g.height
          },
          updateNode: c,
          updateNodeData: (d, f, A = { replace: !1 }) => {
            c(
              d,
              h => {
                const g = typeof f == 'function' ? f(h) : f
                return A.replace ? { ...h, data: g } : { ...h, data: { ...h.data, ...g } }
              },
              A
            )
          },
          updateEdge: u,
          updateEdgeData: (d, f, A = { replace: !1 }) => {
            u(
              d,
              h => {
                const g = typeof f == 'function' ? f(h) : f
                return A.replace ? { ...h, data: g } : { ...h, data: { ...h.data, ...g } }
              },
              A
            )
          },
          getNodesBounds: d => {
            const { nodeLookup: f, nodeOrigin: A } = t.getState()
            return GP(d, { nodeLookup: f, nodeOrigin: A })
          },
          getHandleConnections: ({ type: d, id: f, nodeId: A }) => {
            var h
            return Array.from(((h = t.getState().connectionLookup.get(`${A}-${d}-${f ?? null}`)) == null ? void 0 : h.values()) ?? [])
          },
        }
      }, [])
    return C.useMemo(() => ({ ...r, ...e, viewportInitialized: o }), [o])
  }
  const Qg = e => e.selected,
    BL = { actInsideInputWithModifier: !1 },
    IL = typeof window < 'u' ? window : void 0
  function kL({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
    const n = qe(),
      { deleteElements: o } = No(),
      r = Er(e, BL),
      s = Er(t, { target: IL })
    C.useEffect(() => {
      if (r) {
        const { edges: i, nodes: a } = n.getState()
        o({ nodes: a.filter(Qg), edges: i.filter(Qg) }), n.setState({ nodesSelectionActive: !1 })
      }
    }, [r]),
      C.useEffect(() => {
        n.setState({ multiSelectionActive: s })
      }, [s])
  }
  function NL(e) {
    const t = qe()
    C.useEffect(() => {
      const n = () => {
        var r, s
        if (!e.current) return !1
        const o = Ua(e.current)
        ;(o.height === 0 || o.width === 0) && ((s = (r = t.getState()).onError) == null || s.call(r, '004', zn.error004())), t.setState({ width: o.width || 500, height: o.height || 500 })
      }
      if (e.current) {
        n(), window.addEventListener('resize', n)
        const o = new ResizeObserver(() => n())
        return (
          o.observe(e.current),
          () => {
            window.removeEventListener('resize', n), o && e.current && o.unobserve(e.current)
          }
        )
      }
    }, [])
  }
  const nl = { position: 'absolute', width: '100%', height: '100%', top: 0, left: 0 },
    ML = e => ({ userSelectionActive: e.userSelectionActive, lib: e.lib })
  function PL({
    onPaneContextMenu: e,
    zoomOnScroll: t = !0,
    zoomOnPinch: n = !0,
    panOnScroll: o = !1,
    panOnScrollSpeed: r = 0.5,
    panOnScrollMode: s = Bo.Free,
    zoomOnDoubleClick: i = !0,
    panOnDrag: a = !0,
    defaultViewport: l,
    translateExtent: c,
    minZoom: u,
    maxZoom: d,
    zoomActivationKeyCode: f,
    preventScrolling: A = !0,
    children: h,
    noWheelClassName: g,
    noPanClassName: x,
    onViewportChange: m,
    isControlledViewport: v,
    paneClickDistance: y,
  }) {
    const b = qe(),
      w = C.useRef(null),
      { userSelectionActive: k, lib: E } = ke(ML, it),
      P = Er(f),
      T = C.useRef()
    NL(w)
    const F = C.useCallback(
      D => {
        m == null || m({ x: D[0], y: D[1], zoom: D[2] }), v || b.setState({ transform: D })
      },
      [m, v]
    )
    return (
      C.useEffect(() => {
        if (w.current) {
          T.current = C2({
            domNode: w.current,
            minZoom: u,
            maxZoom: d,
            translateExtent: c,
            viewport: l,
            paneClickDistance: y,
            onDraggingChange: S => b.setState({ paneDragging: S }),
            onPanZoomStart: (S, L) => {
              const { onViewportChangeStart: I, onMoveStart: z } = b.getState()
              z == null || z(S, L), I == null || I(L)
            },
            onPanZoom: (S, L) => {
              const { onViewportChange: I, onMove: z } = b.getState()
              z == null || z(S, L), I == null || I(L)
            },
            onPanZoomEnd: (S, L) => {
              const { onViewportChangeEnd: I, onMoveEnd: z } = b.getState()
              z == null || z(S, L), I == null || I(L)
            },
          })
          const { x: D, y: Q, zoom: R } = T.current.getViewport()
          return (
            b.setState({ panZoom: T.current, transform: [D, Q, R], domNode: w.current.closest('.react-flow') }),
            () => {
              var S
              ;(S = T.current) == null || S.destroy()
            }
          )
        }
      }, []),
      C.useEffect(() => {
        var D
        ;(D = T.current) == null || D.update({ onPaneContextMenu: e, zoomOnScroll: t, zoomOnPinch: n, panOnScroll: o, panOnScrollSpeed: r, panOnScrollMode: s, zoomOnDoubleClick: i, panOnDrag: a, zoomActivationKeyPressed: P, preventScrolling: A, noPanClassName: x, userSelectionActive: k, noWheelClassName: g, lib: E, onTransformChange: F })
      }, [e, t, n, o, r, s, i, a, P, A, x, k, g, E, F]),
      p.jsx('div', { className: 'react-flow__renderer', ref: w, style: nl, children: h })
    )
  }
  const LL = e => ({ userSelectionActive: e.userSelectionActive, userSelectionRect: e.userSelectionRect })
  function TL() {
    const { userSelectionActive: e, userSelectionRect: t } = ke(LL, it)
    return e && t ? p.jsx('div', { className: 'react-flow__selection react-flow__container', style: { width: t.width, height: t.height, transform: `translate(${t.x}px, ${t.y}px)` } }) : null
  }
  const Xu = (e, t) => n => {
      n.target === t.current && (e == null || e(n))
    },
    FL = e => ({ userSelectionActive: e.userSelectionActive, elementsSelectable: e.elementsSelectable, dragging: e.paneDragging })
  function DL({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = xs.Full, panOnDrag: o, selectionOnDrag: r, onSelectionStart: s, onSelectionEnd: i, onPaneClick: a, onPaneContextMenu: l, onPaneScroll: c, onPaneMouseEnter: u, onPaneMouseMove: d, onPaneMouseLeave: f, children: A }) {
    const h = C.useRef(null),
      g = qe(),
      x = C.useRef(0),
      m = C.useRef(0),
      v = C.useRef(),
      y = C.useRef(new Map()),
      { userSelectionActive: b, elementsSelectable: w, dragging: k } = ke(FL, it),
      E = w && (e || b),
      P = C.useRef(!1),
      T = C.useRef(!1),
      F = () => {
        g.setState({ userSelectionActive: !1, userSelectionRect: null }), (x.current = 0), (m.current = 0)
      },
      D = B => {
        if (P.current) {
          P.current = !1
          return
        }
        a == null || a(B), g.getState().resetSelectedElements(), g.setState({ nodesSelectionActive: !1 })
      },
      Q = B => {
        if (Array.isArray(o) && o != null && o.includes(2)) {
          B.preventDefault()
          return
        }
        l == null || l(B)
      },
      R = c ? B => c(B) : void 0,
      S = B => {
        var V, q, ee, re
        const { resetSelectedElements: O, domNode: W, edgeLookup: K } = g.getState()
        if (((v.current = W == null ? void 0 : W.getBoundingClientRect()), !w || !e || B.button !== 0 || B.target !== h.current || !v.current)) return
        ;(q = (V = B.target) == null ? void 0 : V.setPointerCapture) == null || q.call(V, B.pointerId), (T.current = !0), (P.current = !1), (y.current = new Map())
        for (const [J, ie] of K) y.current.set(ie.source, ((ee = y.current.get(ie.source)) == null ? void 0 : ee.add(J)) || new Set([J])), y.current.set(ie.target, ((re = y.current.get(ie.target)) == null ? void 0 : re.add(J)) || new Set([J]))
        const { x: Z, y: oe } = Rn(B.nativeEvent, v.current)
        O(), g.setState({ userSelectionRect: { width: 0, height: 0, startX: Z, startY: oe, x: Z, y: oe } }), s == null || s(B)
      },
      L = B => {
        const { userSelectionRect: O, edgeLookup: W, transform: K, nodeLookup: Z, triggerNodeChanges: oe, triggerEdgeChanges: V } = g.getState()
        if (!v.current || !O) return
        P.current = !0
        const { x: q, y: ee } = Rn(B.nativeEvent, v.current),
          { startX: re, startY: J } = O,
          ie = { startX: re, startY: J, x: q < re ? q : re, y: ee < J ? ee : J, width: Math.abs(q - re), height: Math.abs(ee - J) },
          Ae = Nh(Z, ie, K, n === xs.Partial, !0),
          ae = new Set(),
          se = new Set()
        for (const H of Ae) {
          se.add(H.id)
          const U = y.current.get(H.id)
          if (U) for (const te of U) ae.add(te)
        }
        if (x.current !== se.size) {
          x.current = se.size
          const H = Sr(Z, se, !0)
          oe(H)
        }
        if (m.current !== ae.size) {
          m.current = ae.size
          const H = Sr(W, ae)
          V(H)
        }
        g.setState({ userSelectionRect: ie, userSelectionActive: !0, nodesSelectionActive: !1 })
      },
      I = B => {
        var W, K
        if (B.button !== 0 || !T.current) return
        ;(K = (W = B.target) == null ? void 0 : W.releasePointerCapture) == null || K.call(W, B.pointerId)
        const { userSelectionRect: O } = g.getState()
        !b && O && B.target === h.current && (D == null || D(B)), x.current > 0 && g.setState({ nodesSelectionActive: !0 }), F(), i == null || i(B), (t || r) && (P.current = !1), (T.current = !1)
      },
      z = o === !0 || (Array.isArray(o) && o.includes(0))
    return p.jsxs('div', {
      className: dt(['react-flow__pane', { draggable: z, dragging: k, selection: e }]),
      onClick: E ? void 0 : Xu(D, h),
      onContextMenu: Xu(Q, h),
      onWheel: Xu(R, h),
      onPointerEnter: E ? void 0 : u,
      onPointerDown: E ? S : d,
      onPointerMove: E ? L : d,
      onPointerUp: E ? I : void 0,
      onPointerLeave: f,
      ref: h,
      style: nl,
      children: [A, p.jsx(TL, {})],
    })
  }
  function Yu({ id: e, store: t, unselect: n = !1, nodeRef: o }) {
    const { addSelectedNodes: r, unselectNodesAndEdges: s, multiSelectionActive: i, nodeLookup: a, onError: l } = t.getState(),
      c = a.get(e)
    if (!c) {
      l == null || l('012', zn.error012(e))
      return
    }
    t.setState({ nodesSelectionActive: !1 }),
      c.selected
        ? (n || (c.selected && i)) &&
          (s({ nodes: [c], edges: [] }),
          requestAnimationFrame(() => {
            var u
            return (u = o == null ? void 0 : o.current) == null ? void 0 : u.blur()
          }))
        : r([e])
  }
  function Rg({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: o, nodeId: r, isSelectable: s, nodeClickDistance: i }) {
    const a = qe(),
      [l, c] = C.useState(!1),
      u = C.useRef()
    return (
      C.useEffect(() => {
        u.current = l2({
          getStoreItems: () => a.getState(),
          onNodeMouseDown: d => {
            Yu({ id: d, store: a, nodeRef: e })
          },
          onDragStart: () => {
            c(!0)
          },
          onDragStop: () => {
            c(!1)
          },
        })
      }, []),
      C.useEffect(() => {
        var d, f
        if (t) (d = u.current) == null || d.destroy()
        else if (e.current)
          return (
            (f = u.current) == null || f.update({ noDragClassName: n, handleSelector: o, domNode: e.current, isSelectable: s, nodeId: r, nodeClickDistance: i }),
            () => {
              var A
              ;(A = u.current) == null || A.destroy()
            }
          )
      }, [n, o, t, s, e, r]),
      l
    )
  }
  const zL = e => t => t.selected && (t.draggable || (e && typeof t.draggable > 'u'))
  function Og() {
    const e = qe()
    return C.useCallback(n => {
      const { nodeExtent: o, snapToGrid: r, snapGrid: s, nodesDraggable: i, onError: a, updateNodePositions: l, nodeLookup: c, nodeOrigin: u } = e.getState(),
        d = new Map(),
        f = zL(i),
        A = r ? s[0] : 5,
        h = r ? s[1] : 5,
        g = n.direction.x * A * n.factor,
        x = n.direction.y * h * n.factor
      for (const [, m] of c) {
        if (!f(m)) continue
        let v = { x: m.internals.positionAbsolute.x + g, y: m.internals.positionAbsolute.y + x }
        r && (v = Ya(v, s))
        const { position: y, positionAbsolute: b } = Mh({ nodeId: m.id, nextPosition: v, nodeLookup: c, nodeExtent: o, nodeOrigin: u, onError: a })
        ;(m.position = y), (m.internals.positionAbsolute = b), d.set(m.id, m)
      }
      l(d)
    }, [])
  }
  const Hu = C.createContext(null),
    QL = Hu.Provider
  Hu.Consumer
  const jg = () => C.useContext(Hu),
    RL = e => ({ connectOnClick: e.connectOnClick, noPanClassName: e.noPanClassName, rfId: e.rfId }),
    OL = (e, t, n) => o => {
      const { connectionClickStartHandle: r, connectionMode: s, connection: i } = o,
        { fromHandle: a, toHandle: l, isValid: c } = i,
        u = (l == null ? void 0 : l.nodeId) === e && (l == null ? void 0 : l.id) === t && (l == null ? void 0 : l.type) === n
      return {
        connectingFrom: (a == null ? void 0 : a.nodeId) === e && (a == null ? void 0 : a.id) === t && (a == null ? void 0 : a.type) === n,
        connectingTo: u,
        clickConnecting: (r == null ? void 0 : r.nodeId) === e && (r == null ? void 0 : r.id) === t && (r == null ? void 0 : r.type) === n,
        isPossibleEndHandle: s === yr.Strict ? (a == null ? void 0 : a.type) !== n : e !== (a == null ? void 0 : a.nodeId) || t !== (a == null ? void 0 : a.id),
        connectionInProcess: !!a,
        valid: u && c,
      }
    }
  function jL({ type: e = 'source', position: t = ye.Top, isValidConnection: n, isConnectable: o = !0, isConnectableStart: r = !0, isConnectableEnd: s = !0, id: i, onConnect: a, children: l, className: c, onMouseDown: u, onTouchStart: d, ...f }, A) {
    var S, L
    const h = i || null,
      g = e === 'target',
      x = qe(),
      m = jg(),
      { connectOnClick: v, noPanClassName: y, rfId: b } = ke(RL, it),
      { connectingFrom: w, connectingTo: k, clickConnecting: E, isPossibleEndHandle: P, connectionInProcess: T, valid: F } = ke(OL(m, h, e), it)
    m || (L = (S = x.getState()).onError) == null || L.call(S, '010', zn.error010())
    const D = I => {
        const { defaultEdgeOptions: z, onConnect: B, hasDefaultEdges: O } = x.getState(),
          W = { ...z, ...I }
        if (O) {
          const { edges: K, setEdges: Z } = x.getState()
          Z(Lu(W, K))
        }
        B == null || B(W), a == null || a(W)
      },
      Q = I => {
        if (!m) return
        const z = jh(I.nativeEvent)
        if (r && ((z && I.button === 0) || !z)) {
          const B = x.getState()
          ju.onPointerDown(I.nativeEvent, {
            autoPanOnConnect: B.autoPanOnConnect,
            connectionMode: B.connectionMode,
            connectionRadius: B.connectionRadius,
            domNode: B.domNode,
            nodeLookup: B.nodeLookup,
            lib: B.lib,
            isTarget: g,
            handleId: h,
            nodeId: m,
            flowId: B.rfId,
            panBy: B.panBy,
            cancelConnection: B.cancelConnection,
            onConnectStart: B.onConnectStart,
            onConnectEnd: B.onConnectEnd,
            updateConnection: B.updateConnection,
            onConnect: D,
            isValidConnection: n || B.isValidConnection,
            getTransform: () => x.getState().transform,
            getFromHandle: () => x.getState().connection.fromHandle,
            autoPanSpeed: B.autoPanSpeed,
          })
        }
        z ? u == null || u(I) : d == null || d(I)
      },
      R = I => {
        const { onClickConnectStart: z, onClickConnectEnd: B, connectionClickStartHandle: O, connectionMode: W, isValidConnection: K, lib: Z, rfId: oe, nodeLookup: V, connection: q } = x.getState()
        if (!m || (!O && !r)) return
        if (!O) {
          z == null || z(I.nativeEvent, { nodeId: m, handleId: h, handleType: e }), x.setState({ connectionClickStartHandle: { nodeId: m, type: e, id: h } })
          return
        }
        const ee = Oh(I.target),
          re = n || K,
          { connection: J, isValid: ie } = ju.isValid(I.nativeEvent, { handle: { nodeId: m, id: h, type: e }, connectionMode: W, fromNodeId: O.nodeId, fromHandleId: O.id || null, fromType: O.type, isValidConnection: re, flowId: oe, doc: ee, lib: Z, nodeLookup: V })
        ie && J && D(J)
        const Ae = structuredClone(q)
        delete Ae.inProgress, (Ae.toPosition = Ae.toHandle ? Ae.toHandle.position : null), B == null || B(I, Ae), x.setState({ connectionClickStartHandle: null })
      }
    return p.jsx('div', {
      'data-handleid': h,
      'data-nodeid': m,
      'data-handlepos': t,
      'data-id': `${b}-${m}-${h}-${e}`,
      className: dt(['react-flow__handle', `react-flow__handle-${t}`, 'nodrag', y, c, { source: !g, target: g, connectable: o, connectablestart: r, connectableend: s, clickconnecting: E, connectingfrom: w, connectingto: k, valid: F, connectionindicator: o && (!T || P) && (T ? s : r) }]),
      onMouseDown: Q,
      onTouchStart: Q,
      onClick: v ? R : void 0,
      ref: A,
      ...f,
      children: l,
    })
  }
  const Ns = C.memo(Fg(jL))
  function WL({ data: e, isConnectable: t, sourcePosition: n = ye.Bottom }) {
    return p.jsxs(p.Fragment, { children: [e == null ? void 0 : e.label, p.jsx(Ns, { type: 'source', position: n, isConnectable: t })] })
  }
  function GL({ data: e, isConnectable: t, targetPosition: n = ye.Top, sourcePosition: o = ye.Bottom }) {
    return p.jsxs(p.Fragment, { children: [p.jsx(Ns, { type: 'target', position: n, isConnectable: t }), e == null ? void 0 : e.label, p.jsx(Ns, { type: 'source', position: o, isConnectable: t })] })
  }
  function VL() {
    return null
  }
  function XL({ data: e, isConnectable: t, targetPosition: n = ye.Top }) {
    return p.jsxs(p.Fragment, { children: [p.jsx(Ns, { type: 'target', position: n, isConnectable: t }), e == null ? void 0 : e.label] })
  }
  const ol = { ArrowUp: { x: 0, y: -1 }, ArrowDown: { x: 0, y: 1 }, ArrowLeft: { x: -1, y: 0 }, ArrowRight: { x: 1, y: 0 } },
    Wg = { input: WL, default: GL, output: XL, group: VL }
  function YL(e) {
    var t, n, o, r
    return e.internals.handleBounds === void 0 ? { width: e.width ?? e.initialWidth ?? ((t = e.style) == null ? void 0 : t.width), height: e.height ?? e.initialHeight ?? ((n = e.style) == null ? void 0 : n.height) } : { width: e.width ?? ((o = e.style) == null ? void 0 : o.width), height: e.height ?? ((r = e.style) == null ? void 0 : r.height) }
  }
  const HL = e => {
    const { width: t, height: n, x: o, y: r } = ws(e.nodeLookup, { filter: s => !!s.selected })
    return { width: cn(t) ? t : null, height: cn(n) ? n : null, userSelectionActive: e.userSelectionActive, transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${o}px,${r}px)` }
  }
  function UL({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
    const o = qe(),
      { width: r, height: s, transformString: i, userSelectionActive: a } = ke(HL, it),
      l = Og(),
      c = C.useRef(null)
    if (
      (C.useEffect(() => {
        var f
        n || (f = c.current) == null || f.focus({ preventScroll: !0 })
      }, [n]),
      Rg({ nodeRef: c }),
      a || !r || !s)
    )
      return null
    const u = e
        ? f => {
            const A = o.getState().nodes.filter(h => h.selected)
            e(f, A)
          }
        : void 0,
      d = f => {
        Object.prototype.hasOwnProperty.call(ol, f.key) && (f.preventDefault(), l({ direction: ol[f.key], factor: f.shiftKey ? 4 : 1 }))
      }
    return p.jsx('div', { className: dt(['react-flow__nodesselection', 'react-flow__container', t]), style: { transform: i }, children: p.jsx('div', { ref: c, className: 'react-flow__nodesselection-rect', onContextMenu: u, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : d, style: { width: r, height: s } }) })
  }
  const Gg = typeof window < 'u' ? window : void 0,
    KL = e => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive })
  function Vg({
    children: e,
    onPaneClick: t,
    onPaneMouseEnter: n,
    onPaneMouseMove: o,
    onPaneMouseLeave: r,
    onPaneContextMenu: s,
    onPaneScroll: i,
    paneClickDistance: a,
    deleteKeyCode: l,
    selectionKeyCode: c,
    selectionOnDrag: u,
    selectionMode: d,
    onSelectionStart: f,
    onSelectionEnd: A,
    multiSelectionKeyCode: h,
    panActivationKeyCode: g,
    zoomActivationKeyCode: x,
    elementsSelectable: m,
    zoomOnScroll: v,
    zoomOnPinch: y,
    panOnScroll: b,
    panOnScrollSpeed: w,
    panOnScrollMode: k,
    zoomOnDoubleClick: E,
    panOnDrag: P,
    defaultViewport: T,
    translateExtent: F,
    minZoom: D,
    maxZoom: Q,
    preventScrolling: R,
    onSelectionContextMenu: S,
    noWheelClassName: L,
    noPanClassName: I,
    disableKeyboardA11y: z,
    onViewportChange: B,
    isControlledViewport: O,
  }) {
    const { nodesSelectionActive: W, userSelectionActive: K } = ke(KL),
      Z = Er(c, { target: Gg }),
      oe = Er(g, { target: Gg }),
      V = oe || P,
      q = oe || b,
      ee = u && V !== !0,
      re = Z || K || ee
    return (
      kL({ deleteKeyCode: l, multiSelectionKeyCode: h }),
      p.jsx(PL, {
        onPaneContextMenu: s,
        elementsSelectable: m,
        zoomOnScroll: v,
        zoomOnPinch: y,
        panOnScroll: q,
        panOnScrollSpeed: w,
        panOnScrollMode: k,
        zoomOnDoubleClick: E,
        panOnDrag: !Z && V,
        defaultViewport: T,
        translateExtent: F,
        minZoom: D,
        maxZoom: Q,
        zoomActivationKeyCode: x,
        preventScrolling: R,
        noWheelClassName: L,
        noPanClassName: I,
        onViewportChange: B,
        isControlledViewport: O,
        paneClickDistance: a,
        children: p.jsxs(DL, {
          onSelectionStart: f,
          onSelectionEnd: A,
          onPaneClick: t,
          onPaneMouseEnter: n,
          onPaneMouseMove: o,
          onPaneMouseLeave: r,
          onPaneContextMenu: s,
          onPaneScroll: i,
          panOnDrag: V,
          isSelecting: !!re,
          selectionMode: d,
          selectionKeyPressed: Z,
          selectionOnDrag: ee,
          children: [e, W && p.jsx(UL, { onSelectionContextMenu: S, noPanClassName: I, disableKeyboardA11y: z })],
        }),
      })
    )
  }
  Vg.displayName = 'FlowRenderer'
  const qL = C.memo(Vg),
    ZL = e => t => e ? Nh(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map(n => n.id) : Array.from(t.nodeLookup.keys())
  function JL(e) {
    return ke(C.useCallback(ZL(e), [e]), it)
  }
  const _L = e => e.updateNodeInternals
  function $L() {
    const e = ke(_L),
      [t] = C.useState(() =>
        typeof ResizeObserver > 'u'
          ? null
          : new ResizeObserver(n => {
              const o = new Map()
              n.forEach(r => {
                const s = r.target.getAttribute('data-id')
                o.set(s, { id: s, nodeElement: r.target, force: !0 })
              }),
                e(o)
            })
      )
    return (
      C.useEffect(
        () => () => {
          t == null || t.disconnect()
        },
        [t]
      ),
      t
    )
  }
  function e5({ node: e, nodeType: t, hasDimensions: n, resizeObserver: o }) {
    const r = qe(),
      s = C.useRef(null),
      i = C.useRef(null),
      a = C.useRef(e.sourcePosition),
      l = C.useRef(e.targetPosition),
      c = C.useRef(t),
      u = n && !!e.internals.handleBounds
    return (
      C.useEffect(() => {
        s.current && !e.hidden && (!u || i.current !== s.current) && (i.current && (o == null || o.unobserve(i.current)), o == null || o.observe(s.current), (i.current = s.current))
      }, [u, e.hidden]),
      C.useEffect(
        () => () => {
          i.current && (o == null || o.unobserve(i.current), (i.current = null))
        },
        []
      ),
      C.useEffect(() => {
        if (s.current) {
          const d = c.current !== t,
            f = a.current !== e.sourcePosition,
            A = l.current !== e.targetPosition
          ;(d || f || A) && ((c.current = t), (a.current = e.sourcePosition), (l.current = e.targetPosition), r.getState().updateNodeInternals(new Map([[e.id, { id: e.id, nodeElement: s.current, force: !0 }]])))
        }
      }, [e.id, t, e.sourcePosition, e.targetPosition]),
      s
    )
  }
  function t5({
    id: e,
    onClick: t,
    onMouseEnter: n,
    onMouseMove: o,
    onMouseLeave: r,
    onContextMenu: s,
    onDoubleClick: i,
    nodesDraggable: a,
    elementsSelectable: l,
    nodesConnectable: c,
    nodesFocusable: u,
    resizeObserver: d,
    noDragClassName: f,
    noPanClassName: A,
    disableKeyboardA11y: h,
    rfId: g,
    nodeTypes: x,
    nodeExtent: m,
    nodeClickDistance: v,
    onError: y,
  }) {
    const {
      node: b,
      internals: w,
      isParent: k,
    } = ke(J => {
      const ie = J.nodeLookup.get(e),
        Ae = J.parentLookup.has(e)
      return { node: ie, internals: ie.internals, isParent: Ae }
    }, it)
    let E = b.type || 'default',
      P = (x == null ? void 0 : x[E]) || Wg[E]
    P === void 0 && (y == null || y('003', zn.error003(E)), (E = 'default'), (P = Wg.default))
    const T = !!(b.draggable || (a && typeof b.draggable > 'u')),
      F = !!(b.selectable || (l && typeof b.selectable > 'u')),
      D = !!(b.connectable || (c && typeof b.connectable > 'u')),
      Q = !!(b.focusable || (u && typeof b.focusable > 'u')),
      R = qe(),
      S = Qh(b),
      L = e5({ node: b, nodeType: E, hasDimensions: S, resizeObserver: d }),
      I = Rg({ nodeRef: L, disabled: b.hidden || !T, noDragClassName: f, handleSelector: b.dragHandle, nodeId: e, isSelectable: F, nodeClickDistance: v }),
      z = Og()
    if (b.hidden) return null
    const B = Qn(b),
      O = YL(b),
      W = F || T || t || n || o || r,
      K = n ? J => n(J, { ...w.userNode }) : void 0,
      Z = o ? J => o(J, { ...w.userNode }) : void 0,
      oe = r ? J => r(J, { ...w.userNode }) : void 0,
      V = s ? J => s(J, { ...w.userNode }) : void 0,
      q = i ? J => i(J, { ...w.userNode }) : void 0,
      ee = J => {
        const { selectNodesOnDrag: ie, nodeDragThreshold: Ae } = R.getState()
        F && (!ie || !T || Ae > 0) && Yu({ id: e, store: R, nodeRef: L }), t && t(J, { ...w.userNode })
      },
      re = J => {
        if (!(Pu(J.nativeEvent) || h))
          if (Eh.includes(J.key) && F) {
            const ie = J.key === 'Escape'
            Yu({ id: e, store: R, unselect: ie, nodeRef: L })
          } else T && b.selected && Object.prototype.hasOwnProperty.call(ol, J.key) && (J.preventDefault(), R.setState({ ariaLiveMessage: `Moved selected node ${J.key.replace('Arrow', '').toLowerCase()}. New position, x: ${~~w.positionAbsolute.x}, y: ${~~w.positionAbsolute.y}` }), z({ direction: ol[J.key], factor: J.shiftKey ? 4 : 1 }))
      }
    return p.jsx('div', {
      className: dt(['react-flow__node', `react-flow__node-${E}`, { [A]: T }, b.className, { selected: b.selected, selectable: F, parent: k, draggable: T, dragging: I }]),
      ref: L,
      style: { zIndex: w.z, transform: `translate(${w.positionAbsolute.x}px,${w.positionAbsolute.y}px)`, pointerEvents: W ? 'all' : 'none', visibility: S ? 'visible' : 'hidden', ...b.style, ...O },
      'data-id': e,
      'data-testid': `rf__node-${e}`,
      onMouseEnter: K,
      onMouseMove: Z,
      onMouseLeave: oe,
      onContextMenu: V,
      onClick: ee,
      onDoubleClick: q,
      onKeyDown: Q ? re : void 0,
      tabIndex: Q ? 0 : void 0,
      role: Q ? 'button' : void 0,
      'aria-describedby': h ? void 0 : `${bg}-${g}`,
      'aria-label': b.ariaLabel,
      children: p.jsx(QL, {
        value: e,
        children: p.jsx(P, {
          id: e,
          data: b.data,
          type: E,
          positionAbsoluteX: w.positionAbsolute.x,
          positionAbsoluteY: w.positionAbsolute.y,
          selected: b.selected,
          selectable: F,
          draggable: T,
          deletable: b.deletable ?? !0,
          isConnectable: D,
          sourcePosition: b.sourcePosition,
          targetPosition: b.targetPosition,
          dragging: I,
          dragHandle: b.dragHandle,
          zIndex: w.z,
          parentId: b.parentId,
          ...B,
        }),
      }),
    })
  }
  const n5 = e => ({ nodesDraggable: e.nodesDraggable, nodesConnectable: e.nodesConnectable, nodesFocusable: e.nodesFocusable, elementsSelectable: e.elementsSelectable, onError: e.onError })
  function Xg(e) {
    const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: o, elementsSelectable: r, onError: s } = ke(n5, it),
      i = JL(e.onlyRenderVisibleElements),
      a = $L()
    return p.jsx('div', {
      className: 'react-flow__nodes',
      style: nl,
      children: i.map(l =>
        p.jsx(
          t5,
          {
            id: l,
            nodeTypes: e.nodeTypes,
            nodeExtent: e.nodeExtent,
            onClick: e.onNodeClick,
            onMouseEnter: e.onNodeMouseEnter,
            onMouseMove: e.onNodeMouseMove,
            onMouseLeave: e.onNodeMouseLeave,
            onContextMenu: e.onNodeContextMenu,
            onDoubleClick: e.onNodeDoubleClick,
            noDragClassName: e.noDragClassName,
            noPanClassName: e.noPanClassName,
            rfId: e.rfId,
            disableKeyboardA11y: e.disableKeyboardA11y,
            resizeObserver: a,
            nodesDraggable: t,
            nodesConnectable: n,
            nodesFocusable: o,
            elementsSelectable: r,
            nodeClickDistance: e.nodeClickDistance,
            onError: s,
          },
          l
        )
      ),
    })
  }
  Xg.displayName = 'NodeRenderer'
  const o5 = C.memo(Xg)
  function r5(e) {
    return ke(
      C.useCallback(
        n => {
          if (!e) return n.edges.map(r => r.id)
          const o = []
          if (n.width && n.height)
            for (const r of n.edges) {
              const s = n.nodeLookup.get(r.source),
                i = n.nodeLookup.get(r.target)
              s && i && UP({ sourceNode: s, targetNode: i, width: n.width, height: n.height, transform: n.transform }) && o.push(r.id)
            }
          return o
        },
        [e]
      ),
      it
    )
  }
  const s5 = ({ color: e = 'none', strokeWidth: t = 1 }) => p.jsx('polyline', { style: { stroke: e, strokeWidth: t }, strokeLinecap: 'round', strokeLinejoin: 'round', fill: 'none', points: '-5,-4 0,0 -5,4' }),
    i5 = ({ color: e = 'none', strokeWidth: t = 1 }) => p.jsx('polyline', { style: { stroke: e, fill: e, strokeWidth: t }, strokeLinecap: 'round', strokeLinejoin: 'round', points: '-5,-4 0,0 -5,4 -5,-4' }),
    Yg = { [Wa.Arrow]: s5, [Wa.ArrowClosed]: i5 }
  function a5(e) {
    const t = qe()
    return C.useMemo(() => {
      var r, s
      return Object.prototype.hasOwnProperty.call(Yg, e) ? Yg[e] : ((s = (r = t.getState()).onError) == null || s.call(r, '009', zn.error009(e)), null)
    }, [e])
  }
  const l5 = ({ id: e, type: t, color: n, width: o = 12.5, height: r = 12.5, markerUnits: s = 'strokeWidth', strokeWidth: i, orient: a = 'auto-start-reverse' }) => {
      const l = a5(t)
      return l ? p.jsx('marker', { className: 'react-flow__arrowhead', id: e, markerWidth: `${o}`, markerHeight: `${r}`, viewBox: '-10 -10 20 20', markerUnits: s, orient: a, refX: '0', refY: '0', children: p.jsx(l, { color: n, strokeWidth: i }) }) : null
    },
    Hg = ({ defaultColor: e, rfId: t }) => {
      const n = ke(s => s.edges),
        o = ke(s => s.defaultEdgeOptions),
        r = C.useMemo(() => e2(n, { id: t, defaultColor: e, defaultMarkerStart: o == null ? void 0 : o.markerStart, defaultMarkerEnd: o == null ? void 0 : o.markerEnd }), [n, o, t, e])
      return r.length ? p.jsx('svg', { className: 'react-flow__marker', children: p.jsx('defs', { children: r.map(s => p.jsx(l5, { id: s.id, type: s.type, color: s.color, width: s.width, height: s.height, markerUnits: s.markerUnits, strokeWidth: s.strokeWidth, orient: s.orient }, s.id)) }) }) : null
    }
  Hg.displayName = 'MarkerDefinitions'
  var c5 = C.memo(Hg)
  function Ug({ x: e, y: t, label: n, labelStyle: o = {}, labelShowBg: r = !0, labelBgStyle: s = {}, labelBgPadding: i = [2, 4], labelBgBorderRadius: a = 2, children: l, className: c, ...u }) {
    const [d, f] = C.useState({ x: 1, y: 0, width: 0, height: 0 }),
      A = dt(['react-flow__edge-textwrapper', c]),
      h = C.useRef(null)
    return (
      C.useEffect(() => {
        if (h.current) {
          const g = h.current.getBBox()
          f({ x: g.x, y: g.y, width: g.width, height: g.height })
        }
      }, [n]),
      typeof n > 'u' || !n
        ? null
        : p.jsxs('g', {
            transform: `translate(${e - d.width / 2} ${t - d.height / 2})`,
            className: A,
            visibility: d.width ? 'visible' : 'hidden',
            ...u,
            children: [r && p.jsx('rect', { width: d.width + 2 * i[0], x: -i[0], y: -i[1], height: d.height + 2 * i[1], className: 'react-flow__edge-textbg', style: s, rx: a, ry: a }), p.jsx('text', { className: 'react-flow__edge-text', y: d.height / 2, dy: '0.3em', ref: h, style: o, children: n }), l],
          })
    )
  }
  Ug.displayName = 'EdgeText'
  const u5 = C.memo(Ug)
  function Ms({ path: e, labelX: t, labelY: n, label: o, labelStyle: r, labelShowBg: s, labelBgStyle: i, labelBgPadding: a, labelBgBorderRadius: l, interactionWidth: c = 20, ...u }) {
    return p.jsxs(p.Fragment, {
      children: [
        p.jsx('path', { ...u, d: e, fill: 'none', className: dt(['react-flow__edge-path', u.className]) }),
        c && p.jsx('path', { d: e, fill: 'none', strokeOpacity: 0, strokeWidth: c, className: 'react-flow__edge-interaction' }),
        o && cn(t) && cn(n) ? p.jsx(u5, { x: t, y: n, label: o, labelStyle: r, labelShowBg: s, labelBgStyle: i, labelBgPadding: a, labelBgBorderRadius: l }) : null,
      ],
    })
  }
  function Kg({ pos: e, x1: t, y1: n, x2: o, y2: r }) {
    return e === ye.Left || e === ye.Right ? [0.5 * (t + o), n] : [t, 0.5 * (n + r)]
  }
  function qg({ sourceX: e, sourceY: t, sourcePosition: n = ye.Bottom, targetX: o, targetY: r, targetPosition: s = ye.Top }) {
    const [i, a] = Kg({ pos: n, x1: e, y1: t, x2: o, y2: r }),
      [l, c] = Kg({ pos: s, x1: o, y1: r, x2: e, y2: t }),
      [u, d, f, A] = Gh({ sourceX: e, sourceY: t, targetX: o, targetY: r, sourceControlX: i, sourceControlY: a, targetControlX: l, targetControlY: c })
    return [`M${e},${t} C${i},${a} ${l},${c} ${o},${r}`, u, d, f, A]
  }
  function Zg(e) {
    return C.memo(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: s, sourcePosition: i = ye.Bottom, targetPosition: a = ye.Top, label: l, labelStyle: c, labelShowBg: u, labelBgStyle: d, labelBgPadding: f, labelBgBorderRadius: A, style: h, markerEnd: g, markerStart: x, interactionWidth: m }) => {
      const [v, y, b] = qg({ sourceX: n, sourceY: o, sourcePosition: i, targetX: r, targetY: s, targetPosition: a }),
        w = e.isInternal ? void 0 : t
      return p.jsx(Ms, { id: w, path: v, labelX: y, labelY: b, label: l, labelStyle: c, labelShowBg: u, labelBgStyle: d, labelBgPadding: f, labelBgBorderRadius: A, style: h, markerEnd: g, markerStart: x, interactionWidth: m })
    })
  }
  const d5 = Zg({ isInternal: !1 }),
    Jg = Zg({ isInternal: !0 })
  ;(d5.displayName = 'SimpleBezierEdge'), (Jg.displayName = 'SimpleBezierEdgeInternal')
  function _g(e) {
    return C.memo(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: s, label: i, labelStyle: a, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: d, style: f, sourcePosition: A = ye.Bottom, targetPosition: h = ye.Top, markerEnd: g, markerStart: x, pathOptions: m, interactionWidth: v }) => {
      const [y, b, w] = qa({ sourceX: n, sourceY: o, sourcePosition: A, targetX: r, targetY: s, targetPosition: h, borderRadius: m == null ? void 0 : m.borderRadius, offset: m == null ? void 0 : m.offset }),
        k = e.isInternal ? void 0 : t
      return p.jsx(Ms, { id: k, path: y, labelX: b, labelY: w, label: i, labelStyle: a, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: d, style: f, markerEnd: g, markerStart: x, interactionWidth: v })
    })
  }
  const $g = _g({ isInternal: !1 }),
    em = _g({ isInternal: !0 })
  ;($g.displayName = 'SmoothStepEdge'), (em.displayName = 'SmoothStepEdgeInternal')
  function tm(e) {
    return C.memo(({ id: t, ...n }) => {
      var r
      const o = e.isInternal ? void 0 : t
      return p.jsx($g, {
        ...n,
        id: o,
        pathOptions: C.useMemo(() => {
          var s
          return { borderRadius: 0, offset: (s = n.pathOptions) == null ? void 0 : s.offset }
        }, [(r = n.pathOptions) == null ? void 0 : r.offset]),
      })
    })
  }
  const f5 = tm({ isInternal: !1 }),
    nm = tm({ isInternal: !0 })
  ;(f5.displayName = 'StepEdge'), (nm.displayName = 'StepEdgeInternal')
  function om(e) {
    return C.memo(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: s, label: i, labelStyle: a, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: d, style: f, markerEnd: A, markerStart: h, interactionWidth: g }) => {
      const [x, m, v] = Hh({ sourceX: n, sourceY: o, targetX: r, targetY: s }),
        y = e.isInternal ? void 0 : t
      return p.jsx(Ms, { id: y, path: x, labelX: m, labelY: v, label: i, labelStyle: a, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: d, style: f, markerEnd: A, markerStart: h, interactionWidth: g })
    })
  }
  const A5 = om({ isInternal: !1 }),
    rm = om({ isInternal: !0 })
  ;(A5.displayName = 'StraightEdge'), (rm.displayName = 'StraightEdgeInternal')
  function sm(e) {
    return C.memo(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: s, sourcePosition: i = ye.Bottom, targetPosition: a = ye.Top, label: l, labelStyle: c, labelShowBg: u, labelBgStyle: d, labelBgPadding: f, labelBgBorderRadius: A, style: h, markerEnd: g, markerStart: x, pathOptions: m, interactionWidth: v }) => {
      const [y, b, w] = Xh({ sourceX: n, sourceY: o, sourcePosition: i, targetX: r, targetY: s, targetPosition: a, curvature: m == null ? void 0 : m.curvature }),
        k = e.isInternal ? void 0 : t
      return p.jsx(Ms, { id: k, path: y, labelX: b, labelY: w, label: l, labelStyle: c, labelShowBg: u, labelBgStyle: d, labelBgPadding: f, labelBgBorderRadius: A, style: h, markerEnd: g, markerStart: x, interactionWidth: v })
    })
  }
  const p5 = sm({ isInternal: !1 }),
    im = sm({ isInternal: !0 })
  ;(p5.displayName = 'BezierEdge'), (im.displayName = 'BezierEdgeInternal')
  const am = { default: im, straight: rm, step: nm, smoothstep: em, simplebezier: Jg },
    lm = { sourceX: null, sourceY: null, targetX: null, targetY: null, sourcePosition: null, targetPosition: null },
    h5 = (e, t, n) => (n === ye.Left ? e - t : n === ye.Right ? e + t : e),
    g5 = (e, t, n) => (n === ye.Top ? e - t : n === ye.Bottom ? e + t : e),
    cm = 'react-flow__edgeupdater'
  function um({ position: e, centerX: t, centerY: n, radius: o = 10, onMouseDown: r, onMouseEnter: s, onMouseOut: i, type: a }) {
    return p.jsx('circle', { onMouseDown: r, onMouseEnter: s, onMouseOut: i, className: dt([cm, `${cm}-${a}`]), cx: h5(t, o, e), cy: g5(n, o, e), r: o, stroke: 'transparent', fill: 'transparent' })
  }
  function m5({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: o, sourceY: r, targetX: s, targetY: i, sourcePosition: a, targetPosition: l, onReconnect: c, onReconnectStart: u, onReconnectEnd: d, setReconnecting: f, setUpdateHover: A }) {
    const h = qe(),
      g = (b, w) => {
        if (b.button !== 0) return
        const { autoPanOnConnect: k, domNode: E, isValidConnection: P, connectionMode: T, connectionRadius: F, lib: D, onConnectStart: Q, onConnectEnd: R, cancelConnection: S, nodeLookup: L, rfId: I, panBy: z, updateConnection: B } = h.getState(),
          O = w.type === 'target'
        f(!0), u == null || u(b, n, w.type)
        const W = (Z, oe) => {
            f(!1), d == null || d(Z, n, w.type, oe)
          },
          K = Z => (c == null ? void 0 : c(n, Z))
        ju.onPointerDown(b.nativeEvent, {
          autoPanOnConnect: k,
          connectionMode: T,
          connectionRadius: F,
          domNode: E,
          handleId: w.id,
          nodeId: w.nodeId,
          nodeLookup: L,
          isTarget: O,
          edgeUpdaterType: w.type,
          lib: D,
          flowId: I,
          cancelConnection: S,
          panBy: z,
          isValidConnection: P,
          onConnect: K,
          onConnectStart: Q,
          onConnectEnd: R,
          onReconnectEnd: W,
          updateConnection: B,
          getTransform: () => h.getState().transform,
          getFromHandle: () => h.getState().connection.fromHandle,
        })
      },
      x = b => g(b, { nodeId: n.target, id: n.targetHandle ?? null, type: 'target' }),
      m = b => g(b, { nodeId: n.source, id: n.sourceHandle ?? null, type: 'source' }),
      v = () => A(!0),
      y = () => A(!1)
    return p.jsxs(p.Fragment, {
      children: [(e === !0 || e === 'source') && p.jsx(um, { position: a, centerX: o, centerY: r, radius: t, onMouseDown: x, onMouseEnter: v, onMouseOut: y, type: 'source' }), (e === !0 || e === 'target') && p.jsx(um, { position: l, centerX: s, centerY: i, radius: t, onMouseDown: m, onMouseEnter: v, onMouseOut: y, type: 'target' })],
    })
  }
  function y5({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: o, onClick: r, onDoubleClick: s, onContextMenu: i, onMouseEnter: a, onMouseMove: l, onMouseLeave: c, reconnectRadius: u, onReconnect: d, onReconnectStart: f, onReconnectEnd: A, rfId: h, edgeTypes: g, noPanClassName: x, onError: m, disableKeyboardA11y: v }) {
    let y = ke(se => se.edgeLookup.get(e))
    const b = ke(se => se.defaultEdgeOptions)
    y = b ? { ...b, ...y } : y
    let w = y.type || 'default',
      k = (g == null ? void 0 : g[w]) || am[w]
    k === void 0 && (m == null || m('011', zn.error011(w)), (w = 'default'), (k = am.default))
    const E = !!(y.focusable || (t && typeof y.focusable > 'u')),
      P = typeof d < 'u' && (y.reconnectable || (n && typeof y.reconnectable > 'u')),
      T = !!(y.selectable || (o && typeof y.selectable > 'u')),
      F = C.useRef(null),
      [D, Q] = C.useState(!1),
      [R, S] = C.useState(!1),
      L = qe(),
      {
        zIndex: I,
        sourceX: z,
        sourceY: B,
        targetX: O,
        targetY: W,
        sourcePosition: K,
        targetPosition: Z,
      } = ke(
        C.useCallback(
          se => {
            const H = se.nodeLookup.get(y.source),
              U = se.nodeLookup.get(y.target)
            if (!H || !U) return { zIndex: y.zIndex, ...lm }
            const te = $P({ id: e, sourceNode: H, targetNode: U, sourceHandle: y.sourceHandle || null, targetHandle: y.targetHandle || null, connectionMode: se.connectionMode, onError: m })
            return { zIndex: HP({ selected: y.selected, zIndex: y.zIndex, sourceNode: H, targetNode: U, elevateOnSelect: se.elevateEdgesOnSelect }), ...(te || lm) }
          },
          [y.source, y.target, y.sourceHandle, y.targetHandle, y.selected, y.zIndex]
        ),
        it
      ),
      oe = C.useMemo(() => (y.markerStart ? `url('#${Tu(y.markerStart, h)}')` : void 0), [y.markerStart, h]),
      V = C.useMemo(() => (y.markerEnd ? `url('#${Tu(y.markerEnd, h)}')` : void 0), [y.markerEnd, h])
    if (y.hidden || z === null || B === null || O === null || W === null) return null
    const q = se => {
        var be
        const { addSelectedEdges: H, unselectNodesAndEdges: U, multiSelectionActive: te } = L.getState()
        T && (L.setState({ nodesSelectionActive: !1 }), y.selected && te ? (U({ nodes: [], edges: [y] }), (be = F.current) == null || be.blur()) : H([e])), r && r(se, y)
      },
      ee = s
        ? se => {
            s(se, { ...y })
          }
        : void 0,
      re = i
        ? se => {
            i(se, { ...y })
          }
        : void 0,
      J = a
        ? se => {
            a(se, { ...y })
          }
        : void 0,
      ie = l
        ? se => {
            l(se, { ...y })
          }
        : void 0,
      Ae = c
        ? se => {
            c(se, { ...y })
          }
        : void 0,
      ae = se => {
        var H
        if (!v && Eh.includes(se.key) && T) {
          const { unselectNodesAndEdges: U, addSelectedEdges: te } = L.getState()
          se.key === 'Escape' ? ((H = F.current) == null || H.blur(), U({ edges: [y] })) : te([e])
        }
      }
    return p.jsx('svg', {
      style: { zIndex: I },
      children: p.jsxs('g', {
        className: dt(['react-flow__edge', `react-flow__edge-${w}`, y.className, x, { selected: y.selected, animated: y.animated, inactive: !T && !r, updating: D, selectable: T }]),
        onClick: q,
        onDoubleClick: ee,
        onContextMenu: re,
        onMouseEnter: J,
        onMouseMove: ie,
        onMouseLeave: Ae,
        onKeyDown: E ? ae : void 0,
        tabIndex: E ? 0 : void 0,
        role: E ? 'button' : 'img',
        'data-id': e,
        'data-testid': `rf__edge-${e}`,
        'aria-label': y.ariaLabel === null ? void 0 : y.ariaLabel || `Edge from ${y.source} to ${y.target}`,
        'aria-describedby': E ? `${vg}-${h}` : void 0,
        ref: F,
        children: [
          !R &&
            p.jsx(k, {
              id: e,
              source: y.source,
              target: y.target,
              type: y.type,
              selected: y.selected,
              animated: y.animated,
              selectable: T,
              deletable: y.deletable ?? !0,
              label: y.label,
              labelStyle: y.labelStyle,
              labelShowBg: y.labelShowBg,
              labelBgStyle: y.labelBgStyle,
              labelBgPadding: y.labelBgPadding,
              labelBgBorderRadius: y.labelBgBorderRadius,
              sourceX: z,
              sourceY: B,
              targetX: O,
              targetY: W,
              sourcePosition: K,
              targetPosition: Z,
              data: y.data,
              style: y.style,
              sourceHandleId: y.sourceHandle,
              targetHandleId: y.targetHandle,
              markerStart: oe,
              markerEnd: V,
              pathOptions: 'pathOptions' in y ? y.pathOptions : void 0,
              interactionWidth: y.interactionWidth,
            }),
          P && p.jsx(m5, { edge: y, isReconnectable: P, reconnectRadius: u, onReconnect: d, onReconnectStart: f, onReconnectEnd: A, sourceX: z, sourceY: B, targetX: O, targetY: W, sourcePosition: K, targetPosition: Z, setUpdateHover: Q, setReconnecting: S }),
        ],
      }),
    })
  }
  const b5 = e => ({ edgesFocusable: e.edgesFocusable, edgesReconnectable: e.edgesReconnectable, elementsSelectable: e.elementsSelectable, connectionMode: e.connectionMode, onError: e.onError })
  function dm({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: o, noPanClassName: r, onReconnect: s, onEdgeContextMenu: i, onEdgeMouseEnter: a, onEdgeMouseMove: l, onEdgeMouseLeave: c, onEdgeClick: u, reconnectRadius: d, onEdgeDoubleClick: f, onReconnectStart: A, onReconnectEnd: h, disableKeyboardA11y: g }) {
    const { edgesFocusable: x, edgesReconnectable: m, elementsSelectable: v, onError: y } = ke(b5, it),
      b = r5(t)
    return p.jsxs('div', {
      className: 'react-flow__edges',
      children: [
        p.jsx(c5, { defaultColor: e, rfId: n }),
        b.map(w =>
          p.jsx(y5, { id: w, edgesFocusable: x, edgesReconnectable: m, elementsSelectable: v, noPanClassName: r, onReconnect: s, onContextMenu: i, onMouseEnter: a, onMouseMove: l, onMouseLeave: c, onClick: u, reconnectRadius: d, onDoubleClick: f, onReconnectStart: A, onReconnectEnd: h, rfId: n, onError: y, edgeTypes: o, disableKeyboardA11y: g }, w)
        ),
      ],
    })
  }
  dm.displayName = 'EdgeRenderer'
  const v5 = C.memo(dm),
    x5 = e => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`
  function C5({ children: e }) {
    const t = ke(x5)
    return p.jsx('div', { className: 'react-flow__viewport xyflow__viewport react-flow__container', style: { transform: t }, children: e })
  }
  function w5(e) {
    const t = No(),
      n = C.useRef(!1)
    C.useEffect(() => {
      !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), (n.current = !0))
    }, [e, t.viewportInitialized])
  }
  const E5 = e => {
    var t
    return (t = e.panZoom) == null ? void 0 : t.syncViewport
  }
  function S5(e) {
    const t = ke(E5),
      n = qe()
    return (
      C.useEffect(() => {
        e && (t == null || t(e), n.setState({ transform: [e.x, e.y, e.zoom] }))
      }, [e, t]),
      null
    )
  }
  function B5(e) {
    return e.connection.inProgress ? { ...e.connection, to: Ss(e.connection.to, e.transform) } : { ...e.connection }
  }
  function I5(e) {
    return B5
  }
  function k5(e) {
    const t = I5()
    return ke(t, it)
  }
  const N5 = e => ({ nodesConnectable: e.nodesConnectable, isValid: e.connection.isValid, inProgress: e.connection.inProgress, width: e.width, height: e.height })
  function M5({ containerStyle: e, style: t, type: n, component: o }) {
    const { nodesConnectable: r, width: s, height: i, isValid: a, inProgress: l } = ke(N5, it)
    return !(s && r && l) ? null : p.jsx('svg', { style: e, width: s, height: i, className: 'react-flow__connectionline react-flow__container', children: p.jsx('g', { className: dt(['react-flow__connection', Ih(a)]), children: p.jsx(fm, { style: t, type: n, CustomComponent: o, isValid: a }) }) })
  }
  const fm = ({ style: e, type: t = Sn.Bezier, CustomComponent: n, isValid: o }) => {
    const { inProgress: r, from: s, fromNode: i, fromHandle: a, fromPosition: l, to: c, toNode: u, toHandle: d, toPosition: f } = k5()
    if (!r) return
    if (n) return p.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: i, fromHandle: a, fromX: s.x, fromY: s.y, toX: c.x, toY: c.y, fromPosition: l, toPosition: f, connectionStatus: Ih(o), toNode: u, toHandle: d })
    let A = ''
    const h = { sourceX: s.x, sourceY: s.y, sourcePosition: l, targetX: c.x, targetY: c.y, targetPosition: f }
    switch (t) {
      case Sn.Bezier:
        ;[A] = Xh(h)
        break
      case Sn.SimpleBezier:
        ;[A] = qg(h)
        break
      case Sn.Step:
        ;[A] = qa({ ...h, borderRadius: 0 })
        break
      case Sn.SmoothStep:
        ;[A] = qa(h)
        break
      default:
        ;[A] = Hh(h)
    }
    return p.jsx('path', { d: A, fill: 'none', className: 'react-flow__connection-path', style: e })
  }
  fm.displayName = 'ConnectionLine'
  const P5 = {}
  function Am(e = P5) {
    C.useRef(e), qe(), C.useEffect(() => {}, [e])
  }
  function L5() {
    qe(), C.useRef(!1), C.useEffect(() => {}, [])
  }
  function pm({
    nodeTypes: e,
    edgeTypes: t,
    onInit: n,
    onNodeClick: o,
    onEdgeClick: r,
    onNodeDoubleClick: s,
    onEdgeDoubleClick: i,
    onNodeMouseEnter: a,
    onNodeMouseMove: l,
    onNodeMouseLeave: c,
    onNodeContextMenu: u,
    onSelectionContextMenu: d,
    onSelectionStart: f,
    onSelectionEnd: A,
    connectionLineType: h,
    connectionLineStyle: g,
    connectionLineComponent: x,
    connectionLineContainerStyle: m,
    selectionKeyCode: v,
    selectionOnDrag: y,
    selectionMode: b,
    multiSelectionKeyCode: w,
    panActivationKeyCode: k,
    zoomActivationKeyCode: E,
    deleteKeyCode: P,
    onlyRenderVisibleElements: T,
    elementsSelectable: F,
    defaultViewport: D,
    translateExtent: Q,
    minZoom: R,
    maxZoom: S,
    preventScrolling: L,
    defaultMarkerColor: I,
    zoomOnScroll: z,
    zoomOnPinch: B,
    panOnScroll: O,
    panOnScrollSpeed: W,
    panOnScrollMode: K,
    zoomOnDoubleClick: Z,
    panOnDrag: oe,
    onPaneClick: V,
    onPaneMouseEnter: q,
    onPaneMouseMove: ee,
    onPaneMouseLeave: re,
    onPaneScroll: J,
    onPaneContextMenu: ie,
    paneClickDistance: Ae,
    nodeClickDistance: ae,
    onEdgeContextMenu: se,
    onEdgeMouseEnter: H,
    onEdgeMouseMove: U,
    onEdgeMouseLeave: te,
    reconnectRadius: be,
    onReconnect: Ne,
    onReconnectStart: Me,
    onReconnectEnd: Ue,
    noDragClassName: we,
    noWheelClassName: Se,
    noPanClassName: et,
    disableKeyboardA11y: We,
    nodeExtent: Ie,
    rfId: Ze,
    viewport: Ke,
    onViewportChange: Ve,
  }) {
    return (
      Am(e),
      Am(t),
      L5(),
      w5(n),
      S5(Ke),
      p.jsx(qL, {
        onPaneClick: V,
        onPaneMouseEnter: q,
        onPaneMouseMove: ee,
        onPaneMouseLeave: re,
        onPaneContextMenu: ie,
        onPaneScroll: J,
        paneClickDistance: Ae,
        deleteKeyCode: P,
        selectionKeyCode: v,
        selectionOnDrag: y,
        selectionMode: b,
        onSelectionStart: f,
        onSelectionEnd: A,
        multiSelectionKeyCode: w,
        panActivationKeyCode: k,
        zoomActivationKeyCode: E,
        elementsSelectable: F,
        zoomOnScroll: z,
        zoomOnPinch: B,
        zoomOnDoubleClick: Z,
        panOnScroll: O,
        panOnScrollSpeed: W,
        panOnScrollMode: K,
        panOnDrag: oe,
        defaultViewport: D,
        translateExtent: Q,
        minZoom: R,
        maxZoom: S,
        onSelectionContextMenu: d,
        preventScrolling: L,
        noDragClassName: we,
        noWheelClassName: Se,
        noPanClassName: et,
        disableKeyboardA11y: We,
        onViewportChange: Ve,
        isControlledViewport: !!Ke,
        children: p.jsxs(C5, {
          children: [
            p.jsx(v5, {
              edgeTypes: t,
              onEdgeClick: r,
              onEdgeDoubleClick: i,
              onReconnect: Ne,
              onReconnectStart: Me,
              onReconnectEnd: Ue,
              onlyRenderVisibleElements: T,
              onEdgeContextMenu: se,
              onEdgeMouseEnter: H,
              onEdgeMouseMove: U,
              onEdgeMouseLeave: te,
              reconnectRadius: be,
              defaultMarkerColor: I,
              noPanClassName: et,
              disableKeyboardA11y: We,
              rfId: Ze,
            }),
            p.jsx(M5, { style: g, type: h, component: x, containerStyle: m }),
            p.jsx('div', { className: 'react-flow__edgelabel-renderer' }),
            p.jsx(o5, { nodeTypes: e, onNodeClick: o, onNodeDoubleClick: s, onNodeMouseEnter: a, onNodeMouseMove: l, onNodeMouseLeave: c, onNodeContextMenu: u, nodeClickDistance: ae, onlyRenderVisibleElements: T, noPanClassName: et, noDragClassName: we, disableKeyboardA11y: We, nodeExtent: Ie, rfId: Ze }),
            p.jsx('div', { className: 'react-flow__viewport-portal' }),
          ],
        }),
      })
    )
  }
  pm.displayName = 'GraphView'
  const T5 = C.memo(pm),
    hm = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: s, fitView: i, nodeOrigin: a, nodeExtent: l } = {}) => {
      const c = new Map(),
        u = new Map(),
        d = new Map(),
        f = new Map(),
        A = o ?? t ?? [],
        h = n ?? e ?? [],
        g = a ?? [0, 0],
        x = l ?? vs
      $h(d, f, A), zu(h, c, u, { nodeOrigin: g, nodeExtent: x, elevateNodesOnSelect: !1 })
      let m = [0, 0, 1]
      if (i && r && s) {
        const v = ws(c, { filter: k => !!((k.width || k.initialWidth) && (k.height || k.initialHeight)) }),
          { x: y, y: b, zoom: w } = Mu(v, r, s, 0.5, 2, 0.1)
        m = [y, b, w]
      }
      return {
        rfId: '1',
        width: 0,
        height: 0,
        transform: m,
        nodes: h,
        nodeLookup: c,
        parentLookup: u,
        edges: A,
        edgeLookup: f,
        connectionLookup: d,
        onNodesChange: null,
        onEdgesChange: null,
        hasDefaultNodes: n !== void 0,
        hasDefaultEdges: o !== void 0,
        panZoom: null,
        minZoom: 0.5,
        maxZoom: 2,
        translateExtent: vs,
        nodeExtent: x,
        nodesSelectionActive: !1,
        userSelectionActive: !1,
        userSelectionRect: null,
        connectionMode: yr.Strict,
        domNode: null,
        paneDragging: !1,
        noPanClassName: 'nopan',
        nodeOrigin: g,
        nodeDragThreshold: 1,
        snapGrid: [15, 15],
        snapToGrid: !1,
        nodesDraggable: !0,
        nodesConnectable: !0,
        nodesFocusable: !0,
        edgesFocusable: !0,
        edgesReconnectable: !0,
        elementsSelectable: !0,
        elevateNodesOnSelect: !0,
        elevateEdgesOnSelect: !1,
        fitViewOnInit: !1,
        fitViewDone: !1,
        fitViewOnInitOptions: void 0,
        selectNodesOnDrag: !0,
        multiSelectionActive: !1,
        connection: { ...Sh },
        connectionClickStartHandle: null,
        connectOnClick: !0,
        ariaLiveMessage: '',
        autoPanOnConnect: !0,
        autoPanOnNodeDrag: !0,
        autoPanSpeed: 15,
        connectionRadius: 20,
        onError: XP,
        isValidConnection: void 0,
        onSelectionChangeHandlers: [],
        lib: 'react',
        debug: !1,
      }
    },
    F5 = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: s, fitView: i, nodeOrigin: a, nodeExtent: l }) =>
      eL(
        (c, u) => ({
          ...hm({ nodes: e, edges: t, width: r, height: s, fitView: i, nodeOrigin: a, nodeExtent: l, defaultNodes: n, defaultEdges: o }),
          setNodes: d => {
            const { nodeLookup: f, parentLookup: A, nodeOrigin: h, elevateNodesOnSelect: g } = u()
            zu(d, f, A, { nodeOrigin: h, nodeExtent: l, elevateNodesOnSelect: g, checkEquality: !0 }), c({ nodes: d })
          },
          setEdges: d => {
            const { connectionLookup: f, edgeLookup: A } = u()
            $h(f, A, d), c({ edges: d })
          },
          setDefaultNodesAndEdges: (d, f) => {
            if (d) {
              const { setNodes: A } = u()
              A(d), c({ hasDefaultNodes: !0 })
            }
            if (f) {
              const { setEdges: A } = u()
              A(f), c({ hasDefaultEdges: !0 })
            }
          },
          updateNodeInternals: (d, f = { triggerFitView: !0 }) => {
            const { triggerNodeChanges: A, nodeLookup: h, parentLookup: g, fitViewOnInit: x, fitViewDone: m, fitViewOnInitOptions: v, domNode: y, nodeOrigin: b, nodeExtent: w, debug: k, fitViewSync: E } = u(),
              { changes: P, updatedInternals: T } = s2(d, h, g, y, b, w)
            if (T) {
              if ((n2(h, g, { nodeOrigin: b, nodeExtent: w }), f.triggerFitView)) {
                let F = m
                !m && x && (F = E({ ...v, nodes: v == null ? void 0 : v.nodes })), c({ fitViewDone: F })
              } else c({})
              ;(P == null ? void 0 : P.length) > 0 && (k && console.log('React Flow: trigger node changes', P), A == null || A(P))
            }
          },
          updateNodePositions: (d, f = !1) => {
            const A = [],
              h = []
            for (const [g, x] of d) {
              const m = !!(x != null && x.expandParent && x != null && x.parentId && x != null && x.position),
                v = { id: g, type: 'position', position: m ? { x: Math.max(0, x.position.x), y: Math.max(0, x.position.y) } : x.position, dragging: f }
              m && A.push({ id: g, parentId: x.parentId, rect: { ...x.internals.positionAbsolute, width: x.measured.width, height: x.measured.height } }), h.push(v)
            }
            if (A.length > 0) {
              const { nodeLookup: g, parentLookup: x, nodeOrigin: m } = u(),
                v = Ru(A, g, x, m)
              h.push(...v)
            }
            u().triggerNodeChanges(h)
          },
          triggerNodeChanges: d => {
            const { onNodesChange: f, setNodes: A, nodes: h, hasDefaultNodes: g, debug: x } = u()
            if (d != null && d.length) {
              if (g) {
                const m = Ng(d, h)
                A(m)
              }
              x && console.log('React Flow: trigger node changes', d), f == null || f(d)
            }
          },
          triggerEdgeChanges: d => {
            const { onEdgesChange: f, setEdges: A, edges: h, hasDefaultEdges: g, debug: x } = u()
            if (d != null && d.length) {
              if (g) {
                const m = Mg(d, h)
                A(m)
              }
              x && console.log('React Flow: trigger edge changes', d), f == null || f(d)
            }
          },
          addSelectedNodes: d => {
            const { multiSelectionActive: f, edgeLookup: A, nodeLookup: h, triggerNodeChanges: g, triggerEdgeChanges: x } = u()
            if (f) {
              const m = d.map(v => ko(v, !0))
              g(m)
              return
            }
            g(Sr(h, new Set([...d]), !0)), x(Sr(A))
          },
          addSelectedEdges: d => {
            const { multiSelectionActive: f, edgeLookup: A, nodeLookup: h, triggerNodeChanges: g, triggerEdgeChanges: x } = u()
            if (f) {
              const m = d.map(v => ko(v, !0))
              x(m)
              return
            }
            x(Sr(A, new Set([...d]))), g(Sr(h, new Set(), !0))
          },
          unselectNodesAndEdges: ({ nodes: d, edges: f } = {}) => {
            const { edges: A, nodes: h, nodeLookup: g, triggerNodeChanges: x, triggerEdgeChanges: m } = u(),
              v = d || h,
              y = f || A,
              b = v.map(k => {
                const E = g.get(k.id)
                return E && (E.selected = !1), ko(k.id, !1)
              }),
              w = y.map(k => ko(k.id, !1))
            x(b), m(w)
          },
          setMinZoom: d => {
            const { panZoom: f, maxZoom: A } = u()
            f == null || f.setScaleExtent([d, A]), c({ minZoom: d })
          },
          setMaxZoom: d => {
            const { panZoom: f, minZoom: A } = u()
            f == null || f.setScaleExtent([A, d]), c({ maxZoom: d })
          },
          setTranslateExtent: d => {
            var f
            ;(f = u().panZoom) == null || f.setTranslateExtent(d), c({ translateExtent: d })
          },
          setPaneClickDistance: d => {
            var f
            ;(f = u().panZoom) == null || f.setClickDistance(d)
          },
          resetSelectedElements: () => {
            const { edges: d, nodes: f, triggerNodeChanges: A, triggerEdgeChanges: h } = u(),
              g = f.reduce((m, v) => (v.selected ? [...m, ko(v.id, !1)] : m), []),
              x = d.reduce((m, v) => (v.selected ? [...m, ko(v.id, !1)] : m), [])
            A(g), h(x)
          },
          setNodeExtent: d => {
            const { nodes: f, nodeLookup: A, parentLookup: h, nodeOrigin: g, elevateNodesOnSelect: x, nodeExtent: m } = u()
            ;(d[0][0] === m[0][0] && d[0][1] === m[0][1] && d[1][0] === m[1][0] && d[1][1] === m[1][1]) || (zu(f, A, h, { nodeOrigin: g, nodeExtent: d, elevateNodesOnSelect: x, checkEquality: !1 }), c({ nodeExtent: d }))
          },
          panBy: d => {
            const { transform: f, width: A, height: h, panZoom: g, translateExtent: x } = u()
            return i2({ delta: d, panZoom: g, transform: f, translateExtent: x, width: A, height: h })
          },
          fitView: d => {
            const { panZoom: f, width: A, height: h, minZoom: g, maxZoom: x, nodeLookup: m } = u()
            if (!f) return Promise.resolve(!1)
            const v = Iu(m, d)
            return ku({ nodes: v, width: A, height: h, panZoom: f, minZoom: g, maxZoom: x }, d)
          },
          fitViewSync: d => {
            const { panZoom: f, width: A, height: h, minZoom: g, maxZoom: x, nodeLookup: m } = u()
            if (!f) return !1
            const v = Iu(m, d)
            return ku({ nodes: v, width: A, height: h, panZoom: f, minZoom: g, maxZoom: x }, d), v.size > 0
          },
          cancelConnection: () => {
            c({ connection: { ...Sh } })
          },
          updateConnection: d => {
            c({ connection: d })
          },
          reset: () => c({ ...hm() }),
        }),
        Object.is
      )
  function gm({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: o, initialWidth: r, initialHeight: s, fitView: i, nodeOrigin: a, nodeExtent: l, children: c }) {
    const [u] = C.useState(() => F5({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: s, fitView: i, nodeOrigin: a, nodeExtent: l }))
    return p.jsx(tL, { value: u, children: p.jsx(wL, { children: c }) })
  }
  function D5({ children: e, nodes: t, edges: n, defaultNodes: o, defaultEdges: r, width: s, height: i, fitView: a, nodeOrigin: l, nodeExtent: c }) {
    return C.useContext($a) ? p.jsx(p.Fragment, { children: e }) : p.jsx(gm, { initialNodes: t, initialEdges: n, defaultNodes: o, defaultEdges: r, initialWidth: s, initialHeight: i, fitView: a, nodeOrigin: l, nodeExtent: c, children: e })
  }
  const z5 = { width: '100%', height: '100%', overflow: 'hidden', position: 'relative', zIndex: 0 }
  function Q5(
    {
      nodes: e,
      edges: t,
      defaultNodes: n,
      defaultEdges: o,
      className: r,
      nodeTypes: s,
      edgeTypes: i,
      onNodeClick: a,
      onEdgeClick: l,
      onInit: c,
      onMove: u,
      onMoveStart: d,
      onMoveEnd: f,
      onConnect: A,
      onConnectStart: h,
      onConnectEnd: g,
      onClickConnectStart: x,
      onClickConnectEnd: m,
      onNodeMouseEnter: v,
      onNodeMouseMove: y,
      onNodeMouseLeave: b,
      onNodeContextMenu: w,
      onNodeDoubleClick: k,
      onNodeDragStart: E,
      onNodeDrag: P,
      onNodeDragStop: T,
      onNodesDelete: F,
      onEdgesDelete: D,
      onDelete: Q,
      onSelectionChange: R,
      onSelectionDragStart: S,
      onSelectionDrag: L,
      onSelectionDragStop: I,
      onSelectionContextMenu: z,
      onSelectionStart: B,
      onSelectionEnd: O,
      onBeforeDelete: W,
      connectionMode: K,
      connectionLineType: Z = Sn.Bezier,
      connectionLineStyle: oe,
      connectionLineComponent: V,
      connectionLineContainerStyle: q,
      deleteKeyCode: ee = 'Backspace',
      selectionKeyCode: re = 'Shift',
      selectionOnDrag: J = !1,
      selectionMode: ie = xs.Full,
      panActivationKeyCode: Ae = 'Space',
      multiSelectionKeyCode: ae = Ha() ? 'Meta' : 'Control',
      zoomActivationKeyCode: se = Ha() ? 'Meta' : 'Control',
      snapToGrid: H,
      snapGrid: U,
      onlyRenderVisibleElements: te = !1,
      selectNodesOnDrag: be,
      nodesDraggable: Ne,
      nodesConnectable: Me,
      nodesFocusable: Ue,
      nodeOrigin: we = xg,
      edgesFocusable: Se,
      edgesReconnectable: et,
      elementsSelectable: We = !0,
      defaultViewport: Ie = pL,
      minZoom: Ze = 0.5,
      maxZoom: Ke = 2,
      translateExtent: Ve = vs,
      preventScrolling: X = !0,
      nodeExtent: G,
      defaultMarkerColor: ce = '#b1b1b7',
      zoomOnScroll: ne = !0,
      zoomOnPinch: ue = !0,
      panOnScroll: _ = !1,
      panOnScrollSpeed: pe = 0.5,
      panOnScrollMode: xe = Bo.Free,
      zoomOnDoubleClick: Ee = !0,
      panOnDrag: nt = !0,
      onPaneClick: nn,
      onPaneMouseEnter: Hn,
      onPaneMouseMove: Rr,
      onPaneMouseLeave: Or,
      onPaneScroll: Wo,
      onPaneContextMenu: Go,
      paneClickDistance: Vo = 0,
      nodeClickDistance: Xo = 0,
      children: Zs,
      onReconnect: Yo,
      onReconnectStart: Ho,
      onReconnectEnd: Uo,
      onEdgeContextMenu: Js,
      onEdgeDoubleClick: _s,
      onEdgeMouseEnter: $s,
      onEdgeMouseMove: ei,
      onEdgeMouseLeave: le,
      reconnectRadius: de = 10,
      onNodesChange: Be,
      onEdgesChange: ge,
      noDragClassName: Ce = 'nodrag',
      noWheelClassName: Je = 'nowheel',
      noPanClassName: gt = 'nopan',
      fitView: Te,
      fitViewOptions: tt,
      connectOnClick: io,
      attributionPosition: Un,
      proOptions: Dt,
      defaultEdgeOptions: TV,
      elevateNodesOnSelect: FV,
      elevateEdgesOnSelect: DV,
      disableKeyboardA11y: bb = !1,
      autoPanOnConnect: zV,
      autoPanOnNodeDrag: QV,
      autoPanSpeed: RV,
      connectionRadius: OV,
      isValidConnection: jV,
      onError: WV,
      style: GV,
      id: vb,
      nodeDragThreshold: VV,
      viewport: XV,
      onViewportChange: YV,
      width: HV,
      height: UV,
      colorMode: KV = 'light',
      debug: qV,
      ...ZV
    },
    JV
  ) {
    const _d = vb || '1',
      _V = mL(KV)
    return p.jsx('div', {
      'data-testid': 'rf__wrapper',
      ...ZV,
      style: { ...GV, ...z5 },
      ref: JV,
      className: dt(['react-flow', r, _V]),
      id: vb,
      children: p.jsxs(D5, {
        nodes: e,
        edges: t,
        width: HV,
        height: UV,
        fitView: Te,
        nodeOrigin: we,
        nodeExtent: G,
        children: [
          p.jsx(T5, {
            onInit: c,
            onNodeClick: a,
            onEdgeClick: l,
            onNodeMouseEnter: v,
            onNodeMouseMove: y,
            onNodeMouseLeave: b,
            onNodeContextMenu: w,
            onNodeDoubleClick: k,
            nodeTypes: s,
            edgeTypes: i,
            connectionLineType: Z,
            connectionLineStyle: oe,
            connectionLineComponent: V,
            connectionLineContainerStyle: q,
            selectionKeyCode: re,
            selectionOnDrag: J,
            selectionMode: ie,
            deleteKeyCode: ee,
            multiSelectionKeyCode: ae,
            panActivationKeyCode: Ae,
            zoomActivationKeyCode: se,
            onlyRenderVisibleElements: te,
            defaultViewport: Ie,
            translateExtent: Ve,
            minZoom: Ze,
            maxZoom: Ke,
            preventScrolling: X,
            zoomOnScroll: ne,
            zoomOnPinch: ue,
            zoomOnDoubleClick: Ee,
            panOnScroll: _,
            panOnScrollSpeed: pe,
            panOnScrollMode: xe,
            panOnDrag: nt,
            onPaneClick: nn,
            onPaneMouseEnter: Hn,
            onPaneMouseMove: Rr,
            onPaneMouseLeave: Or,
            onPaneScroll: Wo,
            onPaneContextMenu: Go,
            paneClickDistance: Vo,
            nodeClickDistance: Xo,
            onSelectionContextMenu: z,
            onSelectionStart: B,
            onSelectionEnd: O,
            onReconnect: Yo,
            onReconnectStart: Ho,
            onReconnectEnd: Uo,
            onEdgeContextMenu: Js,
            onEdgeDoubleClick: _s,
            onEdgeMouseEnter: $s,
            onEdgeMouseMove: ei,
            onEdgeMouseLeave: le,
            reconnectRadius: de,
            defaultMarkerColor: ce,
            noDragClassName: Ce,
            noWheelClassName: Je,
            noPanClassName: gt,
            rfId: _d,
            disableKeyboardA11y: bb,
            nodeExtent: G,
            viewport: XV,
            onViewportChange: YV,
          }),
          p.jsx(gL, {
            nodes: e,
            edges: t,
            defaultNodes: n,
            defaultEdges: o,
            onConnect: A,
            onConnectStart: h,
            onConnectEnd: g,
            onClickConnectStart: x,
            onClickConnectEnd: m,
            nodesDraggable: Ne,
            nodesConnectable: Me,
            nodesFocusable: Ue,
            edgesFocusable: Se,
            edgesReconnectable: et,
            elementsSelectable: We,
            elevateNodesOnSelect: FV,
            elevateEdgesOnSelect: DV,
            minZoom: Ze,
            maxZoom: Ke,
            nodeExtent: G,
            onNodesChange: Be,
            onEdgesChange: ge,
            snapToGrid: H,
            snapGrid: U,
            connectionMode: K,
            translateExtent: Ve,
            connectOnClick: io,
            defaultEdgeOptions: TV,
            fitView: Te,
            fitViewOptions: tt,
            onNodesDelete: F,
            onEdgesDelete: D,
            onDelete: Q,
            onNodeDragStart: E,
            onNodeDrag: P,
            onNodeDragStop: T,
            onSelectionDrag: L,
            onSelectionDragStart: S,
            onSelectionDragStop: I,
            onMove: u,
            onMoveStart: d,
            onMoveEnd: f,
            noPanClassName: gt,
            nodeOrigin: we,
            rfId: _d,
            autoPanOnConnect: zV,
            autoPanOnNodeDrag: QV,
            autoPanSpeed: RV,
            onError: WV,
            connectionRadius: OV,
            isValidConnection: jV,
            selectNodesOnDrag: be,
            nodeDragThreshold: VV,
            onBeforeDelete: W,
            paneClickDistance: Vo,
            debug: qV,
          }),
          p.jsx(AL, { onSelectionChange: R }),
          Zs,
          p.jsx(lL, { proOptions: Dt, position: Un }),
          p.jsx(iL, { rfId: _d, disableKeyboardA11y: bb }),
        ],
      }),
    })
  }
  var R5 = Fg(Q5)
  const O5 = e => {
    var t
    return (t = e.domNode) == null ? void 0 : t.querySelector('.react-flow__edgelabel-renderer')
  }
  function j5({ children: e }) {
    const t = ke(O5)
    return t ? pt.createPortal(e, t) : null
  }
  function W5() {
    const e = qe()
    return C.useCallback(t => {
      const { domNode: n, updateNodeInternals: o } = e.getState(),
        r = Array.isArray(t) ? t : [t],
        s = new Map()
      r.forEach(i => {
        const a = n == null ? void 0 : n.querySelector(`.react-flow__node[data-id="${i}"]`)
        a && s.set(i, { id: i, nodeElement: a, force: !0 })
      }),
        requestAnimationFrame(() => o(s, { triggerFitView: !1 }))
    }, [])
  }
  function G5({ dimensions: e, lineWidth: t, variant: n, className: o }) {
    return p.jsx('path', { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: dt(['react-flow__background-pattern', n, o]) })
  }
  function V5({ radius: e, className: t }) {
    return p.jsx('circle', { cx: e, cy: e, r: e, className: dt(['react-flow__background-pattern', 'dots', t]) })
  }
  var $n
  ;(function (e) {
    ;(e.Lines = 'lines'), (e.Dots = 'dots'), (e.Cross = 'cross')
  })($n || ($n = {}))
  const X5 = { [$n.Dots]: 1, [$n.Lines]: 1, [$n.Cross]: 6 },
    Y5 = e => ({ transform: e.transform, patternId: `pattern-${e.rfId}` })
  function mm({ id: e, variant: t = $n.Dots, gap: n = 20, size: o, lineWidth: r = 1, offset: s = 0, color: i, bgColor: a, style: l, className: c, patternClassName: u }) {
    const d = C.useRef(null),
      { transform: f, patternId: A } = ke(Y5, it),
      h = o || X5[t],
      g = t === $n.Dots,
      x = t === $n.Cross,
      m = Array.isArray(n) ? n : [n, n],
      v = [m[0] * f[2] || 1, m[1] * f[2] || 1],
      y = h * f[2],
      b = Array.isArray(s) ? s : [s, s],
      w = x ? [y, y] : v,
      k = [b[0] * f[2] || 1 + w[0] / 2, b[1] * f[2] || 1 + w[1] / 2],
      E = `${A}${e || ''}`
    return p.jsxs('svg', {
      className: dt(['react-flow__background', c]),
      style: { ...l, ...nl, '--xy-background-color-props': a, '--xy-background-pattern-color-props': i },
      ref: d,
      'data-testid': 'rf__background',
      children: [
        p.jsx('pattern', { id: E, x: f[0] % v[0], y: f[1] % v[1], width: v[0], height: v[1], patternUnits: 'userSpaceOnUse', patternTransform: `translate(-${k[0]},-${k[1]})`, children: g ? p.jsx(V5, { radius: y / 2, className: u }) : p.jsx(G5, { dimensions: w, lineWidth: r, variant: t, className: u }) }),
        p.jsx('rect', { x: '0', y: '0', width: '100%', height: '100%', fill: `url(#${E})` }),
      ],
    })
  }
  mm.displayName = 'Background'
  const H5 = C.memo(mm)
  function U5() {
    return p.jsx('svg', { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 32 32', children: p.jsx('path', { d: 'M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z' }) })
  }
  function K5() {
    return p.jsx('svg', { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 32 5', children: p.jsx('path', { d: 'M0 0h32v4.2H0z' }) })
  }
  function q5() {
    return p.jsx('svg', {
      xmlns: 'http://www.w3.org/2000/svg',
      viewBox: '0 0 32 30',
      children: p.jsx('path', {
        d: 'M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z',
      }),
    })
  }
  function Z5() {
    return p.jsx('svg', {
      xmlns: 'http://www.w3.org/2000/svg',
      viewBox: '0 0 25 32',
      children: p.jsx('path', {
        d: 'M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z',
      }),
    })
  }
  function J5() {
    return p.jsx('svg', {
      xmlns: 'http://www.w3.org/2000/svg',
      viewBox: '0 0 25 32',
      children: p.jsx('path', {
        d: 'M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z',
      }),
    })
  }
  function rl({ children: e, className: t, ...n }) {
    return p.jsx('button', { type: 'button', className: dt(['react-flow__controls-button', t]), ...n, children: e })
  }
  const _5 = e => ({ isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable, minZoomReached: e.transform[2] <= e.minZoom, maxZoomReached: e.transform[2] >= e.maxZoom })
  function ym({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: o = !0, fitViewOptions: r, onZoomIn: s, onZoomOut: i, onFitView: a, onInteractiveChange: l, className: c, children: u, position: d = 'bottom-left', orientation: f = 'vertical', 'aria-label': A = 'React Flow controls' }) {
    const h = qe(),
      { isInteractive: g, minZoomReached: x, maxZoomReached: m } = ke(_5, it),
      { zoomIn: v, zoomOut: y, fitView: b } = No(),
      w = () => {
        v(), s == null || s()
      },
      k = () => {
        y(), i == null || i()
      },
      E = () => {
        b(r), a == null || a()
      },
      P = () => {
        h.setState({ nodesDraggable: !g, nodesConnectable: !g, elementsSelectable: !g }), l == null || l(!g)
      },
      T = f === 'horizontal' ? 'horizontal' : 'vertical'
    return p.jsxs(el, {
      className: dt(['react-flow__controls', T, c]),
      position: d,
      style: e,
      'data-testid': 'rf__controls',
      'aria-label': A,
      children: [
        t &&
          p.jsxs(p.Fragment, { children: [p.jsx(rl, { onClick: w, className: 'react-flow__controls-zoomin', title: 'zoom in', 'aria-label': 'zoom in', disabled: m, children: p.jsx(U5, {}) }), p.jsx(rl, { onClick: k, className: 'react-flow__controls-zoomout', title: 'zoom out', 'aria-label': 'zoom out', disabled: x, children: p.jsx(K5, {}) })] }),
        n && p.jsx(rl, { className: 'react-flow__controls-fitview', onClick: E, title: 'fit view', 'aria-label': 'fit view', children: p.jsx(q5, {}) }),
        o && p.jsx(rl, { className: 'react-flow__controls-interactive', onClick: P, title: 'toggle interactivity', 'aria-label': 'toggle interactivity', children: g ? p.jsx(J5, {}) : p.jsx(Z5, {}) }),
        u,
      ],
    })
  }
  ;(ym.displayName = 'Controls'), C.memo(ym)
  function $5({ id: e, x: t, y: n, width: o, height: r, style: s, color: i, strokeColor: a, strokeWidth: l, className: c, borderRadius: u, shapeRendering: d, selected: f, onClick: A }) {
    const { background: h, backgroundColor: g } = s || {},
      x = i || h || g
    return p.jsx('rect', { className: dt(['react-flow__minimap-node', { selected: f }, c]), x: t, y: n, rx: u, ry: u, width: o, height: r, style: { fill: x, stroke: a, strokeWidth: l }, shapeRendering: d, onClick: A ? m => A(m, e) : void 0 })
  }
  const eT = C.memo($5),
    tT = e => e.nodes.map(t => t.id),
    Uu = e => (e instanceof Function ? e : () => e)
  function nT({ nodeStrokeColor: e, nodeColor: t, nodeClassName: n = '', nodeBorderRadius: o = 5, nodeStrokeWidth: r, nodeComponent: s = eT, onClick: i }) {
    const a = ke(tT, it),
      l = Uu(t),
      c = Uu(e),
      u = Uu(n),
      d = typeof window > 'u' || window.chrome ? 'crispEdges' : 'geometricPrecision'
    return p.jsx(p.Fragment, { children: a.map(f => p.jsx(rT, { id: f, nodeColorFunc: l, nodeStrokeColorFunc: c, nodeClassNameFunc: u, nodeBorderRadius: o, nodeStrokeWidth: r, NodeComponent: s, onClick: i, shapeRendering: d }, f)) })
  }
  function oT({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: o, nodeBorderRadius: r, nodeStrokeWidth: s, shapeRendering: i, NodeComponent: a, onClick: l }) {
    const {
      node: c,
      x: u,
      y: d,
      width: f,
      height: A,
    } = ke(h => {
      const g = h.nodeLookup.get(e),
        { x, y: m } = g.internals.positionAbsolute,
        { width: v, height: y } = Qn(g)
      return { node: g, x, y: m, width: v, height: y }
    }, it)
    return !c || c.hidden || !Qh(c) ? null : p.jsx(a, { x: u, y: d, width: f, height: A, style: c.style, selected: !!c.selected, className: o(c), color: t(c), borderRadius: r, strokeColor: n(c), strokeWidth: s, shapeRendering: i, onClick: l, id: c.id })
  }
  const rT = C.memo(oT)
  var sT = C.memo(nT)
  const iT = 200,
    aT = 150,
    lT = e => {
      const t = { x: -e.transform[0] / e.transform[2], y: -e.transform[1] / e.transform[2], width: e.width / e.transform[2], height: e.height / e.transform[2] }
      return { viewBB: t, boundingRect: e.nodeLookup.size > 0 ? Fh(ws(e.nodeLookup), t) : t, rfId: e.rfId, panZoom: e.panZoom, translateExtent: e.translateExtent, flowWidth: e.width, flowHeight: e.height }
    },
    cT = 'react-flow__minimap-desc'
  function bm({
    style: e,
    className: t,
    nodeStrokeColor: n,
    nodeColor: o,
    nodeClassName: r = '',
    nodeBorderRadius: s = 5,
    nodeStrokeWidth: i,
    nodeComponent: a,
    bgColor: l,
    maskColor: c,
    maskStrokeColor: u,
    maskStrokeWidth: d,
    position: f = 'bottom-right',
    onClick: A,
    onNodeClick: h,
    pannable: g = !1,
    zoomable: x = !1,
    ariaLabel: m = 'React Flow mini map',
    inversePan: v,
    zoomStep: y = 10,
    offsetScale: b = 5,
  }) {
    const w = qe(),
      k = C.useRef(null),
      { boundingRect: E, viewBB: P, rfId: T, panZoom: F, translateExtent: D, flowWidth: Q, flowHeight: R } = ke(lT, it),
      S = (e == null ? void 0 : e.width) ?? iT,
      L = (e == null ? void 0 : e.height) ?? aT,
      I = E.width / S,
      z = E.height / L,
      B = Math.max(I, z),
      O = B * S,
      W = B * L,
      K = b * B,
      Z = E.x - (O - E.width) / 2 - K,
      oe = E.y - (W - E.height) / 2 - K,
      V = O + K * 2,
      q = W + K * 2,
      ee = `${cT}-${T}`,
      re = C.useRef(0),
      J = C.useRef()
    ;(re.current = B),
      C.useEffect(() => {
        if (k.current && F)
          return (
            (J.current = p2({ domNode: k.current, panZoom: F, getTransform: () => w.getState().transform, getViewScale: () => re.current })),
            () => {
              var ae
              ;(ae = J.current) == null || ae.destroy()
            }
          )
      }, [F]),
      C.useEffect(() => {
        var ae
        ;(ae = J.current) == null || ae.update({ translateExtent: D, width: Q, height: R, inversePan: v, pannable: g, zoomStep: y, zoomable: x })
      }, [g, x, v, y, D, Q, R])
    const ie = A
        ? ae => {
            var U
            const [se, H] = ((U = J.current) == null ? void 0 : U.pointer(ae)) || [0, 0]
            A(ae, { x: se, y: H })
          }
        : void 0,
      Ae = h
        ? C.useCallback((ae, se) => {
            const H = w.getState().nodeLookup.get(se)
            h(ae, H)
          }, [])
        : void 0
    return p.jsx(el, {
      position: f,
      style: {
        ...e,
        '--xy-minimap-background-color-props': typeof l == 'string' ? l : void 0,
        '--xy-minimap-mask-background-color-props': typeof c == 'string' ? c : void 0,
        '--xy-minimap-mask-stroke-color-props': typeof u == 'string' ? u : void 0,
        '--xy-minimap-mask-stroke-width-props': typeof d == 'number' ? d * B : void 0,
        '--xy-minimap-node-background-color-props': typeof o == 'string' ? o : void 0,
        '--xy-minimap-node-stroke-color-props': typeof n == 'string' ? n : void 0,
        '--xy-minimap-node-stroke-width-props': typeof i == 'string' ? i : void 0,
      },
      className: dt(['react-flow__minimap', t]),
      'data-testid': 'rf__minimap',
      children: p.jsxs('svg', {
        width: S,
        height: L,
        viewBox: `${Z} ${oe} ${V} ${q}`,
        className: 'react-flow__minimap-svg',
        role: 'img',
        'aria-labelledby': ee,
        ref: k,
        onClick: ie,
        children: [
          m && p.jsx('title', { id: ee, children: m }),
          p.jsx(sT, { onClick: Ae, nodeColor: o, nodeStrokeColor: n, nodeBorderRadius: s, nodeClassName: r, nodeStrokeWidth: i, nodeComponent: a }),
          p.jsx('path', {
            className: 'react-flow__minimap-mask',
            d: `M${Z - K},${oe - K}h${V + K * 2}v${q + K * 2}h${-V - K * 2}z
        M${P.x},${P.y}h${P.width}v${P.height}h${-P.width}z`,
            fillRule: 'evenodd',
            pointerEvents: 'none',
          }),
        ],
      }),
    })
  }
  bm.displayName = 'MiniMap'
  const uT = C.memo(bm)
  function dT({ nodeId: e, position: t, variant: n = ks.Handle, className: o, style: r = {}, children: s, color: i, minWidth: a = 10, minHeight: l = 10, maxWidth: c = Number.MAX_VALUE, maxHeight: u = Number.MAX_VALUE, keepAspectRatio: d = !1, shouldResize: f, onResizeStart: A, onResize: h, onResizeEnd: g }) {
    const x = jg(),
      m = typeof e == 'string' ? e : x,
      v = qe(),
      y = C.useRef(null),
      b = n === ks.Line ? 'right' : 'bottom-right',
      w = t ?? b,
      k = C.useRef(null)
    C.useEffect(() => {
      if (!(!y.current || !m))
        return (
          k.current ||
            (k.current = N2({
              domNode: y.current,
              nodeId: m,
              getStoreItems: () => {
                const { nodeLookup: F, transform: D, snapGrid: Q, snapToGrid: R, nodeOrigin: S, domNode: L } = v.getState()
                return { nodeLookup: F, transform: D, snapGrid: Q, snapToGrid: R, nodeOrigin: S, paneDomNode: L }
              },
              onChange: (F, D) => {
                const { triggerNodeChanges: Q, nodeLookup: R, parentLookup: S, nodeOrigin: L } = v.getState(),
                  I = [],
                  z = { x: F.x, y: F.y },
                  B = R.get(m)
                if (B && B.expandParent && B.parentId) {
                  const O = B.origin ?? L,
                    W = F.width ?? B.measured.width,
                    K = F.height ?? B.measured.height,
                    Z = { id: B.id, parentId: B.parentId, rect: { width: W, height: K, ...Rh({ x: F.x ?? B.position.x, y: F.y ?? B.position.y }, { width: W, height: K }, B.parentId, R, O) } },
                    oe = Ru([Z], R, S, L)
                  I.push(...oe), (z.x = F.x ? Math.max(O[0] * W, F.x) : void 0), (z.y = F.y ? Math.max(O[1] * K, F.y) : void 0)
                }
                if (z.x !== void 0 && z.y !== void 0) {
                  const O = { id: m, type: 'position', position: { ...z } }
                  I.push(O)
                }
                if (F.width !== void 0 && F.height !== void 0) {
                  const O = { id: m, type: 'dimensions', resizing: !0, setAttributes: !0, dimensions: { width: F.width, height: F.height } }
                  I.push(O)
                }
                for (const O of D) {
                  const W = { ...O, type: 'position' }
                  I.push(W)
                }
                Q(I)
              },
              onEnd: () => {
                const F = { id: m, type: 'dimensions', resizing: !1 }
                v.getState().triggerNodeChanges([F])
              },
            })),
          k.current.update({ controlPosition: w, boundaries: { minWidth: a, minHeight: l, maxWidth: c, maxHeight: u }, keepAspectRatio: d, onResizeStart: A, onResize: h, onResizeEnd: g, shouldResize: f }),
          () => {
            var F
            ;(F = k.current) == null || F.destroy()
          }
        )
    }, [w, a, l, c, u, d, A, h, g, f])
    const E = w.split('-'),
      P = n === ks.Line ? 'borderColor' : 'backgroundColor',
      T = i ? { ...r, [P]: i } : r
    return p.jsx('div', { className: dt(['react-flow__resize-control', 'nodrag', ...E, n, o]), ref: y, style: T, children: s })
  }
  C.memo(dT)
  const vm = st({ opacity: 0, pointerEvents: 'none', cursor: 'auto' }),
    fT = ({ id: e, sourceX: t, sourceY: n, targetX: o, targetY: r, sourcePosition: s, targetPosition: i, data: a }) => {
      const [l, c, u] = qa({ sourceX: t, sourceY: n, sourcePosition: s, targetX: o, targetY: r, targetPosition: i }),
        d = a == null ? void 0 : a.isInvisibleEdge
      return p.jsxs(p.Fragment, {
        children: [p.jsx(Ms, { id: e, path: l, style: { ...(d ? vm : {}) } }), p.jsx(j5, { children: p.jsx('div', { style: st({ transform: `translate(${c - 28}px,${u - 28}px)`, fontSize: 12 }), className: 'edge-label-renderer__custom-edge nodrag nopan', dangerouslySetInnerHTML: { __html: a == null ? void 0 : a.label } }) })],
      })
    },
    xm = { DefaultEdge: 'step' },
    AT = { [xm.DefaultEdge]: fT },
    eo = e => ({ ...e, id: e.id ?? Co(), type: e.type ?? xm.DefaultEdge }),
    pT = e => {
      var t
      return (t = e.style) == null ? void 0 : t.stroke
    },
    hT = e => 'class' in e.data && typeof e.data.class == 'string',
    Oe = e => p.jsx(Ns, { ...e }),
    gT = j('div')`
  padding: 16px 64px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
`,
    mT = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: 100%;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const yT = e => {
      const t = C.useRef(!1)
      C.useEffect(() => {
        t.current || ((t.current = !0), e())
      }, [e])
    },
    sl = (e = !1) => {
      const [t, n] = C.useState(e),
        o = C.useCallback(() => n(!0), []),
        r = C.useCallback(() => n(!1), []),
        s = C.useCallback(() => n(i => !i), [])
      return [t, n, o, r, s]
    },
    Cm = (e, t) => {
      C.useEffect(() => {
        const n = o => {
          const r = new Set()
          o.metaKey && r.add('Meta'), o.ctrlKey && r.add('Ctrl'), o.altKey && r.add('Alt'), o.shiftKey && r.add('Shift'), o.key.length === 1 && r.add(o.key.toUpperCase()), e.every(i => r.has(i)) && (o.preventDefault(), t())
        }
        return (
          window.addEventListener('keydown', n),
          () => {
            window.removeEventListener('keydown', n)
          }
        )
      }, [e, t])
    },
    Et = e => {
      const t = C.useRef(null)
      return (
        C.useEffect(() => {
          t.current && e(t.current)
        }, [e]),
        t
      )
    }
  function bT(e) {
    if (typeof document > 'u') return
    let t = document.head || document.getElementsByTagName('head')[0],
      n = document.createElement('style')
    ;(n.type = 'text/css'), t.firstChild ? t.insertBefore(n, t.firstChild) : t.appendChild(n), n.styleSheet ? (n.styleSheet.cssText = e) : n.appendChild(document.createTextNode(e))
  }
  bT(`:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}
`)
  var Ps = e => typeof e == 'number' && !isNaN(e),
    Mo = e => typeof e == 'string',
    On = e => typeof e == 'function',
    vT = e => Mo(e) || Ps(e),
    Ku = e => (Mo(e) || On(e) ? e : null),
    xT = (e, t) => (e === !1 || (Ps(e) && e > 0) ? e : t),
    qu = e => C.isValidElement(e) || Mo(e) || On(e) || Ps(e)
  function CT(e, t, n = 300) {
    let { scrollHeight: o, style: r } = e
    requestAnimationFrame(() => {
      ;(r.minHeight = 'initial'),
        (r.height = o + 'px'),
        (r.transition = `all ${n}ms`),
        requestAnimationFrame(() => {
          ;(r.height = '0'), (r.padding = '0'), (r.margin = '0'), setTimeout(t, n)
        })
    })
  }
  function wT({ enter: e, exit: t, appendPosition: n = !1, collapse: o = !0, collapseDuration: r = 300 }) {
    return function ({ children: s, position: i, preventExitTransition: a, done: l, nodeRef: c, isIn: u, playToast: d }) {
      let f = n ? `${e}--${i}` : e,
        A = n ? `${t}--${i}` : t,
        h = C.useRef(0)
      return (
        C.useLayoutEffect(() => {
          let g = c.current,
            x = f.split(' '),
            m = v => {
              v.target === c.current && (d(), g.removeEventListener('animationend', m), g.removeEventListener('animationcancel', m), h.current === 0 && v.type !== 'animationcancel' && g.classList.remove(...x))
            }
          g.classList.add(...x), g.addEventListener('animationend', m), g.addEventListener('animationcancel', m)
        }, []),
        C.useEffect(() => {
          let g = c.current,
            x = () => {
              g.removeEventListener('animationend', x), o ? CT(g, l, r) : l()
            }
          u || (a ? x() : ((h.current = 1), (g.className += ` ${A}`), g.addEventListener('animationend', x)))
        }, [u]),
        C.createElement(C.Fragment, null, s)
      )
    }
  }
  function wm(e, t) {
    return { content: Em(e.content, e.props), containerId: e.props.containerId, id: e.props.toastId, theme: e.props.theme, type: e.props.type, data: e.props.data || {}, isLoading: e.props.isLoading, icon: e.props.icon, reason: e.removalReason, status: t }
  }
  function Em(e, t, n = !1) {
    return C.isValidElement(e) && !Mo(e.type) ? C.cloneElement(e, { closeToast: t.closeToast, toastProps: t, data: t.data, isPaused: n }) : On(e) ? e({ closeToast: t.closeToast, toastProps: t, data: t.data, isPaused: n }) : e
  }
  function ET({ closeToast: e, theme: t, ariaLabel: n = 'close' }) {
    return C.createElement(
      'button',
      {
        className: `Toastify__close-button Toastify__close-button--${t}`,
        type: 'button',
        onClick: o => {
          o.stopPropagation(), e(!0)
        },
        'aria-label': n,
      },
      C.createElement('svg', { 'aria-hidden': 'true', viewBox: '0 0 14 16' }, C.createElement('path', { fillRule: 'evenodd', d: 'M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z' }))
    )
  }
  function ST({ delay: e, isRunning: t, closeToast: n, type: o = 'default', hide: r, className: s, controlledProgress: i, progress: a, rtl: l, isIn: c, theme: u }) {
    let d = r || (i && a === 0),
      f = { animationDuration: `${e}ms`, animationPlayState: t ? 'running' : 'paused' }
    i && (f.transform = `scaleX(${a})`)
    let A = fe('Toastify__progress-bar', i ? 'Toastify__progress-bar--controlled' : 'Toastify__progress-bar--animated', `Toastify__progress-bar-theme--${u}`, `Toastify__progress-bar--${o}`, { 'Toastify__progress-bar--rtl': l }),
      h = On(s) ? s({ rtl: l, type: o, defaultClassName: A }) : fe(A, s),
      g = {
        [i && a >= 1 ? 'onTransitionEnd' : 'onAnimationEnd']:
          i && a < 1
            ? null
            : () => {
                c && n()
              },
      }
    return C.createElement(
      'div',
      { className: 'Toastify__progress-bar--wrp', 'data-hidden': d },
      C.createElement('div', { className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${u} Toastify__progress-bar--${o}` }),
      C.createElement('div', { role: 'progressbar', 'aria-hidden': d ? 'true' : 'false', 'aria-label': 'notification timer', className: h, style: f, ...g })
    )
  }
  var BT = 1,
    Sm = () => `${BT++}`
  function IT(e, t, n) {
    let o = 1,
      r = 0,
      s = [],
      i = [],
      a = t,
      l = new Map(),
      c = new Set(),
      u = v => (c.add(v), () => c.delete(v)),
      d = () => {
        ;(i = Array.from(l.values())), c.forEach(v => v())
      },
      f = ({ containerId: v, toastId: y, updateId: b }) => {
        let w = v ? v !== e : e !== 1,
          k = l.has(y) && b == null
        return w || k
      },
      A = (v, y) => {
        l.forEach(b => {
          var w
          ;(y == null || y === b.props.toastId) && ((w = b.toggle) == null || w.call(b, v))
        })
      },
      h = v => {
        var y, b
        ;(b = (y = v.props) == null ? void 0 : y.onClose) == null || b.call(y, v.removalReason), (v.isActive = !1)
      },
      g = v => {
        if (v == null) l.forEach(h)
        else {
          let y = l.get(v)
          y && h(y)
        }
        d()
      },
      x = () => {
        ;(r -= s.length), (s = [])
      },
      m = v => {
        var y, b
        let { toastId: w, updateId: k } = v.props,
          E = k == null
        v.staleId && l.delete(v.staleId), (v.isActive = !0), l.set(w, v), d(), n(wm(v, E ? 'added' : 'updated')), E && ((b = (y = v.props).onOpen) == null || b.call(y))
      }
    return {
      id: e,
      props: a,
      observe: u,
      toggle: A,
      removeToast: g,
      toasts: l,
      clearQueue: x,
      buildToast: (v, y) => {
        if (f(y)) return
        let { toastId: b, updateId: w, data: k, staleId: E, delay: P } = y,
          T = w == null
        T && r++
        let F = {
          ...a,
          style: a.toastStyle,
          key: o++,
          ...Object.fromEntries(Object.entries(y).filter(([Q, R]) => R != null)),
          toastId: b,
          updateId: w,
          data: k,
          isIn: !1,
          className: Ku(y.className || a.toastClassName),
          progressClassName: Ku(y.progressClassName || a.progressClassName),
          autoClose: y.isLoading ? !1 : xT(y.autoClose, a.autoClose),
          closeToast(Q) {
            ;(l.get(b).removalReason = Q), g(b)
          },
          deleteToast() {
            let Q = l.get(b)
            if (Q != null) {
              if ((n(wm(Q, 'removed')), l.delete(b), r--, r < 0 && (r = 0), s.length > 0)) {
                m(s.shift())
                return
              }
              d()
            }
          },
        }
        ;(F.closeButton = a.closeButton), y.closeButton === !1 || qu(y.closeButton) ? (F.closeButton = y.closeButton) : y.closeButton === !0 && (F.closeButton = qu(a.closeButton) ? a.closeButton : !0)
        let D = { content: v, props: F, staleId: E }
        a.limit && a.limit > 0 && r > a.limit && T
          ? s.push(D)
          : Ps(P)
          ? setTimeout(() => {
              m(D)
            }, P)
          : m(D)
      },
      setProps(v) {
        a = v
      },
      setToggle: (v, y) => {
        let b = l.get(v)
        b && (b.toggle = y)
      },
      isToastActive: v => {
        var y
        return (y = l.get(v)) == null ? void 0 : y.isActive
      },
      getSnapshot: () => i,
    }
  }
  var It = new Map(),
    Ls = [],
    Zu = new Set(),
    kT = e => Zu.forEach(t => t(e)),
    Bm = () => It.size > 0
  function NT() {
    Ls.forEach(e => km(e.content, e.options)), (Ls = [])
  }
  var MT = (e, { containerId: t }) => {
    var n
    return (n = It.get(t || 1)) == null ? void 0 : n.toasts.get(e)
  }
  function Im(e, t) {
    var n
    if (t) return !!((n = It.get(t)) != null && n.isToastActive(e))
    let o = !1
    return (
      It.forEach(r => {
        r.isToastActive(e) && (o = !0)
      }),
      o
    )
  }
  function PT(e) {
    if (!Bm()) {
      Ls = Ls.filter(t => e != null && t.options.toastId !== e)
      return
    }
    if (e == null || vT(e))
      It.forEach(t => {
        t.removeToast(e)
      })
    else if (e && ('containerId' in e || 'id' in e)) {
      let t = It.get(e.containerId)
      t
        ? t.removeToast(e.id)
        : It.forEach(n => {
            n.removeToast(e.id)
          })
    }
  }
  var LT = (e = {}) => {
    It.forEach(t => {
      t.props.limit && (!e.containerId || t.id === e.containerId) && t.clearQueue()
    })
  }
  function km(e, t) {
    qu(e) &&
      (Bm() || Ls.push({ content: e, options: t }),
      It.forEach(n => {
        n.buildToast(e, t)
      }))
  }
  function TT(e) {
    var t
    ;(t = It.get(e.containerId || 1)) == null || t.setToggle(e.id, e.fn)
  }
  function Nm(e, t) {
    It.forEach(n => {
      ;(t == null || !(t != null && t.containerId) || (t == null ? void 0 : t.containerId) === n.id) && n.toggle(e, t == null ? void 0 : t.id)
    })
  }
  function FT(e) {
    let t = e.containerId || 1
    return {
      subscribe(n) {
        let o = IT(t, e, kT)
        It.set(t, o)
        let r = o.observe(n)
        return (
          NT(),
          () => {
            r(), It.delete(t)
          }
        )
      },
      setProps(n) {
        var o
        ;(o = It.get(t)) == null || o.setProps(n)
      },
      getSnapshot() {
        var n
        return (n = It.get(t)) == null ? void 0 : n.getSnapshot()
      },
    }
  }
  function DT(e) {
    return (
      Zu.add(e),
      () => {
        Zu.delete(e)
      }
    )
  }
  function zT(e) {
    return e && (Mo(e.toastId) || Ps(e.toastId)) ? e.toastId : Sm()
  }
  function Ts(e, t) {
    return km(e, t), t.toastId
  }
  function il(e, t) {
    return { ...t, type: (t && t.type) || e, toastId: zT(t) }
  }
  function al(e) {
    return (t, n) => Ts(t, il(e, n))
  }
  function De(e, t) {
    return Ts(e, il('default', t))
  }
  De.loading = (e, t) => Ts(e, il('default', { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...t }))
  function QT(e, { pending: t, error: n, success: o }, r) {
    let s
    t && (s = Mo(t) ? De.loading(t, r) : De.loading(t.render, { ...r, ...t }))
    let i = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null },
      a = (c, u, d) => {
        if (u == null) {
          De.dismiss(s)
          return
        }
        let f = { type: c, ...i, ...r, data: d },
          A = Mo(u) ? { render: u } : u
        return s ? De.update(s, { ...f, ...A }) : De(A.render, { ...f, ...A }), d
      },
      l = On(e) ? e() : e
    return l.then(c => a('success', o, c)).catch(c => a('error', n, c)), l
  }
  ;(De.promise = QT), (De.success = al('success')), (De.info = al('info')), (De.error = al('error')), (De.warning = al('warning')), (De.warn = De.warning), (De.dark = (e, t) => Ts(e, il('default', { theme: 'dark', ...t })))
  function RT(e) {
    PT(e)
  }
  ;(De.dismiss = RT),
    (De.clearWaitingQueue = LT),
    (De.isActive = Im),
    (De.update = (e, t = {}) => {
      let n = MT(e, t)
      if (n) {
        let { props: o, content: r } = n,
          s = { delay: 100, ...o, ...t, toastId: t.toastId || e, updateId: Sm() }
        s.toastId !== e && (s.staleId = e)
        let i = s.render || r
        delete s.render, Ts(i, s)
      }
    }),
    (De.done = e => {
      De.update(e, { progress: 1 })
    }),
    (De.onChange = DT),
    (De.play = e => Nm(!0, e)),
    (De.pause = e => Nm(!1, e))
  function OT(e) {
    var t
    let { subscribe: n, getSnapshot: o, setProps: r } = C.useRef(FT(e)).current
    r(e)
    let s = (t = C.useSyncExternalStore(n, o, o)) == null ? void 0 : t.slice()
    function i(a) {
      if (!s) return []
      let l = new Map()
      return (
        e.newestOnTop && s.reverse(),
        s.forEach(c => {
          let { position: u } = c.props
          l.has(u) || l.set(u, []), l.get(u).push(c)
        }),
        Array.from(l, c => a(c[0], c[1]))
      )
    }
    return { getToastToRender: i, isToastActive: Im, count: s == null ? void 0 : s.length }
  }
  function jT(e) {
    let [t, n] = C.useState(!1),
      [o, r] = C.useState(!1),
      s = C.useRef(null),
      i = C.useRef({ start: 0, delta: 0, removalDistance: 0, canCloseOnClick: !0, canDrag: !1, didMove: !1 }).current,
      { autoClose: a, pauseOnHover: l, closeToast: c, onClick: u, closeOnClick: d } = e
    TT({ id: e.toastId, containerId: e.containerId, fn: n }),
      C.useEffect(() => {
        if (e.pauseOnFocusLoss)
          return (
            f(),
            () => {
              A()
            }
          )
      }, [e.pauseOnFocusLoss])
    function f() {
      document.hasFocus() || m(), window.addEventListener('focus', x), window.addEventListener('blur', m)
    }
    function A() {
      window.removeEventListener('focus', x), window.removeEventListener('blur', m)
    }
    function h(E) {
      if (e.draggable === !0 || e.draggable === E.pointerType) {
        v()
        let P = s.current
        ;(i.canCloseOnClick = !0),
          (i.canDrag = !0),
          (P.style.transition = 'none'),
          e.draggableDirection === 'x' ? ((i.start = E.clientX), (i.removalDistance = P.offsetWidth * (e.draggablePercent / 100))) : ((i.start = E.clientY), (i.removalDistance = (P.offsetHeight * (e.draggablePercent === 80 ? e.draggablePercent * 1.5 : e.draggablePercent)) / 100))
      }
    }
    function g(E) {
      let { top: P, bottom: T, left: F, right: D } = s.current.getBoundingClientRect()
      E.nativeEvent.type !== 'touchend' && e.pauseOnHover && E.clientX >= F && E.clientX <= D && E.clientY >= P && E.clientY <= T ? m() : x()
    }
    function x() {
      n(!0)
    }
    function m() {
      n(!1)
    }
    function v() {
      ;(i.didMove = !1), document.addEventListener('pointermove', b), document.addEventListener('pointerup', w)
    }
    function y() {
      document.removeEventListener('pointermove', b), document.removeEventListener('pointerup', w)
    }
    function b(E) {
      let P = s.current
      if (i.canDrag && P) {
        ;(i.didMove = !0), t && m(), e.draggableDirection === 'x' ? (i.delta = E.clientX - i.start) : (i.delta = E.clientY - i.start), i.start !== E.clientX && (i.canCloseOnClick = !1)
        let T = e.draggableDirection === 'x' ? `${i.delta}px, var(--y)` : `0, calc(${i.delta}px + var(--y))`
        ;(P.style.transform = `translate3d(${T},0)`), (P.style.opacity = `${1 - Math.abs(i.delta / i.removalDistance)}`)
      }
    }
    function w() {
      y()
      let E = s.current
      if (i.canDrag && i.didMove && E) {
        if (((i.canDrag = !1), Math.abs(i.delta) > i.removalDistance)) {
          r(!0), e.closeToast(!0), e.collapseAll()
          return
        }
        ;(E.style.transition = 'transform 0.2s, opacity 0.2s'), E.style.removeProperty('transform'), E.style.removeProperty('opacity')
      }
    }
    let k = { onPointerDown: h, onPointerUp: g }
    return (
      a && l && ((k.onMouseEnter = m), e.stacked || (k.onMouseLeave = x)),
      d &&
        (k.onClick = E => {
          u && u(E), i.canCloseOnClick && c(!0)
        }),
      { playToast: x, pauseToast: m, isRunning: t, preventExitTransition: o, toastRef: s, eventHandlers: k }
    )
  }
  var WT = typeof window < 'u' ? C.useLayoutEffect : C.useEffect,
    ll = ({ theme: e, type: t, isLoading: n, ...o }) => C.createElement('svg', { viewBox: '0 0 24 24', width: '100%', height: '100%', fill: e === 'colored' ? 'currentColor' : `var(--toastify-icon-color-${t})`, ...o })
  function GT(e) {
    return C.createElement(
      ll,
      { ...e },
      C.createElement('path', {
        d: 'M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z',
      })
    )
  }
  function VT(e) {
    return C.createElement(ll, { ...e }, C.createElement('path', { d: 'M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z' }))
  }
  function XT(e) {
    return C.createElement(ll, { ...e }, C.createElement('path', { d: 'M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z' }))
  }
  function YT(e) {
    return C.createElement(
      ll,
      { ...e },
      C.createElement('path', {
        d: 'M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z',
      })
    )
  }
  function HT() {
    return C.createElement('div', { className: 'Toastify__spinner' })
  }
  var Ju = { info: VT, warning: GT, success: XT, error: YT, spinner: HT },
    UT = e => e in Ju
  function KT({ theme: e, type: t, isLoading: n, icon: o }) {
    let r = null,
      s = { theme: e, type: t }
    return o === !1 || (On(o) ? (r = o({ ...s, isLoading: n })) : C.isValidElement(o) ? (r = C.cloneElement(o, s)) : n ? (r = Ju.spinner()) : UT(t) && (r = Ju[t](s))), r
  }
  var qT = e => {
      let { isRunning: t, preventExitTransition: n, toastRef: o, eventHandlers: r, playToast: s } = jT(e),
        { closeButton: i, children: a, autoClose: l, onClick: c, type: u, hideProgressBar: d, closeToast: f, transition: A, position: h, className: g, style: x, progressClassName: m, updateId: v, role: y, progress: b, rtl: w, toastId: k, deleteToast: E, isIn: P, isLoading: T, closeOnClick: F, theme: D, ariaLabel: Q } = e,
        R = fe('Toastify__toast', `Toastify__toast-theme--${D}`, `Toastify__toast--${u}`, { 'Toastify__toast--rtl': w }, { 'Toastify__toast--close-on-click': F }),
        S = On(g) ? g({ rtl: w, position: h, type: u, defaultClassName: R }) : fe(R, g),
        L = KT(e),
        I = !!b || !l,
        z = { closeToast: f, type: u, theme: D },
        B = null
      return (
        i === !1 || (On(i) ? (B = i(z)) : C.isValidElement(i) ? (B = C.cloneElement(i, z)) : (B = ET(z))),
        C.createElement(
          A,
          { isIn: P, done: E, position: h, preventExitTransition: n, nodeRef: o, playToast: s },
          C.createElement(
            'div',
            { id: k, tabIndex: 0, onClick: c, 'data-in': P, className: S, ...r, style: x, ref: o, ...(P && { role: y, 'aria-label': Q }) },
            L != null && C.createElement('div', { className: fe('Toastify__toast-icon', { 'Toastify--animate-icon Toastify__zoom-enter': !T }) }, L),
            Em(a, e, !t),
            B,
            !e.customProgressBar && C.createElement(ST, { ...(v && !I ? { key: `p-${v}` } : {}), rtl: w, theme: D, delay: l, isRunning: t, isIn: P, closeToast: f, hide: d, type: u, className: m, controlledProgress: I, progress: b || 0 })
          )
        )
      )
    },
    ZT = (e, t = !1) => ({ enter: `Toastify--animate Toastify__${e}-enter`, exit: `Toastify--animate Toastify__${e}-exit`, appendPosition: t }),
    JT = wT(ZT('bounce', !0)),
    _T = { position: 'top-right', transition: JT, autoClose: 5e3, closeButton: !0, pauseOnHover: !0, pauseOnFocusLoss: !0, draggable: 'touch', draggablePercent: 80, draggableDirection: 'x', role: 'alert', theme: 'light', 'aria-label': 'Notifications Alt+T', hotKeys: e => e.altKey && e.code === 'KeyT' }
  function $T(e) {
    let t = { ..._T, ...e },
      n = e.stacked,
      [o, r] = C.useState(!0),
      s = C.useRef(null),
      { getToastToRender: i, isToastActive: a, count: l } = OT(t),
      { className: c, style: u, rtl: d, containerId: f, hotKeys: A } = t
    function h(x) {
      let m = fe('Toastify__toast-container', `Toastify__toast-container--${x}`, { 'Toastify__toast-container--rtl': d })
      return On(c) ? c({ position: x, rtl: d, defaultClassName: m }) : fe(m, Ku(c))
    }
    function g() {
      n && (r(!0), De.play())
    }
    return (
      WT(() => {
        var x
        if (n) {
          let m = s.current.querySelectorAll('[data-in="true"]'),
            v = 12,
            y = (x = t.position) == null ? void 0 : x.includes('top'),
            b = 0,
            w = 0
          Array.from(m)
            .reverse()
            .forEach((k, E) => {
              let P = k
              P.classList.add('Toastify__toast--stacked'), E > 0 && (P.dataset.collapsed = `${o}`), P.dataset.pos || (P.dataset.pos = y ? 'top' : 'bot')
              let T = b * (o ? 0.2 : 1) + (o ? 0 : v * E)
              P.style.setProperty('--y', `${y ? T : T * -1}px`), P.style.setProperty('--g', `${v}`), P.style.setProperty('--s', `${1 - (o ? w : 0)}`), (b += P.offsetHeight), (w += 0.025)
            })
        }
      }, [o, l, n]),
      C.useEffect(() => {
        function x(m) {
          var v
          let y = s.current
          A(m) && ((v = y.querySelector('[tabIndex="0"]')) == null || v.focus(), r(!1), De.pause()), m.key === 'Escape' && (document.activeElement === y || (y != null && y.contains(document.activeElement))) && (r(!0), De.play())
        }
        return (
          document.addEventListener('keydown', x),
          () => {
            document.removeEventListener('keydown', x)
          }
        )
      }, [A]),
      C.createElement(
        'section',
        {
          ref: s,
          className: 'Toastify',
          id: f,
          onMouseEnter: () => {
            n && (r(!1), De.pause())
          },
          onMouseLeave: g,
          'aria-live': 'polite',
          'aria-atomic': 'false',
          'aria-relevant': 'additions text',
          'aria-label': t['aria-label'],
        },
        i((x, m) => {
          let v = m.length ? { ...u } : { ...u, pointerEvents: 'none' }
          return C.createElement(
            'div',
            { tabIndex: -1, className: h(x), 'data-stacked': n, style: v, key: `c-${x}` },
            m.map(({ content: y, props: b }) => C.createElement(qT, { ...b, stacked: n, collapseAll: g, isIn: a(b.toastId, b.containerId), key: `t-${b.key}` }, y))
          )
        })
      )
    )
  }
  const eF = () => {
      const e = C.useCallback((s, i) => {
          De(s, { type: 'default', ...i })
        }, []),
        t = C.useCallback((s, i) => {
          De(s, { type: 'info', theme: 'colored', ...i })
        }, []),
        n = C.useCallback((s, i) => {
          De(s, { type: 'error', theme: 'colored', ...i })
        }, []),
        o = C.useCallback((s, i) => {
          De(s, { type: 'warning', theme: 'colored', ...i })
        }, []),
        r = C.useCallback((s, i) => {
          De(s, { type: 'success', theme: 'colored', ...i })
        }, [])
      return C.useMemo(() => ({ general: e, info: t, warning: o, error: n, success: r }), [e, t, o, n, r])
    },
    Br = e => {
      const [t, n] = C.useState(e)
      return (
        C.useEffect(() => {
          n(e)
        }, [e]),
        [t, n]
      )
    },
    tF = (e = {}) => ({ ...e }),
    _u = 2e3,
    nF = [12.5, 12.5],
    oF = 'none',
    rF = '#ededed',
    sF = (e = {}) => ({ background: e.background ?? oF, border: rF }),
    Mm = 1 / 3,
    Pm = 1 / 6,
    Lm = 180,
    kt = Lm * Mm,
    Bn = Lm * Pm,
    Ye = 132,
    jn = 32,
    _t = 160,
    iF = 'CapacitorNode',
    aF = 'PCAP',
    lF = 'SubSwitchNode',
    cF = 'SUB_LISW',
    uF = 'line-side',
    dF = e =>
      C.useCallback(
        (t, n = {}) => {
          const o = hn({ position: t, ...n })
          return (
            e(r => {
              const { data: s, type: i } = n
              return (o.type = i ?? iF), (o.data.label = (s == null ? void 0 : s.label) ?? `NEW ASSET ${r.length + 1}`), (o.data.code = (s == null ? void 0 : s.code) ?? aF), [...r, o]
            }),
            o
          )
        },
        [e]
      ),
    fF = (e, t) => {
      const n = C.useCallback(
          r => {
            r.preventDefault()
            const s = e.current.getBoundingClientRect()
            t({ ...nu(r, s), position: tu(r) })
          },
          [t]
        ),
        o = C.useCallback(() => t(null), [t])
      return { openMenu: n, closeMenu: o }
    },
    AF = (e, t, n = {}) => {
      const { onSet: o } = n,
        r = C.useCallback(
          (i, a) => {
            i.preventDefault(), i.stopPropagation()
            const l = e.current.getBoundingClientRect(),
              c = { id: a.id, ...nu(i, l), position: tu(i), targetNode: a }
            t(c), o(c)
          },
          [t]
        ),
        s = C.useCallback(() => t(null), [t])
      return { openMenu: r, closeMenu: s }
    },
    pF = (e, t) => {
      const n = C.useCallback(
          (r, s) => {
            r.preventDefault(), r.stopPropagation()
            const i = e.current.getBoundingClientRect()
            t({ id: s.id, ...nu(r, i), position: tu(r), targetEdge: s })
          },
          [t]
        ),
        o = C.useCallback(() => t(null), [t])
      return { openMenu: n, closeMenu: o }
    },
    hF = e =>
      C.useCallback(
        n => {
          e(o => o.filter(r => r.id !== n))
        },
        [e]
      ),
    gF = e =>
      C.useCallback(
        n => {
          e(o => o.filter(r => r.id !== n))
        },
        [e]
      ),
    mF = { open: !1, openDrawer: () => {}, closeDrawer: () => {}, toggleDrawer: () => {}, setOpen: () => {} },
    Tm = C.createContext(mF),
    yF = ({ children: e }) => {
      const [t, n, o, r, s] = sl(),
        i = C.useMemo(() => ({ open: t, setOpen: n, openDrawer: o, closeDrawer: r, toggleDrawer: s }), [r, t, o, n, s])
      return p.jsx(Tm.Provider, { value: i, children: e })
    },
    bF = () => C.useContext(Tm),
    vF = e => {
      const [t, n] = C.useState(e),
        { openDrawer: o, ...r } = bF(),
        s = C.useCallback(
          i => {
            n(i), o()
          },
          [o]
        )
      return (
        C.useEffect(() => {
          const i = a => {
            const l = a.target
            l && l.classList.contains('MuiBackdrop-root') && r.closeDrawer()
          }
          return (
            window.addEventListener('click', i),
            () => {
              window.removeEventListener('click', i)
            }
          )
        }, [r]),
        { nodeToEdit: t, setNodeToEdit: n, openDrawer: s, ...r }
      )
    },
    xF = e =>
      C.useCallback(
        t => {
          e(n => n.map(o => (o.id !== t.id ? o : t)))
        },
        [e]
      ),
    CF = e =>
      C.useCallback(
        t => {
          e(n => n.map(o => (o.id !== t.id ? o : t)))
        },
        [e]
      ),
    Fm = { maxHistorySize: ba.historyDeepness },
    wF = ({ maxHistorySize: e = Fm.maxHistorySize } = Fm) => {
      const [t, n] = C.useState([]),
        [o, r] = C.useState([]),
        { setNodes: s, setEdges: i, getNodes: a, getEdges: l } = No(),
        c = C.useCallback(() => {
          n(f => [...f.slice(f.length - e + 1, f.length), { nodes: a(), edges: l() }]), r([])
        }, [a, l, e]),
        u = C.useCallback(() => {
          const f = t[t.length - 1]
          f && (n(A => A.slice(0, A.length - 1)), r(A => [...A, { nodes: a(), edges: l() }]), s(f.nodes), i(f.edges))
        }, [s, i, a, l, t]),
        d = C.useCallback(() => {
          const f = o[o.length - 1]
          f && (r(A => A.slice(0, A.length - 1)), n(A => [...A, { nodes: a(), edges: l() }]), s(f.nodes), i(f.edges))
        }, [s, i, a, l, o])
      return { undo: u, redo: d, takeSnapshot: c, canUndo: !t.length, canRedo: !o.length }
    },
    EF = e => {
      const [t, n] = C.useState(e),
        [o, r] = C.useState(void 0),
        [s, i] = C.useState(void 0),
        a = wF(),
        l = C.useCallback(
          m => {
            n(v => (typeof m != 'function' ? { ...m, stateId: Co() } : { ...m(v), stateId: Co() }))
          },
          [n]
        ),
        c = C.useCallback(
          m => {
            l(v => (typeof m != 'function' ? { ...v, nodes: m } : { ...v, nodes: m(v.nodes) }))
          },
          [l]
        ),
        u = C.useCallback(
          m => {
            l(v => (typeof m != 'function' ? { ...v, edges: m } : { ...v, edges: m(v.edges) }))
          },
          [l]
        ),
        d = C.useCallback(
          m => {
            l(v => (typeof m != 'function' ? { ...v, viewMode: m } : { ...v, viewMode: m(v.viewMode) }))
          },
          [l]
        ),
        f = C.useCallback(
          m => {
            l(v => (typeof m != 'function' ? { ...v, editMode: m } : { ...v, editMode: m(v.editMode) }))
          },
          [l]
        ),
        A = C.useCallback((m, v) => {
          if ((r(void 0), i(void 0), m.length === 1 && m[0] && m[0].type === 'position' && m[0].dragging && m[0].position)) {
            const y = uk(m[0], v)
            ;(m[0].position.x = y.snapPosition.x ?? m[0].position.x), (m[0].position.y = y.snapPosition.y ?? m[0].position.y), r(y.horizontal), i(y.vertical)
          }
          return Ng(m, v)
        }, []),
        h = C.useCallback(
          m => {
            l(v => ({ ...v, nodes: A(m, v.nodes) }))
          },
          [A, l]
        ),
        g = C.useCallback(
          m => {
            l(v => ({ ...v, edges: Mg(m, v.edges).map(eo) }))
          },
          [l]
        )
      return { nodeState: [C.useMemo(() => (t.viewMode === no.enhanced ? t.nodes : t.nodes.filter(m => !Sl(m))), [t]), c, h], edgeState: [t.edges, u, g], viewModeState: [t.viewMode, d], editModeState: [t.editMode, f], horizontalHelperLineState: [o, r], verticalHelperLineState: [s, i], history: a }
    },
    SF = e =>
      C.useCallback(
        (t, n) => {
          const o = eo({ source: t.id, target: n.id })
          return e(r => [...r, o]), o
        },
        [e]
      ),
    BF = e =>
      C.useCallback(
        (t, n, { type: o, ...r } = {}) => {
          const s = hn({ parentId: t.id, extent: 'parent', type: o ?? lF, position: n, ...r })
          return (
            e(i => {
              const { data: a } = r
              return (s.data.label = (a == null ? void 0 : a.label) ?? ''), (s.data.code = cF), (s.data.archetype = (a == null ? void 0 : a.archetype) ?? uF), [...i, s]
            }),
            s
          )
        },
        [e]
      ),
    IF = () => {
      const { flowDirection: e } = oo(),
        t = ye
      return { sourceHandlePosition: e === pn.vertical ? t.Bottom : t.Right, targetHandlePosition: e === pn.vertical ? t.Top : t.Left }
    },
    kF = (...e) => Er(...e),
    $u = (e, t) => {
      const [n, o] = sl(),
        r = kF(e)
      C.useEffect(() => {
        r && !n ? (t(), o(!0)) : o(r)
      }, [r, n, t, o])
    },
    NF = () => {
      const e = C.useRef({ x: 0, y: 0 }),
        t = ke(h => h.domNode),
        { getNodes: n, setNodes: o, getEdges: r, setEdges: s, screenToFlowPosition: i } = No(),
        [a, l] = C.useState([]),
        [c, u] = C.useState([])
      C.useEffect(() => {
        const h = ['cut', 'copy', 'paste']
        if (t) {
          const g = m => m.preventDefault(),
            x = m => {
              e.current = { x: m.clientX, y: m.clientY }
            }
          for (const m of h) t.addEventListener(m, g)
          return (
            t.addEventListener('mousemove', x),
            () => {
              for (const m of h) t.removeEventListener(m, g)
              t.removeEventListener('mousemove', x)
            }
          )
        }
      }, [t])
      const d = C.useCallback(() => {
          const h = n().filter(x => x.selected),
            g = Bu(h, r()).filter(x => {
              const m = h.every(y => y.id !== x.source),
                v = h.every(y => y.id !== x.target)
              return !(m || v)
            })
          l(h), u(g)
        }, [n, r]),
        f = C.useCallback(() => {
          const h = n().filter(x => x.selected),
            g = Bu(h, r()).filter(x => {
              const m = h.every(y => y.id !== x.source),
                v = h.every(y => y.id !== x.target)
              return !(m || v)
            })
          l(h), u(g), o(x => x.filter(m => !m.selected)), s(x => x.filter(m => !g.includes(m)))
        }, [n, o, r, s]),
        A = C.useCallback(
          ({ x: h, y: g } = i({ x: e.current.x, y: e.current.y })) => {
            const x = Math.min(...a.map(w => w.position.x)),
              m = Math.min(...a.map(w => w.position.y)),
              v = Co(),
              y = a.map(w => {
                const k = `${w.id}-${v}`,
                  E = h + (w.position.x - x),
                  P = g + (w.position.y - m)
                return { ...w, id: k, position: { x: E, y: P } }
              }),
              b = c.map(w => {
                const k = `${w.id}-${v}`,
                  E = `${w.source}-${v}`,
                  P = `${w.target}-${v}`
                return { ...w, id: k, source: E, target: P }
              })
            o(w => [...w.map(k => ({ ...k, selected: !1 })), ...y]), s(w => [...w.map(k => ({ ...k, selected: !1 })), ...b])
          },
          [a, c, i, o, s]
        )
      return { cut: f, copy: d, paste: A, bufferedNodes: a, bufferedEdges: c }
    },
    MF = () => W5(),
    Dm = e => {
      const { nodes: t, setNodes: n } = oo(),
        o = C.useMemo(() => t.find(s => s.id === e), [e, t]),
        r = C.useCallback(
          s => {
            n(i => i.map(a => (a.id === (o == null ? void 0 : o.id) ? s : a)))
          },
          [n, o]
        )
      return o ? { node: o, updateNode: r } : { node: void 0, updateNode: null }
    },
    PF = (e, t = { resizable: !0, rotatable: !0 }) => {
      const n = C.useRef(null),
        o = MF(),
        { node: r, updateNode: s } = Dm(e),
        i = C.useMemo(() => (r ? cO(r) ?? 0 : 0), [r]),
        [a, l] = C.useState(i),
        [c, u] = C.useState(!!t.resizable),
        [d, f] = C.useState(!!t.rotatable)
      return (
        C.useEffect(() => {
          f(!!t.rotatable)
        }, [t]),
        C.useEffect(() => {
          u(!!t.resizable)
        }, [t]),
        C.useEffect(() => {
          l(i)
        }, [i]),
        C.useEffect(() => {
          if (!n.current) return
          const A = Tt(n.current),
            h = du().on('drag', g => {
              const x = g.x - 100,
                m = g.y - 100,
                b = 180 - Math.atan2(x, m) * (180 / Math.PI)
              l(b), o(e), s == null || s({ ...r, data: { ...r.data, rotation: b }, style: { ...r.style } })
            })
          A.call(h)
        }, [r, e, s, o]),
        { rotation: a, setRotation: l, resizable: c, setResizable: u, rotatable: d, setRotatable: f, rotateControlRef: n, updateNodeInternals: o }
      )
    },
    LF = e => {
      const { nodes: t, setNodes: n } = oo(),
        { node: o } = Dm(e),
        r = C.useMemo(() => (o ? Sd(o, t) : void 0), [o, t]),
        s = C.useCallback(i => n(a => a.map(l => (r && r.id === l.id ? i : l))), [r, n])
      return r ? { node: r, updateNode: s } : { node: void 0, updateNode: null }
    },
    TF = e => {
      const { node: t } = LF(e)
      return t == null ? void 0 : t.data.rotation
    },
    FF = e =>
      C.useCallback(
        (t, n, o) => {
          const r = t,
            s = Sd(r, n),
            i = t.data.archetype,
            a = i === He.lineSide,
            l = i === He.loadSide
          if (!s) return
          const c = a,
            u = l,
            d = ru(r.id),
            f = ru(s.id),
            A = c ? `${d}-${f}` : `${f}-${d}`
          if (o.some(x => x.id === A)) return
          const g = eo({ source: c ? r.id : s.id, target: u ? r.id : s.id, id: A, style: vm, data: { isInvisibleEdge: !0 } })
          e(x => [...x, g])
        },
        [e]
      ),
    DF =
      'data:image/png;base64,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',
    zF =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHwAAAIICAYAAACsMopAAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAViSURBVHgB7dwxqhNRFIDhG0kh2tqI8CoFO1tLV+AOrF2FhbyduAR716C9/evF4pUxgQs24ULKmf/7YHICt8vPKSYwcxj7dxq3OYwdezJIETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPOZ6vT/P768HF17FPPy8fNjzmcL5OgwwbHiN4jOAxgscIHnNcnH2e889gS97MeX/t0IbHrO7DX835MNiSd3P+unZow2MEjxE8RvAYwWMEjxE8RvAYwWMEjxE8RvAYwWMEjxE8RvAYwWMEjxE8RvAYwWMEjxE8RvAYwWMEjxE8ZvX06N2czwdbcrc6tOEx3uIUY8NjBI8RPEbwGMFjVvfhP+Z8HGzJiznfXzu04THe4rQ/3uLEf4LHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB5zXJx9m/NxsCVPV4c2POZwvk6DDBseI3iM4DGCxwges7oP/zDnw2BL3s75/dqhDY9ZbfjvOW34tjxbHdrwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI9ZPVv2cc6/gy15uTq04THe4hRjw2MEjxE8RvAYwWMu9+H3Y9++jNvs+vew4TGHsX+3/s+w69/EhscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgsf8A9M1HnYFS8jzAAAAAElFTkSuQmCC',
    ed =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdAAAALgCAYAAAAkzyYwAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACfJSURBVHgB7d3hdRPZljbg4lv3/9ARtIgAEwEmAiACRAS2I8BEAESAiQCIABEBJgJEBM1E0N9YOrsb1TWizlZJqpKeZ61ht4zEbeBM73p9Tu260wBD9ndT504D7MT/awCAahooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQcKcBupiUerfUk9brqH/+4uuTZv2v25frUn+0vj4v9Xvr5+e/eD1vgLUkUABIkEA5Nu1EGEny/i++3k6SxyYS7bxVP7deXzdwZCRQAEiQQDk0kRxPS73f+vpJwzZdt+rXUmetr8PoSaAAkCCBMjanpUaSfNx6fax7lWMRp30jiX5svZ41MBISKAAkSKAMTSTIaakP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AkCCBHo4JqW+L/Wk2QL3kXIIYkLQhw8fFvXdu3eLusXEOSv1Zes1IyaBAkCCBHq4pqVu5bRuiET65MmTRT07O1v5OgxBJM6YVRtPR+lxVm3bvNR4asqHhoMjgQJAggR6PKalbjWRhkiksUcar2EXdniaNkSUbZ+u5YBJoACQIIEer3jay1mpk2aLYk807iONvdKYxQsZkSw/fvy4qFdXV4u6xb3N0E6cr1tf5whIoACQIIESzxmNTcqd7JGG9ine2DOVTPlZJM3Pnz8vaiTNHp+/+TsSJ/9FAgWABAmUX5mWutNEGtp7ppFMzeI9TLFneX19vah72NNsm5caifOqVImTf0igAJAggdLVtNQYfnva7FEk0dg7vX///srXGabYy/z69euixizaSJ57SJphVqpZtXQmgQJAggRK1qTUy1Iftr6+F3fvLg8VxyneSKSRUOPrZvX2K07DRpKM07LxegAJM8S/wLtSr0q9bqCSBAoACRIofZuWOoi90l9pJ9WokVQjocbX4/3HIpJiO1nG3mV8PfY0B5Asf2VW6pvWa6dp2ZgECgAJEijbNin1tNSYvTuqUUORQCOZthNsvP7zzz9XXv+qhuxebCS+dvJrf709qef79+8rX2+/r/31EZmV+rlUk4LYOgkUABIkUPZlUuqTUh+XetrAr81KjaR5Veq8gR2TQAEgQQJlaCalnpbaTqbHdRz2+MSe5azUdtK0p8lgSKAAkCCBMjanpcYp3set1xLqsEWCjMk/H1uvZw2MhAQKAAkSKIcmkuhp6/X91mu247pVv5Y6a30dRk8CBYAECZRjFUl0UuppqX+2vn6sifVHq0Zy/N56HXXeej8cPAkUABIkUOhm0qp3f/G6nWCb1s/f/cWv25d5q7aT5PdffP269XreAGtJoACQIIHCsP3d1PH/07AjEigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAwv8H2bzP/InUqH8AAAAASUVORK5CYII=',
    QF =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATQAAALkCAYAAACBV8ktAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAB2FSURBVHgB7d17tF51fSbwH8hwCQhIkJsmnBC5CQjlqhUUuVXUERCtUEERK+rMqgI1FVuKMHYhI4zW6kyltlwUKDRMlakiioIgVAsGQgkkXITDpVWRCIkJcjOZ1f1+fwqUhL3POUne9/t+Pv88S7t31zK4njzu/e69VyswsUYi7215/C2RuxQYp9ULQBIKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaaxSYWBuWbtaMXDvy8QJjZKEBaaxWoJ3635XtI/eL3Cdy78gtyvjcE3l55HWRP4i8v8AyWGhAGhYay/KSyOMi3xu5bVm1ron8QuTXIp8uDD0LDUjDQqOqi+xPIj8cOan0t59GfjzywsinCkPHQgPSsNCGV/1n/6HIT0WuXwbbaOT7I79TGBoWGpCGhTZ8toy8JHKvktvnI/8s8peFtCw0IA0LbXi8LvKyyK7PXLYyefLkJjfbbLMmp06d2uTaa/ce1Xz66d7PxRYvXtzk/Pnzm7zjjjuafPzxFfYo592RB0aOFtKx0IA0LLT86i/9vxg5rn/ma621VpN77dW79Hbsscc2eeCBveGzxRZje5Rz6dKlTc6ePbvJq666qskLLrjgWf/+BKjPgh4QeVchDQsNSMNCy6v+0v9zZRw23LB3qe2DH/xgkzNmzGhyo402KivT3LlzmzzllFOavPTSS8s4/Sxy38h5hYFnoQFpWGj5vCXyn8o4HHHEEU1+/vO9n3FtvPHGpZ/Mm9cbVIcddtiz/vUY1Gtqr48cLQwsCw1Iw0LLYyTytshOb8lYb731mrzwwt7LKt761reWQXLaaac1eeqpp5YxmhP52siFhYFjoQFpWGiDr/6l9OPIkdLBlClTmrzmmt6LYKdNm1YG2UUXXdTke9/be8Huk08+WTqqz35+uDBwLDQgDQtt8J0U+akO55Qtt+y9dOPaa69tsj5zmcV11/U+FnXAAb0HAp544onS0UGRVxYGhoUGpGGhDa56seueDuf85hf+s2bNanJkZKRkdvHFFzd55JFHlo7mRu4RubjQ9yw0II01CoPqL8sYXHZZ73Vo2ZdZVZ94uOuu3ks16rOgLdQvxH8g8jOFvmehAWm4hjZ4touc2+Gc3/yC/hOf+EQZZvvss0+T9S5oC/VZz1dGupbWxyw0IA0LbfCcH/nuNgfXJwFuvfXWJjfYYIMyzOq3C7bbbrvS0bGR5xb6loUGpOEu5+BYL/L3SwfHH398k8O+zKptt922yUMOOaTJete3hfrnbqH1MQsNSMM1tMFxaORX2xy8ySabNHn//b2bdPVrTfTcdlvvtXE77rhj21Pq3c16t/P+Qt+x0IA0XEMbHPt1Ofjwww9v0jJ7fjvssEOTe+zRe1TzxhtvfKFT1o18U+QXC33HQgPSsNAGx9u6HFy/aM7yvfGNb2yyxUKrdin0LQsNSMNdzv63WeRP2hxcv960cGHvo0WrreYf8fLcdNNNTe62225tT6lTbs9C37HQgDRcQ+t/r+hy8M4779ykZdbOLrv0LonVJykWLFjwQqdsGbl+pO939hELDUjDQut/L+1y8LC8iXairL567+/0LbbYoskWC22TyHpt00LrIxYakIaF1v8263JwvYZGN3XZzp3b+kXALyn0HQsNSMNC63/rdDl48803L3RXf7/XwfqFvmOhAWlYaMksWbKk0N0Y/tyWFvqOhQakYaH1vye6HFyf4aSbRYsWlY6eLPQdCw1Iw0Lrf50mV/3uJN388pe/LB2Zwn3IQgPSsND63wNdDp4zZ06huw7L9rHI+wp9x0ID0rDQ+t+PuxxsoXUzOjra5Pz589ueUv+AHyn0HQsNSMNC63/1GtovIjda3sEPP/xwk/fee2+T06ZNKyzbZZddVjrqtJhZuSw0IA0LbXBcEfkHbQ6+8MILmzz55JMLy3b55ZeXjq4r9C0LDUjDp4EGx3siz2tz8JQpU5q8777ez6V8BerZHnigd2ly6tSppaPdI2cV+o6FBqThGtrg+EZkfXHXcv8yqgvku9/9bpMHHHBA4bdOOeWU0tEPIi2zPmahAWm4sDJ46t3O32tzcP0y+KxZvWFRv0M5rOpy3XbbbZv81a9+1fbUD0T+TaFvWWhAGhba4Nk38urSwUUXXdTkkUceWYbZ0Ucf3eQFF1zQ9pT63rMdIzu9/YSVy0ID0rDQBle927Zrm4MnTZrU5G233dZk/VL4sLj44oubHMNCPStyRqHvWWhAGhba4Hp95PdKB1tttVWTs2fPbvLFL35xyezOO+9scq+99mry0UcfbXtqfbvJbpGjhb5noQFpWGiD7+8jjygdHHTQQU1+4xu9BxDWWCPXQyMPPvhgk3vvvXeT9ZnWDt4f+beFgWGhAWlYaINv48i7IjcsHey///5NfvWrX21y0K+p3XPPPU3ut99+TY5hmX0z8k2FgWOhAWlYaHm8OfLrZQzqtweuvPLKJqdPn14GyRVX9B5xPeqoo5rs8BWnyl3NBCw0IA0LLZ+PR55exmCjjXoflTrppJOanDGjP38gv2jRoiZPPPHEJr/0pS+VcXp15L8UBpaFBqRhoeX12cjjyzhsvfXWTX7uc59r8uCDDy6rwuOPP97kOeec02T9mtUjj4z7A+bHRJ5fGHgWGpCGhZbfGZEfKxOgPgt66KGHNvmBD/Re5LrNNtuUibBkSe+TCddff32T9b1lM2fObHICFln1vshzCmlYaEAaFlp++0ReW1ag+h3Q7bbbrsm65DbddNMm11lnnWcdv3Bh70WwDz30UJPz5s1rcs6cOU0uWLCgTLD65tm3RH6/kI6FBqRhoeVVH8r818iRMpxujzws8s5CWhYakIYvp+dV72qOlOGyNPK0yPpNgMWF9Cw0IA3X0PJ5VeQtpZsbIp+O/N0yWM6NrIvs9sLQsdCANCy0POr10Prm2pHSzVaR90a+MfKYyHqXcM2yaj0W+X8iL4q8uTD0LDQgDXc58/izyJHSzcmR9z7n37/iOfnyyP0iD4x8Q+TLysSaG/ndyKsjvxO5sMBzWGhAGq6hDb567evuyLb/TO+I/J3IX5WxqX8pbh05JXLzyMmRa0cuiazXwupDm6OR9T/HTwp0ZKEBaVhog+tFkbMjdyzd1ONvK5CEhQak4S7n4PrjyK7L7H9EWmakY6EBabiGNnhGIudFrtXutHJP5F6RDxdIxkID0nANbfDMjGy7zKrjIi0z0rLQgDQstMHx/sjdSzf1C+rfLZCchQak4S5n/xuJrG+fWLvlefdF7hn5UIHkLDQgDdfQ+t9fRbZdZtWfRlpmDA0LDUjDQutf74n8r6WbCyIvKjBkLDQgDXc5+8+WkbMiJ7c8r77htT6r+UCBIWOhAWm4htZ//iKy7TJ77nmWGUPLQgPScA2tf/x+5CWlm+9FvqHAkLPQgDQstFWvfpH8R5Gbtjyvfs/yVZH3FxhyFhqQhrucq94nItsus6re1bTMIFhoQBquoa06B0ReWbqZE7lTAZ7FQgPSsNBWvvoEwI2R01qe91TkdpH3FOBZLDQgDXc5V76TI9sus+qsSMsMlsFCA9JwDW3l+d3I70e2/ctkXuT2BVguCw1Iw0Jb8erXmn4YuXPL85ZG7hA5twDLZaEBabjLueLNiGy7zKovRlpm0JKFBqThGtqKU99T9oPISS3PuzdyeuTSArRioQFpuIY28epfEn8X2XaZVe+MtMygIwsNSMNCm3gfjdy9dFPvat5YgDGx0IA03OWcOPWu5D9HbtLyvNHIXSMfKcCYWGhAGq6hTZzPR7ZdZlV9ksAyg3Gy0IA0LLTx+1DkwaWb8yIvLcCEsNCANNzlHLstI6+NnNryvNHIvSIfKsCEsNCANFxDG7szI9sus+qTkZYZTDALDUjDQuvuXZHvKN18JfKcAqwQFhqQhruc7W0eWZ/VHGl3Wrkvct/I0QKsEBYakIZraO2dHjlSuql3Q0cLsEJZaEAarqG9sDdHfr1084+Rb4/0jQBYwSw0IA0Lbdk2iJwdOdLutPJA5OsiRwuwUlhoQBruci7bGZEjpZv/HTlagJXKQgPScA3tP/udyJtKNz+MfG3kkgKsVBYakIaF9lv/JfLOyJF2p5VFkXtEzivAKmGhAWm4y/lb9U2yI6Wb+oynZQarmIUGpOEaWik7RN4a2fbPpC6yelf08QKsUhYakMYwL7T6n/3uyK1anvdE5Gsiby5AX7DQgDSG+S7nqZFtl1n1mUjLDPqMhQakMYzX0EYi74hcs91pv3l7xu6R8wvQVyw0II1hvIb2T5Ftl1l1XKRlBn3KQgPSGKaF9vHIHUs3X4i8sgB9zUID0hiGu5wjkfXZy7XanVb+LXKXyIcL0NcsNCCNYbiGdm5k22VWnRhpmcGAsNCANDIvtD+M3Ld0MzPyHwowUCw0II2MdzmnRs6OfEnL834RWe9qPlCAgWKhAWlkvIZ2VmTbZVb9SaRlBgPKQgPSyHQN7ajIr5RuvhZ5WAEGmoUGpJFhob008qbIl7c8r35Hc/vI0QIMNAsNSCPDXc7TI9sus+pjkaMFSMFCA9IY5Gtovxd5RenmXyN3LkAqFhqQxiAutI0jb4wcaXdaeTJy28jRAqRioQFpDOJdzj+OHCnd1Luho4UVYe3IaZH161qbPuf/vjSy/g6wPjt7c+SDzzkOWrPQgDQG6RrarpGzSjc/jtw60t/8YzMp8i2RB0a+NnKryK7fbniuutzqYrsh8rLIqwssg4UGpDEIC60ug/r7sektz6tLrC6H0UIXr478QOShkRuWVevuyG9GfiZytDD0LDQgjUFYaB+PPL10c8Zzzmf59oqsf26vj+z3/448HXlh5J9G/nth6FhoQBr9/Ldv/UV/vau5bsvzRiO3iXyq8HzWi/xfkcdGDvobWOZHfjqyXmN7upCehQak0Y8LrZbsDyL3LN3U36vdXHg+9VrZ30dOK7ldFfmeyAcLaVloQBr9eL1kRmTXZVavlVhmz++EyHq3eO0ygTbZZJMmd9pppyanT+/9XHDy5MlNrrtu7xLokiVLmnzssceavP/++5+Vs2f3Pni/aNGiMkH2i/znyD+IvK6QjoUGpNFP19BGIuvCavuL9NHI+gbahYVn+mTkyWUCTJkypcl3vetdTR54YO+Rzt13373J9ddfv4zHAw/0Xr5x0029j3jNnDmzySuu6L2YeP78+WWcHo08PvL8QhoWGpBGPyy0Wqr12byDSjevi/x+4ZlOizyljMPOO/eG73HHHddkXWYbbLBBWZnuu+++Js8555wmzz333CbrohuD+gbjevfz4sLAs9CANPphof33yC+Ubs6NPLbwTPVa2SfLGEya1Hu5yYwZvZvNJ5zQuzm6shfZCxkdHW3ytNN6Q/S8884rY/SLyPq/DLq+b48+YqEBaazKhTYSefVz/vULGY18TeRPC/+h/m6vPmHR6S+rV77ylU1++ctfbnK33XYrg6ReUzvppJOafOihh0pH9c3Gb4gc88U5Vh0LDUhjVS60L0ceXbp5Z+Q/FP7DlMj6y/eppYN99923yQsv7L1ObIsttiiDrD5pcOihvRfs1rujHXwt8vDIJYWBYaEBaayKhVbvSv5d6aYusncWnumvIz9YOthjjz2avOqq3sso1ltvvZJJfTZ07733bnIMv1erf55nFwaGhQaksTIX2khk17ua90fWu5reFd+zfeTtpYNttum9yPfqq3v/GAb9mtkLmTWr97Oy/fbrvXRj4cLWj/r+LPKVkb8o9D0LDUhjZS60+sv+Y0o3H4r8YuGZ6i/ad21z8JprrtnkHXfc0eTIyEgZJuef33upxjHHHFM6qk9cjOuZWFYOCw1IY2UstHdEdv3d2OWRby48U/2i+Q86nFPOPPPMJj/60Y+WYbb//vs3We/utvBE5GaRjxb6loUGpLEiF9pLIm+KHGl3WqkP4dW7mvcUnqku3Xe0OXjatN5Hne6+++4mV199uP8Oq2/p2HHHHZtcvHhx21NPjPxsoW9ZaEAaK/KrT5+KHCndnBVpmT1bvYZzeIdzyqc/3fuA+LAvs6re3T3qqKOaPPvs1g8CHBJpofUx/y0H0lgR19D2j/xO6eaGyHoXb2nhmTrdLa7Xzu65x9B9PvXPpT458etf//qFTqkH7BI5p9B3LDQgjYm8hlY/yPg3pZt6m+mYSMvs+R3c5eB3v/vdhWXbaqutmtxnn32a/N73vvdCp7wo8vWRFlofstCANCZyoZ0RuVXppp43t7A8b+t08Ns6HT603vSmNzXZYqFVuxf6loUGpDERdznr+6LmdPz/OTuy3tV8ovB8towcbXPw5MmTm3z44YcLL6w+QbH11lu3PaW+f26HQt+x0IA0JuIa2j9Gtl1m9Ss6/y3SMlu+kS4H77TTToX2XvGKVzT50pe+tMmf//znL3TK5pEbR5rCfcRCA9IYz0Krdye3Ld38ZWSn93kNsU26HDx9+vRCd5tt1ntUtsVCq2+RmRxpofURCw1IYzwLresyuyvyLwpdbNrlYNfQxqa+hePWW29te0q9hnZHoW9YaEAa41loh0UeEXlm5MuXcXz9EvUjhS7W6nJw/R0a3ayzzjqlo0mFvmOhAWlMxO/QLo78fuRpke+L/NvI1p/Z4Vk6vX1kyZIlhe5avA/tufxB9yELDUhjIt+28W+Rfxj5tcjZhfH4VZeDPcM5NgsWLCgdPVnoOxYakMaK/OrT1wsTYWGXg2+//fZCd2NYaL6g3ocsNCCNFbnQmBj3dTl43rx5he46LNv6O8rRQt+x0IA0LLT+d1eXg+uziEuX9n6+ttpqK+LTq3nMndv7lMXixYvbnlKn3C8LfcdCA9Kw0PrfzyLr7/xetryDFy7s3RS9+eabm9x1110Ly3bJJZeUjn5c6FsWGpCGhTY4/l/kh9ocPHPmzCYttOW7/PLLS0fXFvqWhQak4RbY4KifQv+/bQ7ecMMNm3zwwQebXHfddQu/VX+vt/3227c9pX6dbMfIuwt9x0ID0nANbXDU98nVH0wtd3I9+mjvUcOLL+69ru5973tf4bdOP/300lH987fM+piFBqThGtrgOS/yPW0O3nTT3kej7rzzzibXX3/9Msxuu+22Jl/1qlc12eENv++NPK/Qtyw0IA0LbfDsFfnD0sHHPvaxJs8444wyzPbYY48mf/SjH7U9pT6hsUukVwL3MQsNSMNCG1yXRb61zcFrrNG7oX399dc3ueeee5ZhctppvY+RnXrqqaWjP4r8QqHvWWhAGhba4No5clbki9qc9LKX9V7WUZfalltuWTK75pprmjzwwAObfOqpp9qeOhr5msifFvqehQakYaENvr+K/KMO55RtttmmySuvvLLJqVOnlkxuuOGGJg899NAmf/KTn5SO3h35lcLAsNCANCy0wbdh5M2RI6WDrbfeuslvf/vbvZNHRsogu+qq3iOXb3/725t85JFHSkfnRx5TGDgWGpCGhZZH/SX7dZGdXoA2ZcqUJs8+++wmDz744DJIPvvZzzZ54oknljGq3wp4XeS/FwaOhQakYaHlU9/CcV4Zh4985CNNnnDCCU322+/V6vdHZ8yY0eS3vvWtMka/iHx1ZKfvoNJfLDQgDQstr49GnlnGoT5ZUJfQYYcd1uTK/t1afY/Z+ef3bkKeddZZTdYvxI/BY5H7Rf5LYeBZaEAaFlp+MyI/XSbA6qv3/g48+uijmzzkkEOa3G233Zoc63Krb4699957m6y/J7v00kubrL+TmwCPRu4TOaeQhoUGpGGhDY8jIv86csOyAkyePLnJ3Xffvcnp06c3OWnSpCbrEluwYEGTc+fObfKWW25pcvHixWUFqXcvD4ocLaRjoQFpWGjDZ9vIb0ZOK7ldEVk/TOoJgMQsNCANC436GagPR65TBtvPI+v74S4pDA0LDUjDQqOqD2v+eWT9Uni//6VXf1f2+cj/GbnCbpfSvyw0IA0LjWV5eeTxkYdHjpRVa3Zkfdf/2ZEWGRYakIeFRlf1k+vviKzvEdsxcrxPINTvX9bvjd4QeV7k/QWWwUID0rDQmGj12wY3tzz+lsi9IxcVGCMLDUhjjQIT69EyNpYZ42ahAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGgoNSEOhAWkoNCANhQakodCANBQakIZCA9JQaEAaCg1IQ6EBaSg0IA2FBqSh0IA0FBqQhkID0lBoQBoKDUhDoQFpKDQgDYUGpKHQgDQUGpCGQgPSUGhAGmsUmFiPRv55y+MfKjBBLDQgjf8P4H1PMXpzKPQAAAAASUVORK5CYII=',
    RF =
      'data:image/png;base64,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c13mOtGdXTPPjvF5QWb5xlo6ulAahI9//OPB4Nx8881Nlmb79ttvjy6VJumAmAAaBACgMpENQnFo5n9GCyed1HkLe9999w367zOf+UyTBx98cLT09sxPBQyPDTJ/Hd15MHPlzIejO9/L7OrymaWX7hQPl112WZMbbrhh0H9vfetbmyy7SbpQdnOVxXU/iwmgQQAAKsPQICybeX3mjOjCWmut1eR5553XpPvQ++Omm25q8iUv6Vxud+ONN0aXbsksE/LvA4ZH2V11bHTn1MxXRzs7Zp4bLbz0pZ3Lc8tdNvRH2dW1666dpScLFnR9rEs592DPmEAaBACgMgwNQvGvmUdFCzvttFOTZZKjN8ptjW9+85ub/OpXvxotvTPz6IDh0+q9///rzZn/Hb1xXuZLooWjj+58ux122GFB79xyS6cQ3XrrrZssdwa1UE7wbH3ATBsaBACgMkwNQjnrvOyLf0608LGPfazJd77znUF773rXu5r8j//4j2ipnHuxeebcgOGxfOY1mavG+DyWWb6+fx69sUnmldHC4ot3Lqc8/fTTm9x5552D7v3xj39scu+9927yhz/8YbR0SubeMQQ0CABAZZgahOJvMr8WPfD1r3+9yf322y8Yv699rfNpeP3rXx89cmDmiQHDp7xy+0Z0p9zauHH0x2cy/59oYcaMzmaxcgLq2muP69JIUlnLccwxx0RLpUl9YebNMQQ0CABAZRgbhKJcoP3KaGG55TpLG8rJf6973euCZ9aH5mCo3luDp/DFzG7Pvv9E5qHRHytmlrUNrdZqrbbaak1efPHFTTo/ZuG84x2dYzKOO+646JF3Z340hogGAQCoDHODsFpmWbW7erRQmoR///d/b/Itb3lLUCtnhx9yyCFNzp8/P1q6M3PTzFsDhs9imb/KfF50p2wLaHXy4UIoJ+x9K7PVi73SJJx//vlNPu953f7vT20HHXRQk5/73OeiRy7K3Cmz9RNuL2kQAIDKMDcIxT6Z5ei+xaMHjjjiiCbf//73N7nIIpPhr6J/ynkR//mfnUs1W5whXpR/wW6ZpwcMr3InyCXRnXK3SHnp/ccYjE9mvj16YKmllmqynJS61157xSi79957myy3BJ911lnRI/dllvMyroshpEEAACqT6WXzezI/HD20ww47NHnCCSc0ud5668UouPrqq5v8+7//+yYvuuii6JHS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',
    OF =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtAAAALoCAYAAABRfsJcAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACYFSURBVHgB7d15uGVldSbwhZQGCSg4IAEN5YRRwRhxnlJ2cIiJQ0eTSBITNZMazUS3JrHTjR3tqIkkGmfiPMUxUTHOWo5oK84zKoWIqDiBoiACeXxYC/CUNay997n3nnN+v3/eh6Iope7i1HvW/c639wgA1suFMc4eAcCau0wAAAC7TYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgYVPwi5k3jZ4TM7cGAMBiuV3m1aPnU5kfjhVmAw0AAA020BF3yzw6eo7N3BoAAIvlQZlHRU/1HxtoAABg9yjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAEDDpmConwkAAFaODTQAADQo0AAA0KBAAwBAgwINAAANCjQAADQo0AAA0KBAAwBAgwINAAANCjQAADQo0AAA0KBAAwBAgwINAAANCjQAADQo0AAA0KBAAwBAgwINAAANCjQAADRsCs6PYfYIiPjrzKOi5wWZjwuAYR6duSV6XpL5xGCV7RnDDO1NS8UGGgAAGmygI74Tw+wVEHHDzMOj57CAiBdm/nb0/EdAxI0ybx09JwVE7B3DfDewgQYAgA4b6OHvpPYPiDgohjkkYPj8XDkgYr8YxusPPzJ0fs4ObKABAKDDBjri2zHM1QKGv4O/XsDw+Tk0YPgm+cCA4fPz9cAGGgAAOmygI86MYeoM9BUyzwpWyeUzh76Dr+9gmJ/VZH4Yo+bn6jFM/fm1T6ZbFVbL2Pk5ObCBBgCADhvo4fdhXiXzmpkfCVZJbQ7H3sZiflaT+WGM+roPfSJu/fl1QKYN9GoZOz+fDmygAQCgwwY64pOZda/hT+/mP1fP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',
    jF =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlwAAALgCAYAAABBFKm+AAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAEvvSURBVHgB7d15lJTVnf/xy77KvomIBS4sUWmMEIwammg0UX8K0Riz0piJmTh/gJOcyeSMCc0sZyYzZyLmjJPJSnOSOMkkETBqolFpXGLcoIkoGrdCECUgssvO7/it+1G6pLuf56m6VU9VvV9/5JNuqhoVuvvWp+/93k4OANLriIunkwOAFOrsAAAAEBQLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYJ0cAESX8Tmgg7f7571/QBuPy5f/uKS25WVH78/mvX97G+/flvf+rAOACGi4AAAAAqPhAmpLfsNUl/f+SXm/np84tmwbuc5nS977WxyAmkLDBQAAEBgNF1AdMj7r8nJS3tsZhzTJb75W570//9cBVCgaLgAAgMBouIB0096q/OZqus/6vMehOul0pBqvFT6b896/zQFIJRouAACAwGi4gPJSM1XvM7+5qnNAdGq6mn3mN2E0YECZ0HABAAAERsMFlEa9z/wGq94BpdPsM7/5anYAgqLhAgAACIyGCygO7cWa6XN63ttVcYpwwIDcv0Ymk2mV+e/v379/q/d3lPn0cZLatm1bq+zo/dlsttX7t2/f3ur9+b+e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',
    WF =
      'data:image/png;base64,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S6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsq4HzPVowIFsUECWDYrZrgYcyAYFZAkUkCVQQJb3oFjrxYBJbFBAlg2Ktf4dMIkNCsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggKzrAXM9HnAgGxSQJVBAlkABWQIFZAkUkOVP8Vjr2YBJbFBAlg2KtZ4OmMQGBWQJFJAlUECWQAFZAgVkCRSQJVBAlkABWQIFZAkUkCVQQJZAAVkCBWQJFJAlUECWQAFZAgVkCRSQJVBAlkABWQIFZAkUkCVQQJZAAVkCBWQJFJAlUECWQAFZAgVkCRSQJVBAlkABWQIFZAkUkCVQQJZAAVkCBWQJFJAlUECWQAFZAgVkCRSQJVBAlkABWQIFZAkUkCVQQJZAAVkCBWQJFJAlUEDW9YB1/ljml+M4TwYcyAYFAADwyvgPnbB96DKjgGMAAAAASUVORK5CYII=',
    GF =
      'data:image/png;base64,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',
    VF =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlwAAALgCAYAAABBFKm+AAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAC3HSURBVHgB7d3hXRtXFjfgu+8v3+OtYMcVBFcQUUGcCgwVYFcAVGBcAaIC4wpQKjCpwEoF61Twvm/EPVkzsbFmpCPNjJ7nQ86O0BBnE8TVX+ee+68CMB3/t3TzrwKwA/+nAACQyoILACCZBRcAQDILLgCAZBZcAADJLLgAAJJZcAEAJLPgAgBIZsEFAJDMggsAIJkFFwBAMgsuAIBkFlwAAMksuAAAkllwAQAks+ACAEhmwQUAkMyCCwAgmQUXAEAyCy4AgGQWXAAAySy4AACSWXABACSz4AIASGbBBQCQzIILACCZBRcAQDILLgCAZBZcAADJLLgAAJJZcAEAJLPgAgBIZsEFAJDMggsAIJkFFwBAMgsuAIBkFlwAAMksuAAAkllwAQAks+ACAEhmwQUAkMyCCwAgmQUXAEAyCy4AgGQWXAAAySy4AACSWXABACSz4AIASGbBBQCQzIILACCZBRcAQDILLgCAZBZcAADJLLgAAJJZcAEAJLPgAgBIZsEFAJDMggsAIJkFFwBAMgsuAIBkFlwAAMksuAAAkllwAQAks+ACAEhmwQUAkMyCCwAgmQUXAECyfxWA9TW1PvvO9Y+tx59943lt7edlW9S6rPVzrX9+4/HPrceXBWANEi4AgGQSLjgs7YTpqPX4T62vtytft/xG/aPW+9bj9wU4KBIuAIBkEi6YhqbWo1b9qXXdFIaknXz93nq8/XVgpCRcAADJJFwwbNFb1U6ufq511noe0xS7IyPx+q3WRevxzwUYJAkXAEAyCRfsVyRTs1rbydVRgfVF0rWotZ2EScBgTyRcAADJJFywG7Na2wnWrMDuLGptJ1+LAqSScAEAJJNwwXZEL9bLWn9uXU9iF+GzZw//GE3TPKrtx3/88cdHj3+vtsX36evz58+P6vceXy6Xjx7/888/Hz3e/nr7egKWtS5q/dC61vsFG5JwAQAkk3BBNxHJnNT6S63tMwkHLRKko6OjR9f/+c9/vvr17yVSh+pbidf9/cNmwT/++OPRddQRJmO3tbaTr2UB1iLhAgBIJuGCr2v3ZL2qddBJViRSUX/66aevPi6p2q92Ehb1998fjlKMxGyxWJSBaydf8wJ8lYQLACCZhAsezGqNnqyTWgcRBUVP1Ww2W9VIruK6vVuQaYmkK5Kw33777dF1JGIDEM1pkXzd1LoocOAkXAAAySRcHJqIgM5qfd16fC8imXr58qFl7OefH8Z4tRMs+Jp2z1ckYHE9gARsWetlrYvW4zB5Ei4AgGQSLqZuVut563qnIsGKXYK//PLQKhaJlgSLTNHrFYnXhw8fHl3v0bxWvV5MnoQLACCZhIup+NYE+FnZoXYvViRZ0YtlFyFDEvPA2snX7e3to6/v0LLW6PWaF5gICRcAQDIJF2O1192GkVSdnJysajvJgimI5Ovm5ubR9Q53PS5rndd603ocRkPCBQCQTMLFWOwl0WrvLjw/P390rSeLQxQ9XtHzNZ/Py47Na41er2WBgZNwAQAkk3AxVE2tMT/rpOxA9GBFT1b0aEmy4Nvak+7fvXu3qjH/awfmtUq8GCwJFwBAMgkXQ9HUupNEyy5DyBcJVyReO5zvNa9V4sVgSLgAAJJJuNiXne46jF2Fr169WlW9WbB7kWxF0nV5+RBA7WCu17xWiRd7I+ECAEgm4WJXdppoRS9WzM3SmwXDFbsbI/GK6wTLWue1XhbYEQkXAEAyCRfZTmp9W2tKohU9WdGjJdGC8Yqerki8EifZL2uNpGteIImECwAgmYSLbZvVet663qpItKJHq2maAkzTHhKv49Y1bEzCBQCQTMLFpqInKxKt1yWBRAsIO0y85rWa38XGJFwAAMkkXPQV87Quat3q7kOJFrCuHSRey1rtZqQ3CRcAQDIJF+tqar2udVa2yGR4YFt2mHjZzcjaJFwAAMkkXHxPe/fhVnq1JFrArsTZjKenp6saCdgWXdTqbEa+ScIFAJBMwkXbUa3XreuNPHv2EIxFovX6dcq4LoDvip6u6PHaYuK1rFVvF/8g4QIASCbhIsRcrauyRWdnD9/24uJiVSPpAti3HexmvKhVbxcSLgCAbBKuw9XUutW5WnYfAmMVidfx8fGj621861r1dh0wCRcAQDIJ1+HZ6hmIdh8CU3V19dDSGj1enz9/LhuKb/Cm1nnhYEi4AACSSbimLxKs9sT4jURv1vX1QwtY0zQFYIoSdzPGrvDYxbhxhMZwSbgAAJJJuKarqfWudd2LXi2ABwmT6pe12sU4YRIuAIBkEq7peVVr9AZstAtRrxbA10WydXp6uqqLxaJsKHq4oqdrqyd/sF8SLgCAZBKu6Xhb60bNVXq1APqJM2Ojt2sb37JWZzFOgIQLACCZhGu8mlq3chZi9Ga9f/9+VY+OjgoA3SWcyXhf66/xtyiMjoQLACCZhGt8Inp6X2tTNnB29nC0YvQeRA8XAJuJsxejpyvOZtzAslbzukZIwgUAkEzCNR5bma9lFyLAfkTCFYlXJGA9xI2ntd4WBk/CBQCQTMI1fOe1XpQNxC7Eu7u7R9cA7FbCLsaLWs3rGjAJFwBAMgnXcG1lcvzLly9XNc5CtAsRYBiihyvOYry93bgV66JWSdcASbgAAJJJuIYjoqdItk7KBmIXYszXAmDYtngW47zWN7X23g7J9ki4AACSSbj2L5Ktu1p7HWIYvVlv3z4EZCcnJwWA8dnivK44gzEm00u69kjCBQCQTMK1P02td63rbt+kztN6//7haMWjo14BGQADs8V5XctancG4RxIuAIBkEq7da2rdSrJlcjzAtEm6pkHCBQCQTMK1O02tGyVb0aMVyZbJ8QCHIXYrRtJ1f39felrWKunaIQkXAEAyCVe+ptaNkq1Xr16t6nw+LwAQ8xZvbm5KT8taJV07IOECAEgm4crT1LpRsuVMRACesoUzGJe1SroSSbgAAJJJuLavqVWyBcDOSLqGTcIFAJBMwrU9Ta2SLQD2RtI1TBIuAIBkEq7NNbVKtgAYDEnXsEi4AACSSbj6i0MMP9balB4kWwBk2mLS9aLWz4XOJFwAAMkkXN1FshU9W0elB8kWALu0haTrvtbo6ZJ0dSDhAgBIJuHq7rrWk9KDZAuAfdpC0jWv9bSwNgkXAECyHwrrOq/1pPQg2QJgCNq/h3okXSe1Rg/Xm8J3SbgAAJLp4fq+SLYuSg+SLQCGbAs9XRe19v4Gh0DCBQCQTML1bS9rfV96ePXq1arO5/MCAEN3cnKyqjc3N6Wnk1p7f4Mpk3ABACSTcP1TU2uckfisdHB09DB4/uPHjwUAxubFi4cjE+/v70tHsWsxJtF3/gZTJuECAEgm4fqfpta71vV6NzcPT49k69mzTsEYAAzC588PQVUkXcvlsnS0rPW4dX3QJFwAAMkkXP8TTVdHXW6KZOvu7u7RNQCMWSRbx8fHj647WNR6XJBwAQBkk3D1nCQfPVrRsyXZAmCKYrdiJF3R49XBVa0HfeaihAsAINkhJ1xntV6VHt6+fbuqr1+/LgAwdXFyyunpaenppNaDnEQv4QIASHaICVdTa69J8ufnDy1fcbo6AByS+P13eXlZOormrxe1LssBkXABACQ7pIQrkqxItprSwcuXL1f1/fv3BQAO3a+//rqqt7e3paNlrZF0dd72OEYSLgCAZIeUcL2ttdO2QmckAsA/beHMxYOazyXhAgBIdggJ10mt16UDk+QB4Psi2Yqkq8ck+ki4es3FHAsJFwBAsiknXE2tveZtmSQPAOu7unoIqN686dySdRDzuSRcAADJppxwfaq1KR2cnT0csRgrdQBgfZFw9fg9uqj1uEyQhAsAINkUE67zWi9KB+ZtAcDmtjCfa5K7FiVcAADJppRwNbV+Kj18+vRwm3lbALC5+/v7VT0+fmjJ6jGfK3Yt3pcJkHABACT7oUzHXenh/Pyh5UuyBQDbc3R0tKrxe7bHfK44IeZFmQAJFwBAsin0cPXalTibzVb17q5XMAYAdBC9XIvFonR0WetFGTEJFwBAsjEnXE2tnXYlRq9WJFt6twAgX8zjivlcHXYtTuKsRQkXAECyMSdcvc5KvL5+2PRwcnJSAIDdijMWe+xaXNQ6yrMWJVwAAMnGmHCd1Hrd4Z6/E61IuACA/dlg1+Ioz1qUcAEAJBtTwtXUete6ftKzZ89W9ePHjw832ZUIAHu3hV2Lz1vXgybhAgBINqazFGOifFM6cFYiAAxP/F7ucdbis1pjXdB5u+M+SLgAAJKNoYerqbXXRPlPnzrdBgDswQa7FmMu16IMmIQLACDZGBKuXhPlI9nSuwUAwxfJViRdXW6tddAT6CVcAADJhrxL8aTWpnQQE+UlWwAwHrPZbFVfv369qnHm4jq31npS67wMkIQLACDZkHu4OvVuRaJ1d3f36BoAGI+YOP/8+fNH1+vcWusgJ9BLuAAAkg2xh8tEeQA4UHEG8gYT6F/XelEGRMIFAJBsSD1cTa13reunbzJRHgAmq8cE+kH2ckm4AACSDSnhuq71pHQQuxJjfgcAMB0bTKC/rPWiDICECwAg2RASrqbWTk1YMVH++vq6AADTtkEv14tal2WPJFwAAMmGkHD16t2KXYnmbgHA9G3QyzWv9bTskYQLACDZPhOupla9WwDAWk5PH4Kq+XxeOoq5XMuyBxIuAIBk+0y49G4BAJ0sl8tVff78eeloXuteerkkXAAAyfaRcDW16t0CAHrZoJfr37Xu9IxFCRcAQLJ9JFx6twCAjWzQy7WXMxYlXAAAyXaZcDW16t0CALaiRy9X9G49b12nknABACTbZcJ1XutF6UDvFgDwLWPp5ZJwAQAk22XCFb1bzTpP1rsFAKxr6L1cEi4AgGS7SLhOau0UVendAgDWtVgsVvX4+Lh09KbWq5JIwgUAkGwXCVen3q3ZbLaqd3d3BQCgi0i4IvFaQzyxczTWhYQLACBZZsI1q7VTVBXJViRdAADr2qCXK25YlAQSLgCAZJkJV+xKPFnnybEbMXYnAgD09eLFi1W9v79f95ZFrSm9XBIuAIBkP5Tta2o9KR2cn58XAIBtiBNrXr9+ve4ts1qf1brVyfMSLgCAZBk9XCe1rjVZ/tmzh4Vk9G7FNQBAX58/PwRUz58/f3S9hstaL8oWSbgAAJJl9HB1asZ6+fLlqkq2AIBtiXVF9HJdXa19VOJZrRdliyRcAADJttnDNau102T5jx8/rurR0VEBANimoUyel3ABACTbZsLVabJ8JFqRcAEAZImEKxKvNbyrde1BXk+RcAEAJNvmLsWXXZ58dnZWAAB2IaYidEi4XtV6UetGk+clXAAAybbRw3VS61qT5UNMlm+apgAAZNpg8vxprfOyAQkXAECybfRw/dLlyTHxVbLFPp2ePrxhWS6XZUqiR0GP5LS8efNmVe/v78uUzGazVT0/73RACfQSk+djSkKPXq552YCECwAg2SY9XE2tnzrcU96/f7+q8U4c9iE+w59awhXv4P773/8Wxi/++4z/XqcmPvG4vu7UAgwb6TF5Ppq9nreuO5FwAQAk26SHa9blydGzJdmCPLHrJt7BRY8M43R5eVmA7YoervhEYI3dis9qPan1qvQg4QIASLZJwtVpd6J32rA7kYz4uRuneMd9e3tbgO2KZCt6CK+u1g6sYt0j4QIAGKI+CVd8ltmpGevVq1cF2I3o4Yq5TdGzwDhEstVhEjbQ0S+/PARWHRKueCGNdVCnH1AJFwBAsj4J16zLk+OzUr0ksHsfPnxYVQnXuNidCPliXdJjt2J8wjcvHUi4AACS9Um4Ou1ONHcL9id6E+JsxXgnxzBF793UTkCAIYt1ynw+X/eWn2udlw4kXAAAydJ7uGIXALB70ZNwc3OzqpF0MUzx7wnYnR4JV3x0d1o6kHABACTrknDNam1KB3Ynwv7FXCcJ1zBFz1aHd9jAlvz880NLVo/dirNaF2UNEi4AgGR9Eq71ntyabwHsT+x+iyp5Hpb49wLsXqxTYl5hh5/HWa2LdZ4s4QIASNYl4fq5w3PN34IBisnzEq5hMVke9i/WLR0Srk7rIgkXAECyf63xnGjC+m/p4OPHj6vqDDeG6Pnz56t6aBO9o1fh06dPj67Zj3gnfXx8XA7RycnJql5fXxfYt/h9EL8fOvh3rU9ub5RwAQAkW6eHa1Y6aJpmVSVbMDwmzw/Lu3fvCjAMsX7pMI8rzGq9fepJEi4AgGRbT7jsfoLhM3l+v6JXJP49AMPR42zFWa0SLgCAfVon4eo0ZyLOJAKGy+T5/dK7BcMV65gOCddaCx8JFwBAsqcSrhjQ02m7oXfKMB6RtPi53S29WzBcPV4PY50U66avbm+UcAEAJHsq4eqUbMX8iqjA8EUPV8ybMXk+V/SEHNoJBzAm7fVMh5/XWDctvvZFCRcAQLKnEq5Z6cBkeRifSLail+v8/LyQJyb8A8MXvVwdditKuAAA9umphKvTQC27nGC8rq6uVlXClSN6QKJnDhi+Hp/czWq9+toXJVwAAMm2tkvxp59+KsA4RS+XyfM5Li8vCzAuPU7OefIGCRcAQLKvJVxNrZ0G8nhHDOMXSYyf5+3SuwXj02OuaKybmlqXX35RwgUAkOxrCZezE+FAmTy/XSbLw3jF61/sVry/v1/31lhHLb98UMIFAJBs44TL2YkwPSbPb0f8/wiM1wYJ1+2XD0q4AACSfS3h6jRQyxmKMD0mz28m3gl3eEcMDFSPdc5Xb5BwAQAke2oO11pMmIfpiV2Kt7cPLQgvX74srE/vFkxHj3XOV2+QcAEAJNt4l6IeLpiuSGokXOuJeVsxfwsYvx7rnKbWGGS4+shAwgUAkOzLhKvTEi4msJpEDdMVk+djt51E+2nOTITpiXVOzB3tcHJEU+vqBVTCBQCQ7MuEqykdeKcLh+Pm5mZV/dw/7fLysgDTFK9/HRKueMGUcAEA7ELvHi7vdOFwxK67mDyvd/Ox6N3q8M4XGJkeZ0c/eqGUcAEAJOvdw9VjpQeMVEyej16us7Ozwv/E/y/AdPVY9zyaOC/hAgBI9mXC9Z/SgTMU4fDE2YoSrgcmy8Ph6JFwNV9eSLgAAJL17uGySwkOT+zGizqbzcohM1keDkePT/aaLy8kXAAAyexSBDr78OHDqh56wmWyPByOHp/sNV9eSLgAAJL9lXA1XW6IFZ4eLjhchz55PhI+k+XhcLTXPzGfcA3NX3+RcAEAJOuccOndAuKd3bt371Y1kq5DYe4WHK5YB93f3697yyoSk3ABACT7K+Hq1HyhdwsIMXn+UBKu6NmKf27g8PRIuFY3SLgAAJJ1Trj0cMHuxM9bJMsd3lHtRPx5DmXy/NDnbsV/L3ZPQp4en/Tp4QIA2AW7FGHAIjF69erVqh4fH5chiuRn6gnX0M9OvLu7W9X470TSBdvXYx3U/PUXCRcAQDK7FGEEIjmKOrSkJf48MZ9raq8TMXdrqInRycnJqvoEAvLp4QIAGCgJF4zIy5cvV3WovURTnTx/c3NThuzs7KwAu/Hjjz+WjlY3SLgAAJL9lXD9p8sN//lPp6cDWxS7FS8uLla1w2n1O3F1dbWqU0m4omdrqIni0dHRowrk+/e//106Wt0g4QIASPZDAUYjeihjV1okSkMRidtUJs8PfbK83i3YPT1cAAADZZcijNAvv/yyqkNLuMLYJ8+3k7qhidfh2LUK7E6PdVDz118kXAAAySRcMEImz+e6vb1d1aFOlo9ky+sx7F7fnzsJFwBAMrsUYcRMns9hdyKwbRIuAIBkerhgxMYyeT4SmaG/fkRSONTeLZPlYZRWL3wSLgCAZBIuGLGxTZ4f+tyom5ubMmR6t2D/mqYpHUm4AAB2wS5FmIChT56P3YpDTbiiZ2s+n5chMlkexk/CBQCQTMIFEzCWyfNRh3bG4lDnmAWT5WH8JFwAAMkkXDAhQ588/+HDh1UdWsJlsjyQTcIFAJBMwgUTMvTJ87ELMM5W3HdPksnywK5IuAAAkkm4YELGMnk+JrrvuzfJZHlgVyRcAADJJFwwQUOfPH97e7uq+0pwTJYHdk3CBQCQTMIFE2Ty/NOG3rtlsjxMj4QLACDZXwlXDOpZ661U9D40TVOAYRv65PlImnadcA21dyvYnQjD1WO+4eoGCRcAQLLOCRcwHkOfPB+7Fd++fbuq2T1LkWyZLA/0JeECABgouxRhwsYyef7du3erGmcsZjFZHtgXCRcAQLLOCdfQekCA7xv65PnorcpKuKJna6i7NU2Wh/HQwwUAMFB/JVzL+r+bdW6QcMH4DH3yfDuB2vZcrsvLyzJkJsvDeEi4AAAG6ss5XGuRcMF4DX3yfCRR2064hvrPG+xOhOmTcAEAJPsr4fqzyw1//tnp6cCADH3yfCRR8efatKfJZHlg23q8niz/+ouECwAgmR4uOCBDnzwftjV53mR5YNt6fNK3ukHCBQCQTMIFB2jok+fjz9U34TJZHshiDhcAwEB9OWl+LUPd7QOsb+iT5+MdZN/J8ybLA1nsUgQAGCg9XHDApjZ5Pl6fbm9vy5DZnQjj1SPh0sMFALALerjggI1l8vz9/f2qfm8ieyRbQ03iTZaH8bNLEQBgoDr3cEm4YDrGMnn+w4cPq/q9ZGjouxP1bsH42aUIADBQnXu44rPLqObIwPiNZfJ8JETt153o9RpqAm+yPIxfe/3TwfKvv0i4AACS/fDF/17W2pQ1SLhgOsYyef7m5mZV271Q8fhQmSwP49e3dytIuAAAkvVOuGIuTtOs9XRgBIY+eT7mbEXCFe845/N5GTK7E2H8+vZuBQkXAECyLxOuP0oHf/zR6enACIxl8nzM2xr62a4my8N0/P7776Wj5ZcXEi4AgGRfJlz3tb5a50YT52F6xjJ5PhK4odO7BdPRY93z6KNACRcAQLIvEy5nKgIrQ588P3Qmy8P0xHSGLrd8eSHhAgBI9rUerrX0WOkBIzH0yfNDZ7I8TE+Pdc/yywsJFwBAsq9Nml9L9HA5UxGma+iT54fK7kSYjljn9Jj7p4cLAGCXvrZLcVlrU9YQn2lGrwcwHUOfPD80JsvD9Gy6OzFIuAAAkv3wlcdiZdaUNcTZQhIumJ6xTJ4fCr1bMD09zlD86mHTEi4AgGRfS7hiKbfWiGTzuGD6TJ5/msnyMF16uAAARuKpHq61SLhg+kyef5rJ8jBdPc6OlnABAOzD1hIuE+dh+kye/7rz8/MCTFOP1zsJFwDAPnwt4VrWGiOl14qs4jNOE5Zhukyefyx62pqmKcC09Ei22if2PCLhAgBI9sMTX1vUutZgmd9++21VJVwwXSbPPxaJHzA9PSbMP9kDL+ECAEj2VML1W60mzgOPHPrk+ejZiqQPmJ4ePVy/PfVFCRcAQLKnEq5OkZW5PHA4Dn3yfPxzA9PV45O7xVNflHABACTbWsIVc7iimksD03eok+dNlofpaq9nOrBLEQBgn55KuGJiaqzY1hqwFfO4JFwwfYc2ed5keZi+Dc5OfPIFUMIFAJDshzWeE3Ml1kq4YmVoAjNM36FNnve6BtMXn9R1uWWdJ0m4AACSrZNwLWo9W+O55fb2dlWvr68LcBimPnneZHk4HD16uBbrPEnCBQCQrEvCtZbYpWQeFxyOqU+eN1kepi8my/eYv7VY50kSLgCAZOskXDFXYlHrbI17yocPH1b17Gyt1i9gAqY6ed5keZi+HrsTF7WuNYBQwgUAkGydhCvE0m+2zpNjt6KECw7H1CbPmywPhyPWLR10isQkXAAAybokXIta12pmiG7/eIcbE6mB6Zra5HmT5WH6Yp2SNX8rSLgAAJL1SbiiKePJyKq9YozdS8D0jX3yvMnycDh67E5c1rooHUi4AACSdUm4woda12puiHlcEi44HGOfPG+yPByOHrsTF6UHCRcAQLI+Cdei1rUSrlg5Xl9fF+CwjHXyvMnycDh6JFwfSg8SLgCAZH0SrlgKvq21025FvRFwOMY2ed5keTgcsS7p8bq0KD1IuAAAkvVJuGIpeF/rbJ2bYreihAsOx9gmz5ssD4fj5uamdBS9W72iegkXAECyPglXiJXebJ0nz+fzVY3dP85WhMMx9MnzJsvD4emxe7rzdsYvSbgAAJJtknDNa42BNWvtVry/f2j90ssFhyN+3o+OjlY1XgeGwusRHI7oKV8ul6WjRdmAhAsAINkmCVev3YqXl5cPT/aOEg5OTJ4fWsJlsjwcjg0myy/LBiRcAADJNkm4QgyymK3z5HhnGz1ddivC4Tg7O1vV2K2478nzJsvD4YierZia0MFGuxODhAsAINk2Eq5eZyvGhNd4xwtMXyTakSz16KXYKpPl4XD0mLsVEfy8bIGECwAg2TYSrlgBRi/XWpFVvLOVcMHhiZ/7fSVcJsvD4Xn37l3paKsvUBIuAIBk20i4QqwE14qs4rPUqOZyweHY9+R5rzdwOOL1pcfrzE3ZIgkXAECybSZci1qjp2utAVtxppF3nHB4YsL777//XnbJ7kQ4HD16t5a1LsoWSbgAAJL9q2zfRa1rHU4Wc3k+ffr06BoAoK+Y+/n8+fNH12s4rXVetkjCBQCQbJs9XOGq1rUSLpPnAYBtizl/Pc5sXZQEEi4AgGQZPVzhrtbZOk+OeTwfP34sAACbiN6t5XK57i3zWk9LAgkXAECyzIRrVutdh3vK3d3D083lAgC6ihNsjo+PS0dxw6IkkHABACTLTLhCp16uSLYi6QIAWFckW5F0rWFZ6/OSSMIFAJBsFwnX61rflg70cgEA64rdiLE7sYOUyfJtEi4AgGQZk+bb5rXG5Pm1DkuMyfMSLgDgey4vL0tHy1rnZQckXAAAyXbRwxUual3rjMXw6dOnVW2apgAAfGmD3q2IxC7KDki4AACS7TLhit6tT63rJ52cnKzq9fV1AQD40unpwybD+XxeOopIbFl2QMIFAJBslwlXuKhVLxcA0MsGvVvzWk/LDkm4AACS7SPhit6t/5YO9HIBAGEsvVtBwgUAkGwfCVeY1/qqdKCXCwAO19h6t4KECwAg2T4TrqbWTx3u0csFAAdsbL1bQcIFAJBsnwlXmNfaqZfr7u5uVWezWQEApm2svVtBwgUAkGwICVdT68da1zpjMZKtSLoAgOkaa+9WkHABACQbQsIVLmrtdMaiXi4AmK7FYrGqx8fHpaN5rXvt3QoSLgCAZENKuKJ361Pr+kl6uQBgumJXYuxSXEM88bh1vVcSLgCAZD+U4fhc67ta1+rlis923717uO3s7KwAAOMWuxE7JFvhptZlGRAJFwBAsiH1cIVevVzPnj087dOnT4+uAYDxiEQrdiX26N3qPIp+FyRcAADJhtTDFaKX602t12vd9PnhtsvLy1V9+/ZtAQDGJX6P9+jduiwDJuECAEg2xB6uthiwNSsdmEAPAOMRiVbM3epya62D7N0KEi4AgGRjSLhmtXYaJW8CPQCMR4+J8n/fWuuyDJiECwAg2RB3KbYtao0J9GuNkjeBHgCGL35P90i25rUuywhIuAAAko2hhytsNIH+48ePq9o0TQEA9isSrRcvXqxqzNNc59Zaj1vXgybhAgBINoYerhBL35gku9Yo+Vgxn56erqpdiwCwfzFRvkOy9fettS7LiEi4AACSjamHq63XBPqrq6tVtWsRAHZvPp+vanzy1MGy1kFPlP8WCRcAQLIxJ1xNrR9rtWsRAAYqdiUeHx8/uu5gFBPlv0XCBQCQbMwJV7io9bx04KxFANidSLbiJJgOYlfiRRkxCRcAQLIpJFwhermOSgd2LQJAnpi3dXFxUTpa1jrKXYltEi4AgGRTSrgi2frY4Z6/dy1GL9fRUaeADAD4itiF+Px574Bq1LsS2yRcAADJppRwhde1rnXWYoh5XDGfK5IvAGB9cTbiixcvVrXHvK1J7Epsk3ABACSbYsIVep21+Pr1Q0D29m2ngAwA+P/evHmzqjEFoINlrZPYldgm4QIASDblhKuptdNZi8F8LgBY37t371Y1Pinq4HOtL2pdlgmScAEAJJtywhV67VqMXYqxazF2MQIA/xO7EGNXYuxS7OC01nmZMAkXAECyQ0i4QmyX6NSUZT4XAPzTFuZtvau1c9PXGEm4AACSHVLCFdFU7FpsSgcvX75c1ffv3xcAOHS//vrrqt7e3paOlrXGrsTOTV9jJOECAEh2SAlXaGrtNZ/r4uJiVc/PzwsAHJrLy4ejDuP3YQcHMW/rWyRcAADJDjHhCie1Xpce5vP5qr569aoAwNRtMEk+vKm18yGLUyDhAgBIdsgJV+g1nyvmcd3d3a3q0dFRAYCp2cIk+ctaL8oBk3ABACSTcP3PXa2z0kFMoo+ky5mLAExBJFvHx8ePrju4r/VFQcIFAJBNwvU/Ta13rev1bnbmIgATsIUzEpe1HreuD5qECwAgmYTrn2K7YSRdnaKq2K0YSRcAjEkkW/f396Wjg54k/z0SLgCAZBKubzuptdck+pOTk4ebr3vdDgA7dXp6uqpxkkoPv9Z6W/gHCRcAQLIfCt8yr7Wp9bx0EO8QYvfi+Xmn2wFgJy4vHwbBb5BsxSR5ydYTJFwAAMn0cK2v15mL4eLiYlUlXQAMQSRb8fupz7eo9aLwXRIuAIBkEq7u5rW+Kj1IugDYpy0kWze1nhTWJuECAEgm4eouJs/HJPqj0oOkC4Bd2kKyFaPn44zEz4W1SbgAAJJJuPqLpCsOTWxKD5IuADJtIdla1hpnJEq2epBwAQAkk3Btrqn1rnXdiaQLgG3aYrJ13LqmBwkXAEAyCdf2NLVKugDYG8nWMEm4AACSSbi2r6lV0gXAzki2hk3CBQCQTMKVp6lV0gVAGsnWOEi4AACSSbjyNbVulHSdnJys6vX1dQGA09PTVZ3P56WnZa2SrR2QcAEAJJNw7U5T60ZJ19HR0cM3uXv4Ns+ePSsATN/nzw9HGB4fPwRS9/f3padlrZKtHZJwAQAkk3DtXlPrRklX0zQP36QmXXENwLQsl8tVjWQrrvt8q1olW3sg4QIASCbh2p+mVkkXAP8QPVq//vrrqkq2xk3CBQCQTMK1f7HNMJKuo9JD7FaMScNnZ2cFgPG5ublZ1devX69q7E7sIbYxRrLV+xuxOQkXAEAyCddwRNJ1VeursgFnMAKMyxbORAw3tb6uVbI1ABIuAIBkEq7huqh1o4jq5cuXqxpnMJpMDzAM0ZsVZyLe3t6WDb2r9XVhcCRcAADJJFzDd1HrRkmXeV0Aw7DFyfHhstaLwmBJuAAAkkm4xuNlrde19mrGMq8LYD/evXtosYrX3w3ma8WNb2qdFwZPwgUAkEzCNT5NrRudwRhiknHM67KLEWA7IsGK+VpXV1dlQ8taf631vjAaEi4AgGQSrvFqan1fa68zGP/+ZnYxAmzF/f1D8PTrrw9B1BZ2IS5qPa11WRgdCRcAQDIJ13Rc1LqVwxOdxQjQzRZ3If79LWs1OX4CJFwAAMkkXNMT74Qimtpo2+FsNlvVOItRbxfAg+jNirMQF4tF2ZD5WhMm4QIASCbhmq6m1q3M64pkK3oTXr16VQAOUUKv1rLW49Y1EyLhAgBIJuGavujhuqh1K4cnnpycrGrsYtTbBUxVQq9WiF2IF7VuHJUxXBIuAIBkEq7Dc1Lr21o32sUYZy9GL8PZ2VYCNIC9S+jVim9wWevGhysyHhIuAIBkEq7D1dS6lV2Mf39TZzICIxW9WZeXl4+ut/Gta3UW4gGTcAEAJJNwES5q3erhiXYzAkMVPVmRaF1dbb2lKibG69VCwgUAkE3CRVtTa0pvl0n1wL4l7D4M97Wetq5BwgUAkE3Cxfdc1LrV3q5IvK6vr1d1NpsVgAyJuw9DzNW6KPANEi4AgGQSLtbV1LrV3q5gNyOwLTtItBa1mqvF2iRcAADJJFz0dVJr9HY1ZYskXsC6lsvlqkaiNZ/Py5Y5A5GNSbgAAJJJuNhUU+tFrSkDtiReQNhBohXe1XpR69YGdnF4JFwAAMkkXGxbU2vKbsYg8YLDscNEa1HrZesaNibhAgBIJuEi20mtKbsZ//6bSLxgMmJu1s3NzaomJlrRk/Wm1nmBJBIuAIBkEi527aLW2M3YlARxNmMkXs5qhOHawWT4EIlW7D68aj0OaSRcAADJJFzsS1PrRa0p87v+/pvVnq6Li4tV/eWXX1b12bNnBdiNz58fgqR2b9b9/X1JItFiMCRcAADJJFwMRVPrRa2piVckWy9fvlzVs7OzVT06OirAdkQv1ocPH1Y1Eq1IuhLNa415WssCeybhAgBIJuFiqJpaL2pNTbxCJFyvX79e1Z9//vnhD2OuF3xTuzfr9vZ2VRN3G7bNa5VoMVgSLgCAZBIuxqKp9aLWnSReISbZx+7G6P2CQxJJVuwqjLlZcb2D3iy7DhktCRcAQDIJF2PV1HpSa+rk+n/8zWtPV0ywf/Xq1aNrmII97jIMEi0mQ8IFAJBMwsXUnNR6XmtTdqg93yt6viL5MtmeIYmkqp1kxS7DHSZZYVHrh1rntUq0GD0JFwBAMgkXUzer9aTWne5ubIukKxKwmPNlwj2ZlsvlqrYTrB3uLvyWRa2XrWuYHAkXAEAyCReHpql1Vuteer3a2rseo5p0zzoiwYperN9++21V99iL1Wa3IQdPwgUAkEzCBQ9mtZ7U+kutg9hWGAlX9HpFAvbTTz89umZaIpmKBCuSq+i9ikQrvj4AkVjd1Hpb66LAgZNwAQAkk3DB005qjcRr0IcoRtLVTsQiCYtr88D2q30m4e+///7oul0HKJKs+AO2Ey29WdAi4QIASCbhgm6aWme1jiL5aouEKxKvqJGMRSIWz4vHJWOPRVLVTqz++OOPVY3eqqjx9QH1XH1PO8kyAR56knABACSTcMF2RPQzqzUSr59rbcoEfCvxiuv24z/++OOjx9vfp52Yfevxrr6VILUTqXb9888/H13H92lftx+fgPgHiR6s31rXkizYkIQLACCZhAt2Y9aqP7euYRcWtf7Wul4UIJWECwAgmYQL9qvd+xU1ErCjAuuL3YTfSrD0YsGeSLgAAJJJuGDYIgGLpGtWazsBMyBr2iKZWtQaCdZ9q0qwYKAkXAAAySRcMA1NrUet+tM3vs4wLGuNhOr31vV963nASEm4AACSSbjgMEXS1bSu/9N6vF35uuU3aiRW7TMJl63HgYmTcAEAJJNwAV00rfqsVduP/9h6vHzjvu89nqV9VuCfrevlmtcAT5JwAQAkk3ABU/J/SzdeA4GdkHABACSz4AIASGbBBQCQzIILACCZBRcAQDILLgCAZBZcAADJLLgAAJJZcAEAJLPgAgBIZsEFAJDMggsAIJkFFwBAMgsuAIBkFlwAAMksuAAAkllwAQAks+ACAEhmwQUAkMyCCwAgmQUXAEAyCy4AgGQWXAAAySy4AACSWXABACSz4AIASGbBBQCQzIILACCZBRcAQDILLgCAZBZcAADJLLgAAJJZcAEAJLPgAgBIZsEFAJDMggsAIJkFFwBAMgsuAIBkFlwAAMksuAAAkllwAQAks+ACAEhmwQUAkMyCCwAgmQUXAEAyCy4AgGQWXAAAySy4AACSWXABACSz4AIASGbBBQCQzIILACCZBRcAQDILLgCAZBZcAADJLLgAAJJZcAEAJLPgAgBIZsEFAJDMggsAIJkFFwBAMgsuAIBkFlwAAMn+H5fWBetrL50zAAAAAElFTkSuQmCC',
    XF =
      'data:image/png;base64,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',
    YF =
      'data:image/png;base64,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',
    HF = 180,
    UF = 30,
    un = e => (e ? e * Mm : HF),
    td = e => (e ? e * Pm : UF),
    dn = kt,
    nd = Bn,
    cl = { src: ed, alt: 'generic', width: un(), height: dn },
    Wt = {
      CIRCUIT_BREAKER: { src: DF, alt: 'circuit breaker', width: td(104), height: nd },
      ELECTRICAL_PANEL: { src: ed, alt: 'electrical panel', width: un(0), height: dn },
      FUSE: { src: zF, alt: 'fuse', width: td(45), height: nd },
      MISC: { src: ed, alt: 'other', width: un(116), height: dn },
      SWITCH: { src: QF, alt: 'switch', width: un(77), height: dn },
      TRANSFER_SWITCH: { src: RF, alt: 'transfer switch', width: un(130), height: dn },
      TRANSFORMER: { src: OF, alt: 'transformer', width: un(180), height: dn },
      UPS_SYSTEM: { src: jF, alt: 'ups system', width: un(151), height: dn },
      CAPACITOR: { src: WF, alt: 'capacitor', width: un(74), height: dn },
      SUB_SWITCH: { src: GF, alt: 'switch', width: td(72), height: nd },
      MOTOR: { src: VF, alt: 'motor', width: un(151), height: dn },
      GENERATOR: { src: XF, alt: 'generator', width: un(151), height: dn },
      RELAY: { src: YF, alt: 'relay', width: un(151), height: dn },
      GROUND_FAULT_SYSTEM: cl,
      GROUNDING_OR_BONDING: cl,
      INSTRUMENT_TRANSFORMER: cl,
      METER: cl,
    },
    KF = async () => ({ services: { appEnvironment: ba.appEnvironment } }),
    qF = wc({
      palette: { ...Rb },
      typography: {
        fontFamily: ['Manrope-Regular', 'Manrope-Medium', 'Manrope-Bold', 'BlinkMacSystemFont', '"Segoe UI"', 'Roboto', '"Helvetica Neue"', 'Arial', 'sans-serif', '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"'].join(','),
        fontSize: 14,
        body1: { fontSize: '14px' },
        body2: { fontSize: '13px' },
        h1: { fontSize: '2rem' },
        h2: { fontSize: '1.5rem' },
        h3: { fontSize: '1.25rem' },
      },
    }),
    Fs = () => {
      const [e, t] = C.useState(),
        [n, o] = sl(),
        r = C.useCallback(async () => {
          const s = await KF()
          t(s.services), o(!0)
        }, [o])
      return (
        yT(() => {
          r()
        }),
        { services: e, config: ba, bootstrapped: n, theme: qF }
      )
    },
    od = ({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s, onNodeArchetypeChange: i, onDeleteClick: a, onCopyClick: l }) => {
      var Ke, Ve
      const { config: c } = Fs(),
        { minAmpereRating: u = 0.01, maxAmpereRating: d = 1e3, defaultAmpereRating: f = 1, minPoles: A = 1, maxPoles: h = 10, defaultPoles: g = 3 } = c.subNodeParameters,
        x = eF(),
        { nodes: m, setNodes: v, edges: y, setEdges: b } = oo(),
        [w, k] = C.useState(() => Mp(e) ?? ''),
        [E, P] = C.useState(() => z0(e).background ?? ''),
        [T, F] = C.useState(() => D0(e)),
        [D, Q] = C.useState(() => su(e, m)),
        [R, S] = C.useState(() => e.data.electricalPanelType ?? Do.MCB),
        L = C.useMemo(() => Sl(e), [e]),
        I = C.useMemo(() => !L, [L]),
        z = I && Gs[Ed[T]] === Fo.ElectricalPanelNode,
        B = F0(e),
        O = T0(e),
        W = uO(e),
        K = Sd(e, m),
        Z = iO(e, m),
        oe = W ? 'Parent name' : 'Parent id',
        [V, q] = C.useState(((Ke = e == null ? void 0 : e.data) == null ? void 0 : Ke.archetype) ?? He.lineSide),
        [ee, re] = C.useState(((Ve = e == null ? void 0 : e.data) == null ? void 0 : Ve.amperes) ?? f),
        [J, ie] = C.useState((e == null ? void 0 : e.data.poles) ?? g),
        Ae = X => ie(G => Math.min(G + X, h)),
        ae = X => ie(G => Math.max(G - X, A)),
        se = C.useCallback(
          X => {
            q(X), i == null || i(hn({ ...e, data: { ...e.data, archetype: X } }))
          },
          [i]
        )
      C.useEffect(() => {
        Q(su(e, m))
      }, [m, e])
      const H = X => G => {
          Q(ce => ce.map(ne => (ne.id !== X.id ? ne : dO(X, G.target.value))))
        },
        U = C.useMemo(
          () =>
            m.some(X => {
              var G
              return ((G = Ar(X)) == null ? void 0 : G.trim()) === w.trim() && X.id !== e.id
            }),
          [m, w, e]
        ),
        te = X => {
          k(X.target.value), n == null || n(hn({ ...e, data: { ...e.data, label: X.target.value.trim() } }))
        },
        be = C.useCallback(
          ({ classCode: X = T, nodeColor: G = E, epType: ce = R } = {}) => {
            const ne = aO(B),
              ue = Ed[X],
              _ = P0[X],
              pe = ne ? null : I ? ue : _,
              xe = ne ? (I ? Fo.ResizableNode : Fo.ResizableSubNode) : I ? (Q0(ue) ? Gs[ue] : Fo.ImageNode) : Q0(_) ? Gs[_] : Fo.ImageSubNode,
              Ee = pe ?? B,
              nt = L ? `${k0[Ee]}-${L0[V]}-${m.length + 1}-${J}P/${ee}A` : null,
              nn = w.trim(),
              Hn = nt ? null : nn
            return hn({ ...e, type: xe, data: ne ? { ...e.data, label: Hn, defaultLabel: nt, background: G } : { ...e.data, class: Ee, image: Wt[Ee], code: X, background: G, electricalPanelType: ce, defaultLabel: nt, ...(O ? { label: Hn } : {}), ...(I ? {} : { archetype: V, amperes: ee, poles: J }) } })
          },
          [B, I, O, E, w, e, T, R, V, ee, J]
        ),
        Ne = X => {
          const G = X.target.value
          F(G), r == null || r(hn(be({ classCode: G })))
        },
        Me = X => {
          P(X), o == null || o(be({ nodeColor: X }))
        },
        Ue = () => {
          const X = y.filter(G => G.target === e.id)
          b(G => G.filter(ne => X.every(ue => ue.id !== ne.id)))
        },
        we = () => {
          const X = m.filter(ne => ne.parentId === e.id && ne.data.archetype === He.lineSide)
          X.length > 0 && x.warning('Switching to MLO results in deleting all of the line-side components')
          const ce = y.filter(ne => X.some(ue => ue.id === ne.target)).map(ne => eo({ ...ne, target: e.id }))
          b(ne => ne.map(_ => (ce.some(pe => pe.id === _.id) ? ce.find(pe => pe.id === _.id) : _))), v(ne => ne.filter(_ => X.every(pe => pe.id !== _.id)))
        }
      return {
        node: e,
        existingNodes: m,
        setNodes: v,
        existingEdges: y,
        setEdges: b,
        name: w,
        setName: k,
        color: E,
        setColor: P,
        code: T,
        setCode: F,
        archetype: V,
        setArchetype: q,
        ampereRating: ee,
        setAmpereRating: re,
        poles: J,
        setPoles: ie,
        nodeChildren: D,
        setNodeChildren: Q,
        electricalPanelType: R,
        setElectricalPanelType: S,
        hasParent: L,
        isTopLevelNode: I,
        isElectricalPanel: z,
        heterogenousClass: B,
        isWithImplicitClass: O,
        hasName: W,
        nodeParent: K,
        hasChildren: Z,
        parentNodeInputLabel: oe,
        handleChildNameChange: H,
        nameExistsAlready: U,
        handleNameChange: te,
        evaluateNextNode: be,
        handleNodeClassCodeChange: Ne,
        handleColorChange: Me,
        handleSwitchToMCB: Ue,
        handleSwitchToMLO: we,
        handleElectricalPanelTypeChange: X => {
          const G = X.target.value,
            ce = G === Do.MCB,
            ne = G === Do.MLO
          ce && Ue(), ne && we(), S(G), s == null || s(be({ epType: G }))
        },
        handleSave: () => {
          t == null || t(hn(be({ classCode: T }))), Z && v(X => X.map(G => D.find(ne => ne.id === G.id) ?? G))
        },
        handleArchetypeChange: se,
        handleAmpereRatingChange: (X, G) => {
          X.preventDefault(), re(G > d ? d : G < u ? u : G)
        },
        handlePolesIncrement: Ae,
        handlePolesDecrement: ae,
        handleDeleteClick: () => {
          a == null || a(hn(be({ classCode: T })))
        },
        handleCopyClick: () => {
          l == null || l(hn(be({ classCode: T })), K)
        },
      }
    },
    rd = e => {
      const t = e.label,
        n = e.defaultLabel
      return n ? p.jsxs(p.Fragment, { children: [k0[e.class], '-', L0[e.archetype], '-', n.split('-')[2], p.jsx('br', {}), e.poles, 'P/', e.amperes, 'A'] }) : t ? p.jsxs(p.Fragment, { children: [t, p.jsx('br', {}), e.poles, 'P/', e.amperes, 'A'] }) : ''
    }
  function ZF(e) {
    return typeof e == 'string'
  }
  function JF(e, t, n) {
    return e === void 0 || ZF(e) ? t : { ...t, ownerState: { ...t.ownerState, ...n } }
  }
  const _F = { disableDefaultClasses: !1 },
    $F = N.createContext(_F)
  function zm(e) {
    const { disableDefaultClasses: t } = N.useContext($F)
    return n => (t ? '' : e(n))
  }
  function ul(e, t = []) {
    if (e === void 0) return {}
    const n = {}
    return (
      Object.keys(e)
        .filter(o => o.match(/^on[A-Z]/) && typeof e[o] == 'function' && !t.includes(o))
        .forEach(o => {
          n[o] = e[o]
        }),
      n
    )
  }
  function sd(e, t) {
    typeof e == 'function' ? e(t) : e && (e.current = t)
  }
  function dl(...e) {
    return N.useMemo(
      () =>
        e.every(t => t == null)
          ? null
          : t => {
              e.forEach(n => {
                sd(n, t)
              })
            },
      e
    )
  }
  function Qm(e) {
    if (e === void 0) return {}
    const t = {}
    return (
      Object.keys(e)
        .filter(n => !(n.match(/^on[A-Z]/) && typeof e[n] == 'function'))
        .forEach(n => {
          t[n] = e[n]
        }),
      t
    )
  }
  function e3(e) {
    const { getSlotProps: t, additionalProps: n, externalSlotProps: o, externalForwardedProps: r, className: s } = e
    if (!t) {
      const A = fe(n == null ? void 0 : n.className, s, r == null ? void 0 : r.className, o == null ? void 0 : o.className),
        h = { ...(n == null ? void 0 : n.style), ...(r == null ? void 0 : r.style), ...(o == null ? void 0 : o.style) },
        g = { ...n, ...r, ...o }
      return A.length > 0 && (g.className = A), Object.keys(h).length > 0 && (g.style = h), { props: g, internalRef: void 0 }
    }
    const i = ul({ ...r, ...o }),
      a = Qm(o),
      l = Qm(r),
      c = t(i),
      u = fe(c == null ? void 0 : c.className, n == null ? void 0 : n.className, s, r == null ? void 0 : r.className, o == null ? void 0 : o.className),
      d = { ...(c == null ? void 0 : c.style), ...(n == null ? void 0 : n.style), ...(r == null ? void 0 : r.style), ...(o == null ? void 0 : o.style) },
      f = { ...c, ...n, ...l, ...a }
    return u.length > 0 && (f.className = u), Object.keys(d).length > 0 && (f.style = d), { props: f, internalRef: c.ref }
  }
  function t3(e, t, n) {
    return typeof e == 'function' ? e(t, n) : e
  }
  function Ds(e) {
    var d
    const { elementType: t, externalSlotProps: n, ownerState: o, skipResolvingSlotProps: r = !1, ...s } = e,
      i = r ? {} : t3(n, o),
      { props: a, internalRef: l } = e3({ ...s, externalSlotProps: i }),
      c = dl(l, i == null ? void 0 : i.ref, (d = e.additionalProps) == null ? void 0 : d.ref)
    return JF(t, { ...a, ref: c }, o)
  }
  function n3(e) {
    let t = 'https://mui.com/production-error/?code=' + e
    for (let n = 1; n < arguments.length; n += 1) t += '&args[]=' + encodeURIComponent(arguments[n])
    return 'Minified MUI error #' + e + '; visit ' + t + ' for the full message.'
  }
  const id = typeof window < 'u' ? N.useLayoutEffect : N.useEffect
  let Rm = 0
  function o3(e) {
    const [t, n] = N.useState(e),
      o = e || t
    return (
      N.useEffect(() => {
        t == null && ((Rm += 1), n(`mui-${Rm}`))
      }, [t]),
      o
    )
  }
  const Om = N.useId
  function r3(e) {
    if (Om !== void 0) {
      const t = Om()
      return e ?? t
    }
    return o3(e)
  }
  function jm(e, t, n = void 0) {
    const o = {}
    for (const r in e) {
      const s = e[r]
      let i = ''
      for (let a = 0; a < s.length; a += 1) {
        const l = s[a]
        l && ((i += t(l) + ' '), n && n[l] && (i += n[l] + ' '))
      }
      o[r] = i
    }
    return o
  }
  const s3 = { active: 'active', checked: 'checked', completed: 'completed', disabled: 'disabled', error: 'error', expanded: 'expanded', focused: 'focused', focusVisible: 'focusVisible', open: 'open', readOnly: 'readOnly', required: 'required', selected: 'selected' }
  function ad(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, n))
  }
  function i3(e) {
    return !e || !N.isValidElement(e) ? null : e.props.propertyIsEnumerable('ref') ? e.props.ref : e.ref
  }
  const Wm = 'base'
  function a3(e) {
    return `${Wm}--${e}`
  }
  function l3(e, t) {
    return `${Wm}-${e}-${t}`
  }
  function ld(e, t) {
    const n = s3[t]
    return n ? a3(n) : l3(e, t)
  }
  function Gm(e, t) {
    const n = {}
    return (
      t.forEach(o => {
        n[o] = ld(e, o)
      }),
      n
    )
  }
  function c3(e, t) {
    return e === t
  }
  const cd = {},
    Vm = () => {}
  function ud(e, t) {
    const n = { ...e }
    return (
      Object.keys(t).forEach(o => {
        t[o] !== void 0 && (n[o] = t[o])
      }),
      n
    )
  }
  function u3(e) {
    const { nextState: t, initialState: n, stateComparers: o, onStateChange: r, controlledProps: s, lastActionRef: i } = e,
      a = N.useRef(n)
    N.useEffect(() => {
      if (i.current === null) return
      const l = ud(a.current, s)
      Object.keys(t).forEach(c => {
        const u = o[c] ?? c3,
          d = t[c],
          f = l[c]
        ;((f == null && d != null) || (f != null && d == null) || (f != null && d != null && !u(d, f))) && (r == null || r(i.current.event ?? null, c, d, i.current.type ?? '', t))
      }),
        (a.current = t),
        (i.current = null)
    }, [a, t, i, r, o, s])
  }
  function d3(e) {
    const t = N.useRef(null),
      { reducer: n, initialState: o, controlledProps: r = cd, stateComparers: s = cd, onStateChange: i = Vm, actionContext: a, componentName: l = '' } = e
    N.useRef(r)
    const c = N.useCallback(
        (A, h) => {
          t.current = h
          const g = ud(A, r)
          return n(g, h)
        },
        [r, n]
      ),
      [u, d] = N.useReducer(c, o),
      f = N.useCallback(
        A => {
          d({ ...A, context: a })
        },
        [a]
      )
    return u3({ nextState: u, initialState: o, stateComparers: s ?? cd, onStateChange: i ?? Vm, controlledProps: r, lastActionRef: t }), [ud(u, r), f]
  }
  const f3 = N.createContext(void 0)
  function A3() {
    return N.useContext(f3)
  }
  const fl = Math.min,
    Po = Math.max,
    Al = Math.round,
    pl = Math.floor,
    In = e => ({ x: e, y: e }),
    p3 = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' },
    h3 = { start: 'end', end: 'start' }
  function Xm(e, t, n) {
    return Po(e, fl(t, n))
  }
  function hl(e, t) {
    return typeof e == 'function' ? e(t) : e
  }
  function Lo(e) {
    return e.split('-')[0]
  }
  function gl(e) {
    return e.split('-')[1]
  }
  function Ym(e) {
    return e === 'x' ? 'y' : 'x'
  }
  function Hm(e) {
    return e === 'y' ? 'height' : 'width'
  }
  function Ir(e) {
    return ['top', 'bottom'].includes(Lo(e)) ? 'y' : 'x'
  }
  function Um(e) {
    return Ym(Ir(e))
  }
  function g3(e, t, n) {
    n === void 0 && (n = !1)
    const o = gl(e),
      r = Um(e),
      s = Hm(r)
    let i = r === 'x' ? (o === (n ? 'end' : 'start') ? 'right' : 'left') : o === 'start' ? 'bottom' : 'top'
    return t.reference[s] > t.floating[s] && (i = ml(i)), [i, ml(i)]
  }
  function m3(e) {
    const t = ml(e)
    return [dd(e), t, dd(t)]
  }
  function dd(e) {
    return e.replace(/start|end/g, t => h3[t])
  }
  function y3(e, t, n) {
    const o = ['left', 'right'],
      r = ['right', 'left'],
      s = ['top', 'bottom'],
      i = ['bottom', 'top']
    switch (e) {
      case 'top':
      case 'bottom':
        return n ? (t ? r : o) : t ? o : r
      case 'left':
      case 'right':
        return t ? s : i
      default:
        return []
    }
  }
  function b3(e, t, n, o) {
    const r = gl(e)
    let s = y3(Lo(e), n === 'start', o)
    return r && ((s = s.map(i => i + '-' + r)), t && (s = s.concat(s.map(dd)))), s
  }
  function ml(e) {
    return e.replace(/left|right|bottom|top/g, t => p3[t])
  }
  function v3(e) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...e }
  }
  function x3(e) {
    return typeof e != 'number' ? v3(e) : { top: e, right: e, bottom: e, left: e }
  }
  function yl(e) {
    const { x: t, y: n, width: o, height: r } = e
    return { width: o, height: r, top: n, left: t, right: t + o, bottom: n + r, x: t, y: n }
  }
  function Km(e, t, n) {
    let { reference: o, floating: r } = e
    const s = Ir(t),
      i = Um(t),
      a = Hm(i),
      l = Lo(t),
      c = s === 'y',
      u = o.x + o.width / 2 - r.width / 2,
      d = o.y + o.height / 2 - r.height / 2,
      f = o[a] / 2 - r[a] / 2
    let A
    switch (l) {
      case 'top':
        A = { x: u, y: o.y - r.height }
        break
      case 'bottom':
        A = { x: u, y: o.y + o.height }
        break
      case 'right':
        A = { x: o.x + o.width, y: d }
        break
      case 'left':
        A = { x: o.x - r.width, y: d }
        break
      default:
        A = { x: o.x, y: o.y }
    }
    switch (gl(t)) {
      case 'start':
        A[i] -= f * (n && c ? -1 : 1)
        break
      case 'end':
        A[i] += f * (n && c ? -1 : 1)
        break
    }
    return A
  }
  const C3 = async (e, t, n) => {
    const { placement: o = 'bottom', strategy: r = 'absolute', middleware: s = [], platform: i } = n,
      a = s.filter(Boolean),
      l = await (i.isRTL == null ? void 0 : i.isRTL(t))
    let c = await i.getElementRects({ reference: e, floating: t, strategy: r }),
      { x: u, y: d } = Km(c, o, l),
      f = o,
      A = {},
      h = 0
    for (let g = 0; g < a.length; g++) {
      const { name: x, fn: m } = a[g],
        { x: v, y, data: b, reset: w } = await m({ x: u, y: d, initialPlacement: o, placement: f, strategy: r, middlewareData: A, rects: c, platform: i, elements: { reference: e, floating: t } })
      ;(u = v ?? u), (d = y ?? d), (A = { ...A, [x]: { ...A[x], ...b } }), w && h <= 50 && (h++, typeof w == 'object' && (w.placement && (f = w.placement), w.rects && (c = w.rects === !0 ? await i.getElementRects({ reference: e, floating: t, strategy: r }) : w.rects), ({ x: u, y: d } = Km(c, f, l))), (g = -1))
    }
    return { x: u, y: d, placement: f, strategy: r, middlewareData: A }
  }
  async function qm(e, t) {
    var n
    t === void 0 && (t = {})
    const { x: o, y: r, platform: s, rects: i, elements: a, strategy: l } = e,
      { boundary: c = 'clippingAncestors', rootBoundary: u = 'viewport', elementContext: d = 'floating', altBoundary: f = !1, padding: A = 0 } = hl(t, e),
      h = x3(A),
      x = a[f ? (d === 'floating' ? 'reference' : 'floating') : d],
      m = yl(await s.getClippingRect({ element: (n = await (s.isElement == null ? void 0 : s.isElement(x))) == null || n ? x : x.contextElement || (await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating))), boundary: c, rootBoundary: u, strategy: l })),
      v = d === 'floating' ? { x: o, y: r, width: i.floating.width, height: i.floating.height } : i.reference,
      y = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)),
      b = (await (s.isElement == null ? void 0 : s.isElement(y))) ? (await (s.getScale == null ? void 0 : s.getScale(y))) || { x: 1, y: 1 } : { x: 1, y: 1 },
      w = yl(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: a, rect: v, offsetParent: y, strategy: l }) : v)
    return { top: (m.top - w.top + h.top) / b.y, bottom: (w.bottom - m.bottom + h.bottom) / b.y, left: (m.left - w.left + h.left) / b.x, right: (w.right - m.right + h.right) / b.x }
  }
  const w3 = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'flip',
        options: e,
        async fn(t) {
          var n, o
          const { placement: r, middlewareData: s, rects: i, initialPlacement: a, platform: l, elements: c } = t,
            { mainAxis: u = !0, crossAxis: d = !0, fallbackPlacements: f, fallbackStrategy: A = 'bestFit', fallbackAxisSideDirection: h = 'none', flipAlignment: g = !0, ...x } = hl(e, t)
          if ((n = s.arrow) != null && n.alignmentOffset) return {}
          const m = Lo(r),
            v = Ir(a),
            y = Lo(a) === a,
            b = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
            w = f || (y || !g ? [ml(a)] : m3(a)),
            k = h !== 'none'
          !f && k && w.push(...b3(a, g, h, b))
          const E = [a, ...w],
            P = await qm(t, x),
            T = []
          let F = ((o = s.flip) == null ? void 0 : o.overflows) || []
          if ((u && T.push(P[m]), d)) {
            const S = g3(r, i, b)
            T.push(P[S[0]], P[S[1]])
          }
          if (((F = [...F, { placement: r, overflows: T }]), !T.every(S => S <= 0))) {
            var D, Q
            const S = (((D = s.flip) == null ? void 0 : D.index) || 0) + 1,
              L = E[S]
            if (L) return { data: { index: S, overflows: F }, reset: { placement: L } }
            let I = (Q = F.filter(z => z.overflows[0] <= 0).sort((z, B) => z.overflows[1] - B.overflows[1])[0]) == null ? void 0 : Q.placement
            if (!I)
              switch (A) {
                case 'bestFit': {
                  var R
                  const z =
                    (R = F.filter(B => {
                      if (k) {
                        const O = Ir(B.placement)
                        return O === v || O === 'y'
                      }
                      return !0
                    })
                      .map(B => [B.placement, B.overflows.filter(O => O > 0).reduce((O, W) => O + W, 0)])
                      .sort((B, O) => B[1] - O[1])[0]) == null
                      ? void 0
                      : R[0]
                  z && (I = z)
                  break
                }
                case 'initialPlacement':
                  I = a
                  break
              }
            if (r !== I) return { reset: { placement: I } }
          }
          return {}
        },
      }
    )
  }
  async function E3(e, t) {
    const { placement: n, platform: o, elements: r } = e,
      s = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)),
      i = Lo(n),
      a = gl(n),
      l = Ir(n) === 'y',
      c = ['left', 'top'].includes(i) ? -1 : 1,
      u = s && l ? -1 : 1,
      d = hl(t, e)
    let { mainAxis: f, crossAxis: A, alignmentAxis: h } = typeof d == 'number' ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : { mainAxis: d.mainAxis || 0, crossAxis: d.crossAxis || 0, alignmentAxis: d.alignmentAxis }
    return a && typeof h == 'number' && (A = a === 'end' ? h * -1 : h), l ? { x: A * u, y: f * c } : { x: f * c, y: A * u }
  }
  const S3 = function (e) {
      return (
        e === void 0 && (e = 0),
        {
          name: 'offset',
          options: e,
          async fn(t) {
            var n, o
            const { x: r, y: s, placement: i, middlewareData: a } = t,
              l = await E3(t, e)
            return i === ((n = a.offset) == null ? void 0 : n.placement) && (o = a.arrow) != null && o.alignmentOffset ? {} : { x: r + l.x, y: s + l.y, data: { ...l, placement: i } }
          },
        }
      )
    },
    B3 = function (e) {
      return (
        e === void 0 && (e = {}),
        {
          name: 'shift',
          options: e,
          async fn(t) {
            const { x: n, y: o, placement: r } = t,
              {
                mainAxis: s = !0,
                crossAxis: i = !1,
                limiter: a = {
                  fn: x => {
                    let { x: m, y: v } = x
                    return { x: m, y: v }
                  },
                },
                ...l
              } = hl(e, t),
              c = { x: n, y: o },
              u = await qm(t, l),
              d = Ir(Lo(r)),
              f = Ym(d)
            let A = c[f],
              h = c[d]
            if (s) {
              const x = f === 'y' ? 'top' : 'left',
                m = f === 'y' ? 'bottom' : 'right',
                v = A + u[x],
                y = A - u[m]
              A = Xm(v, A, y)
            }
            if (i) {
              const x = d === 'y' ? 'top' : 'left',
                m = d === 'y' ? 'bottom' : 'right',
                v = h + u[x],
                y = h - u[m]
              h = Xm(v, h, y)
            }
            const g = a.fn({ ...t, [f]: A, [d]: h })
            return { ...g, data: { x: g.x - n, y: g.y - o, enabled: { [f]: s, [d]: i } } }
          },
        }
      )
    }
  function bl() {
    return typeof window < 'u'
  }
  function kr(e) {
    return Zm(e) ? (e.nodeName || '').toLowerCase() : '#document'
  }
  function Gt(e) {
    var t
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
  }
  function kn(e) {
    var t
    return (t = (Zm(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement
  }
  function Zm(e) {
    return bl() ? e instanceof Node || e instanceof Gt(e).Node : !1
  }
  function fn(e) {
    return bl() ? e instanceof Element || e instanceof Gt(e).Element : !1
  }
  function Nn(e) {
    return bl() ? e instanceof HTMLElement || e instanceof Gt(e).HTMLElement : !1
  }
  function Jm(e) {
    return !bl() || typeof ShadowRoot > 'u' ? !1 : e instanceof ShadowRoot || e instanceof Gt(e).ShadowRoot
  }
  function zs(e) {
    const { overflow: t, overflowX: n, overflowY: o, display: r } = An(e)
    return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !['inline', 'contents'].includes(r)
  }
  function I3(e) {
    return ['table', 'td', 'th'].includes(kr(e))
  }
  function vl(e) {
    return [':popover-open', ':modal'].some(t => {
      try {
        return e.matches(t)
      } catch {
        return !1
      }
    })
  }
  function fd(e) {
    const t = Ad(),
      n = fn(e) ? An(e) : e
    return (
      n.transform !== 'none' ||
      n.perspective !== 'none' ||
      (n.containerType ? n.containerType !== 'normal' : !1) ||
      (!t && (n.backdropFilter ? n.backdropFilter !== 'none' : !1)) ||
      (!t && (n.filter ? n.filter !== 'none' : !1)) ||
      ['transform', 'perspective', 'filter'].some(o => (n.willChange || '').includes(o)) ||
      ['paint', 'layout', 'strict', 'content'].some(o => (n.contain || '').includes(o))
    )
  }
  function k3(e) {
    let t = to(e)
    for (; Nn(t) && !Nr(t); ) {
      if (fd(t)) return t
      if (vl(t)) return null
      t = to(t)
    }
    return null
  }
  function Ad() {
    return typeof CSS > 'u' || !CSS.supports ? !1 : CSS.supports('-webkit-backdrop-filter', 'none')
  }
  function Nr(e) {
    return ['html', 'body', '#document'].includes(kr(e))
  }
  function An(e) {
    return Gt(e).getComputedStyle(e)
  }
  function xl(e) {
    return fn(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY }
  }
  function to(e) {
    if (kr(e) === 'html') return e
    const t = e.assignedSlot || e.parentNode || (Jm(e) && e.host) || kn(e)
    return Jm(t) ? t.host : t
  }
  function _m(e) {
    const t = to(e)
    return Nr(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : Nn(t) && zs(t) ? t : _m(t)
  }
  function Qs(e, t, n) {
    var o
    t === void 0 && (t = []), n === void 0 && (n = !0)
    const r = _m(e),
      s = r === ((o = e.ownerDocument) == null ? void 0 : o.body),
      i = Gt(r)
    if (s) {
      const a = pd(i)
      return t.concat(i, i.visualViewport || [], zs(r) ? r : [], a && n ? Qs(a) : [])
    }
    return t.concat(r, Qs(r, [], n))
  }
  function pd(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
  }
  function $m(e) {
    const t = An(e)
    let n = parseFloat(t.width) || 0,
      o = parseFloat(t.height) || 0
    const r = Nn(e),
      s = r ? e.offsetWidth : n,
      i = r ? e.offsetHeight : o,
      a = Al(n) !== s || Al(o) !== i
    return a && ((n = s), (o = i)), { width: n, height: o, $: a }
  }
  function hd(e) {
    return fn(e) ? e : e.contextElement
  }
  function Mr(e) {
    const t = hd(e)
    if (!Nn(t)) return In(1)
    const n = t.getBoundingClientRect(),
      { width: o, height: r, $: s } = $m(t)
    let i = (s ? Al(n.width) : n.width) / o,
      a = (s ? Al(n.height) : n.height) / r
    return (!i || !Number.isFinite(i)) && (i = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: i, y: a }
  }
  const N3 = In(0)
  function e0(e) {
    const t = Gt(e)
    return !Ad() || !t.visualViewport ? N3 : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop }
  }
  function M3(e, t, n) {
    return t === void 0 && (t = !1), !n || (t && n !== Gt(e)) ? !1 : t
  }
  function To(e, t, n, o) {
    t === void 0 && (t = !1), n === void 0 && (n = !1)
    const r = e.getBoundingClientRect(),
      s = hd(e)
    let i = In(1)
    t && (o ? fn(o) && (i = Mr(o)) : (i = Mr(e)))
    const a = M3(s, n, o) ? e0(s) : In(0)
    let l = (r.left + a.x) / i.x,
      c = (r.top + a.y) / i.y,
      u = r.width / i.x,
      d = r.height / i.y
    if (s) {
      const f = Gt(s),
        A = o && fn(o) ? Gt(o) : o
      let h = f,
        g = pd(h)
      for (; g && o && A !== h; ) {
        const x = Mr(g),
          m = g.getBoundingClientRect(),
          v = An(g),
          y = m.left + (g.clientLeft + parseFloat(v.paddingLeft)) * x.x,
          b = m.top + (g.clientTop + parseFloat(v.paddingTop)) * x.y
        ;(l *= x.x), (c *= x.y), (u *= x.x), (d *= x.y), (l += y), (c += b), (h = Gt(g)), (g = pd(h))
      }
    }
    return yl({ width: u, height: d, x: l, y: c })
  }
  function gd(e, t) {
    const n = xl(e).scrollLeft
    return t ? t.left + n : To(kn(e)).left + n
  }
  function t0(e, t, n) {
    n === void 0 && (n = !1)
    const o = e.getBoundingClientRect(),
      r = o.left + t.scrollLeft - (n ? 0 : gd(e, o)),
      s = o.top + t.scrollTop
    return { x: r, y: s }
  }
  function P3(e) {
    let { elements: t, rect: n, offsetParent: o, strategy: r } = e
    const s = r === 'fixed',
      i = kn(o),
      a = t ? vl(t.floating) : !1
    if (o === i || (a && s)) return n
    let l = { scrollLeft: 0, scrollTop: 0 },
      c = In(1)
    const u = In(0),
      d = Nn(o)
    if ((d || (!d && !s)) && ((kr(o) !== 'body' || zs(i)) && (l = xl(o)), Nn(o))) {
      const A = To(o)
      ;(c = Mr(o)), (u.x = A.x + o.clientLeft), (u.y = A.y + o.clientTop)
    }
    const f = i && !d && !s ? t0(i, l, !0) : In(0)
    return { width: n.width * c.x, height: n.height * c.y, x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x, y: n.y * c.y - l.scrollTop * c.y + u.y + f.y }
  }
  function L3(e) {
    return Array.from(e.getClientRects())
  }
  function T3(e) {
    const t = kn(e),
      n = xl(e),
      o = e.ownerDocument.body,
      r = Po(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth),
      s = Po(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight)
    let i = -n.scrollLeft + gd(e)
    const a = -n.scrollTop
    return An(o).direction === 'rtl' && (i += Po(t.clientWidth, o.clientWidth) - r), { width: r, height: s, x: i, y: a }
  }
  function F3(e, t) {
    const n = Gt(e),
      o = kn(e),
      r = n.visualViewport
    let s = o.clientWidth,
      i = o.clientHeight,
      a = 0,
      l = 0
    if (r) {
      ;(s = r.width), (i = r.height)
      const c = Ad()
      ;(!c || (c && t === 'fixed')) && ((a = r.offsetLeft), (l = r.offsetTop))
    }
    return { width: s, height: i, x: a, y: l }
  }
  function D3(e, t) {
    const n = To(e, !0, t === 'fixed'),
      o = n.top + e.clientTop,
      r = n.left + e.clientLeft,
      s = Nn(e) ? Mr(e) : In(1),
      i = e.clientWidth * s.x,
      a = e.clientHeight * s.y,
      l = r * s.x,
      c = o * s.y
    return { width: i, height: a, x: l, y: c }
  }
  function n0(e, t, n) {
    let o
    if (t === 'viewport') o = F3(e, n)
    else if (t === 'document') o = T3(kn(e))
    else if (fn(t)) o = D3(t, n)
    else {
      const r = e0(e)
      o = { x: t.x - r.x, y: t.y - r.y, width: t.width, height: t.height }
    }
    return yl(o)
  }
  function o0(e, t) {
    const n = to(e)
    return n === t || !fn(n) || Nr(n) ? !1 : An(n).position === 'fixed' || o0(n, t)
  }
  function z3(e, t) {
    const n = t.get(e)
    if (n) return n
    let o = Qs(e, [], !1).filter(a => fn(a) && kr(a) !== 'body'),
      r = null
    const s = An(e).position === 'fixed'
    let i = s ? to(e) : e
    for (; fn(i) && !Nr(i); ) {
      const a = An(i),
        l = fd(i)
      !l && a.position === 'fixed' && (r = null), (s ? !l && !r : (!l && a.position === 'static' && !!r && ['absolute', 'fixed'].includes(r.position)) || (zs(i) && !l && o0(e, i))) ? (o = o.filter(u => u !== i)) : (r = a), (i = to(i))
    }
    return t.set(e, o), o
  }
  function Q3(e) {
    let { element: t, boundary: n, rootBoundary: o, strategy: r } = e
    const i = [...(n === 'clippingAncestors' ? (vl(t) ? [] : z3(t, this._c)) : [].concat(n)), o],
      a = i[0],
      l = i.reduce((c, u) => {
        const d = n0(t, u, r)
        return (c.top = Po(d.top, c.top)), (c.right = fl(d.right, c.right)), (c.bottom = fl(d.bottom, c.bottom)), (c.left = Po(d.left, c.left)), c
      }, n0(t, a, r))
    return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top }
  }
  function R3(e) {
    const { width: t, height: n } = $m(e)
    return { width: t, height: n }
  }
  function O3(e, t, n) {
    const o = Nn(t),
      r = kn(t),
      s = n === 'fixed',
      i = To(e, !0, s, t)
    let a = { scrollLeft: 0, scrollTop: 0 }
    const l = In(0)
    if (o || (!o && !s))
      if (((kr(t) !== 'body' || zs(r)) && (a = xl(t)), o)) {
        const f = To(t, !0, s, t)
        ;(l.x = f.x + t.clientLeft), (l.y = f.y + t.clientTop)
      } else r && (l.x = gd(r))
    const c = r && !o && !s ? t0(r, a) : In(0),
      u = i.left + a.scrollLeft - l.x - c.x,
      d = i.top + a.scrollTop - l.y - c.y
    return { x: u, y: d, width: i.width, height: i.height }
  }
  function md(e) {
    return An(e).position === 'static'
  }
  function r0(e, t) {
    if (!Nn(e) || An(e).position === 'fixed') return null
    if (t) return t(e)
    let n = e.offsetParent
    return kn(e) === n && (n = n.ownerDocument.body), n
  }
  function s0(e, t) {
    const n = Gt(e)
    if (vl(e)) return n
    if (!Nn(e)) {
      let r = to(e)
      for (; r && !Nr(r); ) {
        if (fn(r) && !md(r)) return r
        r = to(r)
      }
      return n
    }
    let o = r0(e, t)
    for (; o && I3(o) && md(o); ) o = r0(o, t)
    return o && Nr(o) && md(o) && !fd(o) ? n : o || k3(e) || n
  }
  const j3 = async function (e) {
    const t = this.getOffsetParent || s0,
      n = this.getDimensions,
      o = await n(e.floating)
    return { reference: O3(e.reference, await t(e.floating), e.strategy), floating: { x: 0, y: 0, width: o.width, height: o.height } }
  }
  function W3(e) {
    return An(e).direction === 'rtl'
  }
  const G3 = { convertOffsetParentRelativeRectToViewportRelativeRect: P3, getDocumentElement: kn, getClippingRect: Q3, getOffsetParent: s0, getElementRects: j3, getClientRects: L3, getDimensions: R3, getScale: Mr, isElement: fn, isRTL: W3 }
  function V3(e, t) {
    let n = null,
      o
    const r = kn(e)
    function s() {
      var a
      clearTimeout(o), (a = n) == null || a.disconnect(), (n = null)
    }
    function i(a, l) {
      a === void 0 && (a = !1), l === void 0 && (l = 1), s()
      const { left: c, top: u, width: d, height: f } = e.getBoundingClientRect()
      if ((a || t(), !d || !f)) return
      const A = pl(u),
        h = pl(r.clientWidth - (c + d)),
        g = pl(r.clientHeight - (u + f)),
        x = pl(c),
        v = { rootMargin: -A + 'px ' + -h + 'px ' + -g + 'px ' + -x + 'px', threshold: Po(0, fl(1, l)) || 1 }
      let y = !0
      function b(w) {
        const k = w[0].intersectionRatio
        if (k !== l) {
          if (!y) return i()
          k
            ? i(!1, k)
            : (o = setTimeout(() => {
                i(!1, 1e-7)
              }, 1e3))
        }
        y = !1
      }
      try {
        n = new IntersectionObserver(b, { ...v, root: r.ownerDocument })
      } catch {
        n = new IntersectionObserver(b, v)
      }
      n.observe(e)
    }
    return i(!0), s
  }
  function i0(e, t, n, o) {
    o === void 0 && (o = {})
    const { ancestorScroll: r = !0, ancestorResize: s = !0, elementResize: i = typeof ResizeObserver == 'function', layoutShift: a = typeof IntersectionObserver == 'function', animationFrame: l = !1 } = o,
      c = hd(e),
      u = r || s ? [...(c ? Qs(c) : []), ...Qs(t)] : []
    u.forEach(m => {
      r && m.addEventListener('scroll', n, { passive: !0 }), s && m.addEventListener('resize', n)
    })
    const d = c && a ? V3(c, n) : null
    let f = -1,
      A = null
    i &&
      ((A = new ResizeObserver(m => {
        let [v] = m
        v &&
          v.target === c &&
          A &&
          (A.unobserve(t),
          cancelAnimationFrame(f),
          (f = requestAnimationFrame(() => {
            var y
            ;(y = A) == null || y.observe(t)
          }))),
          n()
      })),
      c && !l && A.observe(c),
      A.observe(t))
    let h,
      g = l ? To(e) : null
    l && x()
    function x() {
      const m = To(e)
      g && (m.x !== g.x || m.y !== g.y || m.width !== g.width || m.height !== g.height) && n(), (g = m), (h = requestAnimationFrame(x))
    }
    return (
      n(),
      () => {
        var m
        u.forEach(v => {
          r && v.removeEventListener('scroll', n), s && v.removeEventListener('resize', n)
        }),
          d == null || d(),
          (m = A) == null || m.disconnect(),
          (A = null),
          l && cancelAnimationFrame(h)
      }
    )
  }
  const X3 = S3,
    Y3 = B3,
    H3 = w3,
    U3 = (e, t, n) => {
      const o = new Map(),
        r = { platform: G3, ...n },
        s = { ...r.platform, _c: o }
      return C3(e, t, { ...r, platform: s })
    }
  var Cl = typeof document < 'u' ? C.useLayoutEffect : C.useEffect
  function wl(e, t) {
    if (e === t) return !0
    if (typeof e != typeof t) return !1
    if (typeof e == 'function' && e.toString() === t.toString()) return !0
    let n, o, r
    if (e && t && typeof e == 'object') {
      if (Array.isArray(e)) {
        if (((n = e.length), n !== t.length)) return !1
        for (o = n; o-- !== 0; ) if (!wl(e[o], t[o])) return !1
        return !0
      }
      if (((r = Object.keys(e)), (n = r.length), n !== Object.keys(t).length)) return !1
      for (o = n; o-- !== 0; ) if (!{}.hasOwnProperty.call(t, r[o])) return !1
      for (o = n; o-- !== 0; ) {
        const s = r[o]
        if (!(s === '_owner' && e.$$typeof) && !wl(e[s], t[s])) return !1
      }
      return !0
    }
    return e !== e && t !== t
  }
  function a0(e) {
    return typeof window > 'u' ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
  }
  function l0(e, t) {
    const n = a0(e)
    return Math.round(t * n) / n
  }
  function yd(e) {
    const t = N.useRef(e)
    return (
      Cl(() => {
        t.current = e
      }),
      t
    )
  }
  function K3(e) {
    e === void 0 && (e = {})
    const { placement: t = 'bottom', strategy: n = 'absolute', middleware: o = [], platform: r, elements: { reference: s, floating: i } = {}, transform: a = !0, whileElementsMounted: l, open: c } = e,
      [u, d] = N.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }),
      [f, A] = N.useState(o)
    wl(f, o) || A(o)
    const [h, g] = N.useState(null),
      [x, m] = N.useState(null),
      v = N.useCallback(B => {
        B !== k.current && ((k.current = B), g(B))
      }, []),
      y = N.useCallback(B => {
        B !== E.current && ((E.current = B), m(B))
      }, []),
      b = s || h,
      w = i || x,
      k = N.useRef(null),
      E = N.useRef(null),
      P = N.useRef(u),
      T = l != null,
      F = yd(l),
      D = yd(r),
      Q = yd(c),
      R = N.useCallback(() => {
        if (!k.current || !E.current) return
        const B = { placement: t, strategy: n, middleware: f }
        D.current && (B.platform = D.current),
          U3(k.current, E.current, B).then(O => {
            const W = { ...O, isPositioned: Q.current !== !1 }
            S.current &&
              !wl(P.current, W) &&
              ((P.current = W),
              jl.flushSync(() => {
                d(W)
              }))
          })
      }, [f, t, n, D, Q])
    Cl(() => {
      c === !1 && P.current.isPositioned && ((P.current.isPositioned = !1), d(B => ({ ...B, isPositioned: !1 })))
    }, [c])
    const S = N.useRef(!1)
    Cl(
      () => (
        (S.current = !0),
        () => {
          S.current = !1
        }
      ),
      []
    ),
      Cl(() => {
        if ((b && (k.current = b), w && (E.current = w), b && w)) {
          if (F.current) return F.current(b, w, R)
          R()
        }
      }, [b, w, R, F, T])
    const L = N.useMemo(() => ({ reference: k, floating: E, setReference: v, setFloating: y }), [v, y]),
      I = N.useMemo(() => ({ reference: b, floating: w }), [b, w]),
      z = N.useMemo(() => {
        const B = { position: n, left: 0, top: 0 }
        if (!I.floating) return B
        const O = l0(I.floating, u.x),
          W = l0(I.floating, u.y)
        return a ? { ...B, transform: 'translate(' + O + 'px, ' + W + 'px)', ...(a0(I.floating) >= 1.5 && { willChange: 'transform' }) } : { position: n, left: O, top: W }
      }, [n, a, I.floating, u.x, u.y])
    return N.useMemo(() => ({ ...u, update: R, refs: L, elements: I, floatingStyles: z }), [u, R, L, I, z])
  }
  const c0 = (e, t) => ({ ...X3(e), options: [e, t] }),
    q3 = (e, t) => ({ ...Y3(e), options: [e, t] }),
    Z3 = (e, t) => ({ ...H3(e), options: [e, t] })
  function J3(e) {
    return typeof e == 'function' ? e() : e
  }
  const _3 = N.forwardRef(function (t, n) {
      const { children: o, container: r, disablePortal: s = !1 } = t,
        [i, a] = N.useState(null),
        l = dl(i3(o), n)
      if (
        (id(() => {
          s || a(J3(r) || document.body)
        }, [r, s]),
        id(() => {
          if (i && !s)
            return (
              sd(n, i),
              () => {
                sd(n, null)
              }
            )
        }, [n, i, s]),
        s)
      ) {
        if (N.isValidElement(o)) {
          const c = { ref: l }
          return N.cloneElement(o, c)
        }
        return p.jsx(N.Fragment, { children: o })
      }
      return p.jsx(N.Fragment, { children: i && jl.createPortal(o, i) })
    }),
    u0 = 'Popup'
  function $3(e) {
    return ld(u0, e)
  }
  Gm(u0, ['root', 'open'])
  const eD = N.createContext(null)
  function tD(e) {
    const [t, n] = N.useState(!0),
      o = N.useRef(!1),
      r = N.useRef(0),
      [s, i] = N.useState(!1),
      a = N.useRef(e)
    N.useEffect(() => {
      !e && r.current > 0 && a.current !== e && ((o.current = !0), n(!1)), (a.current = e)
    }, [e])
    const l = N.useCallback(() => {
        ;(o.current = !1), n(!0)
      }, []),
      c = N.useCallback(
        () => (
          (r.current += 1),
          i(!0),
          () => {
            ;(r.current -= 1), r.current === 0 && i(!1)
          }
        ),
        []
      )
    let u
    return s ? (e ? (u = !1) : (u = !o.current && t)) : (u = !e), { contextValue: N.useMemo(() => ({ requestedEnter: e, onExited: l, registerTransition: c, hasExited: u }), [l, e, c, u]), hasExited: u }
  }
  const nD = N.createContext(null)
  function oD(e) {
    const { open: t } = e
    return jm({ root: ['root', t && 'open'] }, zm($3))
  }
  function rD(e) {
    return typeof e == 'function' ? e() : e
  }
  const sD = N.forwardRef(function (t, n) {
      const { anchor: o, children: r, container: s, disablePortal: i = !1, keepMounted: a = !1, middleware: l, offset: c = 0, open: u = !1, placement: d = 'bottom', slotProps: f = {}, slots: A = {}, strategy: h = 'absolute', ...g } = t,
        { refs: x, elements: m, floatingStyles: v, update: y, placement: b } = K3({ elements: { reference: rD(o) }, open: u, middleware: l ?? [c0(c ?? 0), Z3(), q3()], placement: d, strategy: h, whileElementsMounted: a ? void 0 : i0 }),
        w = dl(x.setFloating, n)
      id(() => {
        if (a && u && m.reference && m.floating) return i0(m.reference, m.floating, y)
      }, [a, u, m, y])
      const k = { ...t, disablePortal: i, keepMounted: a, offset: c0, open: u, placement: d, finalPlacement: b, strategy: h },
        { contextValue: E, hasExited: P } = tD(u),
        T = a && P ? 'hidden' : void 0,
        F = oD(k),
        D = (A == null ? void 0 : A.root) ?? 'div',
        Q = Ds({ elementType: D, externalSlotProps: f.root, externalForwardedProps: g, ownerState: k, className: F.root, additionalProps: { ref: w, role: 'tooltip', style: { ...v, visibility: T } } }),
        R = N.useMemo(() => ({ placement: b }), [b])
      return a || !P ? p.jsx(_3, { disablePortal: i, container: s, children: p.jsx(nD.Provider, { value: R, children: p.jsx(eD.Provider, { value: E, children: p.jsx(D, { ...Q, children: r }) }) }) }) : null
    }),
    d0 = 'NumberInput'
  function iD(e) {
    return ld(d0, e)
  }
  const bd = Gm(d0, ['root', 'formControl', 'focused', 'disabled', 'readOnly', 'error', 'input', 'incrementButton', 'decrementButton', 'adornedStart', 'adornedEnd']),
    bt = { clamp: 'numberInput:clamp', inputChange: 'numberInput:inputChange', increment: 'numberInput:increment', decrement: 'numberInput:decrement', decrementToMin: 'numberInput:decrementToMin', incrementToMax: 'numberInput:incrementToMax', resetInputValue: 'numberInput:resetInputValue' }
  function aD(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER, o = NaN) {
    if (Number.isNaN(o)) return ad(e, t, n)
    const r = o || 1,
      s = e % r,
      i = Math.sign(s)
    return Math.abs(s) > r / 2 ? ad(e + i * (r - Math.abs(s)), t, n) : ad(e - i * Math.abs(s), t, n)
  }
  function Rs(e) {
    return typeof e == 'number' && !Number.isNaN(e) && Number.isFinite(e)
  }
  function f0(e, t) {
    const { min: n, max: o, step: r } = t,
      s = e === null ? null : aD(e, n, o, r),
      i = s === null ? '' : String(s)
    return { value: s, inputValue: i }
  }
  function lD(e, t, n, o) {
    const { value: r } = e,
      { step: s = 1, min: i, max: a } = t
    return Rs(r) ? { up: r + (s ?? 1) * o, down: r - (s ?? 1) * o }[n] : { up: i ?? 1, down: a ?? -1 }[n]
  }
  function cD(e, t, n) {
    const { getInputValueAsString: o } = t,
      r = o(n),
      s = r === '' || r === '-' ? null : parseInt(r, 10),
      i = f0(s, t)
    return { ...e, ...i }
  }
  function uD(e, t, n) {
    const { getInputValueAsString: o } = t,
      r = o(n)
    return r.match(/^-?\d+?$/) || r === '' || r === '-' ? { ...e, inputValue: r } : e
  }
  function A0(e, t, n, o) {
    const r = n ? t.shiftMultiplier : 1,
      s = lD(e, t, o, r),
      i = f0(s, t)
    return { ...e, ...i }
  }
  function p0(e, t, n) {
    const o = t[n]
    return Rs(o) ? { ...e, value: o, inputValue: String(o) } : e
  }
  function dD(e, t) {
    const { type: n, context: o } = t
    switch (n) {
      case bt.clamp:
        return cD(e, o, t.inputValue)
      case bt.inputChange:
        return uD(e, o, t.inputValue)
      case bt.increment:
        return A0(e, o, t.applyMultiplier, 'up')
      case bt.decrement:
        return A0(e, o, t.applyMultiplier, 'down')
      case bt.incrementToMax:
        return p0(e, o, 'max')
      case bt.decrementToMin:
        return p0(e, o, 'min')
      case bt.resetInputValue:
        return { ...e, inputValue: String(e.value) }
      default:
        return e
    }
  }
  const fD = [...['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown'], 'Home', 'End']
  function AD(e) {
    return String(e && e.trim())
  }
  function pD(e) {
    const { min: t, max: n, step: o, shiftMultiplier: r = 10, defaultValue: s, disabled: i = !1, error: a = !1, onBlur: l, onInputChange: c, onFocus: u, onChange: d, required: f = !1, readOnly: A = !1, value: h, inputRef: g, inputId: x, componentName: m = 'useNumberInput' } = e,
      v = A3(),
      { current: y } = N.useRef(h != null),
      b = N.useCallback(H => {}, []),
      w = N.useRef(null),
      k = dl(w, g, b),
      E = r3(x),
      [P, T] = N.useState(!1),
      F = N.useCallback(
        (H, U, te, be) => {
          if (U === 'value' && typeof te != 'string')
            switch (be) {
              case 'numberInput:clamp':
                d == null || d(H, te)
                break
              case 'numberInput:increment':
              case 'numberInput:decrement':
              case 'numberInput:incrementToMax':
              case 'numberInput:decrementToMin':
                d == null || d(H, te)
                break
            }
        },
        [d]
      ),
      D = N.useMemo(() => ({ min: t, max: n, step: o, shiftMultiplier: r, getInputValueAsString: AD }), [t, n, o, r]),
      Q = h ?? s ?? null,
      R = { value: Q, inputValue: Q ? String(Q) : '' },
      S = N.useMemo(() => ({ value: h }), [h]),
      [L, I] = d3({ reducer: dD, controlledProps: S, initialState: R, onStateChange: F, actionContext: N.useMemo(() => D, [D]), componentName: m }),
      { value: z, inputValue: B } = L
    N.useEffect(() => {
      !v && i && P && (T(!1), l == null || l())
    }, [v, i, P, l]),
      N.useEffect(() => {
        y && Rs(z) && I({ type: bt.resetInputValue })
      }, [z, I, y])
    const O = H => U => {
        var te, be
        ;(te = H.onFocus) == null || te.call(H, U), !(U.defaultMuiPrevented || U.defaultPrevented) && (v && v.onFocus && ((be = v == null ? void 0 : v.onFocus) == null || be.call(v)), T(!0))
      },
      W = H => U => {
        var te, be
        if (!y && U.target === null) throw new Error(n3(17))
        ;(te = v == null ? void 0 : v.onChange) == null || te.call(v, U), (be = H.onInputChange) == null || be.call(H, U), !(U.defaultMuiPrevented || U.defaultPrevented) && I({ type: bt.inputChange, event: U, inputValue: U.currentTarget.value })
      },
      K = H => U => {
        var te
        v == null || v.onBlur(), (te = H.onBlur) == null || te.call(H, U), !(U.defaultMuiPrevented || U.defaultPrevented) && (I({ type: bt.clamp, event: U, inputValue: U.currentTarget.value }), T(!1))
      },
      Z = H => U => {
        var te
        ;(te = H.onClick) == null || te.call(H, U), !(U.defaultMuiPrevented || U.defaultPrevented) && w.current && U.currentTarget === U.target && w.current.focus()
      },
      oe = H => U => {
        const te = !!U.shiftKey,
          be = { up: bt.increment, down: bt.decrement }[H]
        I({ type: be, event: U, applyMultiplier: te })
      },
      V = H => U => {
        var te
        if (((te = H.onKeyDown) == null || te.call(H, U), !(U.defaultMuiPrevented || U.defaultPrevented)))
          switch ((fD.includes(U.key) && U.preventDefault(), U.key)) {
            case 'ArrowUp':
              I({ type: bt.increment, event: U, applyMultiplier: !!U.shiftKey })
              break
            case 'ArrowDown':
              I({ type: bt.decrement, event: U, applyMultiplier: !!U.shiftKey })
              break
            case 'PageUp':
              I({ type: bt.increment, event: U, applyMultiplier: !0 })
              break
            case 'PageDown':
              I({ type: bt.decrement, event: U, applyMultiplier: !0 })
              break
            case 'Home':
              I({ type: bt.incrementToMax, event: U })
              break
            case 'End':
              I({ type: bt.decrementToMin, event: U })
              break
          }
      },
      q = (H = {}) => {
        const te = { ...ul(e, ['onBlur', 'onInputChange', 'onFocus', 'onChange']), ...ul(H) }
        return { ...H, ...te, onClick: Z(te) }
      },
      ee = (H = {}) => {
        const te = { ...{ onBlur: l, onFocus: u, onChange: c }, ...ul(H, ['onClick']) },
          be = { ...te, onFocus: O(te), onChange: W({ ...te, onInputChange: te.onChange }), onBlur: K(te), onKeyDown: V(te) },
          Ne = (P ? B : z) ?? ''
        return (
          delete H.onInputChange,
          { type: 'text', id: E, 'aria-invalid': a || void 0, defaultValue: void 0, value: Ne, 'aria-valuenow': Ne, 'aria-valuetext': String(Ne), 'aria-valuemin': t, 'aria-valuemax': n, autoComplete: 'off', autoCorrect: 'off', spellCheck: 'false', required: f, readOnly: A, 'aria-disabled': i, disabled: i, ...H, ref: k, ...be }
        )
      },
      re = H => {
        H.preventDefault(), w.current && w.current.focus()
      },
      J = { 'aria-controls': E, tabIndex: -1 },
      ie = i || (Rs(z) ? z >= (n ?? Number.MAX_SAFE_INTEGER) : !1),
      Ae = (H = {}) => ({ ...H, ...J, disabled: ie, 'aria-disabled': ie, onMouseDown: re, onClick: oe('up') }),
      ae = i || (Rs(z) ? z <= (t ?? Number.MIN_SAFE_INTEGER) : !1)
    return {
      disabled: i,
      error: a,
      focused: P,
      formControlContext: v,
      getInputProps: ee,
      getIncrementButtonProps: Ae,
      getDecrementButtonProps: (H = {}) => ({ ...H, ...J, disabled: ae, 'aria-disabled': ae, onMouseDown: re, onClick: oe('down') }),
      getRootProps: q,
      required: f,
      value: z,
      inputValue: B,
      isIncrementDisabled: ie,
      isDecrementDisabled: ae,
    }
  }
  const hD = e => {
      const { disabled: t, error: n, focused: o, readOnly: r, formControlContext: s, isIncrementDisabled: i, isDecrementDisabled: a, startAdornment: l, endAdornment: c } = e
      return jm({ root: ['root', t && 'disabled', n && 'error', o && 'focused', r && 'readOnly', !!s && 'formControl', !!l && 'adornedStart', !!c && 'adornedEnd'], input: ['input', t && 'disabled', r && 'readOnly'], incrementButton: ['incrementButton', i && 'disabled'], decrementButton: ['decrementButton', a && 'disabled'] }, zm(iD))
    },
    gD = N.forwardRef(function (t, n) {
      const { className: o, defaultValue: r, disabled: s, endAdornment: i, error: a, id: l, max: c, min: u, onBlur: d, onInputChange: f, onFocus: A, onChange: h, placeholder: g, required: x, readOnly: m = !1, shiftMultiplier: v, startAdornment: y, step: b, value: w, slotProps: k = {}, slots: E = {}, ...P } = t,
        {
          getRootProps: T,
          getInputProps: F,
          getIncrementButtonProps: D,
          getDecrementButtonProps: Q,
          focused: R,
          error: S,
          disabled: L,
          formControlContext: I,
          isIncrementDisabled: z,
          isDecrementDisabled: B,
        } = pD({ min: u, max: c, step: b, shiftMultiplier: v, defaultValue: r, disabled: s, error: a, onFocus: A, onInputChange: f, onBlur: d, onChange: h, required: x, readOnly: m, value: w, inputId: l, componentName: 'NumberInput' }),
        O = { ...t, disabled: L, error: S, focused: R, readOnly: m, formControlContext: I, isIncrementDisabled: z, isDecrementDisabled: B },
        W = hD(O),
        K = { placeholder: g },
        Z = E.root ?? 'div',
        oe = Ds({ elementType: Z, getSlotProps: T, externalSlotProps: k.root, externalForwardedProps: P, additionalProps: { ref: n }, ownerState: O, className: [W.root, o] }),
        V = E.input ?? 'input',
        q = Ds({ elementType: V, getSlotProps: Ae => F({ ...K, ...Ae }), externalSlotProps: k.input, ownerState: O, className: W.input }),
        ee = E.incrementButton ?? 'button',
        re = Ds({ elementType: ee, getSlotProps: D, externalSlotProps: k.incrementButton, ownerState: O, className: W.incrementButton }),
        J = E.decrementButton ?? 'button',
        ie = Ds({ elementType: J, getSlotProps: Q, externalSlotProps: k.decrementButton, ownerState: O, className: W.decrementButton })
      return p.jsxs(Z, { ...oe, children: [p.jsx(J, { ...ie }), p.jsx(ee, { ...re }), y, p.jsx(V, { ...q }), i] })
    }),
    mD = e => p.jsx(sD, { ...e }),
    vd = { 50: '#F3F6F9', 100: '#E5EAF2', 200: '#DAE2ED', 300: '#C7D0DD', 400: '#B0B8C4', 500: '#9DA8B7', 600: '#6B7A90', 700: '#434D5B', 800: '#303740', 900: '#1C2025' },
    yD = j('div')(
      ({ theme: e }) => `
  width: max-content;
  padding: 12px 16px;
  margin: 8px;
  border-radius: 8px;
  border: 1px solid ${e.palette.mode === 'dark' ? vd[700] : vd[200]};
  background-color: ${e.palette.mode === 'dark' ? vd[900] : '#fff'};
  box-shadow: ${e.palette.mode === 'dark' ? '0px 4px 8px rgb(0 0 0 / 0.7)' : '0px 4px 8px rgb(0 0 0 / 0.1)'};
  font-family: 'IBM Plex Sans', sans-serif;
  font-size: 0.875rem;
  z-index: 1;
`
    ),
    bD = e => p.jsx(yD, { ...e }),
    Os = j('div')`
  display: flex;
  gap: 8px;
`,
    js = j('span')`
  font-weight: 600;
  font-size: 13px;
`,
    Ws = j('span')`
  font-size: 13px;
`,
    vD = e => e,
    xD = 12,
    Nt = e =>
      vD(t => {
        const n = oo(),
          [o, r, s, i] = sl(),
          [a, l] = C.useState([]),
          [c, u] = C.useState(null),
          { changesEnabled: d, nodes: f, edges: A } = n,
          h = IF(),
          g = PF(t.id, { rotatable: d }),
          x = TF(t.id),
          m = `popup-${t.id}`,
          v = () => {
            s()
          },
          y = () => {
            i()
          },
          b = t,
          w = !Sl(b),
          k = Ar(b),
          E = F0(b),
          P = D0(b),
          T = fO(b, f, A),
          F = z0(b),
          { data: D, ...Q } = t,
          R = C.useMemo(() => ({ ...D, label: w ? AO(D.label, xD) : D.label }), [t])
        return p.jsxs(p.Fragment, {
          children: [
            p.jsx(e, { ...Q, data: R, ...h, ...g, parentRotation: x, showPopup: o, setShowPopup: r, popupAnchor: c, setPopupAnchor: u, handleNodeBaseHover: v, handleNodeBaseMouseLeave: y, nodeColor: F, customPopupPoints: a, setCustomPopupPoints: l, flow: n }),
            p.jsx(mD, {
              id: m,
              anchor: c,
              open: o,
              placement: 'left',
              children: p.jsxs(bD, {
                children: [
                  w && p.jsxs(Os, { children: [p.jsx(js, { children: 'Name:' }), p.jsx(Ws, { children: k })] }),
                  p.jsxs(Os, { children: [p.jsx(js, { children: 'Class:' }), p.jsx(Ws, { children: HR[E] })] }),
                  P && p.jsxs(Os, { children: [p.jsx(js, { children: 'Class Code:' }), p.jsx(Ws, { children: wd[P] })] }),
                  T && p.jsxs(Os, { children: [p.jsx(js, { children: 'Closest Parent:' }), p.jsx(Ws, { children: Ar(T) })] }),
                  a.map(S => p.jsxs(Os, { children: [p.jsx(js, { children: S.label }), p.jsx(Ws, { children: S.value })] }, S.value)),
                ],
              }),
            }),
          ],
        })
      }),
    CD = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i)
      return p.jsxs(mT, { ref: l, rotation: n, onMouseEnter: r, onMouseLeave: s, ...a, children: [p.jsx(Oe, { type: 'target', position: t }), p.jsx(gT, { children: e.label }), p.jsx(Oe, { type: 'source', position: o })] })
    }),
    wD = C.memo(CD),
    ED = j('div')`
  padding: 4px 4px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
`,
    SD = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: 100%;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`,
    BD = Nt(({ data: e, parentRotation: t, handleNodeBaseHover: n, handleNodeBaseMouseLeave: o, setPopupAnchor: r, nodeColor: s }) => {
      const i = Et(r)
      return p.jsx(SD, { ref: i, rotation: t ?? 0, onMouseEnter: n, onMouseLeave: o, ...s, children: p.jsx(ED, { children: e.label }) })
    }),
    ID = C.memo(BD),
    kD = j('div')`
  position: relative;
  padding: 16px 48px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
`,
    ND = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: 100%;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const MD = j('p')`
  margin: 0;
`,
    PD = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        { src: c, alt: u, width: d, height: f } = e.image,
        A = e.code
      return p.jsxs(ND, { ref: l, rotation: n, onMouseEnter: r, onMouseLeave: s, ...a, children: [p.jsx(Oe, { type: 'target', position: t }), p.jsxs(kD, { children: [p.jsx('img', { src: c, alt: u, width: d, height: f }), p.jsx(MD, { children: A })] }), p.jsx(Oe, { type: 'source', position: o })] })
    }),
    LD = C.memo(PD),
    TD = j('div')`
  position: relative;
  padding: 4px 4px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
`,
    FD = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: 100%;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('p')`
  margin: 0;
  position: absolute;
  left: 4px;
  bottom: 2px;
`
  const DD = Nt(({ data: e, parentRotation: t, nodeColor: n }) => {
      const { src: o, alt: r, width: s, height: i } = e.image
      return p.jsx(FD, { rotation: t ?? 0, ...n, children: p.jsx(TD, { children: p.jsx('img', { src: o, alt: r, width: s, height: i }) }) })
    }),
    zD = C.memo(DD),
    $t = e => p.jsx('img', { ...e }),
    QD = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    RD = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-top {
    left: ${Ye}px;
  }

  .react-flow__handle-bottom {
    left: ${Ye}px;
  }
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const OD = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    jD = j('div')`
  position: absolute;
  left: ${jn};
  top: 50%;
  transform: translateY(-50%);
`,
    WD = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    GD = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    VD = Wt['SWITCH'],
    { src: XD, alt: YD, width: HD, height: UD } = VD,
    KD = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.label,
        u = e.code
      return p.jsxs(RD, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [p.jsx(Oe, { type: 'target', position: t }), p.jsxs(QD, { children: [p.jsx(OD, { src: XD, alt: YD, width: HD, height: UD }), p.jsxs(jD, { children: [p.jsx(WD, { children: c }), p.jsx(GD, { children: u })] })] }), p.jsx(Oe, { type: 'source', position: o })],
      })
    }),
    qD = C.memo(KD),
    ZD = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    JD = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-top {
    left: ${Ye}px;
  }

  .react-flow__handle-bottom {
    left: ${Ye}px;
  }
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const _D = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    $D = j('div')`
  position: absolute;
  left: ${jn - 12}px;
  top: 50%;
  transform: translateY(-50%);
`,
    ez = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    tz = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    nz = Wt['CAPACITOR'],
    { src: oz, alt: rz, width: sz, height: iz } = nz,
    az = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.label,
        u = e.code
      return p.jsxs(JD, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [p.jsx(Oe, { type: 'target', position: t }), p.jsxs(ZD, { children: [p.jsx(_D, { src: oz, alt: rz, width: sz, height: iz }), p.jsxs($D, { children: [p.jsx(ez, { children: c }), p.jsx(tz, { children: u })] })] }), p.jsx(Oe, { type: 'source', position: o })],
      })
    }),
    lz = C.memo(az),
    cz = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t + 20}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    uz = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-top {
    left: ${Ye}px;
  }

  .react-flow__handle-bottom {
    left: ${Ye}px;
  }
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const dz = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    fz = j('div')`
  position: absolute;
  left: ${jn - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
    Az = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    pz = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    hz = Wt['TRANSFORMER'],
    { src: gz, alt: mz, width: yz, height: bz } = hz,
    vz = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.label,
        u = e.code
      return p.jsxs(uz, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [p.jsx(Oe, { type: 'target', position: t }), p.jsxs(cz, { children: [p.jsx(dz, { src: gz, alt: mz, width: yz, height: bz }), p.jsxs(fz, { children: [p.jsx(Az, { children: c }), p.jsx(pz, { children: u })] })] }), p.jsx(Oe, { type: 'source', position: o })],
      })
    }),
    xz = C.memo(vz),
    Cz = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t + 20}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    wz = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-bottom {
    left: ${Ye}px;
  }
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const Ez = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    Sz = j('div')`
  position: absolute;
  left: ${jn - 12}px;
  top: 50%;
  transform: translateY(-50%);
`,
    Bz = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    Iz = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    kz = st({ left: 118.6, top: -2 }),
    Nz = st({ left: 145.6, top: -2 }),
    Mz = Wt['TRANSFER_SWITCH'],
    { src: Pz, alt: Lz, width: Tz, height: Fz } = Mz,
    Dz = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a, id: l }) => {
      const c = Et(i),
        u = e.label,
        d = e.code
      return p.jsxs(wz, {
        ref: c,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [
          p.jsx(Oe, { type: 'target', position: t, style: kz, id: `${l}-left` }),
          p.jsx(Oe, { type: 'target', position: t, style: Nz, id: `${l}-right` }),
          p.jsxs(Cz, { children: [p.jsx(Ez, { src: Pz, alt: Lz, width: Tz, height: Fz }), p.jsxs(Sz, { children: [p.jsx(Bz, { children: u }), p.jsx(Iz, { children: d })] })] }),
          p.jsx(Oe, { type: 'source', position: o }),
        ],
      })
    }),
    zz = C.memo(Dz),
    h0 = j('div')`
  position: relative;
  height: 60px;
  width: 100%;
  min-width: ${_t}px;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    g0 = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const m0 = j('div')`
  position: absolute;
  top: 4px;
  left: 6px;
`,
    y0 = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    b0 = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    v0 = j('div')`
  width: 100%;
  height: 4px;
  background: #000;
`,
    Qz = st({ top: 'calc(50% - 4px)', zIndex: 1e5 }),
    Rz = st({ opacity: 0, pointerEvents: 'none', left: 0, top: 23 }),
    Wn = e => {
      const { style: t, ...n } = e
      return p.jsx(Oe, { ...n, style: { ...Rz, ...t } })
    },
    Oz = _t,
    x0 = 1,
    jz = 40,
    Wz = (e, { baseWidthPx: t = Oz } = {}) =>
      e <= x0
        ? t
        : Array.from({ length: e - x0 })
            .fill(jz)
            .reduce((n, o) => n + o, t),
    Gz = Nt(e => {
      const { data: t, rotation: n, handleNodeBaseHover: o, handleNodeBaseMouseLeave: r, setPopupAnchor: s, nodeColor: i, sourceHandlePosition: a, setCustomPopupPoints: l, flow: c, id: u } = e,
        [d] = C.useState(_t),
        { nodes: f } = c,
        A = C.useMemo(() => su({ id: u }, f), [f, u]),
        h = C.useMemo(() => A.filter(E => E.data.archetype === He.lineSide), [A]),
        g = C.useMemo(() => A.filter(E => E.data.archetype === He.loadSide), [A]),
        x = Math.max(h.length, g.length),
        m = Wz(x, { baseWidthPx: d }),
        v = Et(s),
        y = t.label,
        b = t.code,
        w = t.electricalPanelType
      return (
        C.useEffect(() => {
          l([{ label: 'Panel Type: ', value: w }])
        }, [w]),
        w === Do.MLO
          ? p.jsxs(g0, {
              ref: v,
              rotation: n,
              onMouseEnter: o,
              onMouseLeave: r,
              ...i,
              children: [p.jsx(Oe, { type: 'target', position: ye.Top, style: Qz }), p.jsxs(h0, { style: { width: m }, children: [p.jsxs(m0, { children: [p.jsx(y0, { children: y }), p.jsx(b0, { children: b })] }), p.jsx(v0, {})] }), p.jsx(Wn, { position: a, type: 'source' })],
            })
          : p.jsxs(g0, {
              ref: v,
              rotation: n,
              onMouseEnter: o,
              onMouseLeave: r,
              ...i,
              children: [p.jsx(Wn, { position: ye.Top, type: 'target', style: st({ left: '50%', transform: 'translateX(-50%)' }) }), p.jsxs(h0, { style: { width: m }, children: [p.jsxs(m0, { children: [p.jsx(y0, { children: y }), p.jsx(b0, { children: b })] }), p.jsx(v0, {})] }), p.jsx(Wn, { position: a, type: 'source' })],
            })
      )
    }),
    Vz = C.memo(Gz),
    Xz = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t + 12}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    Yz = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-top {
    left: ${Ye}px;
  }

  .react-flow__handle-bottom {
    left: ${Ye}px;
  }
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const Hz = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    Uz = j('div')`
  position: absolute;
  left: ${jn - 8}px;
  top: 50%;
  transform: translateY(-50%);
`,
    Kz = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    qz = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    Zz = Wt['MISC'],
    { src: Jz, alt: _z, width: $z, height: eQ } = Zz,
    tQ = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.label,
        u = e.code
      return p.jsxs(Yz, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [p.jsx(Oe, { type: 'target', position: t }), p.jsxs(Xz, { children: [p.jsx(Hz, { src: Jz, alt: _z, width: $z, height: eQ }), p.jsxs(Uz, { children: [p.jsx(Kz, { children: c }), p.jsx(qz, { children: u })] })] }), p.jsx(Oe, { type: 'source', position: o })],
      })
    }),
    nQ = C.memo(tQ),
    oQ = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t + 32}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    rQ = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const sQ = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    iQ = j('div')`
  position: absolute;
  left: ${jn - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
    aQ = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    lQ = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    cQ = st({ left: Ye, top: -2 }),
    uQ = st({ left: Ye, top: 55 }),
    dQ = Wt['MOTOR'],
    { src: fQ, alt: AQ, width: pQ, height: hQ } = dQ,
    gQ = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.label,
        u = e.code
      return p.jsxs(rQ, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [p.jsx(Oe, { type: 'target', position: t, style: cQ }), p.jsxs(oQ, { children: [p.jsx(sQ, { src: fQ, alt: AQ, width: pQ, height: hQ }), p.jsxs(iQ, { children: [p.jsx(aQ, { children: c }), p.jsx(lQ, { children: u })] })] }), p.jsx(Oe, { type: 'source', position: o, style: uQ })],
      })
    }),
    mQ = C.memo(gQ),
    yQ = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t + 32}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    bQ = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const vQ = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    xQ = j('div')`
  position: absolute;
  left: ${jn - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
    CQ = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    wQ = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    EQ = st({ left: Ye, top: -2 }),
    SQ = st({ left: Ye, top: 55 }),
    BQ = Wt['GENERATOR'],
    { src: IQ, alt: kQ, width: NQ, height: MQ } = BQ,
    PQ = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.label,
        u = e.code
      return p.jsxs(bQ, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [p.jsx(Oe, { type: 'target', position: t, style: EQ }), p.jsxs(yQ, { children: [p.jsx(vQ, { src: IQ, alt: kQ, width: NQ, height: MQ }), p.jsxs(xQ, { children: [p.jsx(CQ, { children: c }), p.jsx(wQ, { children: u })] })] }), p.jsx(Oe, { type: 'source', position: o, style: SQ })],
      })
    }),
    LQ = C.memo(PQ),
    TQ = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t + 32}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    FQ = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const DQ = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    zQ = j('div')`
  position: absolute;
  left: ${jn - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
    QQ = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    RQ = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    OQ = st({ left: Ye, top: -2 }),
    jQ = st({ left: Ye, top: 55 }),
    WQ = Wt['RELAY'],
    { src: GQ, alt: VQ, width: XQ, height: YQ } = WQ,
    HQ = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.label,
        u = e.code
      return p.jsxs(FQ, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [p.jsx(Oe, { type: 'target', position: t, style: OQ }), p.jsxs(TQ, { children: [p.jsx(DQ, { src: GQ, alt: VQ, width: XQ, height: YQ }), p.jsxs(zQ, { children: [p.jsx(QQ, { children: c }), p.jsx(RQ, { children: u })] })] }), p.jsx(Oe, { type: 'source', position: o, style: jQ })],
      })
    }),
    UQ = C.memo(HQ),
    KQ = j('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${_t + 20}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
    qQ = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const ZQ = j($t)`
  position: absolute;
  left: ${Ye}px;
  transform: translateX(-50%);
`,
    JQ = j('div')`
  position: absolute;
  left: ${jn - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
    _Q = j('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
    $Q = j('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
    eR = st({ left: Ye, top: -2 }),
    tR = st({ left: Ye, top: 55 }),
    nR = Wt['UPS_SYSTEM'],
    { src: oR, alt: rR, width: sR, height: iR } = nR,
    aR = Nt(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.label,
        u = e.code
      return p.jsxs(qQ, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [p.jsx(Oe, { type: 'target', position: t, style: eR }), p.jsxs(KQ, { children: [p.jsx(ZQ, { src: oR, alt: rR, width: sR, height: iR }), p.jsxs(JQ, { children: [p.jsx(_Q, { children: c }), p.jsx($Q, { children: u })] })] }), p.jsx(Oe, { type: 'source', position: o, style: tR })],
      })
    }),
    lR = C.memo(aR),
    xd = Nt,
    cR = j('div')`
  position: relative;
  height: ${Bn}px;
  width: ${Bn}px;
  display: flex;
  justify-content: center;
  align-items: center;
`,
    uR = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const dR = j($t)`
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: ${e => (e.archetype === He.loadSide ? `${Bn}px` : '0')};
`,
    C0 = st({ top: -2 }),
    w0 = st({ top: 55 }),
    fR = j('p')`
  position: absolute;
  top: ${e => (e.lineSide ? '50%' : '164%')};
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8px;
  line-height: 1.14;
  margin: 0;
  min-width: 100px;
`,
    AR = Wt['SUB_SWITCH'],
    { src: pR, alt: hR, width: gR, height: mR } = AR,
    yR = xd(e => {
      const { data: t, targetHandlePosition: n, rotation: o, sourceHandlePosition: r, handleNodeBaseHover: s, handleNodeBaseMouseLeave: i, setPopupAnchor: a, nodeColor: l } = e,
        c = Et(a),
        u = t.archetype,
        d = C.useMemo(() => u === He.lineSide, [u]),
        f = C.useMemo(() => u === He.loadSide, [u]),
        A = rd(t)
      return p.jsxs(uR, {
        ref: c,
        rotation: o,
        onMouseEnter: s,
        onMouseLeave: i,
        ...l,
        children: [
          d ? p.jsx(Oe, { type: 'target', position: n, style: C0 }) : p.jsx(Wn, { type: 'target', position: n, style: C0 }),
          p.jsxs(cR, { children: [p.jsx(dR, { archetype: u, src: pR, alt: hR, width: gR, height: mR }), p.jsx(fR, { lineSide: t.archetype === He.lineSide, children: A })] }),
          f ? p.jsx(Oe, { type: 'source', position: r, style: w0 }) : p.jsx(Wn, { type: 'source', position: r, style: w0 }),
        ],
      })
    }),
    bR = C.memo(yR),
    vR = j('div')`
  position: relative;
  height: ${Bn}px;
  width: ${Bn}px;
  display: flex;
  justify-content: center;
  align-items: center;
`,
    xR = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const CR = j($t)`
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: ${e => (e.archetype === He.loadSide ? `${Bn}px` : '0')};
`,
    E0 = st({ top: -2 }),
    S0 = st({ top: 55 }),
    wR = j('p')`
  position: absolute;
  top: ${e => (e.lineSide ? '50%' : '164%')};
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8px;
  line-height: 1.14;
  margin: 0;
  min-width: 100px;
`,
    ER = Wt['FUSE'],
    { src: SR, alt: BR, width: IR, height: kR } = ER,
    NR = xd(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.archetype,
        u = c === He.lineSide,
        d = c === He.loadSide,
        f = rd(e)
      return p.jsxs(xR, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [
          u ? p.jsx(Oe, { type: 'target', position: t, style: E0 }) : p.jsx(Wn, { type: 'target', position: t, style: E0 }),
          p.jsxs(vR, { children: [p.jsx(CR, { archetype: c, src: SR, alt: BR, width: IR, height: kR }), p.jsx(wR, { lineSide: e.archetype === He.lineSide, children: f })] }),
          d ? p.jsx(Oe, { type: 'source', position: o, style: S0 }) : p.jsx(Wn, { type: 'source', position: o, style: S0 }),
        ],
      })
    }),
    MR = C.memo(NR),
    PR = j('div')`
  position: relative;
  height: ${Bn}px;
  width: ${Bn}px;
  display: flex;
  justify-content: center;
  align-items: center;
`,
    LR = j('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${kt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
  j('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
  const TR = j($t)`
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: ${e => (e.archetype === He.loadSide ? `${Bn}px` : '0')};
`,
    B0 = st({ top: -2 }),
    I0 = st({ top: 55 }),
    FR = j('p')`
  position: absolute;
  top: ${e => (e.lineSide ? '50%' : '164%')};
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8px;
  line-height: 1.14;
  margin: 0;
  min-width: 100px;
`,
    DR = Wt['CIRCUIT_BREAKER'],
    { src: zR, alt: QR, width: RR, height: OR } = DR,
    jR = xd(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: s, setPopupAnchor: i, nodeColor: a }) => {
      const l = Et(i),
        c = e.archetype,
        u = c === He.lineSide,
        d = c === He.loadSide,
        f = rd(e)
      return p.jsxs(LR, {
        ref: l,
        rotation: n,
        onMouseEnter: r,
        onMouseLeave: s,
        ...a,
        children: [
          u ? p.jsx(Oe, { type: 'target', position: t, style: B0 }) : p.jsx(Wn, { type: 'target', position: t, style: B0 }),
          p.jsxs(PR, { children: [p.jsx(TR, { archetype: c, src: zR, alt: QR, width: RR, height: OR }), p.jsx(FR, { lineSide: e.archetype === He.lineSide, children: f })] }),
          d ? p.jsx(Oe, { type: 'source', position: o, style: I0 }) : p.jsx(Wn, { type: 'source', position: o, style: I0 }),
        ],
      })
    }),
    WR = C.memo(jR),
    Fo = {
      ResizableNode: 'ResizableNode',
      ResizableSubNode: 'ResizableSubNode',
      ImageNode: 'ImageNode',
      ImageSubNode: 'ImageSubNode',
      SwitchNode: 'SwitchNode',
      CapacitorNode: 'CapacitorNode',
      TransformerNode: 'TransformerNode',
      TransferSwitchNode: 'TransferSwitchNode',
      ElectricalPanelNode: 'ElectricalPanelNode',
      MiscNode: 'MiscNode',
      MotorNode: 'MotorNode',
      GeneratorNode: 'GeneratorNode',
      RelayNode: 'RelayNode',
      UPSSystemNode: 'UPSSystemNode',
      SubSwitchNode: 'SubSwitchNode',
      FuseNode: 'FuseNode',
      CircuitBreakerNode: 'CircuitBreakerNode',
    },
    GR = { ResizableNode: wD, ResizableSubNode: ID, ImageNode: LD, ImageSubNode: zD, SwitchNode: qD, CapacitorNode: lz, TransformerNode: xz, TransferSwitchNode: zz, ElectricalPanelNode: Vz, MiscNode: nQ, MotorNode: mQ, GeneratorNode: LQ, RelayNode: UQ, UPSSystemNode: lR, SubSwitchNode: bR, FuseNode: MR, CircuitBreakerNode: WR },
    pn = { vertical: 'TB', horizontal: 'LR' },
    VR = { [pn.vertical]: 'Apply Layout', [pn.horizontal]: 'Horizontal' },
    Gn = { locked: 'LOCKED', unlocked: 'UNLOCKED' },
    XR = { [Gn.locked]: 'Locked', [Gn.unlocked]: 'Unlocked' },
    no = { standard: 'standard', enhanced: 'enhanced' },
    YR = { [no.standard]: 'Standard', [no.enhanced]: 'Enhanced' },
    $ = {
      circuitBreaker: 'CIRCUIT_BREAKER',
      electricalPanel: 'ELECTRICAL_PANEL',
      fuse: 'FUSE',
      generator: 'GENERATOR',
      groundFaultSystem: 'GROUND_FAULT_SYSTEM',
      groundingOrBonding: 'GROUNDING_OR_BONDING',
      instrumentTransformer: 'INSTRUMENT_TRANSFORMER',
      meter: 'METER',
      misc: 'MISC',
      motor: 'MOTOR',
      relay: 'RELAY',
      switch: 'SWITCH',
      subSwitch: 'SUB_SWITCH',
      transferSwitch: 'TRANSFER_SWITCH',
      transformer: 'TRANSFORMER',
      upsSystem: 'UPS_SYSTEM',
      capacitor: 'CAPACITOR',
    },
    k0 = { [$.circuitBreaker]: 'CB', [$.fuse]: 'FUSE', [$.subSwitch]: 'SWITCH' },
    HR = {
      [$.circuitBreaker]: 'CIRCUIT_BREAKER',
      [$.electricalPanel]: 'ELECTRICAL_PANEL',
      [$.fuse]: 'FUSE',
      [$.generator]: 'GENERATOR',
      [$.groundFaultSystem]: 'GROUND_FAULT_SYSTEM',
      [$.groundingOrBonding]: 'GROUNDING_OR_BONDING',
      [$.instrumentTransformer]: 'INSTRUMENT_TRANSFORMER',
      [$.meter]: 'METER',
      [$.misc]: 'MISC',
      [$.motor]: 'MOTOR',
      [$.relay]: 'RELAY',
      [$.switch]: 'SWITCH',
      [$.subSwitch]: 'SWITCH',
      [$.transferSwitch]: 'TRANSFER_SWITCH',
      [$.transformer]: 'TRANSFORMER',
      [$.upsSystem]: 'UPS_SYSTEM',
      [$.capacitor]: 'CAPACITOR',
    },
    Cd = {
      CapacitorNode: $.capacitor,
      ElectricalPanelNode: $.electricalPanel,
      SwitchNode: $.switch,
      TransferSwitchNode: $.transferSwitch,
      TransformerNode: $.transformer,
      MiscNode: $.misc,
      MotorNode: $.motor,
      GeneratorNode: $.generator,
      RelayNode: $.relay,
      UPSSystemNode: $.upsSystem,
      SubSwitchNode: $.subSwitch,
      FuseNode: $.fuse,
      CircuitBreakerNode: $.circuitBreaker,
    },
    Gs = lk(Cd),
    N0 = { ...$, textAsset: 'TEXT_ASSET' },
    Y = {
      ARCB: 'ARCB',
      AMCB: 'AMCB',
      CTCR: 'CTCR',
      GICB: 'GICB',
      ICCB: 'ICCB',
      LVCB: 'LVCB',
      'MCCB-L-LV': 'MCCB-L-LV',
      'MCCB-S-LV': 'MCCB-S-LV',
      OICB: 'OICB',
      VCCB: 'VCCB',
      RCLS: 'RCLS',
      DPNL: 'DPNL',
      'MCEQ-LV': 'MCEQ-LV',
      'MCEQ-MV': 'MCEQ-MV',
      PANL: 'PANL',
      PDUX: 'PDUX',
      SWBD: 'SWBD',
      'SWGR-LV': 'SWGR-LV',
      'SWGR-MV': 'SWGR-MV',
      'USSX-LV': 'USSX-LV',
      'USSX-MV': 'USSX-MV',
      'FUSE-LV': 'FUSE-LV',
      'FUSE-MV': 'FUSE-MV',
      GENR: 'GENR',
      'GFPS-E-LV': 'GFPS-E-LV',
      'GFPS-E-MV': 'GFPS-E-MV',
      'GFPS-I-LV': 'GFPS-I-LV',
      'GFPS-I-MV': 'GFPS-I-MV',
      REGR: 'REGR',
      BNDG: 'BNDG',
      GRND: 'GRND',
      CITR: 'CITR',
      PITR: 'PITR',
      AMME: 'AMME',
      LIMI: 'LIMI',
      MMME: 'MMME',
      VVME: 'VVME',
      WHME: 'WHME',
      CBBX: 'CBBX',
      ENCL: 'ENCL',
      ENDX: 'ENDX',
      EVCS: 'EVCS',
      FSBX: 'FSBX',
      INVR: 'INVR',
      JCBX: 'JCBX',
      Other: 'Other',
      RCTF: 'RCTF',
      REAC: 'REAC',
      SOLR: 'SOLR',
      WIND: 'WIND',
      'LVMT-DC': 'LVMT-DC',
      'LVMT-L': 'LVMT-L',
      'LVMT-S': 'LVMT-S',
      MVIN: 'MVIN',
      MVSC: 'MVSC',
      EMRE: 'EMRE',
      MPRE: 'MPRE',
      SSRE: 'SSRE',
      'BISW-LV': 'BISW-LV',
      'BISW-MV': 'BISW-MV',
      BPSW: 'BPSW',
      'DISC-F-LV': 'DISC-F-LV',
      'DISC-F-MV': 'DISC-F-MV',
      'DISC-LV': 'DISC-LV',
      'DISC-MV': 'DISC-MV',
      HPSW: 'HPSW',
      LISW: 'LISW',
      'SUB_BISW-LV': 'SUB_BISW-LV',
      'SUB_BISW-MV': 'SUB_BISW-MV',
      SUB_BPSW: 'SUB_BPSW',
      'SUB_DISC-F-LV': 'SUB_DISC-F-LV',
      'SUB_DISC-F-MV': 'SUB_DISC-F-MV',
      'SUB_DISC-LV': 'SUB_DISC-LV',
      'SUB_DISC-MV': 'SUB_DISC-MV',
      SUB_HPSW: 'SUB_HPSW',
      SUB_LISW: 'SUB_LISW',
      'ATSW-LV': 'ATSW-LV',
      'ATSW-MV': 'ATSW-MV',
      'MTSW-LV': 'MTSW-LV',
      'MTSW-MV': 'MTSW-MV',
      'DTTR-LV': 'DTTR-LV',
      'DTTR-MV': 'DTTR-MV',
      OFTR: 'OFTR',
      UPSH: 'UPSH',
      UPSR: 'UPSR',
      UPSS: 'UPSS',
      PCAP: 'PCAP',
      SCAP: 'SCAP',
    },
    M0 = {
      ARCB: 'ARCB Circuit Breaker',
      AMCB: 'Medium-Voltage Air Magnetic Circuit Breaker',
      CTCR: 'Contactor',
      GICB: 'Medim-Voltage Gas Insulated Circuit Breaker',
      ICCB: 'Low-Voltage Insulated Case Circuit Breaker',
      LVCB: 'Low-Voltage Power Circuit Breaker',
      'MCCB-L-LV': 'Low-Voltage Molded Case Circuit Breaker (> 250A)',
      'MCCB-S-LV': 'Low-Voltage Molded Case Circuit Breaker (<= 250A)',
      OICB: 'Medium-Voltage Oil Insulated Circuit Breaker',
      VCCB: 'Medium-Voltage Vacuum Circuit Breaker',
      RCLS: 'Recloser',
      DPNL: 'Distribution Panelboard',
      'MCEQ-LV': 'Motor Control Equipment (<=1000V)',
      'MCEQ-MV': 'Motor Control Equipment (>1000V)',
      PANL: 'Panelboard',
      PDUX: 'Power Distribution Unit',
      SWBD: 'Switchboard',
      'SWGR-LV': 'Switchgear (<= 1000V)',
      'SWGR-MV': 'Switchgear (> 1000V)',
      'USSX-LV': 'Unitized Substation (USS) (<= 1000V)',
      'USSX-MV': 'Unitized Substation (USS) (> 1000V)',
      'FUSE-LV': 'Fuse (<= 1000V)',
      'FUSE-MV': 'Fuse (> 1000V)',
      GENR: 'Generator',
      'GFPS-E-LV': 'Low-Voltage External Ground Fault Protection System',
      'GFPS-E-MV': 'Medium-Voltage External Ground Fault Protection System',
      'GFPS-I-LV': 'Low-Voltage Integral Ground Fault Protection System',
      'GFPS-I-MV': 'Medium-Voltage Integral Ground Fault Protection System',
      REGR: 'Ground Resistor',
      BNDG: 'Bonding',
      GRND: 'Grounding',
      CITR: 'Current Transformer',
      PITR: 'Potential Transformer',
      AMME: 'Ammeter',
      LIMI: 'Line Isolation Monitor',
      MMME: 'Multimeter',
      VVME: 'Votmeter',
      WHME: 'Watt-Hour Meter',
      CBBX: 'Combiner Box',
      ENCL: 'General Enclosure',
      ENDX: 'General Endpoint',
      EVCS: 'Electrical Vehicle Charging Station',
      FSBX: 'Fuse Box',
      INVR: 'Inverter',
      JCBX: 'Junction Box',
      Other: 'Other',
      RCTF: 'Recitifier',
      REAC: 'Reactor',
      SOLR: 'Solar Photovoltaic System',
      WIND: 'Wind Power System',
      'LVMT-DC': 'Low-Voltage Motor (dc)',
      'LVMT-L': 'Low-Voltage Motor (>200hp)',
      'LVMT-S': 'Low-Voltage Motor (<= 200hp)',
      MVIN: 'Medium-Voltage Induction Motor',
      MVSC: 'Medium-Voltage Synchronous Motor',
      EMRE: 'Electromechanical Relay',
      MPRE: 'Microprocessor Relay',
      SSRE: 'Solid-State Relay',
      'BISW-LV': 'Bypass-Isolation Switch (<= 1000V)',
      'BISW-MV': 'Bypass-Isolation Switch (> 1000V)',
      BPSW: 'Bolted-Pressure Switch (BPS)',
      'DISC-F-LV': 'Fused Disconnect Switch (<= 1000V)',
      'DISC-F-MV': 'Fused Disconnect Switch (>1000V)',
      'DISC-LV': 'Disconnect Switch (<= 1000V)',
      'DISC-MV': 'Disconnect Switch (>1000V)',
      HPSW: 'High-Pressure Contact Switch (HPC)',
      LISW: 'Load-Interruptor Switch',
      'SUB_BISW-LV': 'Bypass-Isolation Switch (<= 1000V)',
      'SUB_BISW-MV': 'Bypass-Isolation Switch (> 1000V)',
      SUB_BPSW: 'Bolted-Pressure Switch (BPS)',
      'SUB_DISC-F-LV': 'Fused Disconnect Switch (<= 1000V)',
      'SUB_DISC-F-MV': 'Fused Disconnect Switch (>1000V)',
      'SUB_DISC-LV': 'Disconnect Switch (<= 1000V)',
      'SUB_DISC-MV': 'Disconnect Switch (>1000V)',
      SUB_HPSW: 'High-Pressure Contact Switch (HPC)',
      SUB_LISW: 'Load-Interruptor Switch',
      'ATSW-LV': 'Automatic Transfer Switch (<= 1000V)',
      'ATSW-MV': 'Automatic Transfer Switch (>1000V)',
      'MTSW-LV': 'Transfer Switch (<= 1000V)',
      'MTSW-MV': 'Transfer Switch (> 1000V)',
      'DTTR-LV': 'Dry-Type Transformer (<=600V)',
      'DTTR-MV': 'Dry-Type Transformer (>600V)',
      OFTR: 'Oil-Filled Transformer',
      UPSH: 'Hybrid UPS System',
      UPSR: 'Rotary UPS System',
      UPSS: 'Static UPS System',
      PCAP: 'P-Capacitor',
      SCAP: 'S-Capcitor',
    },
    wd = {
      ARCB: 'ARCB',
      AMCB: 'AMCB',
      CTCR: 'CTCR',
      GICB: 'GICB',
      ICCB: 'ICCB',
      LVCB: 'LVCB',
      'MCCB-L-LV': 'MCCB-L-LV',
      'MCCB-S-LV': 'MCCB-S-LV',
      OICB: 'OICB',
      VCCB: 'VCCB',
      RCLS: 'RCLS',
      DPNL: 'DPNL',
      'MCEQ-LV': 'MCEQ-LV',
      'MCEQ-MV': 'MCEQ-MV',
      PANL: 'PANL',
      PDUX: 'PDUX',
      SWBD: 'SWBD',
      'SWGR-LV': 'SWGR-LV',
      'SWGR-MV': 'SWGR-MV',
      'USSX-LV': 'USSX-LV',
      'USSX-MV': 'USSX-MV',
      'FUSE-LV': 'FUSE-LV',
      'FUSE-MV': 'FUSE-MV',
      GENR: 'GENR',
      'GFPS-E-LV': 'GFPS-E-LV',
      'GFPS-E-MV': 'GFPS-E-MV',
      'GFPS-I-LV': 'GFPS-I-LV',
      'GFPS-I-MV': 'GFPS-I-MV',
      REGR: 'REGR',
      BNDG: 'BNDG',
      GRND: 'GRND',
      CITR: 'CITR',
      PITR: 'PITR',
      AMME: 'AMME',
      LIMI: 'LIMI',
      MMME: 'MMME',
      VVME: 'VVME',
      WHME: 'WHME',
      CBBX: 'CBBX',
      ENCL: 'ENCL',
      ENDX: 'ENDX',
      EVCS: 'EVCS',
      FSBX: 'FSBX',
      INVR: 'INVR',
      JCBX: 'JCBX',
      Other: 'Other',
      RCTF: 'RCTF',
      REAC: 'REAC',
      SOLR: 'SOLR',
      WIND: 'WIND',
      'LVMT-DC': 'LVMT-DC',
      'LVMT-L': 'LVMT-L',
      'LVMT-S': 'LVMT-S',
      MVIN: 'MVIN',
      MVSC: 'MVSC',
      EMRE: 'EMRE',
      MPRE: 'MPRE',
      SSRE: 'SSRE',
      'BISW-LV': 'BISW-LV',
      'BISW-MV': 'BISW-MV',
      BPSW: 'BPSW',
      'DISC-F-LV': 'DISC-F-LV',
      'DISC-F-MV': 'DISC-F-MV',
      'DISC-LV': 'DISC-LV',
      'DISC-MV': 'DISC-MV',
      HPSW: 'HPSW',
      LISW: 'LISW',
      'SUB_BISW-LV': 'BISW-LV',
      'SUB_BISW-MV': 'BISW-MV',
      SUB_BPSW: 'BPSW',
      'SUB_DISC-F-LV': 'DISC-F-LV',
      'SUB_DISC-F-MV': 'DISC-F-MV',
      'SUB_DISC-LV': 'DISC-LV',
      'SUB_DISC-MV': 'DISC-MV',
      SUB_HPSW: 'HPSW',
      SUB_LISW: 'LISW',
      'ATSW-LV': 'ATSW-LV',
      'ATSW-MV': 'ATSW-MV',
      'MTSW-LV': 'MTSW-LV',
      'MTSW-MV': 'MTSW-MV',
      'DTTR-LV': 'DTTR-LV',
      'DTTR-MV': 'DTTR-MV',
      OFTR: 'OFTR',
      UPSH: 'UPSH',
      UPSR: 'UPSR',
      UPSS: 'UPSS',
      PCAP: 'PCAP',
      SCAP: 'SCAP',
    },
    UR = [
      Y['ATSW-LV'],
      Y['ATSW-MV'],
      Y['MTSW-LV'],
      Y['MTSW-MV'],
      Y['DTTR-LV'],
      Y['DTTR-MV'],
      Y.OFTR,
      Y.PCAP,
      Y.SCAP,
      Y['BISW-LV'],
      Y['BISW-MV'],
      Y.BPSW,
      Y['DISC-F-LV'],
      Y['DISC-F-MV'],
      Y['DISC-LV'],
      Y['DISC-MV'],
      Y.HPSW,
      Y.LISW,
      Y.DPNL,
      Y['MCEQ-LV'],
      Y['MCEQ-MV'],
      Y.PANL,
      Y.PDUX,
      Y.SWBD,
      Y['SWGR-LV'],
      Y['SWGR-MV'],
      Y['USSX-LV'],
      Y['USSX-MV'],
      Y.UPSH,
      Y.UPSR,
      Y.UPSS,
      Y.GENR,
      Y.EMRE,
      Y.MPRE,
      Y.SSRE,
      Y['LVMT-DC'],
      Y['LVMT-L'],
      Y['LVMT-S'],
      Y.MVIN,
      Y.MVSC,
      Y.CBBX,
      Y.ENCL,
      Y.ENDX,
      Y.EVCS,
      Y.FSBX,
      Y.INVR,
      Y.JCBX,
      Y.Other,
      Y.RCTF,
      Y.REAC,
      Y.SOLR,
      Y.WIND,
    ],
    KR = [Y.AMCB, Y.CTCR, Y.ARCB, Y.GICB, Y.ICCB, Y.LVCB, Y['MCCB-L-LV'], Y['MCCB-S-LV'], Y.OICB, Y.RCLS, Y.VCCB, Y['FUSE-LV'], Y['FUSE-MV'], Y['SUB_BISW-LV'], Y['SUB_BISW-MV'], Y.SUB_BPSW, Y['SUB_DISC-F-LV'], Y['SUB_DISC-F-MV'], Y['SUB_DISC-LV'], Y['SUB_DISC-MV'], Y.SUB_HPSW, Y.SUB_LISW],
    Ed = {
      [Y['ATSW-LV']]: $.transferSwitch,
      [Y['ATSW-MV']]: $.transferSwitch,
      [Y['MTSW-LV']]: $.transferSwitch,
      [Y['MTSW-MV']]: $.transferSwitch,
      [Y['DTTR-LV']]: $.transformer,
      [Y['DTTR-MV']]: $.transformer,
      [Y.OFTR]: $.transformer,
      [Y.PCAP]: $.capacitor,
      [Y.SCAP]: $.capacitor,
      [Y['BISW-LV']]: $.switch,
      [Y['BISW-MV']]: $.switch,
      [Y.BPSW]: $.switch,
      [Y['DISC-F-LV']]: $.switch,
      [Y['DISC-F-MV']]: $.switch,
      [Y['DISC-LV']]: $.switch,
      [Y['DISC-MV']]: $.switch,
      [Y.HPSW]: $.switch,
      [Y.LISW]: $.switch,
      [Y.DPNL]: $.electricalPanel,
      [Y['MCEQ-LV']]: $.electricalPanel,
      [Y['MCEQ-MV']]: $.electricalPanel,
      [Y.PANL]: $.electricalPanel,
      [Y.PDUX]: $.electricalPanel,
      [Y.SWBD]: $.electricalPanel,
      [Y['SWGR-LV']]: $.electricalPanel,
      [Y['SWGR-MV']]: $.electricalPanel,
      [Y['USSX-LV']]: $.electricalPanel,
      [Y['USSX-MV']]: $.electricalPanel,
      [Y.UPSH]: $.upsSystem,
      [Y.UPSR]: $.upsSystem,
      [Y.UPSS]: $.upsSystem,
      [Y.GENR]: $.generator,
      [Y.EMRE]: $.relay,
      [Y.MPRE]: $.relay,
      [Y.SSRE]: $.relay,
      [Y['LVMT-DC']]: $.motor,
      [Y['LVMT-L']]: $.motor,
      [Y['LVMT-S']]: $.motor,
      [Y.MVIN]: $.motor,
      [Y.MVSC]: $.motor,
      [Y.CBBX]: $.misc,
      [Y.ENCL]: $.misc,
      [Y.ENDX]: $.misc,
      [Y.EVCS]: $.misc,
      [Y.FSBX]: $.misc,
      [Y.INVR]: $.misc,
      [Y.JCBX]: $.misc,
      [Y.Other]: $.misc,
      [Y.RCTF]: $.misc,
      [Y.REAC]: $.misc,
      [Y.SOLR]: $.misc,
      [Y.WIND]: $.misc,
    },
    P0 = {
      [Y.AMCB]: $.circuitBreaker,
      [Y.CTCR]: $.circuitBreaker,
      [Y.ARCB]: $.circuitBreaker,
      [Y.GICB]: $.circuitBreaker,
      [Y.ICCB]: $.circuitBreaker,
      [Y.LVCB]: $.circuitBreaker,
      [Y['MCCB-L-LV']]: $.circuitBreaker,
      [Y['MCCB-S-LV']]: $.circuitBreaker,
      [Y.OICB]: $.circuitBreaker,
      [Y.RCLS]: $.circuitBreaker,
      [Y.VCCB]: $.circuitBreaker,
      [Y['FUSE-LV']]: $.fuse,
      [Y['FUSE-MV']]: $.fuse,
      [Y['SUB_BISW-LV']]: $.subSwitch,
      [Y['SUB_BISW-MV']]: $.subSwitch,
      [Y.SUB_BPSW]: $.subSwitch,
      [Y['SUB_DISC-F-LV']]: $.subSwitch,
      [Y['SUB_DISC-F-MV']]: $.subSwitch,
      [Y['SUB_DISC-LV']]: $.subSwitch,
      [Y['SUB_DISC-MV']]: $.subSwitch,
      [Y.SUB_HPSW]: $.subSwitch,
      [Y.SUB_LISW]: $.subSwitch,
    },
    He = { lineSide: 'line-side', loadSide: 'load-side' },
    qR = { [He.lineSide]: 'Line Side', [He.loadSide]: 'Load Side' },
    L0 = { [He.lineSide]: 'LINE', [He.loadSide]: 'LOAD' },
    ZR = [He.lineSide, He.loadSide],
    Do = { MLO: 'MLO', MCB: 'MCB' },
    JR = [Do.MCB, Do.MLO],
    $e = { nonFlexConduit: 'Non-Flex Conduit', flexibleConduit: 'Flexible Conduit', cable: 'Cable', busduct: 'Busduct' },
    _R = [$e.nonFlexConduit, $e.flexibleConduit, $e.cable, $e.busduct],
    Vs = { PVC: 'PVC', EMT: 'EMT', IMC: 'IMC', RMC: 'RMC' },
    $R = [Vs.PVC, Vs.EMT, Vs.IMC, Vs.RMC],
    El = { smurf: 'Smurf', flex: 'Flex', sealTight: 'SealTight' },
    eO = [El.smurf, El.flex, El.sealTight],
    Xs = { [$e.nonFlexConduit]: Vs, [$e.flexibleConduit]: El, [$e.cable]: null, [$e.busduct]: null },
    zo = { copper: 'Copper', aluminum: 'Aluminum' },
    tO = { [zo.copper]: 'Copper', [zo.aluminum]: 'Aluminum' },
    nO = { [zo.copper]: 'Cu', [zo.aluminum]: 'Al' },
    oO = [zo.copper, zo.aluminum],
    ve = {
      AWG18: '18 AWG',
      AWG16: '16 AWG',
      AWG14: '14 AWG',
      AWG12: '12 AWG',
      AWG10: '10 AWG',
      AWG8: '8 AWG',
      AWG6: '6 AWG',
      AWG4: '4 AWG',
      AWG2: '2 AWG',
      AWG1: '1 AWG',
      AWG1_0: '1/0 AWG',
      AWG2_0: '2/0 AWG',
      AWG3_0: '3/0 AWG',
      AWG4_0: '4/0 AWG',
      KCMIL250: '250 kcmil',
      KCMIL300: '300 kcmil',
      KCMIL350: '350 kcmil',
      KCMIL400: '400 kcmil',
      KCMIL500: '500 kcmil',
      KCMIL600: '600 kcmil',
      KCMIL750: '750 kcmil',
      KCMIL1000: '1000 kcmil',
    },
    rO = {
      [ve.AWG18]: '18 AWG',
      [ve.AWG16]: '16 AWG',
      [ve.AWG14]: '14 AWG',
      [ve.AWG12]: '12 AWG',
      [ve.AWG10]: '10 AWG',
      [ve.AWG8]: '8 AWG',
      [ve.AWG6]: '6 AWG',
      [ve.AWG4]: '4 AWG',
      [ve.AWG2]: '2 AWG',
      [ve.AWG1]: '1 AWG',
      [ve.AWG1_0]: '1/0 AWG',
      [ve.AWG2_0]: '2/0 AWG',
      [ve.AWG3_0]: '3/0 AWG',
      [ve.AWG4_0]: '4/0 AWG',
      [ve.KCMIL250]: '250 kcmil',
      [ve.KCMIL300]: '300 kcmil',
      [ve.KCMIL350]: '350 kcmil',
      [ve.KCMIL400]: '400 kcmil',
      [ve.KCMIL500]: '500 kcmil',
      [ve.KCMIL600]: '600 kcmil',
      [ve.KCMIL750]: '750 kcmil',
      [ve.KCMIL1000]: '1000 kcmil',
    },
    sO = [ve.AWG18, ve.AWG16, ve.AWG14, ve.AWG12, ve.AWG10, ve.AWG8, ve.AWG6, ve.AWG4, ve.AWG2, ve.AWG1, ve.AWG1_0, ve.AWG2_0, ve.AWG3_0, ve.AWG4_0, ve.KCMIL250, ve.KCMIL300, ve.KCMIL350, ve.KCMIL400, ve.KCMIL500, ve.KCMIL600, ve.KCMIL750, ve.KCMIL1000],
    T0 = e => Object.keys(Cd).some(t => t === e.type),
    iO = (e, t) => t.some(n => n.parentId === e.id),
    Sl = e => !!e.parentId,
    aO = e => e === N0.textAsset,
    lO = tF(),
    hn = e => {
      var o, r
      const { background: t, border: n } = sF()
      return { ...e, type: e.type ?? Fo.ResizableNode, data: e.data ? { ...e.data, background: ((o = e.data) == null ? void 0 : o.background) ?? t, border: ((r = e.data) == null ? void 0 : r.border) ?? n } : { label: 'NEW ASSET', background: t, border: n }, id: e.id ?? Co(), style: e.style ?? lO }
    },
    F0 = e => (hT(e) ? e.data.class : T0(e) ? Cd[e.type] : N0.textAsset),
    D0 = e => ('code' in e.data && typeof e.data.code == 'string' ? e.data.code : void 0),
    z0 = e => {
      var t, n
      return { background: (t = e.data) == null ? void 0 : t.background, border: (n = e.data) == null ? void 0 : n.border }
    },
    cO = e => ('rotation' in e.data && typeof e.data.rotation == 'number' && e.data.rotation) || void 0,
    uO = e => 'label' in e.data && typeof e.data.string == 'string',
    Sd = (e, t) => t.find(n => n.id === e.parentId),
    dO = (e, t) => hn({ ...e, data: { ...e.data, label: t } }),
    fO = (e, t, n) => {
      const o = n.find(r => r.target === e.id)
      return o ? t.find(r => r.id === o.source) ?? null : null
    },
    Q0 = e => !!Gs[e],
    AO = (e, t) => (e.length >= t ? `${e.slice(0, t)}...` : e),
    pO = (e, { x: t, y: n, zoom: o }) => ({ x: (e.clientX - t) * (1 / o) - Ye, y: (e.clientY - n) * (1 / o) - kt / 2 }),
    R0 = [],
    O0 = []
  var hO = '\0',
    Qo = '\0',
    j0 = ''
  let gO = class {
    constructor(t) {
      At(this, '_isDirected', !0)
      At(this, '_isMultigraph', !1)
      At(this, '_isCompound', !1)
      At(this, '_label')
      At(this, '_defaultNodeLabelFn', () => {})
      At(this, '_defaultEdgeLabelFn', () => {})
      At(this, '_nodes', {})
      At(this, '_in', {})
      At(this, '_preds', {})
      At(this, '_out', {})
      At(this, '_sucs', {})
      At(this, '_edgeObjs', {})
      At(this, '_edgeLabels', {})
      At(this, '_nodeCount', 0)
      At(this, '_edgeCount', 0)
      At(this, '_parent')
      At(this, '_children')
      t && ((this._isDirected = Object.hasOwn(t, 'directed') ? t.directed : !0), (this._isMultigraph = Object.hasOwn(t, 'multigraph') ? t.multigraph : !1), (this._isCompound = Object.hasOwn(t, 'compound') ? t.compound : !1)), this._isCompound && ((this._parent = {}), (this._children = {}), (this._children[Qo] = {}))
    }
    isDirected() {
      return this._isDirected
    }
    isMultigraph() {
      return this._isMultigraph
    }
    isCompound() {
      return this._isCompound
    }
    setGraph(t) {
      return (this._label = t), this
    }
    graph() {
      return this._label
    }
    setDefaultNodeLabel(t) {
      return (this._defaultNodeLabelFn = t), typeof t != 'function' && (this._defaultNodeLabelFn = () => t), this
    }
    nodeCount() {
      return this._nodeCount
    }
    nodes() {
      return Object.keys(this._nodes)
    }
    sources() {
      var t = this
      return this.nodes().filter(n => Object.keys(t._in[n]).length === 0)
    }
    sinks() {
      var t = this
      return this.nodes().filter(n => Object.keys(t._out[n]).length === 0)
    }
    setNodes(t, n) {
      var o = arguments,
        r = this
      return (
        t.forEach(function (s) {
          o.length > 1 ? r.setNode(s, n) : r.setNode(s)
        }),
        this
      )
    }
    setNode(t, n) {
      return Object.hasOwn(this._nodes, t)
        ? (arguments.length > 1 && (this._nodes[t] = n), this)
        : ((this._nodes[t] = arguments.length > 1 ? n : this._defaultNodeLabelFn(t)), this._isCompound && ((this._parent[t] = Qo), (this._children[t] = {}), (this._children[Qo][t] = !0)), (this._in[t] = {}), (this._preds[t] = {}), (this._out[t] = {}), (this._sucs[t] = {}), ++this._nodeCount, this)
    }
    node(t) {
      return this._nodes[t]
    }
    hasNode(t) {
      return Object.hasOwn(this._nodes, t)
    }
    removeNode(t) {
      var n = this
      if (Object.hasOwn(this._nodes, t)) {
        var o = r => n.removeEdge(n._edgeObjs[r])
        delete this._nodes[t],
          this._isCompound &&
            (this._removeFromParentsChildList(t),
            delete this._parent[t],
            this.children(t).forEach(function (r) {
              n.setParent(r)
            }),
            delete this._children[t]),
          Object.keys(this._in[t]).forEach(o),
          delete this._in[t],
          delete this._preds[t],
          Object.keys(this._out[t]).forEach(o),
          delete this._out[t],
          delete this._sucs[t],
          --this._nodeCount
      }
      return this
    }
    setParent(t, n) {
      if (!this._isCompound) throw new Error('Cannot set parent in a non-compound graph')
      if (n === void 0) n = Qo
      else {
        n += ''
        for (var o = n; o !== void 0; o = this.parent(o)) if (o === t) throw new Error('Setting ' + n + ' as parent of ' + t + ' would create a cycle')
        this.setNode(n)
      }
      return this.setNode(t), this._removeFromParentsChildList(t), (this._parent[t] = n), (this._children[n][t] = !0), this
    }
    _removeFromParentsChildList(t) {
      delete this._children[this._parent[t]][t]
    }
    parent(t) {
      if (this._isCompound) {
        var n = this._parent[t]
        if (n !== Qo) return n
      }
    }
    children(t = Qo) {
      if (this._isCompound) {
        var n = this._children[t]
        if (n) return Object.keys(n)
      } else {
        if (t === Qo) return this.nodes()
        if (this.hasNode(t)) return []
      }
    }
    predecessors(t) {
      var n = this._preds[t]
      if (n) return Object.keys(n)
    }
    successors(t) {
      var n = this._sucs[t]
      if (n) return Object.keys(n)
    }
    neighbors(t) {
      var n = this.predecessors(t)
      if (n) {
        const r = new Set(n)
        for (var o of this.successors(t)) r.add(o)
        return Array.from(r.values())
      }
    }
    isLeaf(t) {
      var n
      return this.isDirected() ? (n = this.successors(t)) : (n = this.neighbors(t)), n.length === 0
    }
    filterNodes(t) {
      var n = new this.constructor({ directed: this._isDirected, multigraph: this._isMultigraph, compound: this._isCompound })
      n.setGraph(this.graph())
      var o = this
      Object.entries(this._nodes).forEach(function ([i, a]) {
        t(i) && n.setNode(i, a)
      }),
        Object.values(this._edgeObjs).forEach(function (i) {
          n.hasNode(i.v) && n.hasNode(i.w) && n.setEdge(i, o.edge(i))
        })
      var r = {}
      function s(i) {
        var a = o.parent(i)
        return a === void 0 || n.hasNode(a) ? ((r[i] = a), a) : a in r ? r[a] : s(a)
      }
      return this._isCompound && n.nodes().forEach(i => n.setParent(i, s(i))), n
    }
    setDefaultEdgeLabel(t) {
      return (this._defaultEdgeLabelFn = t), typeof t != 'function' && (this._defaultEdgeLabelFn = () => t), this
    }
    edgeCount() {
      return this._edgeCount
    }
    edges() {
      return Object.values(this._edgeObjs)
    }
    setPath(t, n) {
      var o = this,
        r = arguments
      return (
        t.reduce(function (s, i) {
          return r.length > 1 ? o.setEdge(s, i, n) : o.setEdge(s, i), i
        }),
        this
      )
    }
    setEdge() {
      var t,
        n,
        o,
        r,
        s = !1,
        i = arguments[0]
      typeof i == 'object' && i !== null && 'v' in i ? ((t = i.v), (n = i.w), (o = i.name), arguments.length === 2 && ((r = arguments[1]), (s = !0))) : ((t = i), (n = arguments[1]), (o = arguments[3]), arguments.length > 2 && ((r = arguments[2]), (s = !0))), (t = '' + t), (n = '' + n), o !== void 0 && (o = '' + o)
      var a = Ys(this._isDirected, t, n, o)
      if (Object.hasOwn(this._edgeLabels, a)) return s && (this._edgeLabels[a] = r), this
      if (o !== void 0 && !this._isMultigraph) throw new Error('Cannot set a named edge when isMultigraph = false')
      this.setNode(t), this.setNode(n), (this._edgeLabels[a] = s ? r : this._defaultEdgeLabelFn(t, n, o))
      var l = mO(this._isDirected, t, n, o)
      return (t = l.v), (n = l.w), Object.freeze(l), (this._edgeObjs[a] = l), W0(this._preds[n], t), W0(this._sucs[t], n), (this._in[n][a] = l), (this._out[t][a] = l), this._edgeCount++, this
    }
    edge(t, n, o) {
      var r = arguments.length === 1 ? Bd(this._isDirected, arguments[0]) : Ys(this._isDirected, t, n, o)
      return this._edgeLabels[r]
    }
    edgeAsObj() {
      const t = this.edge(...arguments)
      return typeof t != 'object' ? { label: t } : t
    }
    hasEdge(t, n, o) {
      var r = arguments.length === 1 ? Bd(this._isDirected, arguments[0]) : Ys(this._isDirected, t, n, o)
      return Object.hasOwn(this._edgeLabels, r)
    }
    removeEdge(t, n, o) {
      var r = arguments.length === 1 ? Bd(this._isDirected, arguments[0]) : Ys(this._isDirected, t, n, o),
        s = this._edgeObjs[r]
      return s && ((t = s.v), (n = s.w), delete this._edgeLabels[r], delete this._edgeObjs[r], G0(this._preds[n], t), G0(this._sucs[t], n), delete this._in[n][r], delete this._out[t][r], this._edgeCount--), this
    }
    inEdges(t, n) {
      var o = this._in[t]
      if (o) {
        var r = Object.values(o)
        return n ? r.filter(s => s.v === n) : r
      }
    }
    outEdges(t, n) {
      var o = this._out[t]
      if (o) {
        var r = Object.values(o)
        return n ? r.filter(s => s.w === n) : r
      }
    }
    nodeEdges(t, n) {
      var o = this.inEdges(t, n)
      if (o) return o.concat(this.outEdges(t, n))
    }
  }
  function W0(e, t) {
    e[t] ? e[t]++ : (e[t] = 1)
  }
  function G0(e, t) {
    --e[t] || delete e[t]
  }
  function Ys(e, t, n, o) {
    var r = '' + t,
      s = '' + n
    if (!e && r > s) {
      var i = r
      ;(r = s), (s = i)
    }
    return r + j0 + s + j0 + (o === void 0 ? hO : o)
  }
  function mO(e, t, n, o) {
    var r = '' + t,
      s = '' + n
    if (!e && r > s) {
      var i = r
      ;(r = s), (s = i)
    }
    var a = { v: r, w: s }
    return o && (a.name = o), a
  }
  function Bd(e, t) {
    return Ys(e, t.v, t.w, t.name)
  }
  var Id = gO,
    yO = '2.2.4',
    bO = { Graph: Id, version: yO },
    vO = Id,
    xO = { write: CO, read: SO }
  function CO(e) {
    var t = { options: { directed: e.isDirected(), multigraph: e.isMultigraph(), compound: e.isCompound() }, nodes: wO(e), edges: EO(e) }
    return e.graph() !== void 0 && (t.value = structuredClone(e.graph())), t
  }
  function wO(e) {
    return e.nodes().map(function (t) {
      var n = e.node(t),
        o = e.parent(t),
        r = { v: t }
      return n !== void 0 && (r.value = n), o !== void 0 && (r.parent = o), r
    })
  }
  function EO(e) {
    return e.edges().map(function (t) {
      var n = e.edge(t),
        o = { v: t.v, w: t.w }
      return t.name !== void 0 && (o.name = t.name), n !== void 0 && (o.value = n), o
    })
  }
  function SO(e) {
    var t = new vO(e.options).setGraph(e.value)
    return (
      e.nodes.forEach(function (n) {
        t.setNode(n.v, n.value), n.parent && t.setParent(n.v, n.parent)
      }),
      e.edges.forEach(function (n) {
        t.setEdge({ v: n.v, w: n.w, name: n.name }, n.value)
      }),
      t
    )
  }
  var BO = IO
  function IO(e) {
    var t = {},
      n = [],
      o
    function r(s) {
      Object.hasOwn(t, s) || ((t[s] = !0), o.push(s), e.successors(s).forEach(r), e.predecessors(s).forEach(r))
    }
    return (
      e.nodes().forEach(function (s) {
        ;(o = []), r(s), o.length && n.push(o)
      }),
      n
    )
  }
  var V0 = class {
      constructor() {
        At(this, '_arr', [])
        At(this, '_keyIndices', {})
      }
      size() {
        return this._arr.length
      }
      keys() {
        return this._arr.map(function (t) {
          return t.key
        })
      }
      has(t) {
        return Object.hasOwn(this._keyIndices, t)
      }
      priority(t) {
        var n = this._keyIndices[t]
        if (n !== void 0) return this._arr[n].priority
      }
      min() {
        if (this.size() === 0) throw new Error('Queue underflow')
        return this._arr[0].key
      }
      add(t, n) {
        var o = this._keyIndices
        if (((t = String(t)), !Object.hasOwn(o, t))) {
          var r = this._arr,
            s = r.length
          return (o[t] = s), r.push({ key: t, priority: n }), this._decrease(s), !0
        }
        return !1
      }
      removeMin() {
        this._swap(0, this._arr.length - 1)
        var t = this._arr.pop()
        return delete this._keyIndices[t.key], this._heapify(0), t.key
      }
      decrease(t, n) {
        var o = this._keyIndices[t]
        if (n > this._arr[o].priority) throw new Error('New priority is greater than current priority. Key: ' + t + ' Old: ' + this._arr[o].priority + ' New: ' + n)
        ;(this._arr[o].priority = n), this._decrease(o)
      }
      _heapify(t) {
        var n = this._arr,
          o = 2 * t,
          r = o + 1,
          s = t
        o < n.length && ((s = n[o].priority < n[s].priority ? o : s), r < n.length && (s = n[r].priority < n[s].priority ? r : s), s !== t && (this._swap(t, s), this._heapify(s)))
      }
      _decrease(t) {
        for (var n = this._arr, o = n[t].priority, r; t !== 0 && ((r = t >> 1), !(n[r].priority < o)); ) this._swap(t, r), (t = r)
      }
      _swap(t, n) {
        var o = this._arr,
          r = this._keyIndices,
          s = o[t],
          i = o[n]
        ;(o[t] = i), (o[n] = s), (r[i.key] = t), (r[s.key] = n)
      }
    },
    kO = V0,
    X0 = MO,
    NO = () => 1
  function MO(e, t, n, o) {
    return PO(
      e,
      String(t),
      n || NO,
      o ||
        function (r) {
          return e.outEdges(r)
        }
    )
  }
  function PO(e, t, n, o) {
    var r = {},
      s = new kO(),
      i,
      a,
      l = function (c) {
        var u = c.v !== i ? c.v : c.w,
          d = r[u],
          f = n(c),
          A = a.distance + f
        if (f < 0) throw new Error('dijkstra does not allow negative edge weights. Bad edge: ' + c + ' Weight: ' + f)
        A < d.distance && ((d.distance = A), (d.predecessor = i), s.decrease(u, A))
      }
    for (
      e.nodes().forEach(function (c) {
        var u = c === t ? 0 : Number.POSITIVE_INFINITY
        ;(r[c] = { distance: u }), s.add(c, u)
      });
      s.size() > 0 && ((i = s.removeMin()), (a = r[i]), a.distance !== Number.POSITIVE_INFINITY);

    )
      o(i).forEach(l)
    return r
  }
  var LO = X0,
    TO = FO
  function FO(e, t, n) {
    return e.nodes().reduce(function (o, r) {
      return (o[r] = LO(e, r, t, n)), o
    }, {})
  }
  var Y0 = DO
  function DO(e) {
    var t = 0,
      n = [],
      o = {},
      r = []
    function s(i) {
      var a = (o[i] = { onStack: !0, lowlink: t, index: t++ })
      if (
        (n.push(i),
        e.successors(i).forEach(function (u) {
          Object.hasOwn(o, u) ? o[u].onStack && (a.lowlink = Math.min(a.lowlink, o[u].index)) : (s(u), (a.lowlink = Math.min(a.lowlink, o[u].lowlink)))
        }),
        a.lowlink === a.index)
      ) {
        var l = [],
          c
        do (c = n.pop()), (o[c].onStack = !1), l.push(c)
        while (i !== c)
        r.push(l)
      }
    }
    return (
      e.nodes().forEach(function (i) {
        Object.hasOwn(o, i) || s(i)
      }),
      r
    )
  }
  var zO = Y0,
    QO = RO
  function RO(e) {
    return zO(e).filter(function (t) {
      return t.length > 1 || (t.length === 1 && e.hasEdge(t[0], t[0]))
    })
  }
  var OO = WO,
    jO = () => 1
  function WO(e, t, n) {
    return GO(
      e,
      t || jO,
      n ||
        function (o) {
          return e.outEdges(o)
        }
    )
  }
  function GO(e, t, n) {
    var o = {},
      r = e.nodes()
    return (
      r.forEach(function (s) {
        ;(o[s] = {}),
          (o[s][s] = { distance: 0 }),
          r.forEach(function (i) {
            s !== i && (o[s][i] = { distance: Number.POSITIVE_INFINITY })
          }),
          n(s).forEach(function (i) {
            var a = i.v === s ? i.w : i.v,
              l = t(i)
            o[s][a] = { distance: l, predecessor: s }
          })
      }),
      r.forEach(function (s) {
        var i = o[s]
        r.forEach(function (a) {
          var l = o[a]
          r.forEach(function (c) {
            var u = l[s],
              d = i[c],
              f = l[c],
              A = u.distance + d.distance
            A < f.distance && ((f.distance = A), (f.predecessor = d.predecessor))
          })
        })
      }),
      o
    )
  }
  function H0(e) {
    var t = {},
      n = {},
      o = []
    function r(s) {
      if (Object.hasOwn(n, s)) throw new kd()
      Object.hasOwn(t, s) || ((n[s] = !0), (t[s] = !0), e.predecessors(s).forEach(r), delete n[s], o.push(s))
    }
    if ((e.sinks().forEach(r), Object.keys(t).length !== e.nodeCount())) throw new kd()
    return o
  }
  class kd extends Error {
    constructor() {
      super(...arguments)
    }
  }
  var U0 = H0
  H0.CycleException = kd
  var K0 = U0,
    VO = XO
  function XO(e) {
    try {
      K0(e)
    } catch (t) {
      if (t instanceof K0.CycleException) return !1
      throw t
    }
    return !0
  }
  var q0 = YO
  function YO(e, t, n) {
    Array.isArray(t) || (t = [t])
    var o = e.isDirected() ? a => e.successors(a) : a => e.neighbors(a),
      r = n === 'post' ? HO : UO,
      s = [],
      i = {}
    return (
      t.forEach(a => {
        if (!e.hasNode(a)) throw new Error('Graph does not have node: ' + a)
        r(a, o, i, s)
      }),
      s
    )
  }
  function HO(e, t, n, o) {
    for (var r = [[e, !1]]; r.length > 0; ) {
      var s = r.pop()
      s[1] ? o.push(s[0]) : Object.hasOwn(n, s[0]) || ((n[s[0]] = !0), r.push([s[0], !0]), Z0(t(s[0]), i => r.push([i, !1])))
    }
  }
  function UO(e, t, n, o) {
    for (var r = [e]; r.length > 0; ) {
      var s = r.pop()
      Object.hasOwn(n, s) || ((n[s] = !0), o.push(s), Z0(t(s), i => r.push(i)))
    }
  }
  function Z0(e, t) {
    for (var n = e.length; n--; ) t(e[n], n, e)
    return e
  }
  var KO = q0,
    qO = ZO
  function ZO(e, t) {
    return KO(e, t, 'post')
  }
  var JO = q0,
    _O = $O
  function $O(e, t) {
    return JO(e, t, 'pre')
  }
  var e6 = Id,
    t6 = V0,
    n6 = o6
  function o6(e, t) {
    var n = new e6(),
      o = {},
      r = new t6(),
      s
    function i(l) {
      var c = l.v === s ? l.w : l.v,
        u = r.priority(c)
      if (u !== void 0) {
        var d = t(l)
        d < u && ((o[c] = s), r.decrease(c, d))
      }
    }
    if (e.nodeCount() === 0) return n
    e.nodes().forEach(function (l) {
      r.add(l, Number.POSITIVE_INFINITY), n.setNode(l)
    }),
      r.decrease(e.nodes()[0], 0)
    for (var a = !1; r.size() > 0; ) {
      if (((s = r.removeMin()), Object.hasOwn(o, s))) n.setEdge(s, o[s])
      else {
        if (a) throw new Error('Input graph is not connected: ' + e)
        a = !0
      }
      e.nodeEdges(s).forEach(i)
    }
    return n
  }
  var r6 = { components: BO, dijkstra: X0, dijkstraAll: TO, findCycles: QO, floydWarshall: OO, isAcyclic: VO, postorder: qO, preorder: _O, prim: n6, tarjan: Y0, topsort: U0 },
    J0 = bO,
    gn = { Graph: J0.Graph, json: xO, alg: r6, version: J0.version }
  let s6 = class {
    constructor() {
      let t = {}
      ;(t._next = t._prev = t), (this._sentinel = t)
    }
    dequeue() {
      let t = this._sentinel,
        n = t._prev
      if (n !== t) return _0(n), n
    }
    enqueue(t) {
      let n = this._sentinel
      t._prev && t._next && _0(t), (t._next = n._next), (n._next._prev = t), (n._next = t), (t._prev = n)
    }
    toString() {
      let t = [],
        n = this._sentinel,
        o = n._prev
      for (; o !== n; ) t.push(JSON.stringify(o, i6)), (o = o._prev)
      return '[' + t.join(', ') + ']'
    }
  }
  function _0(e) {
    ;(e._prev._next = e._next), (e._next._prev = e._prev), delete e._next, delete e._prev
  }
  function i6(e, t) {
    if (e !== '_next' && e !== '_prev') return t
  }
  var a6 = s6
  let l6 = gn.Graph,
    c6 = a6
  var u6 = f6
  let d6 = () => 1
  function f6(e, t) {
    if (e.nodeCount() <= 1) return []
    let n = p6(e, t || d6)
    return A6(n.graph, n.buckets, n.zeroIdx).flatMap(r => e.outEdges(r.v, r.w))
  }
  function A6(e, t, n) {
    let o = [],
      r = t[t.length - 1],
      s = t[0],
      i
    for (; e.nodeCount(); ) {
      for (; (i = s.dequeue()); ) Nd(e, t, n, i)
      for (; (i = r.dequeue()); ) Nd(e, t, n, i)
      if (e.nodeCount()) {
        for (let a = t.length - 2; a > 0; --a)
          if (((i = t[a].dequeue()), i)) {
            o = o.concat(Nd(e, t, n, i, !0))
            break
          }
      }
    }
    return o
  }
  function Nd(e, t, n, o, r) {
    let s = r ? [] : void 0
    return (
      e.inEdges(o.v).forEach(i => {
        let a = e.edge(i),
          l = e.node(i.v)
        r && s.push({ v: i.v, w: i.w }), (l.out -= a), Md(t, n, l)
      }),
      e.outEdges(o.v).forEach(i => {
        let a = e.edge(i),
          l = i.w,
          c = e.node(l)
        ;(c.in -= a), Md(t, n, c)
      }),
      e.removeNode(o.v),
      s
    )
  }
  function p6(e, t) {
    let n = new l6(),
      o = 0,
      r = 0
    e.nodes().forEach(a => {
      n.setNode(a, { v: a, in: 0, out: 0 })
    }),
      e.edges().forEach(a => {
        let l = n.edge(a.v, a.w) || 0,
          c = t(a),
          u = l + c
        n.setEdge(a.v, a.w, u), (r = Math.max(r, (n.node(a.v).out += c))), (o = Math.max(o, (n.node(a.w).in += c)))
      })
    let s = h6(r + o + 3).map(() => new c6()),
      i = o + 1
    return (
      n.nodes().forEach(a => {
        Md(s, i, n.node(a))
      }),
      { graph: n, buckets: s, zeroIdx: i }
    )
  }
  function Md(e, t, n) {
    n.out ? (n.in ? e[n.out - n.in + t].enqueue(n) : e[e.length - 1].enqueue(n)) : e[0].enqueue(n)
  }
  function h6(e) {
    const t = []
    for (let n = 0; n < e; n++) t.push(n)
    return t
  }
  let $0 = gn.Graph
  var ft = {
    addBorderNode: E6,
    addDummyNode: ey,
    applyWithChunking: Bl,
    asNonCompoundGraph: m6,
    buildLayerMatrix: x6,
    intersectRect: v6,
    mapValues: P6,
    maxRank: ny,
    normalizeRanks: C6,
    notime: k6,
    partition: B6,
    pick: M6,
    predecessorWeights: b6,
    range: ry,
    removeEmptyRanks: w6,
    simplify: g6,
    successorWeights: y6,
    time: I6,
    uniqueId: oy,
    zipObject: Pd,
  }
  function ey(e, t, n, o) {
    let r
    do r = oy(o)
    while (e.hasNode(r))
    return (n.dummy = t), e.setNode(r, n), r
  }
  function g6(e) {
    let t = new $0().setGraph(e.graph())
    return (
      e.nodes().forEach(n => t.setNode(n, e.node(n))),
      e.edges().forEach(n => {
        let o = t.edge(n.v, n.w) || { weight: 0, minlen: 1 },
          r = e.edge(n)
        t.setEdge(n.v, n.w, { weight: o.weight + r.weight, minlen: Math.max(o.minlen, r.minlen) })
      }),
      t
    )
  }
  function m6(e) {
    let t = new $0({ multigraph: e.isMultigraph() }).setGraph(e.graph())
    return (
      e.nodes().forEach(n => {
        e.children(n).length || t.setNode(n, e.node(n))
      }),
      e.edges().forEach(n => {
        t.setEdge(n, e.edge(n))
      }),
      t
    )
  }
  function y6(e) {
    let t = e.nodes().map(n => {
      let o = {}
      return (
        e.outEdges(n).forEach(r => {
          o[r.w] = (o[r.w] || 0) + e.edge(r).weight
        }),
        o
      )
    })
    return Pd(e.nodes(), t)
  }
  function b6(e) {
    let t = e.nodes().map(n => {
      let o = {}
      return (
        e.inEdges(n).forEach(r => {
          o[r.v] = (o[r.v] || 0) + e.edge(r).weight
        }),
        o
      )
    })
    return Pd(e.nodes(), t)
  }
  function v6(e, t) {
    let n = e.x,
      o = e.y,
      r = t.x - n,
      s = t.y - o,
      i = e.width / 2,
      a = e.height / 2
    if (!r && !s) throw new Error('Not possible to find intersection inside of the rectangle')
    let l, c
    return Math.abs(s) * i > Math.abs(r) * a ? (s < 0 && (a = -a), (l = (a * r) / s), (c = a)) : (r < 0 && (i = -i), (l = i), (c = (i * s) / r)), { x: n + l, y: o + c }
  }
  function x6(e) {
    let t = ry(ny(e) + 1).map(() => [])
    return (
      e.nodes().forEach(n => {
        let o = e.node(n),
          r = o.rank
        r !== void 0 && (t[r][o.order] = n)
      }),
      t
    )
  }
  function C6(e) {
    let t = e.nodes().map(o => {
        let r = e.node(o).rank
        return r === void 0 ? Number.MAX_VALUE : r
      }),
      n = Bl(Math.min, t)
    e.nodes().forEach(o => {
      let r = e.node(o)
      Object.hasOwn(r, 'rank') && (r.rank -= n)
    })
  }
  function w6(e) {
    let t = e.nodes().map(i => e.node(i).rank),
      n = Bl(Math.min, t),
      o = []
    e.nodes().forEach(i => {
      let a = e.node(i).rank - n
      o[a] || (o[a] = []), o[a].push(i)
    })
    let r = 0,
      s = e.graph().nodeRankFactor
    Array.from(o).forEach((i, a) => {
      i === void 0 && a % s !== 0 ? --r : i !== void 0 && r && i.forEach(l => (e.node(l).rank += r))
    })
  }
  function E6(e, t, n, o) {
    let r = { width: 0, height: 0 }
    return arguments.length >= 4 && ((r.rank = n), (r.order = o)), ey(e, 'border', r, t)
  }
  function S6(e, t = ty) {
    const n = []
    for (let o = 0; o < e.length; o += t) {
      const r = e.slice(o, o + t)
      n.push(r)
    }
    return n
  }
  const ty = 65535
  function Bl(e, t) {
    if (t.length > ty) {
      const n = S6(t)
      return e.apply(
        null,
        n.map(o => e.apply(null, o))
      )
    } else return e.apply(null, t)
  }
  function ny(e) {
    const n = e.nodes().map(o => {
      let r = e.node(o).rank
      return r === void 0 ? Number.MIN_VALUE : r
    })
    return Bl(Math.max, n)
  }
  function B6(e, t) {
    let n = { lhs: [], rhs: [] }
    return (
      e.forEach(o => {
        t(o) ? n.lhs.push(o) : n.rhs.push(o)
      }),
      n
    )
  }
  function I6(e, t) {
    let n = Date.now()
    try {
      return t()
    } finally {
      console.log(e + ' time: ' + (Date.now() - n) + 'ms')
    }
  }
  function k6(e, t) {
    return t()
  }
  let N6 = 0
  function oy(e) {
    var t = ++N6
    return toString(e) + t
  }
  function ry(e, t, n = 1) {
    t == null && ((t = e), (e = 0))
    let o = s => s < t
    n < 0 && (o = s => t < s)
    const r = []
    for (let s = e; o(s); s += n) r.push(s)
    return r
  }
  function M6(e, t) {
    const n = {}
    for (const o of t) e[o] !== void 0 && (n[o] = e[o])
    return n
  }
  function P6(e, t) {
    let n = t
    return typeof t == 'string' && (n = o => o[t]), Object.entries(e).reduce((o, [r, s]) => ((o[r] = n(s, r)), o), {})
  }
  function Pd(e, t) {
    return e.reduce((n, o, r) => ((n[o] = t[r]), n), {})
  }
  let L6 = u6,
    T6 = ft.uniqueId
  var F6 = { run: D6, undo: Q6 }
  function D6(e) {
    ;(e.graph().acyclicer === 'greedy' ? L6(e, n(e)) : z6(e)).forEach(o => {
      let r = e.edge(o)
      e.removeEdge(o), (r.forwardName = o.name), (r.reversed = !0), e.setEdge(o.w, o.v, r, T6('rev'))
    })
    function n(o) {
      return r => o.edge(r).weight
    }
  }
  function z6(e) {
    let t = [],
      n = {},
      o = {}
    function r(s) {
      Object.hasOwn(o, s) ||
        ((o[s] = !0),
        (n[s] = !0),
        e.outEdges(s).forEach(i => {
          Object.hasOwn(n, i.w) ? t.push(i) : r(i.w)
        }),
        delete n[s])
    }
    return e.nodes().forEach(r), t
  }
  function Q6(e) {
    e.edges().forEach(t => {
      let n = e.edge(t)
      if (n.reversed) {
        e.removeEdge(t)
        let o = n.forwardName
        delete n.reversed, delete n.forwardName, e.setEdge(t.w, t.v, n, o)
      }
    })
  }
  let R6 = ft
  var O6 = { run: j6, undo: G6 }
  function j6(e) {
    ;(e.graph().dummyChains = []), e.edges().forEach(t => W6(e, t))
  }
  function W6(e, t) {
    let n = t.v,
      o = e.node(n).rank,
      r = t.w,
      s = e.node(r).rank,
      i = t.name,
      a = e.edge(t),
      l = a.labelRank
    if (s === o + 1) return
    e.removeEdge(t)
    let c, u, d
    for (d = 0, ++o; o < s; ++d, ++o)
      (a.points = []), (u = { width: 0, height: 0, edgeLabel: a, edgeObj: t, rank: o }), (c = R6.addDummyNode(e, 'edge', u, '_d')), o === l && ((u.width = a.width), (u.height = a.height), (u.dummy = 'edge-label'), (u.labelpos = a.labelpos)), e.setEdge(n, c, { weight: a.weight }, i), d === 0 && e.graph().dummyChains.push(c), (n = c)
    e.setEdge(n, r, { weight: a.weight }, i)
  }
  function G6(e) {
    e.graph().dummyChains.forEach(t => {
      let n = e.node(t),
        o = n.edgeLabel,
        r
      for (e.setEdge(n.edgeObj, o); n.dummy; ) (r = e.successors(t)[0]), e.removeNode(t), o.points.push({ x: n.x, y: n.y }), n.dummy === 'edge-label' && ((o.x = n.x), (o.y = n.y), (o.width = n.width), (o.height = n.height)), (t = r), (n = e.node(t))
    })
  }
  const { applyWithChunking: V6 } = ft
  var Il = { longestPath: X6, slack: Y6 }
  function X6(e) {
    var t = {}
    function n(o) {
      var r = e.node(o)
      if (Object.hasOwn(t, o)) return r.rank
      t[o] = !0
      let s = e.outEdges(o).map(a => (a == null ? Number.POSITIVE_INFINITY : n(a.w) - e.edge(a).minlen))
      var i = V6(Math.min, s)
      return i === Number.POSITIVE_INFINITY && (i = 0), (r.rank = i)
    }
    e.sources().forEach(n)
  }
  function Y6(e, t) {
    return e.node(t.w).rank - e.node(t.v).rank - e.edge(t).minlen
  }
  var H6 = gn.Graph,
    kl = Il.slack,
    sy = U6
  function U6(e) {
    var t = new H6({ directed: !1 }),
      n = e.nodes()[0],
      o = e.nodeCount()
    t.setNode(n, {})
    for (var r, s; K6(t, e) < o; ) (r = q6(t, e)), (s = t.hasNode(r.v) ? kl(e, r) : -kl(e, r)), Z6(t, e, s)
    return t
  }
  function K6(e, t) {
    function n(o) {
      t.nodeEdges(o).forEach(r => {
        var s = r.v,
          i = o === s ? r.w : s
        !e.hasNode(i) && !kl(t, r) && (e.setNode(i, {}), e.setEdge(o, i, {}), n(i))
      })
    }
    return e.nodes().forEach(n), e.nodeCount()
  }
  function q6(e, t) {
    return t.edges().reduce(
      (o, r) => {
        let s = Number.POSITIVE_INFINITY
        return e.hasNode(r.v) !== e.hasNode(r.w) && (s = kl(t, r)), s < o[0] ? [s, r] : o
      },
      [Number.POSITIVE_INFINITY, null]
    )[1]
  }
  function Z6(e, t, n) {
    e.nodes().forEach(o => (t.node(o).rank += n))
  }
  var J6 = sy,
    iy = Il.slack,
    _6 = Il.longestPath,
    $6 = gn.alg.preorder,
    e4 = gn.alg.postorder,
    t4 = ft.simplify,
    n4 = Ro
  ;(Ro.initLowLimValues = Td), (Ro.initCutValues = Ld), (Ro.calcCutValue = ay), (Ro.leaveEdge = cy), (Ro.enterEdge = uy), (Ro.exchangeEdges = dy)
  function Ro(e) {
    ;(e = t4(e)), _6(e)
    var t = J6(e)
    Td(t), Ld(t, e)
    for (var n, o; (n = cy(t)); ) (o = uy(t, e, n)), dy(t, e, n, o)
  }
  function Ld(e, t) {
    var n = e4(e, e.nodes())
    ;(n = n.slice(0, n.length - 1)), n.forEach(o => o4(e, t, o))
  }
  function o4(e, t, n) {
    var o = e.node(n),
      r = o.parent
    e.edge(n, r).cutvalue = ay(e, t, n)
  }
  function ay(e, t, n) {
    var o = e.node(n),
      r = o.parent,
      s = !0,
      i = t.edge(n, r),
      a = 0
    return (
      i || ((s = !1), (i = t.edge(r, n))),
      (a = i.weight),
      t.nodeEdges(n).forEach(l => {
        var c = l.v === n,
          u = c ? l.w : l.v
        if (u !== r) {
          var d = c === s,
            f = t.edge(l).weight
          if (((a += d ? f : -f), s4(e, n, u))) {
            var A = e.edge(n, u).cutvalue
            a += d ? -A : A
          }
        }
      }),
      a
    )
  }
  function Td(e, t) {
    arguments.length < 2 && (t = e.nodes()[0]), ly(e, {}, 1, t)
  }
  function ly(e, t, n, o, r) {
    var s = n,
      i = e.node(o)
    return (
      (t[o] = !0),
      e.neighbors(o).forEach(a => {
        Object.hasOwn(t, a) || (n = ly(e, t, n, a, o))
      }),
      (i.low = s),
      (i.lim = n++),
      r ? (i.parent = r) : delete i.parent,
      n
    )
  }
  function cy(e) {
    return e.edges().find(t => e.edge(t).cutvalue < 0)
  }
  function uy(e, t, n) {
    var o = n.v,
      r = n.w
    t.hasEdge(o, r) || ((o = n.w), (r = n.v))
    var s = e.node(o),
      i = e.node(r),
      a = s,
      l = !1
    s.lim > i.lim && ((a = i), (l = !0))
    var c = t.edges().filter(u => l === fy(e, e.node(u.v), a) && l !== fy(e, e.node(u.w), a))
    return c.reduce((u, d) => (iy(t, d) < iy(t, u) ? d : u))
  }
  function dy(e, t, n, o) {
    var r = n.v,
      s = n.w
    e.removeEdge(r, s), e.setEdge(o.v, o.w, {}), Td(e), Ld(e, t), r4(e, t)
  }
  function r4(e, t) {
    var n = e.nodes().find(r => !t.node(r).parent),
      o = $6(e, n)
    ;(o = o.slice(1)),
      o.forEach(r => {
        var s = e.node(r).parent,
          i = t.edge(r, s),
          a = !1
        i || ((i = t.edge(s, r)), (a = !0)), (t.node(r).rank = t.node(s).rank + (a ? i.minlen : -i.minlen))
      })
  }
  function s4(e, t, n) {
    return e.hasEdge(t, n)
  }
  function fy(e, t, n) {
    return n.low <= t.lim && t.lim <= n.lim
  }
  var i4 = Il,
    Ay = i4.longestPath,
    a4 = sy,
    l4 = n4,
    c4 = u4
  function u4(e) {
    switch (e.graph().ranker) {
      case 'network-simplex':
        py(e)
        break
      case 'tight-tree':
        f4(e)
        break
      case 'longest-path':
        d4(e)
        break
      default:
        py(e)
    }
  }
  var d4 = Ay
  function f4(e) {
    Ay(e), a4(e)
  }
  function py(e) {
    l4(e)
  }
  var A4 = p4
  function p4(e) {
    let t = g4(e)
    e.graph().dummyChains.forEach(n => {
      let o = e.node(n),
        r = o.edgeObj,
        s = h4(e, t, r.v, r.w),
        i = s.path,
        a = s.lca,
        l = 0,
        c = i[l],
        u = !0
      for (; n !== r.w; ) {
        if (((o = e.node(n)), u)) {
          for (; (c = i[l]) !== a && e.node(c).maxRank < o.rank; ) l++
          c === a && (u = !1)
        }
        if (!u) {
          for (; l < i.length - 1 && e.node((c = i[l + 1])).minRank <= o.rank; ) l++
          c = i[l]
        }
        e.setParent(n, c), (n = e.successors(n)[0])
      }
    })
  }
  function h4(e, t, n, o) {
    let r = [],
      s = [],
      i = Math.min(t[n].low, t[o].low),
      a = Math.max(t[n].lim, t[o].lim),
      l,
      c
    l = n
    do (l = e.parent(l)), r.push(l)
    while (l && (t[l].low > i || a > t[l].lim))
    for (c = l, l = o; (l = e.parent(l)) !== c; ) s.push(l)
    return { path: r.concat(s.reverse()), lca: c }
  }
  function g4(e) {
    let t = {},
      n = 0
    function o(r) {
      let s = n
      e.children(r).forEach(o), (t[r] = { low: s, lim: n++ })
    }
    return e.children().forEach(o), t
  }
  let Nl = ft
  var m4 = { run: y4, cleanup: x4 }
  function y4(e) {
    let t = Nl.addDummyNode(e, 'root', {}, '_root'),
      n = b4(e),
      o = Object.values(n),
      r = Nl.applyWithChunking(Math.max, o) - 1,
      s = 2 * r + 1
    ;(e.graph().nestingRoot = t), e.edges().forEach(a => (e.edge(a).minlen *= s))
    let i = v4(e) + 1
    e.children().forEach(a => hy(e, t, s, i, r, n, a)), (e.graph().nodeRankFactor = s)
  }
  function hy(e, t, n, o, r, s, i) {
    let a = e.children(i)
    if (!a.length) {
      i !== t && e.setEdge(t, i, { weight: 0, minlen: n })
      return
    }
    let l = Nl.addBorderNode(e, '_bt'),
      c = Nl.addBorderNode(e, '_bb'),
      u = e.node(i)
    e.setParent(l, i),
      (u.borderTop = l),
      e.setParent(c, i),
      (u.borderBottom = c),
      a.forEach(d => {
        hy(e, t, n, o, r, s, d)
        let f = e.node(d),
          A = f.borderTop ? f.borderTop : d,
          h = f.borderBottom ? f.borderBottom : d,
          g = f.borderTop ? o : 2 * o,
          x = A !== h ? 1 : r - s[i] + 1
        e.setEdge(l, A, { weight: g, minlen: x, nestingEdge: !0 }), e.setEdge(h, c, { weight: g, minlen: x, nestingEdge: !0 })
      }),
      e.parent(i) || e.setEdge(t, l, { weight: 0, minlen: r + s[i] })
  }
  function b4(e) {
    var t = {}
    function n(o, r) {
      var s = e.children(o)
      s && s.length && s.forEach(i => n(i, r + 1)), (t[o] = r)
    }
    return e.children().forEach(o => n(o, 1)), t
  }
  function v4(e) {
    return e.edges().reduce((t, n) => t + e.edge(n).weight, 0)
  }
  function x4(e) {
    var t = e.graph()
    e.removeNode(t.nestingRoot),
      delete t.nestingRoot,
      e.edges().forEach(n => {
        var o = e.edge(n)
        o.nestingEdge && e.removeEdge(n)
      })
  }
  let C4 = ft
  var w4 = E4
  function E4(e) {
    function t(n) {
      let o = e.children(n),
        r = e.node(n)
      if ((o.length && o.forEach(t), Object.hasOwn(r, 'minRank'))) {
        ;(r.borderLeft = []), (r.borderRight = [])
        for (let s = r.minRank, i = r.maxRank + 1; s < i; ++s) gy(e, 'borderLeft', '_bl', n, r, s), gy(e, 'borderRight', '_br', n, r, s)
      }
    }
    e.children().forEach(t)
  }
  function gy(e, t, n, o, r, s) {
    let i = { width: 0, height: 0, rank: s, borderType: t },
      a = r[t][s - 1],
      l = C4.addDummyNode(e, 'border', i, n)
    ;(r[t][s] = l), e.setParent(l, o), a && e.setEdge(a, l, { weight: 1 })
  }
  var S4 = { adjust: B4, undo: I4 }
  function B4(e) {
    let t = e.graph().rankdir.toLowerCase()
    ;(t === 'lr' || t === 'rl') && my(e)
  }
  function I4(e) {
    let t = e.graph().rankdir.toLowerCase()
    ;(t === 'bt' || t === 'rl') && k4(e), (t === 'lr' || t === 'rl') && (N4(e), my(e))
  }
  function my(e) {
    e.nodes().forEach(t => yy(e.node(t))), e.edges().forEach(t => yy(e.edge(t)))
  }
  function yy(e) {
    let t = e.width
    ;(e.width = e.height), (e.height = t)
  }
  function k4(e) {
    e.nodes().forEach(t => Fd(e.node(t))),
      e.edges().forEach(t => {
        let n = e.edge(t)
        n.points.forEach(Fd), Object.hasOwn(n, 'y') && Fd(n)
      })
  }
  function Fd(e) {
    e.y = -e.y
  }
  function N4(e) {
    e.nodes().forEach(t => Dd(e.node(t))),
      e.edges().forEach(t => {
        let n = e.edge(t)
        n.points.forEach(Dd), Object.hasOwn(n, 'x') && Dd(n)
      })
  }
  function Dd(e) {
    let t = e.x
    ;(e.x = e.y), (e.y = t)
  }
  let by = ft
  var M4 = P4
  function P4(e) {
    let t = {},
      n = e.nodes().filter(l => !e.children(l).length),
      o = n.map(l => e.node(l).rank),
      r = by.applyWithChunking(Math.max, o),
      s = by.range(r + 1).map(() => [])
    function i(l) {
      if (t[l]) return
      t[l] = !0
      let c = e.node(l)
      s[c.rank].push(l), e.successors(l).forEach(i)
    }
    return n.sort((l, c) => e.node(l).rank - e.node(c).rank).forEach(i), s
  }
  let L4 = ft.zipObject
  var T4 = F4
  function F4(e, t) {
    let n = 0
    for (let o = 1; o < t.length; ++o) n += D4(e, t[o - 1], t[o])
    return n
  }
  function D4(e, t, n) {
    let o = L4(
        n,
        n.map((c, u) => u)
      ),
      r = t.flatMap(c =>
        e
          .outEdges(c)
          .map(u => ({ pos: o[u.w], weight: e.edge(u).weight }))
          .sort((u, d) => u.pos - d.pos)
      ),
      s = 1
    for (; s < n.length; ) s <<= 1
    let i = 2 * s - 1
    s -= 1
    let a = new Array(i).fill(0),
      l = 0
    return (
      r.forEach(c => {
        let u = c.pos + s
        a[u] += c.weight
        let d = 0
        for (; u > 0; ) u % 2 && (d += a[u + 1]), (u = (u - 1) >> 1), (a[u] += c.weight)
        l += c.weight * d
      }),
      l
    )
  }
  var z4 = Q4
  function Q4(e, t = []) {
    return t.map(n => {
      let o = e.inEdges(n)
      if (o.length) {
        let r = o.reduce(
          (s, i) => {
            let a = e.edge(i),
              l = e.node(i.v)
            return { sum: s.sum + a.weight * l.order, weight: s.weight + a.weight }
          },
          { sum: 0, weight: 0 }
        )
        return { v: n, barycenter: r.sum / r.weight, weight: r.weight }
      } else return { v: n }
    })
  }
  let R4 = ft
  var O4 = j4
  function j4(e, t) {
    let n = {}
    e.forEach((r, s) => {
      let i = (n[r.v] = { indegree: 0, in: [], out: [], vs: [r.v], i: s })
      r.barycenter !== void 0 && ((i.barycenter = r.barycenter), (i.weight = r.weight))
    }),
      t.edges().forEach(r => {
        let s = n[r.v],
          i = n[r.w]
        s !== void 0 && i !== void 0 && (i.indegree++, s.out.push(n[r.w]))
      })
    let o = Object.values(n).filter(r => !r.indegree)
    return W4(o)
  }
  function W4(e) {
    let t = []
    function n(r) {
      return s => {
        s.merged || ((s.barycenter === void 0 || r.barycenter === void 0 || s.barycenter >= r.barycenter) && G4(r, s))
      }
    }
    function o(r) {
      return s => {
        s.in.push(r), --s.indegree === 0 && e.push(s)
      }
    }
    for (; e.length; ) {
      let r = e.pop()
      t.push(r), r.in.reverse().forEach(n(r)), r.out.forEach(o(r))
    }
    return t.filter(r => !r.merged).map(r => R4.pick(r, ['vs', 'i', 'barycenter', 'weight']))
  }
  function G4(e, t) {
    let n = 0,
      o = 0
    e.weight && ((n += e.barycenter * e.weight), (o += e.weight)), t.weight && ((n += t.barycenter * t.weight), (o += t.weight)), (e.vs = t.vs.concat(e.vs)), (e.barycenter = n / o), (e.weight = o), (e.i = Math.min(t.i, e.i)), (t.merged = !0)
  }
  let V4 = ft
  var X4 = Y4
  function Y4(e, t) {
    let n = V4.partition(e, u => Object.hasOwn(u, 'barycenter')),
      o = n.lhs,
      r = n.rhs.sort((u, d) => d.i - u.i),
      s = [],
      i = 0,
      a = 0,
      l = 0
    o.sort(H4(!!t)),
      (l = vy(s, r, l)),
      o.forEach(u => {
        ;(l += u.vs.length), s.push(u.vs), (i += u.barycenter * u.weight), (a += u.weight), (l = vy(s, r, l))
      })
    let c = { vs: s.flat(!0) }
    return a && ((c.barycenter = i / a), (c.weight = a)), c
  }
  function vy(e, t, n) {
    let o
    for (; t.length && (o = t[t.length - 1]).i <= n; ) t.pop(), e.push(o.vs), n++
    return n
  }
  function H4(e) {
    return (t, n) => (t.barycenter < n.barycenter ? -1 : t.barycenter > n.barycenter ? 1 : e ? n.i - t.i : t.i - n.i)
  }
  let U4 = z4,
    K4 = O4,
    q4 = X4
  var Z4 = xy
  function xy(e, t, n, o) {
    let r = e.children(t),
      s = e.node(t),
      i = s ? s.borderLeft : void 0,
      a = s ? s.borderRight : void 0,
      l = {}
    i && (r = r.filter(f => f !== i && f !== a))
    let c = U4(e, r)
    c.forEach(f => {
      if (e.children(f.v).length) {
        let A = xy(e, f.v, n, o)
        ;(l[f.v] = A), Object.hasOwn(A, 'barycenter') && _4(f, A)
      }
    })
    let u = K4(c, n)
    J4(u, l)
    let d = q4(u, o)
    if (i && ((d.vs = [i, d.vs, a].flat(!0)), e.predecessors(i).length)) {
      let f = e.node(e.predecessors(i)[0]),
        A = e.node(e.predecessors(a)[0])
      Object.hasOwn(d, 'barycenter') || ((d.barycenter = 0), (d.weight = 0)), (d.barycenter = (d.barycenter * d.weight + f.order + A.order) / (d.weight + 2)), (d.weight += 2)
    }
    return d
  }
  function J4(e, t) {
    e.forEach(n => {
      n.vs = n.vs.flatMap(o => (t[o] ? t[o].vs : o))
    })
  }
  function _4(e, t) {
    e.barycenter !== void 0 ? ((e.barycenter = (e.barycenter * e.weight + t.barycenter * t.weight) / (e.weight + t.weight)), (e.weight += t.weight)) : ((e.barycenter = t.barycenter), (e.weight = t.weight))
  }
  let $4 = gn.Graph,
    ej = ft
  var tj = nj
  function nj(e, t, n) {
    let o = oj(e),
      r = new $4({ compound: !0 }).setGraph({ root: o }).setDefaultNodeLabel(s => e.node(s))
    return (
      e.nodes().forEach(s => {
        let i = e.node(s),
          a = e.parent(s)
        ;(i.rank === t || (i.minRank <= t && t <= i.maxRank)) &&
          (r.setNode(s),
          r.setParent(s, a || o),
          e[n](s).forEach(l => {
            let c = l.v === s ? l.w : l.v,
              u = r.edge(c, s),
              d = u !== void 0 ? u.weight : 0
            r.setEdge(c, s, { weight: e.edge(l).weight + d })
          }),
          Object.hasOwn(i, 'minRank') && r.setNode(s, { borderLeft: i.borderLeft[t], borderRight: i.borderRight[t] }))
      }),
      r
    )
  }
  function oj(e) {
    for (var t; e.hasNode((t = ej.uniqueId('_root'))); );
    return t
  }
  var rj = sj
  function sj(e, t, n) {
    let o = {},
      r
    n.forEach(s => {
      let i = e.parent(s),
        a,
        l
      for (; i; ) {
        if (((a = e.parent(i)), a ? ((l = o[a]), (o[a] = i)) : ((l = r), (r = i)), l && l !== i)) {
          t.setEdge(l, i)
          return
        }
        i = a
      }
    })
  }
  let ij = M4,
    aj = T4,
    lj = Z4,
    cj = tj,
    uj = rj,
    dj = gn.Graph,
    Ml = ft
  var fj = Cy
  function Cy(e, t) {
    if (t && typeof t.customOrder == 'function') {
      t.customOrder(e, Cy)
      return
    }
    let n = Ml.maxRank(e),
      o = wy(e, Ml.range(1, n + 1), 'inEdges'),
      r = wy(e, Ml.range(n - 1, -1, -1), 'outEdges'),
      s = ij(e)
    if ((Ey(e, s), t && t.disableOptimalOrderHeuristic)) return
    let i = Number.POSITIVE_INFINITY,
      a
    for (let l = 0, c = 0; c < 4; ++l, ++c) {
      Aj(l % 2 ? o : r, l % 4 >= 2), (s = Ml.buildLayerMatrix(e))
      let u = aj(e, s)
      u < i && ((c = 0), (a = Object.assign({}, s)), (i = u))
    }
    Ey(e, a)
  }
  function wy(e, t, n) {
    return t.map(function (o) {
      return cj(e, o, n)
    })
  }
  function Aj(e, t) {
    let n = new dj()
    e.forEach(function (o) {
      let r = o.graph().root,
        s = lj(o, r, n, t)
      s.vs.forEach((i, a) => (o.node(i).order = a)), uj(o, n, s.vs)
    })
  }
  function Ey(e, t) {
    Object.values(t).forEach(n => n.forEach((o, r) => (e.node(o).order = r)))
  }
  let pj = gn.Graph,
    Vn = ft
  var hj = { positionX: yj, findType1Conflicts: Sy, findType2Conflicts: By, addConflict: zd, hasConflict: Iy, verticalAlignment: ky, horizontalCompaction: Ny, alignCoordinates: Py, findSmallestWidthAlignment: My, balance: Ly }
  function Sy(e, t) {
    let n = {}
    function o(r, s) {
      let i = 0,
        a = 0,
        l = r.length,
        c = s[s.length - 1]
      return (
        s.forEach((u, d) => {
          let f = gj(e, u),
            A = f ? e.node(f).order : l
          ;(f || u === c) &&
            (s.slice(a, d + 1).forEach(h => {
              e.predecessors(h).forEach(g => {
                let x = e.node(g),
                  m = x.order
                ;(m < i || A < m) && !(x.dummy && e.node(h).dummy) && zd(n, g, h)
              })
            }),
            (a = d + 1),
            (i = A))
        }),
        s
      )
    }
    return t.length && t.reduce(o), n
  }
  function By(e, t) {
    let n = {}
    function o(s, i, a, l, c) {
      let u
      Vn.range(i, a).forEach(d => {
        ;(u = s[d]),
          e.node(u).dummy &&
            e.predecessors(u).forEach(f => {
              let A = e.node(f)
              A.dummy && (A.order < l || A.order > c) && zd(n, f, u)
            })
      })
    }
    function r(s, i) {
      let a = -1,
        l,
        c = 0
      return (
        i.forEach((u, d) => {
          if (e.node(u).dummy === 'border') {
            let f = e.predecessors(u)
            f.length && ((l = e.node(f[0]).order), o(i, c, d, a, l), (c = d), (a = l))
          }
          o(i, c, i.length, l, s.length)
        }),
        i
      )
    }
    return t.length && t.reduce(r), n
  }
  function gj(e, t) {
    if (e.node(t).dummy) return e.predecessors(t).find(n => e.node(n).dummy)
  }
  function zd(e, t, n) {
    if (t > n) {
      let r = t
      ;(t = n), (n = r)
    }
    let o = e[t]
    o || (e[t] = o = {}), (o[n] = !0)
  }
  function Iy(e, t, n) {
    if (t > n) {
      let o = t
      ;(t = n), (n = o)
    }
    return !!e[t] && Object.hasOwn(e[t], n)
  }
  function ky(e, t, n, o) {
    let r = {},
      s = {},
      i = {}
    return (
      t.forEach(a => {
        a.forEach((l, c) => {
          ;(r[l] = l), (s[l] = l), (i[l] = c)
        })
      }),
      t.forEach(a => {
        let l = -1
        a.forEach(c => {
          let u = o(c)
          if (u.length) {
            u = u.sort((f, A) => i[f] - i[A])
            let d = (u.length - 1) / 2
            for (let f = Math.floor(d), A = Math.ceil(d); f <= A; ++f) {
              let h = u[f]
              s[c] === c && l < i[h] && !Iy(n, c, h) && ((s[h] = c), (s[c] = r[c] = r[h]), (l = i[h]))
            }
          }
        })
      }),
      { root: r, align: s }
    )
  }
  function Ny(e, t, n, o, r) {
    let s = {},
      i = mj(e, t, n, r),
      a = r ? 'borderLeft' : 'borderRight'
    function l(d, f) {
      let A = i.nodes(),
        h = A.pop(),
        g = {}
      for (; h; ) g[h] ? d(h) : ((g[h] = !0), A.push(h), (A = A.concat(f(h)))), (h = A.pop())
    }
    function c(d) {
      s[d] = i.inEdges(d).reduce((f, A) => Math.max(f, s[A.v] + i.edge(A)), 0)
    }
    function u(d) {
      let f = i.outEdges(d).reduce((h, g) => Math.min(h, s[g.w] - i.edge(g)), Number.POSITIVE_INFINITY),
        A = e.node(d)
      f !== Number.POSITIVE_INFINITY && A.borderType !== a && (s[d] = Math.max(s[d], f))
    }
    return l(c, i.predecessors.bind(i)), l(u, i.successors.bind(i)), Object.keys(o).forEach(d => (s[d] = s[n[d]])), s
  }
  function mj(e, t, n, o) {
    let r = new pj(),
      s = e.graph(),
      i = bj(s.nodesep, s.edgesep, o)
    return (
      t.forEach(a => {
        let l
        a.forEach(c => {
          let u = n[c]
          if ((r.setNode(u), l)) {
            var d = n[l],
              f = r.edge(d, u)
            r.setEdge(d, u, Math.max(i(e, c, l), f || 0))
          }
          l = c
        })
      }),
      r
    )
  }
  function My(e, t) {
    return Object.values(t).reduce(
      (n, o) => {
        let r = Number.NEGATIVE_INFINITY,
          s = Number.POSITIVE_INFINITY
        Object.entries(o).forEach(([a, l]) => {
          let c = vj(e, a) / 2
          ;(r = Math.max(l + c, r)), (s = Math.min(l - c, s))
        })
        const i = r - s
        return i < n[0] && (n = [i, o]), n
      },
      [Number.POSITIVE_INFINITY, null]
    )[1]
  }
  function Py(e, t) {
    let n = Object.values(t),
      o = Vn.applyWithChunking(Math.min, n),
      r = Vn.applyWithChunking(Math.max, n)
    ;['u', 'd'].forEach(s => {
      ;['l', 'r'].forEach(i => {
        let a = s + i,
          l = e[a]
        if (l === t) return
        let c = Object.values(l),
          u = o - Vn.applyWithChunking(Math.min, c)
        i !== 'l' && (u = r - Vn.applyWithChunking(Math.max, c)), u && (e[a] = Vn.mapValues(l, d => d + u))
      })
    })
  }
  function Ly(e, t) {
    return Vn.mapValues(e.ul, (n, o) => {
      if (t) return e[t.toLowerCase()][o]
      {
        let r = Object.values(e)
          .map(s => s[o])
          .sort((s, i) => s - i)
        return (r[1] + r[2]) / 2
      }
    })
  }
  function yj(e) {
    let t = Vn.buildLayerMatrix(e),
      n = Object.assign(Sy(e, t), By(e, t)),
      o = {},
      r
    ;['u', 'd'].forEach(i => {
      ;(r = i === 'u' ? t : Object.values(t).reverse()),
        ['l', 'r'].forEach(a => {
          a === 'r' && (r = r.map(d => Object.values(d).reverse()))
          let l = (i === 'u' ? e.predecessors : e.successors).bind(e),
            c = ky(e, r, n, l),
            u = Ny(e, r, c.root, c.align, a === 'r')
          a === 'r' && (u = Vn.mapValues(u, d => -d)), (o[i + a] = u)
        })
    })
    let s = My(e, o)
    return Py(o, s), Ly(o, e.graph().align)
  }
  function bj(e, t, n) {
    return (o, r, s) => {
      let i = o.node(r),
        a = o.node(s),
        l = 0,
        c
      if (((l += i.width / 2), Object.hasOwn(i, 'labelpos')))
        switch (i.labelpos.toLowerCase()) {
          case 'l':
            c = -i.width / 2
            break
          case 'r':
            c = i.width / 2
            break
        }
      if ((c && (l += n ? c : -c), (c = 0), (l += (i.dummy ? t : e) / 2), (l += (a.dummy ? t : e) / 2), (l += a.width / 2), Object.hasOwn(a, 'labelpos')))
        switch (a.labelpos.toLowerCase()) {
          case 'l':
            c = a.width / 2
            break
          case 'r':
            c = -a.width / 2
            break
        }
      return c && (l += n ? c : -c), (c = 0), l
    }
  }
  function vj(e, t) {
    return e.node(t).width
  }
  let Ty = ft,
    xj = hj.positionX
  var Cj = wj
  function wj(e) {
    ;(e = Ty.asNonCompoundGraph(e)), Ej(e), Object.entries(xj(e)).forEach(([t, n]) => (e.node(t).x = n))
  }
  function Ej(e) {
    let t = Ty.buildLayerMatrix(e),
      n = e.graph().ranksep,
      o = 0
    t.forEach(r => {
      const s = r.reduce((i, a) => {
        const l = e.node(a).height
        return i > l ? i : l
      }, 0)
      r.forEach(i => (e.node(i).y = o + s / 2)), (o += s + n)
    })
  }
  let Fy = F6,
    Dy = O6,
    Sj = c4,
    Bj = ft.normalizeRanks,
    Ij = A4,
    kj = ft.removeEmptyRanks,
    zy = m4,
    Nj = w4,
    Qy = S4,
    Mj = fj,
    Pj = Cj,
    en = ft,
    Lj = gn.Graph
  var Tj = Fj
  function Fj(e, t) {
    let n = t && t.debugTiming ? en.time : en.notime
    n('layout', () => {
      let o = n('  buildLayoutGraph', () => Xj(e))
      n('  runLayout', () => Dj(o, n, t)), n('  updateInputGraph', () => zj(e, o))
    })
  }
  function Dj(e, t, n) {
    t('    makeSpaceForEdgeLabels', () => Yj(e)),
      t('    removeSelfEdges', () => eW(e)),
      t('    acyclic', () => Fy.run(e)),
      t('    nestingGraph.run', () => zy.run(e)),
      t('    rank', () => Sj(en.asNonCompoundGraph(e))),
      t('    injectEdgeLabelProxies', () => Hj(e)),
      t('    removeEmptyRanks', () => kj(e)),
      t('    nestingGraph.cleanup', () => zy.cleanup(e)),
      t('    normalizeRanks', () => Bj(e)),
      t('    assignRankMinMax', () => Uj(e)),
      t('    removeEdgeLabelProxies', () => Kj(e)),
      t('    normalize.run', () => Dy.run(e)),
      t('    parentDummyChains', () => Ij(e)),
      t('    addBorderSegments', () => Nj(e)),
      t('    order', () => Mj(e, n)),
      t('    insertSelfEdges', () => tW(e)),
      t('    adjustCoordinateSystem', () => Qy.adjust(e)),
      t('    position', () => Pj(e)),
      t('    positionSelfEdges', () => nW(e)),
      t('    removeBorderNodes', () => $j(e)),
      t('    normalize.undo', () => Dy.undo(e)),
      t('    fixupEdgeLabelCoords', () => Jj(e)),
      t('    undoCoordinateSystem', () => Qy.undo(e)),
      t('    translateGraph', () => qj(e)),
      t('    assignNodeIntersects', () => Zj(e)),
      t('    reversePoints', () => _j(e)),
      t('    acyclic.undo', () => Fy.undo(e))
  }
  function zj(e, t) {
    e.nodes().forEach(n => {
      let o = e.node(n),
        r = t.node(n)
      o && ((o.x = r.x), (o.y = r.y), (o.rank = r.rank), t.children(n).length && ((o.width = r.width), (o.height = r.height)))
    }),
      e.edges().forEach(n => {
        let o = e.edge(n),
          r = t.edge(n)
        ;(o.points = r.points), Object.hasOwn(r, 'x') && ((o.x = r.x), (o.y = r.y))
      }),
      (e.graph().width = t.graph().width),
      (e.graph().height = t.graph().height)
  }
  let Qj = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy'],
    Rj = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' },
    Oj = ['acyclicer', 'ranker', 'rankdir', 'align'],
    jj = ['width', 'height'],
    Ry = { width: 0, height: 0 },
    Wj = ['minlen', 'weight', 'width', 'height', 'labeloffset'],
    Gj = { minlen: 1, weight: 1, width: 0, height: 0, labeloffset: 10, labelpos: 'r' },
    Vj = ['labelpos']
  function Xj(e) {
    let t = new Lj({ multigraph: !0, compound: !0 }),
      n = Rd(e.graph())
    return (
      t.setGraph(Object.assign({}, Rj, Qd(n, Qj), en.pick(n, Oj))),
      e.nodes().forEach(o => {
        let r = Rd(e.node(o))
        const s = Qd(r, jj)
        Object.keys(Ry).forEach(i => {
          s[i] === void 0 && (s[i] = Ry[i])
        }),
          t.setNode(o, s),
          t.setParent(o, e.parent(o))
      }),
      e.edges().forEach(o => {
        let r = Rd(e.edge(o))
        t.setEdge(o, Object.assign({}, Gj, Qd(r, Wj), en.pick(r, Vj)))
      }),
      t
    )
  }
  function Yj(e) {
    let t = e.graph()
    ;(t.ranksep /= 2),
      e.edges().forEach(n => {
        let o = e.edge(n)
        ;(o.minlen *= 2), o.labelpos.toLowerCase() !== 'c' && (t.rankdir === 'TB' || t.rankdir === 'BT' ? (o.width += o.labeloffset) : (o.height += o.labeloffset))
      })
  }
  function Hj(e) {
    e.edges().forEach(t => {
      let n = e.edge(t)
      if (n.width && n.height) {
        let o = e.node(t.v),
          s = { rank: (e.node(t.w).rank - o.rank) / 2 + o.rank, e: t }
        en.addDummyNode(e, 'edge-proxy', s, '_ep')
      }
    })
  }
  function Uj(e) {
    let t = 0
    e.nodes().forEach(n => {
      let o = e.node(n)
      o.borderTop && ((o.minRank = e.node(o.borderTop).rank), (o.maxRank = e.node(o.borderBottom).rank), (t = Math.max(t, o.maxRank)))
    }),
      (e.graph().maxRank = t)
  }
  function Kj(e) {
    e.nodes().forEach(t => {
      let n = e.node(t)
      n.dummy === 'edge-proxy' && ((e.edge(n.e).labelRank = n.rank), e.removeNode(t))
    })
  }
  function qj(e) {
    let t = Number.POSITIVE_INFINITY,
      n = 0,
      o = Number.POSITIVE_INFINITY,
      r = 0,
      s = e.graph(),
      i = s.marginx || 0,
      a = s.marginy || 0
    function l(c) {
      let u = c.x,
        d = c.y,
        f = c.width,
        A = c.height
      ;(t = Math.min(t, u - f / 2)), (n = Math.max(n, u + f / 2)), (o = Math.min(o, d - A / 2)), (r = Math.max(r, d + A / 2))
    }
    e.nodes().forEach(c => l(e.node(c))),
      e.edges().forEach(c => {
        let u = e.edge(c)
        Object.hasOwn(u, 'x') && l(u)
      }),
      (t -= i),
      (o -= a),
      e.nodes().forEach(c => {
        let u = e.node(c)
        ;(u.x -= t), (u.y -= o)
      }),
      e.edges().forEach(c => {
        let u = e.edge(c)
        u.points.forEach(d => {
          ;(d.x -= t), (d.y -= o)
        }),
          Object.hasOwn(u, 'x') && (u.x -= t),
          Object.hasOwn(u, 'y') && (u.y -= o)
      }),
      (s.width = n - t + i),
      (s.height = r - o + a)
  }
  function Zj(e) {
    e.edges().forEach(t => {
      let n = e.edge(t),
        o = e.node(t.v),
        r = e.node(t.w),
        s,
        i
      n.points ? ((s = n.points[0]), (i = n.points[n.points.length - 1])) : ((n.points = []), (s = r), (i = o)), n.points.unshift(en.intersectRect(o, s)), n.points.push(en.intersectRect(r, i))
    })
  }
  function Jj(e) {
    e.edges().forEach(t => {
      let n = e.edge(t)
      if (Object.hasOwn(n, 'x'))
        switch (((n.labelpos === 'l' || n.labelpos === 'r') && (n.width -= n.labeloffset), n.labelpos)) {
          case 'l':
            n.x -= n.width / 2 + n.labeloffset
            break
          case 'r':
            n.x += n.width / 2 + n.labeloffset
            break
        }
    })
  }
  function _j(e) {
    e.edges().forEach(t => {
      let n = e.edge(t)
      n.reversed && n.points.reverse()
    })
  }
  function $j(e) {
    e.nodes().forEach(t => {
      if (e.children(t).length) {
        let n = e.node(t),
          o = e.node(n.borderTop),
          r = e.node(n.borderBottom),
          s = e.node(n.borderLeft[n.borderLeft.length - 1]),
          i = e.node(n.borderRight[n.borderRight.length - 1])
        ;(n.width = Math.abs(i.x - s.x)), (n.height = Math.abs(r.y - o.y)), (n.x = s.x + n.width / 2), (n.y = o.y + n.height / 2)
      }
    }),
      e.nodes().forEach(t => {
        e.node(t).dummy === 'border' && e.removeNode(t)
      })
  }
  function eW(e) {
    e.edges().forEach(t => {
      if (t.v === t.w) {
        var n = e.node(t.v)
        n.selfEdges || (n.selfEdges = []), n.selfEdges.push({ e: t, label: e.edge(t) }), e.removeEdge(t)
      }
    })
  }
  function tW(e) {
    var t = en.buildLayerMatrix(e)
    t.forEach(n => {
      var o = 0
      n.forEach((r, s) => {
        var i = e.node(r)
        ;(i.order = s + o),
          (i.selfEdges || []).forEach(a => {
            en.addDummyNode(e, 'selfedge', { width: a.label.width, height: a.label.height, rank: i.rank, order: s + ++o, e: a.e, label: a.label }, '_se')
          }),
          delete i.selfEdges
      })
    })
  }
  function nW(e) {
    e.nodes().forEach(t => {
      var n = e.node(t)
      if (n.dummy === 'selfedge') {
        var o = e.node(n.e.v),
          r = o.x + o.width / 2,
          s = o.y,
          i = n.x - r,
          a = o.height / 2
        e.setEdge(n.e, n.label),
          e.removeNode(t),
          (n.label.points = [
            { x: r + (2 * i) / 3, y: s - a },
            { x: r + (5 * i) / 6, y: s - a },
            { x: r + i, y: s },
            { x: r + (5 * i) / 6, y: s + a },
            { x: r + (2 * i) / 3, y: s + a },
          ]),
          (n.label.x = n.x),
          (n.label.y = n.y)
      }
    })
  }
  function Qd(e, t) {
    return en.mapValues(en.pick(e, t), Number)
  }
  function Rd(e) {
    var t = {}
    return (
      e &&
        Object.entries(e).forEach(([n, o]) => {
          typeof n == 'string' && (n = n.toLowerCase()), (t[n] = o)
        }),
      t
    )
  }
  let oW = ft,
    rW = gn.Graph
  var sW = { debugOrdering: iW }
  function iW(e) {
    let t = oW.buildLayerMatrix(e),
      n = new rW({ compound: !0, multigraph: !0 }).setGraph({})
    return (
      e.nodes().forEach(o => {
        n.setNode(o, { label: o }), n.setParent(o, 'layer' + e.node(o).rank)
      }),
      e.edges().forEach(o => n.setEdge(o.v, o.w, {}, o.name)),
      t.forEach((o, r) => {
        let s = 'layer' + r
        n.setNode(s, { rank: 'same' }), o.reduce((i, a) => (n.setEdge(i, a, { style: 'invis' }), a))
      }),
      n
    )
  }
  var aW = '1.1.4',
    lW = { graphlib: gn, layout: Tj, debug: sW, util: { time: ft.time, notime: ft.notime }, version: aW }
  const Oy = $d(lW),
    jy = C.createContext({
      nodes: R0,
      edges: O0,
      flowDirection: pn.vertical,
      viewMode: no.enhanced,
      editMode: Gn.unlocked,
      changesEnabled: !1,
      horizontalHelperLine: void 0,
      verticalHelperLine: void 0,
      setNodes: () => {},
      setEdges: () => {},
      setFlowDirection: () => {},
      setViewMode: () => {},
      setEditMode: () => {},
      setHorizontalHelperLine: () => {},
      setVerticalHelperLine: () => {},
      onNodesChange: () => {},
      onEdgesChange: () => {},
      onLayout: () => {},
      takeSnapshot: () => {},
    }),
    Pr = new Oy.graphlib.Graph()
  Pr.setDefaultEdgeLabel(() => ({}))
  const Wy = (e, t, n = flowDireflowDirectionMapction.vertical) => {
      const o = n === pn.horizontal
      return (
        Pr.setGraph({ rankdir: n }),
        e.forEach(s => {
          Pr.setNode(s.id, { width: s.measured.width, height: s.measured.height })
        }),
        t.forEach(s => {
          Pr.setEdge(s.source, s.target)
        }),
        Oy.layout(Pr),
        {
          nodes: e.map(s => {
            const i = Pr.node(s.id)
            return { ...s, targetPosition: o ? 'left' : 'top', sourcePosition: o ? 'right' : 'bottom', position: { x: i.x - s.measured.width / 2, y: i.y - s.measured.height / 2 } }
          }),
          edges: t,
        }
      )
    },
    { nodes: cW, edges: uW } = Wy(R0, O0, pn.vertical),
    dW = ({ children: e }) => {
      const {
          nodeState: [t, n, o],
          edgeState: [r, s, i],
          viewModeState: [a, l],
          editModeState: [c, u],
          horizontalHelperLineState: [d, f],
          verticalHelperLineState: [A, h],
          history: { undo: g, redo: x, takeSnapshot: m },
        } = EF({ nodes: cW, edges: uW, viewMode: no.enhanced, editMode: Gn.unlocked, stateId: 'initial-state' }),
        [v, y] = C.useState(pn.vertical),
        { cut: b, copy: w, paste: k } = NF(),
        E = (...Q) => {
          m(), b(...Q)
        },
        P = (...Q) => {
          m(), k(...Q)
        }
      $u(['Meta+x', 'Control+x'], E), $u(['Meta+c', 'Control+c'], w), $u(['Meta+v', 'Control+v'], P)
      const T = C.useCallback(
        Q => {
          y(Q)
          const { nodes: R, edges: S } = Wy(t, r, Q)
          n([...R]), s([...S])
        },
        [t, r, n, s]
      )
      Cm(['Ctrl', 'Z'], g), Cm(['Ctrl', 'Y'], x)
      const F = C.useMemo(() => c === Gn.unlocked, [c]),
        D = C.useMemo(
          () => ({
            nodes: t,
            edges: r,
            flowDirection: v,
            viewMode: a,
            editMode: c,
            horizontalHelperLine: d,
            verticalHelperLine: A,
            setNodes: n,
            setEdges: s,
            setFlowDirection: y,
            setViewMode: l,
            setEditMode: u,
            setHorizontalHelperLine: f,
            setVerticalHelperLine: h,
            onNodesChange: o,
            onEdgesChange: i,
            onLayout: T,
            takeSnapshot: m,
            changesEnabled: F,
          }),
          [t, r, v, a, c, d, A, n, s, l, u, f, h, o, i, T, m, F]
        )
      return p.jsx(jy.Provider, { value: D, children: e })
    },
    oo = () => C.useContext(jy),
    fW = j('div')`
  .react-flow__handle {
    z-index: 30;
  }

  .react-flow__handle.target {
    background-color: ${({ theme: e }) => e.palette.green[300]};
  }

  .react-flow__handle.source {
    background-color: ${({ theme: e }) => e.palette.red[300]};
  }
`,
    AW = ({ children: e }) => p.jsx(fW, { children: e }),
    Od = e => p.jsx(oS, { className: e.className, ...e, style: { maxWidth: 'none', ...e.style } }),
    Gy = e => p.jsx(lS, { ...e }),
    Mt = e => p.jsx(YA, { ...e }),
    pW = e => p.jsx(DS, { ...e }),
    hW = ({ flexDirection: e = 'row', ...t }) => p.jsx(pW, { flexDirection: e, ...t }),
    gW = j('form')`
  width: 450px;
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 0 24px 16px;
`,
    mW = j(Mt)`
  width: 100%;
`,
    yW = j(hW)`
  gap: 20px;
`,
    Hs = e => p.jsx(kp, { ...e }),
    bW = 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(135deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(135deg, transparent 75%, #ccc 75%) /*! @noflip */',
    vW = 'linear-gradient(to top, #000000, transparent), linear-gradient(to right, #ffffff, transparent) /*! @noflip */',
    xW = { Button: j(YA)(() => ({ backgroundSize: '8px 8px', backgroundPosition: '0 0, 4px 0, 4px -4px, 0px 4px', transition: 'none', boxShadow: '0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08)', border: 0, borderRadius: 4, width: '24px', aspectRatio: '1 / 1', height: '24px', minWidth: 0 })) },
    CW = e => {
      const { bgColor: t, className: n, disablePopover: o, isBgColorValid: r, ...s } = e
      return p.jsx(xW.Button, { disableTouchRipple: !0, style: { backgroundColor: r ? t : void 0, backgroundImage: r ? void 0 : bW, cursor: o ? 'default' : void 0 }, className: `MuiColorInput-Button ${n || ''}`, variant: 'text', disableElevation: !1, ...s })
    },
    wW = { Container: j('div')(() => ({ width: 300, padding: 8 })) },
    EW = ({ children: e, className: t, position: n = 'start', ...o }) =>
      p.jsx(gp, { className: `MuiColorInput-Popover ${t || ''}`, anchorOrigin: { vertical: 'bottom', horizontal: n === 'start' ? 'left' : 'right' }, transformOrigin: { vertical: 'top', horizontal: n === 'start' ? 'left' : 'right' }, ...o, children: p.jsx(wW.Container, { children: e }) }),
    SW = {
      Slider: j(Ip, { shouldForwardProp: e => e !== '$rgbaFrom' && e !== '$rgbaTo' })(() => ({
        height: 8,
        '& .MuiSlider-rail': { opacity: 1, background: 'linear-gradient(to right, rgba(var(--rgb-r), var(--rgb-g), var(--rgb-b), 0) 0%, rgba(var(--rgb-r), var(--rgb-g), var(--rgb-b), 1) 100%)' },
        '& .MuiSlider-track': { color: 'transparent', border: 0 },
        '& .MuiSlider-thumb': { backgroundColor: '#ffffff', border: '3px solid currentColor' },
      })),
    },
    BW = e => {
      const { rgbColor: t, style: n, className: o, ...r } = e,
        s = { '--rgb-r': t.r, '--rgb-g': t.g, '--rgb-b': t.b, ...n }
      return p.jsx(SW.Slider, { className: `MuiColorInput-AlphaSlider ${o || ''}`, style: s, ...r })
    },
    Pl = { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' },
    IW = { ArrowUp: { type: 'hsvV', value: 1 }, ArrowDown: { type: 'hsvV', value: -1 }, ArrowLeft: { type: 'hsvS', value: -1 }, ArrowRight: { type: 'hsvS', value: 1 } }
  function kW(e) {
    return e === Pl.up || e === Pl.down || e === Pl.left || e === Pl.right
  }
  function Ll(e, t, n) {
    return Math.max(t, Math.min(e, n))
  }
  function Vy(e) {
    return typeof e == 'number'
  }
  function Xy(e, t, n) {
    const o = e.toLocaleString('en', { useGrouping: !1, minimumFractionDigits: t, maximumFractionDigits: n })
    return Number(o)
  }
  function NW(e, t, n) {
    const o = e.getBoundingClientRect(),
      r = t - o.left,
      s = n - o.top
    return { x: Ll(r / o.width, 0, 1), y: Ll(1 - s / o.height, 0, 1) }
  }
  function MW(e) {
    const t = C.useRef()
    return (
      (t.current = e),
      C.useCallback((...n) => {
        var o
        return (o = t.current) == null ? void 0 : o.call(t, ...n)
      }, [])
    )
  }
  const Yy = {
      Space: j('div')(() => ({ width: '100%', height: '180px', boxSizing: 'border-box', outline: 0, position: 'relative', backgroundImage: vW })),
      Thumb: j('div')(() => ({
        position: 'absolute',
        border: '3px solid #ffffff',
        borderRadius: '50%',
        width: '20px',
        height: '20px',
        marginLeft: '-10px /*! @noflip */',
        marginBottom: '-10px /*! @noflip */',
        outline: 0,
        boxSizing: 'border-box',
        willChange: 'left, bottom',
        transition: 'box-shadow 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms',
        '&:hover': { boxShadow: '0px 0px 0px 4px rgba(255 255 255 / 0.16)' },
        '&.MuiColorInput-Thumb-active': { boxShadow: '0px 0px 0px 8px rgba(255 255 255 / 0.16)' },
        '@media (hover: none)': { boxShadow: 'none' },
      })),
    },
    PW = e => {
      const { hsv: t, onChange: n, currentHue: o } = e,
        r = C.useRef(!1),
        s = C.useRef(null),
        [i, a] = C.useState(!1),
        l = MW((g, x) => {
          if (!s.current) return
          const { x: m, y: v } = NW(s.current, g, x)
          n({ s: m, v }), s.current && document.activeElement !== s.current && s.current.focus()
        }),
        c = C.useCallback(() => {
          r.current && ((r.current = !1), a(!1))
        }, []),
        u = C.useCallback(g => {
          r.current && l(g.clientX, g.clientY)
        }, [])
      C.useEffect(
        () => (
          document.addEventListener('pointermove', u, !1),
          document.addEventListener('pointerup', c, !1),
          () => {
            document.removeEventListener('pointermove', u, !1), document.removeEventListener('pointerup', c, !1)
          }
        ),
        [c, u]
      )
      const d = g => {
          g.preventDefault(), (r.current = !0), l(g.clientX, g.clientY), a(!0)
        },
        f = g => {
          if (kW(g.key)) {
            g.preventDefault()
            const { type: x, value: m } = IW[g.key],
              v = g.shiftKey ? 10 : 1,
              y = x === 'hsvS' ? t.s : t.v,
              b = Ll(y + m * v * 0.01, 0, 1)
            a(!0), n({ s: x === 'hsvS' ? b : t.s, v: x === 'hsvV' ? b : t.v })
          }
        },
        A = t.s * 100,
        h = t.v * 100
      return p.jsx(Yy.Space, {
        onPointerDown: d,
        ref: s,
        className: 'MuiColorInput-ColorSpace',
        style: { backgroundColor: `hsl(${o} 100% 50%)`, touchAction: 'none' },
        role: 'slider',
        'aria-valuetext': `Saturation ${Xy(A, 0, 0)}%, Brightness ${Xy(h, 0, 0)}%`,
        onKeyDown: f,
        tabIndex: 0,
        children: p.jsx(Yy.Thumb, { 'aria-label': 'Color space thumb', className: i ? 'MuiColorInput-Thumb-active' : '', style: { left: `${A}%`, bottom: `${h}%` } }),
      })
    },
    LW = {
      Slider: j(Ip)(() => ({
        height: 8,
        '& .MuiSlider-rail': { opacity: 1, background: 'linear-gradient(to right, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%) /*! @noflip */' },
        '& .MuiSlider-track': { color: 'transparent', border: 0 },
        '& .MuiSlider-thumb': { backgroundColor: '#ffffff', border: '3px solid currentColor' },
      })),
    },
    TW = e => {
      const { className: t, ...n } = e
      return p.jsx(LW.Slider, { className: `MuiColorInput-HueSlider ${t || ''}`, ...n })
    }
  function FW(e) {
    return typeof e == 'string'
  }
  function Ct(e, t) {
    DW(e) && (e = '100%')
    const n = zW(e)
    return (e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e)))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? (e = (e < 0 ? (e % t) + t : e % t) / parseFloat(String(t))) : (e = (e % t) / parseFloat(String(t))), e)
  }
  function Tl(e) {
    return Math.min(1, Math.max(0, e))
  }
  function DW(e) {
    return typeof e == 'string' && e.indexOf('.') !== -1 && parseFloat(e) === 1
  }
  function zW(e) {
    return typeof e == 'string' && e.indexOf('%') !== -1
  }
  function Hy(e) {
    return (e = parseFloat(e)), (isNaN(e) || e < 0 || e > 1) && (e = 1), e
  }
  function Fl(e) {
    return Number(e) <= 1 ? `${Number(e) * 100}%` : e
  }
  function Oo(e) {
    return e.length === 1 ? '0' + e : String(e)
  }
  function QW(e, t, n) {
    return { r: Ct(e, 255) * 255, g: Ct(t, 255) * 255, b: Ct(n, 255) * 255 }
  }
  function Uy(e, t, n) {
    ;(e = Ct(e, 255)), (t = Ct(t, 255)), (n = Ct(n, 255))
    const o = Math.max(e, t, n),
      r = Math.min(e, t, n)
    let s = 0,
      i = 0
    const a = (o + r) / 2
    if (o === r) (i = 0), (s = 0)
    else {
      const l = o - r
      switch (((i = a > 0.5 ? l / (2 - o - r) : l / (o + r)), o)) {
        case e:
          s = (t - n) / l + (t < n ? 6 : 0)
          break
        case t:
          s = (n - e) / l + 2
          break
        case n:
          s = (e - t) / l + 4
          break
      }
      s /= 6
    }
    return { h: s, s: i, l: a }
  }
  function jd(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
  }
  function RW(e, t, n) {
    let o, r, s
    if (((e = Ct(e, 360)), (t = Ct(t, 100)), (n = Ct(n, 100)), t === 0)) (r = n), (s = n), (o = n)
    else {
      const i = n < 0.5 ? n * (1 + t) : n + t - n * t,
        a = 2 * n - i
      ;(o = jd(a, i, e + 1 / 3)), (r = jd(a, i, e)), (s = jd(a, i, e - 1 / 3))
    }
    return { r: o * 255, g: r * 255, b: s * 255 }
  }
  function Ky(e, t, n) {
    ;(e = Ct(e, 255)), (t = Ct(t, 255)), (n = Ct(n, 255))
    const o = Math.max(e, t, n),
      r = Math.min(e, t, n)
    let s = 0
    const i = o,
      a = o - r,
      l = o === 0 ? 0 : a / o
    if (o === r) s = 0
    else {
      switch (o) {
        case e:
          s = (t - n) / a + (t < n ? 6 : 0)
          break
        case t:
          s = (n - e) / a + 2
          break
        case n:
          s = (e - t) / a + 4
          break
      }
      s /= 6
    }
    return { h: s, s: l, v: i }
  }
  function OW(e, t, n) {
    ;(e = Ct(e, 360) * 6), (t = Ct(t, 100)), (n = Ct(n, 100))
    const o = Math.floor(e),
      r = e - o,
      s = n * (1 - t),
      i = n * (1 - r * t),
      a = n * (1 - (1 - r) * t),
      l = o % 6,
      c = [n, i, s, s, a, n][l],
      u = [a, n, n, i, s, s][l],
      d = [s, s, a, n, n, i][l]
    return { r: c * 255, g: u * 255, b: d * 255 }
  }
  function qy(e, t, n, o) {
    const r = [Oo(Math.round(e).toString(16)), Oo(Math.round(t).toString(16)), Oo(Math.round(n).toString(16))]
    return o && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join('')
  }
  function jW(e, t, n, o, r) {
    const s = [Oo(Math.round(e).toString(16)), Oo(Math.round(t).toString(16)), Oo(Math.round(n).toString(16)), Oo(GW(o))]
    return r && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join('')
  }
  function WW(e, t, n, o) {
    const r = e / 100,
      s = t / 100,
      i = n / 100,
      a = o / 100,
      l = 255 * (1 - r) * (1 - a),
      c = 255 * (1 - s) * (1 - a),
      u = 255 * (1 - i) * (1 - a)
    return { r: l, g: c, b: u }
  }
  function Zy(e, t, n) {
    let o = 1 - e / 255,
      r = 1 - t / 255,
      s = 1 - n / 255,
      i = Math.min(o, r, s)
    return i === 1 ? ((o = 0), (r = 0), (s = 0)) : ((o = ((o - i) / (1 - i)) * 100), (r = ((r - i) / (1 - i)) * 100), (s = ((s - i) / (1 - i)) * 100)), (i *= 100), { c: Math.round(o), m: Math.round(r), y: Math.round(s), k: Math.round(i) }
  }
  function GW(e) {
    return Math.round(parseFloat(e) * 255).toString(16)
  }
  function Jy(e) {
    return Vt(e) / 255
  }
  function Vt(e) {
    return parseInt(e, 16)
  }
  function VW(e) {
    return { r: e >> 16, g: (e & 65280) >> 8, b: e & 255 }
  }
  const Wd = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkgrey: '#a9a9a9',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    goldenrod: '#daa520',
    gold: '#ffd700',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    grey: '#808080',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavenderblush: '#fff0f5',
    lavender: '#e6e6fa',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightgrey: '#d3d3d3',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32',
  }
  function XW(e) {
    let t = { r: 0, g: 0, b: 0 },
      n = 1,
      o = null,
      r = null,
      s = null,
      i = !1,
      a = !1
    return (
      typeof e == 'string' && (e = UW(e)),
      typeof e == 'object' &&
        (Xt(e.r) && Xt(e.g) && Xt(e.b)
          ? ((t = QW(e.r, e.g, e.b)), (i = !0), (a = String(e.r).substr(-1) === '%' ? 'prgb' : 'rgb'))
          : Xt(e.h) && Xt(e.s) && Xt(e.v)
          ? ((o = Fl(e.s)), (r = Fl(e.v)), (t = OW(e.h, o, r)), (i = !0), (a = 'hsv'))
          : Xt(e.h) && Xt(e.s) && Xt(e.l)
          ? ((o = Fl(e.s)), (s = Fl(e.l)), (t = RW(e.h, o, s)), (i = !0), (a = 'hsl'))
          : Xt(e.c) && Xt(e.m) && Xt(e.y) && Xt(e.k) && ((t = WW(e.c, e.m, e.y, e.k)), (i = !0), (a = 'cmyk')),
        Object.prototype.hasOwnProperty.call(e, 'a') && (n = e.a)),
      (n = Hy(n)),
      { ok: i, format: e.format || a, r: Math.min(255, Math.max(t.r, 0)), g: Math.min(255, Math.max(t.g, 0)), b: Math.min(255, Math.max(t.b, 0)), a: n }
    )
  }
  const YW = '[-\\+]?\\d+%?',
    HW = '[-\\+]?\\d*\\.\\d+%?',
    ro = '(?:' + HW + ')|(?:' + YW + ')',
    Gd = '[\\s|\\(]+(' + ro + ')[,|\\s]+(' + ro + ')[,|\\s]+(' + ro + ')\\s*\\)?',
    Dl = '[\\s|\\(]+(' + ro + ')[,|\\s]+(' + ro + ')[,|\\s]+(' + ro + ')[,|\\s]+(' + ro + ')\\s*\\)?',
    tn = {
      CSS_UNIT: new RegExp(ro),
      rgb: new RegExp('rgb' + Gd),
      rgba: new RegExp('rgba' + Dl),
      hsl: new RegExp('hsl' + Gd),
      hsla: new RegExp('hsla' + Dl),
      hsv: new RegExp('hsv' + Gd),
      hsva: new RegExp('hsva' + Dl),
      cmyk: new RegExp('cmyk' + Dl),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    }
  function UW(e) {
    if (((e = e.trim().toLowerCase()), e.length === 0)) return !1
    let t = !1
    if (Wd[e]) (e = Wd[e]), (t = !0)
    else if (e === 'transparent') return { r: 0, g: 0, b: 0, a: 0, format: 'name' }
    let n = tn.rgb.exec(e)
    return n
      ? { r: n[1], g: n[2], b: n[3] }
      : ((n = tn.rgba.exec(e)),
        n
          ? { r: n[1], g: n[2], b: n[3], a: n[4] }
          : ((n = tn.hsl.exec(e)),
            n
              ? { h: n[1], s: n[2], l: n[3] }
              : ((n = tn.hsla.exec(e)),
                n
                  ? { h: n[1], s: n[2], l: n[3], a: n[4] }
                  : ((n = tn.hsv.exec(e)),
                    n
                      ? { h: n[1], s: n[2], v: n[3] }
                      : ((n = tn.hsva.exec(e)),
                        n
                          ? { h: n[1], s: n[2], v: n[3], a: n[4] }
                          : ((n = tn.cmyk.exec(e)),
                            n
                              ? { c: n[1], m: n[2], y: n[3], k: n[4] }
                              : ((n = tn.hex8.exec(e)),
                                n
                                  ? { r: Vt(n[1]), g: Vt(n[2]), b: Vt(n[3]), a: Jy(n[4]), format: t ? 'name' : 'hex8' }
                                  : ((n = tn.hex6.exec(e)),
                                    n
                                      ? { r: Vt(n[1]), g: Vt(n[2]), b: Vt(n[3]), format: t ? 'name' : 'hex' }
                                      : ((n = tn.hex4.exec(e)), n ? { r: Vt(n[1] + n[1]), g: Vt(n[2] + n[2]), b: Vt(n[3] + n[3]), a: Jy(n[4] + n[4]), format: t ? 'name' : 'hex8' } : ((n = tn.hex3.exec(e)), n ? { r: Vt(n[1] + n[1]), g: Vt(n[2] + n[2]), b: Vt(n[3] + n[3]), format: t ? 'name' : 'hex' } : !1))))))))))
  }
  function Xt(e) {
    return typeof e == 'number' ? !Number.isNaN(e) : tn.CSS_UNIT.test(e)
  }
  class Ge {
    constructor(t = '', n = {}) {
      if (t instanceof Ge) return t
      typeof t == 'number' && (t = VW(t)), (this.originalInput = t)
      const o = XW(t)
      ;(this.originalInput = t),
        (this.r = o.r),
        (this.g = o.g),
        (this.b = o.b),
        (this.a = o.a),
        (this.roundA = Math.round(100 * this.a) / 100),
        (this.format = n.format ?? o.format),
        (this.gradientType = n.gradientType),
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        (this.isValid = o.ok)
    }
    isDark() {
      return this.getBrightness() < 128
    }
    isLight() {
      return !this.isDark()
    }
    getBrightness() {
      const t = this.toRgb()
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3
    }
    getLuminance() {
      const t = this.toRgb()
      let n, o, r
      const s = t.r / 255,
        i = t.g / 255,
        a = t.b / 255
      return s <= 0.03928 ? (n = s / 12.92) : (n = Math.pow((s + 0.055) / 1.055, 2.4)), i <= 0.03928 ? (o = i / 12.92) : (o = Math.pow((i + 0.055) / 1.055, 2.4)), a <= 0.03928 ? (r = a / 12.92) : (r = Math.pow((a + 0.055) / 1.055, 2.4)), 0.2126 * n + 0.7152 * o + 0.0722 * r
    }
    getAlpha() {
      return this.a
    }
    setAlpha(t) {
      return (this.a = Hy(t)), (this.roundA = Math.round(100 * this.a) / 100), this
    }
    isMonochrome() {
      const { s: t } = this.toHsl()
      return t === 0
    }
    toHsv() {
      const t = Ky(this.r, this.g, this.b)
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a }
    }
    toHsvString() {
      const t = Ky(this.r, this.g, this.b),
        n = Math.round(t.h * 360),
        o = Math.round(t.s * 100),
        r = Math.round(t.v * 100)
      return this.a === 1 ? `hsv(${n}, ${o}%, ${r}%)` : `hsva(${n}, ${o}%, ${r}%, ${this.roundA})`
    }
    toHsl() {
      const t = Uy(this.r, this.g, this.b)
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a }
    }
    toHslString() {
      const t = Uy(this.r, this.g, this.b),
        n = Math.round(t.h * 360),
        o = Math.round(t.s * 100),
        r = Math.round(t.l * 100)
      return this.a === 1 ? `hsl(${n}, ${o}%, ${r}%)` : `hsla(${n}, ${o}%, ${r}%, ${this.roundA})`
    }
    toHex(t = !1) {
      return qy(this.r, this.g, this.b, t)
    }
    toHexString(t = !1) {
      return '#' + this.toHex(t)
    }
    toHex8(t = !1) {
      return jW(this.r, this.g, this.b, this.a, t)
    }
    toHex8String(t = !1) {
      return '#' + this.toHex8(t)
    }
    toHexShortString(t = !1) {
      return this.a === 1 ? this.toHexString(t) : this.toHex8String(t)
    }
    toRgb() {
      return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b), a: this.a }
    }
    toRgbString() {
      const t = Math.round(this.r),
        n = Math.round(this.g),
        o = Math.round(this.b)
      return this.a === 1 ? `rgb(${t}, ${n}, ${o})` : `rgba(${t}, ${n}, ${o}, ${this.roundA})`
    }
    toPercentageRgb() {
      const t = n => `${Math.round(Ct(n, 255) * 100)}%`
      return { r: t(this.r), g: t(this.g), b: t(this.b), a: this.a }
    }
    toPercentageRgbString() {
      const t = n => Math.round(Ct(n, 255) * 100)
      return this.a === 1 ? `rgb(${t(this.r)}%, ${t(this.g)}%, ${t(this.b)}%)` : `rgba(${t(this.r)}%, ${t(this.g)}%, ${t(this.b)}%, ${this.roundA})`
    }
    toCmyk() {
      return { ...Zy(this.r, this.g, this.b) }
    }
    toCmykString() {
      const { c: t, m: n, y: o, k: r } = Zy(this.r, this.g, this.b)
      return `cmyk(${t}, ${n}, ${o}, ${r})`
    }
    toName() {
      if (this.a === 0) return 'transparent'
      if (this.a < 1) return !1
      const t = '#' + qy(this.r, this.g, this.b, !1)
      for (const [n, o] of Object.entries(Wd)) if (t === o) return n
      return !1
    }
    toString(t) {
      const n = !!t
      t = t ?? this.format
      let o = !1
      const r = this.a < 1 && this.a >= 0
      return !n && r && (t.startsWith('hex') || t === 'name')
        ? t === 'name' && this.a === 0
          ? this.toName()
          : this.toRgbString()
        : (t === 'rgb' && (o = this.toRgbString()),
          t === 'prgb' && (o = this.toPercentageRgbString()),
          (t === 'hex' || t === 'hex6') && (o = this.toHexString()),
          t === 'hex3' && (o = this.toHexString(!0)),
          t === 'hex4' && (o = this.toHex8String(!0)),
          t === 'hex8' && (o = this.toHex8String()),
          t === 'name' && (o = this.toName()),
          t === 'hsl' && (o = this.toHslString()),
          t === 'hsv' && (o = this.toHsvString()),
          t === 'cmyk' && (o = this.toCmykString()),
          o || this.toHexString())
    }
    toNumber() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
    }
    clone() {
      return new Ge(this.toString())
    }
    lighten(t = 10) {
      const n = this.toHsl()
      return (n.l += t / 100), (n.l = Tl(n.l)), new Ge(n)
    }
    brighten(t = 10) {
      const n = this.toRgb()
      return (n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100))))), (n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100))))), (n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100))))), new Ge(n)
    }
    darken(t = 10) {
      const n = this.toHsl()
      return (n.l -= t / 100), (n.l = Tl(n.l)), new Ge(n)
    }
    tint(t = 10) {
      return this.mix('white', t)
    }
    shade(t = 10) {
      return this.mix('black', t)
    }
    desaturate(t = 10) {
      const n = this.toHsl()
      return (n.s -= t / 100), (n.s = Tl(n.s)), new Ge(n)
    }
    saturate(t = 10) {
      const n = this.toHsl()
      return (n.s += t / 100), (n.s = Tl(n.s)), new Ge(n)
    }
    greyscale() {
      return this.desaturate(100)
    }
    spin(t) {
      const n = this.toHsl(),
        o = (n.h + t) % 360
      return (n.h = o < 0 ? 360 + o : o), new Ge(n)
    }
    mix(t, n = 50) {
      const o = this.toRgb(),
        r = new Ge(t).toRgb(),
        s = n / 100,
        i = { r: (r.r - o.r) * s + o.r, g: (r.g - o.g) * s + o.g, b: (r.b - o.b) * s + o.b, a: (r.a - o.a) * s + o.a }
      return new Ge(i)
    }
    analogous(t = 6, n = 30) {
      const o = this.toHsl(),
        r = 360 / n,
        s = [this]
      for (o.h = (o.h - ((r * t) >> 1) + 720) % 360; --t; ) (o.h = (o.h + r) % 360), s.push(new Ge(o))
      return s
    }
    complement() {
      const t = this.toHsl()
      return (t.h = (t.h + 180) % 360), new Ge(t)
    }
    monochromatic(t = 6) {
      const n = this.toHsv(),
        { h: o } = n,
        { s: r } = n
      let { v: s } = n
      const i = [],
        a = 1 / t
      for (; t--; ) i.push(new Ge({ h: o, s: r, v: s })), (s = (s + a) % 1)
      return i
    }
    splitcomplement() {
      const t = this.toHsl(),
        { h: n } = t
      return [this, new Ge({ h: (n + 72) % 360, s: t.s, l: t.l }), new Ge({ h: (n + 216) % 360, s: t.s, l: t.l })]
    }
    onBackground(t) {
      const n = this.toRgb(),
        o = new Ge(t).toRgb(),
        r = n.a + o.a * (1 - n.a)
      return new Ge({ r: (n.r * n.a + o.r * o.a * (1 - n.a)) / r, g: (n.g * n.a + o.g * o.a * (1 - n.a)) / r, b: (n.b * n.a + o.b * o.a * (1 - n.a)) / r, a: r })
    }
    triad() {
      return this.polyad(3)
    }
    tetrad() {
      return this.polyad(4)
    }
    polyad(t) {
      const n = this.toHsl(),
        { h: o } = n,
        r = [this],
        s = 360 / t
      for (let i = 1; i < t; i++) r.push(new Ge({ h: (o + i * s) % 360, s: n.s, l: n.l }))
      return r
    }
    equals(t) {
      const n = new Ge(t)
      return this.format === 'cmyk' || n.format === 'cmyk' ? this.toCmykString() === n.toCmykString() : this.toRgbString() === n.toRgbString()
    }
  }
  function Lr(e, t) {
    return e.isValid ? e.toString(t) : e.originalInput.toString()
  }
  function _y(e, t) {
    return new Ge(e, t)
  }
  function KW(e) {
    return FW(e) ? e : new Ge(e).toString()
  }
  const qW = e => {
      const { currentColor: t, format: n, onChange: o, isAlphaHidden: r } = e,
        [s, i] = C.useState(t.toHsv()),
        a = (u, d) => {
          if (!Vy(d)) return
          const f = Ll((360 * d) / 100, 0, 359)
          i(h => ({ ...h, h: f }))
          const A = new Ge({ ...s, a: t.toHsv().a, h: f })
          o == null || o(Lr(A, n))
        },
        l = (u, d) => {
          if (!Vy(d)) return
          const f = t.clone().setAlpha(d)
          o == null || o(Lr(f, n))
        },
        c = ({ s: u, v: d }) => {
          const f = new Ge({ h: s.h, a: t.toHsv().a, s: u, v: d })
          i(A => ({ ...A, s: u, v: d })), o == null || o(Lr(f, n))
        }
      return p.jsxs(Wc, {
        className: 'MuiColorInput-PopoverBody',
        children: [
          p.jsx(PW, { currentHue: s.h, hsv: s, onChange: c }),
          p.jsx(Wc, { mt: '10px', px: '3px', children: p.jsx(TW, { min: 0, max: 100, step: 1, onChange: a, 'aria-label': 'hue', value: (s.h * 100) / 360 }) }),
          r ? null : p.jsx(Wc, { mt: '10px', px: '3px', children: p.jsx(BW, { min: 0, max: 1, step: 0.01, 'aria-label': 'alpha', rgbColor: t.toRgb(), onChange: l, value: t.getAlpha() }) }),
        ],
      })
    },
    ZW = C.forwardRef((e, t) => {
      const { className: n, ...o } = e
      return p.jsx(kp, { className: `MuiColorInput-TextField ${n || ''}`, ref: t, ...o })
    }),
    JW = 'rgb'
  function _W(e) {
    return typeof e == 'object' && !Array.isArray(e) && e !== null
  }
  function $y(e, t) {
    typeof t == 'function' ? t(e) : t && _W(t) && 'current' in t && (t.current = e)
  }
  const $W = C.forwardRef((e, t) => {
      const { value: n, format: o, onChange: r, adornmentPosition: s = 'start', PopoverProps: i, Adornment: a = CW, fallbackValue: l, isAlphaHidden: c, disablePopover: u, ...d } = e,
        { onBlur: f, InputProps: A, ...h } = d,
        { onClose: g, ...x } = i || {},
        m = h.disabled || (A == null ? void 0 : A.disabled) || !1,
        v = C.useRef(null),
        y = C.useRef(null),
        [b, w] = C.useState(null),
        k = o || JW,
        E = _y(n, { format: k }),
        [P, T] = C.useState(n),
        [F, D] = C.useState(n),
        Q = V => {
          V.preventDefault(), V.stopPropagation(), !m && !u && w(v.current)
        },
        R = V => {
          const q = new Ge(V)
          r == null || r(V, { hex: q.isValid ? q.toHexString() : '', hsv: q.isValid ? q.toHsvString() : '', hsl: q.isValid ? q.toHslString() : '', rgb: q.isValid ? q.toRgbString() : '', hex8: q.isValid ? q.toHex8String() : '' })
        },
        S = V => {
          const q = V.target.value
          if ((T(q), q === '')) D(''), R('')
          else {
            const ee = new Ge(q),
              re = Lr(ee, k)
            D(re), R(re)
          }
        },
        L = (...V) => {
          g == null || g(...V),
            w(null),
            queueMicrotask(() => {
              var q
              ;(q = y.current) == null || q.focus()
            })
        },
        I = V => {
          f == null || f(V)
          const q = new Ge(P)
          if (q.isValid) q.format !== k && T(Lr(q, k))
          else {
            if (P === '') return
            if (l) {
              const ee = new Ge(l),
                re = Lr(ee, k)
              T(re), D(re), R(re)
            }
          }
        }
      C.useEffect(() => {
        if (n !== F) {
          const V = _y(n).originalInput
          D(V), T(V)
        }
      }, [n, F])
      const z = V => {
          T(V), D(V), R(V)
        },
        B = V => {
          ;(v.current = V), t && $y(V, t)
        },
        O = V => {
          ;(y.current = V), y && $y(V, y)
        },
        W = !!b,
        K = W ? 'color-popover' : void 0,
        Z = p.jsx(oB, { position: s, children: p.jsx(a, { disabled: m, 'aria-describedby': K, disablePopover: u || !1, component: u ? 'span' : void 0, bgColor: E.toString(), isBgColorValid: !!(P !== '' && E.isValid), onClick: u ? void 0 : Q }) }),
        oe = s === 'start' ? { startAdornment: Z } : { endAdornment: Z }
      return p.jsxs(p.Fragment, {
        children: [
          p.jsx(ZW, { ref: B, spellCheck: 'false', type: 'text', autoComplete: 'off', onChange: S, value: KW(P), onBlur: I, inputRef: O, disabled: m, InputProps: { ...oe, ...A }, ...h }),
          u ? null : p.jsx(EW, { id: K, open: W, position: s, anchorEl: b, onClose: L, ...x, children: p.jsx(qW, { onChange: z, currentColor: E, format: k, isAlphaHidden: c }) }),
        ],
      })
    }),
    eb = e => p.jsx($W, { ...e }),
    eG = e => p.jsx(ep, { ...e }),
    tG = e => p.jsx(ap, { ...e }),
    nG = e => p.jsx(op, { ...e }),
    Tr = ({ formControlProps: e, inputLabelProps: t, inputLabel: n, inputLabelId: o, formHelperTextProps: r, helperText: s, ...i }) => p.jsxs(eG, { ...e, children: [p.jsx(tG, { ...t, children: n, id: o }), p.jsx(eu, { ...i }), s && p.jsx(nG, { ...r, children: s })] }),
    Fr = e => p.jsx(YB, { ...e }),
    oG = e => {
      const { edge: t, onSave: n, onClose: o, maxWidth: r, ...s } = e,
        { nodes: i } = oo(),
        [a, l] = C.useState(t.label ?? ''),
        [c, u] = C.useState(pT(t) ?? ''),
        [d, f] = C.useState(t.source),
        [A, h] = C.useState(t.target),
        g = C.useId(),
        x = `${g}-edit-edge-name`,
        m = `${g}-edit-edge-color`,
        v = `${g}-edit-source-node`,
        y = `${g}-edit-source-node-label`,
        b = `${g}-edit-target-node`,
        w = `${g}-edit-target-node-label`,
        k = (...I) => {
          o == null || o(...I)
        },
        E = I => {
          l(I.target.value)
        },
        P = I => {
          u(I)
        },
        T = () => {
          n(eo({ ...t, label: a, source: d, target: A, style: { ...(t.style ?? {}), stroke: c } }))
        },
        F = I => {
          f(I.target.value)
        },
        D = I => {
          h(I.target.value)
        },
        Q = C.useMemo(() => i.map(I => p.jsx(Fr, { value: I.id, children: Ar(I) }, I.id)), [i]),
        R = d === A,
        S = R,
        L = R ? 'Cannot choose the same node' : ''
      return p.jsxs(Od, {
        onClose: k,
        maxWidth: r ?? 'sm',
        ...s,
        children: [
          p.jsx(Gy, { children: 'Edit Edge' }),
          p.jsxs(gW, {
            id: g,
            children: [
              p.jsx(Hs, { value: a, onChange: E, label: 'Edge name', size: 'small', id: x }),
              p.jsx(eb, { value: c, onChange: P, label: 'Edge Color', size: 'small', id: m }),
              p.jsxs(yW, {
                children: [
                  p.jsx(Tr, { id: v, labelId: y, inputLabelId: y, label: 'Source Node Id', inputLabel: 'Source Node Id', formControlProps: { fullWidth: !0, error: R }, value: d, onChange: F, helperText: L, children: Q }),
                  p.jsx(Tr, { id: b, labelId: w, inputLabelId: w, label: 'Target Node Id', inputLabel: 'Target Node Id', formControlProps: { fullWidth: !0, error: R }, value: A, onChange: D, helperText: L, children: Q }),
                ],
              }),
              p.jsx(mW, { onClick: T, variant: 'contained', disabled: S, children: 'Save' }),
            ],
          }),
        ],
      })
    },
    tb = () => C.useContext(cb),
    rG = j('div')`
  display: flex;
  align-items: center;
  gap: 12px;
`,
    sG = j(Mt)``,
    nb = ({ items: e, onChange: t, value: n, className: o, ...r }) => {
      const [s, i] = C.useState(e[0].value),
        a = c => u => {
          i(c), t == null || t(c)
        },
        l = n ?? s
      return p.jsx(rG, { className: o, ...r, children: e.map(c => p.jsx(sG, { onClick: a(c.value), variant: l === c.value ? 'contained' : 'outlined', size: 'small', children: c.label }, c.value)) })
    },
    iG = j(Od)`
  .MuiPaper-root {
    max-width: none !important;
    max-height: none !important;
  }
`,
    aG = j('form')`
  width: 680px;
  height: 600px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 0 24px 16px;
  position: relative;
`,
    Dr = j('div')`
  display: flex;
  justify-content: space-between;
  height: 40px;
`,
    zr = j('p')`
  font-weight: 500;
`,
    Us = j('div')``,
    Vd = j(nb)`
  height: 100%;
`,
    lG = j(Mt)`
  position: absolute;
  bottom: 20px;
  right: 20px;
`,
    cG = j(Dr)`
  flex-direction: column;
  justify-content: unset;
  gap: 8px;
`,
    uG = j('div')`
  display: flex;
  justify-content: space-between;
`
  var Xd = {},
    Yd = {}
  const dG = Mn(dw)
  var ob
  function Hd() {
    return (
      ob ||
        ((ob = 1),
        (function (e) {
          'use client'
          Object.defineProperty(e, '__esModule', { value: !0 }),
            Object.defineProperty(e, 'default', {
              enumerable: !0,
              get: function () {
                return t.createSvgIcon
              },
            })
          var t = dG
        })(Yd)),
      Yd
    )
  }
  var fG = qr
  Object.defineProperty(Xd, '__esModule', { value: !0 })
  var zl = (Xd.default = void 0),
    AG = fG(Hd()),
    pG = p
  zl = Xd.default = (0, AG.default)((0, pG.jsx)('path', { d: 'M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z' }), 'Add')
  var Ud = {},
    hG = qr
  Object.defineProperty(Ud, '__esModule', { value: !0 })
  var rb = (Ud.default = void 0),
    gG = hG(Hd()),
    mG = p
  rb = Ud.default = (0, gG.default)((0, mG.jsx)('path', { d: 'M19 13H5v-2h14z' }), 'Remove')
  const yG = j('div')`
  display: flex;
  align-items: center;
`,
    bG = j(RA)``,
    vG = j(RA)``,
    xG = j('div')`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 40px;
  font-weight: 500;
`,
    Qr = { INCREMENT: 'INCREMENT', DECREMENT: 'DECREMENT' },
    Ks = ({ value: e, onIncrement: t, onDecrement: n, onChange: o, incrementStep: r = 1, decrementStep: s = 1, ...i }) => {
      const [a, l] = C.useState(0),
        c = A => h => () => {
          switch (A) {
            case Qr.INCREMENT:
              l(g => g + h), t == null || t(h), o == null || o(Qr.INCREMENT, h)
              break
            case Qr.DECREMENT:
              l(g => g - h), n == null || n(h), o == null || o(Qr.DECREMENT, h)
              break
          }
        },
        u = c(Qr.INCREMENT),
        d = c(Qr.DECREMENT),
        f = e ?? a
      return p.jsxs(yG, { ...i, children: [p.jsx(vG, { onClick: d(s), children: p.jsx(rb, {}) }), p.jsx(xG, { children: f }), p.jsx(bG, { onClick: u(r), children: p.jsx(zl, {}) })] })
    },
    CG = _R.map(e => ({ value: e, label: e })),
    wG = $R.map(e => ({ value: e, label: e })),
    EG = eO.map(e => ({ value: e, label: e })),
    SG = { [$e.nonFlexConduit]: wG, [$e.flexibleConduit]: EG, [$e.cable]: null, [$e.busduct]: null },
    BG = oO.map(e => ({ value: e, label: tO[e] })),
    so = (e, t) => `${e}-edit-edge-${t}`,
    sb = { amount: 1, material: zo.aluminum, size: ve.AWG18 },
    IG = e => {
      var Ze, Ke, Ve, X, G, ce
      const { edge: t = { data: {} }, onSave: n, onClose: o, maxWidth: r, ...s } = e,
        { config: i } = Fs()
      oo()
      const {
          minEdgeDiameterInches: a,
          maxEdgeDiameterInches: l,
          edgeDiameterIncrementStep: c,
          edgeDiameterDecrementStep: u,
          minEdgeLengthFeet: d,
          maxEdgeLengthFeet: f,
          edgeLengthFeetIncrementStep: A,
          edgeLengthFeetDecrementStep: h,
          minEdgeParallelSets: g,
          maxEdgeParallelSets: x,
          edgeParallelSetsIncrementStep: m,
          edgeParallelSetsDecrementStep: v,
          maxEdgeConductors: y,
          minEdgeConductorAmount: b,
          maxEdgeConductorAmount: w,
          edgeConductorAmountIncrementStep: k,
          edgeConductorAmountDecrementStep: E,
        } = i.edgeParameters,
        P = C.useMemo(() => [sb], []),
        [T, F] = Br(((Ze = t.data) == null ? void 0 : Ze.type) ?? $e.nonFlexConduit),
        [D, Q] = Br(((Ke = t.data) == null ? void 0 : Ke.material) ?? Xs[$e.nonFlexConduit].PVC),
        [R, S] = Br(((Ve = t.data) == null ? void 0 : Ve.diameter) ?? 1),
        [L, I] = Br(((X = t.data) == null ? void 0 : X.length) ?? 50),
        [z, B] = Br(((G = t.data) == null ? void 0 : G.sets) ?? 1),
        [O, W] = Br(((ce = t.data) == null ? void 0 : ce.conductors) ?? P)
      C.useEffect(() => {
        if (T === $e.nonFlexConduit) return Q(Xs[$e.nonFlexConduit].PVC)
        if (T === $e.flexibleConduit) return Q(Xs[$e.flexibleConduit].smurf)
        if (T === $e.cable) return Q(Xs[$e.cable])
        if (T === $e.busduct) return Q(Xs[$e.busduct])
      }, [T])
      const K = C.useId(),
        Z = so(K, 'type'),
        oe = so(K, 'material'),
        V = so(K, 'diameter'),
        q = so(K, 'length'),
        ee = so(K, 'sets'),
        re = ne => {
          F(ne)
        },
        J = ne => {
          Q(ne)
        },
        ie = (...ne) => {
          o == null || o(...ne)
        },
        Ae = C.useMemo(() => `${z} Parallel Sets</br>${R}″${D ? ` ${D} ` : ''}${L}′</br>${O.map(ne => `${ne.amount}x ${nO[ne.material]} ${ne.size}</br>`)}`, [z, R, D, L, O]),
        ae = T !== $e.cable && T !== $e.busduct && !D,
        se = () => {
          n(eo({ ...t, label: Ae, data: { label: Ae, type: T, material: D, diameter: R, length: L, sets: z, conductors: O }, style: { ...(t.style ?? {}), stroke: ae ? 'red' : '#b1b1b7' } }))
        },
        H = SG[T],
        U = ne => S(ue => Math.min(ue + ne, l)),
        te = ne => S(ue => Math.max(ue - ne, a)),
        be = ne => I(ue => Math.min(ue + ne, f)),
        Ne = ne => I(ue => Math.max(ue - ne, d)),
        Me = ne => B(ue => Math.min(ue + ne, x)),
        Ue = ne => B(ue => Math.max(ue - ne, g)),
        we = () => {
          W(ne => [...ne, { ...sb }])
        },
        Se = ne => ue => W(_ => _.map((pe, xe) => (xe === ne ? { ...pe, amount: Math.max(pe.amount + ue, b) } : pe))),
        et = ne => ue => W(_ => _.map((pe, xe) => (xe === ne ? { ...pe, amount: Math.min(pe.amount - ue, w) } : pe))),
        We = ne => ue => {
          W(_ => _.map((pe, xe) => (xe === ne ? { ...pe, material: ue } : pe)))
        },
        Ie = ne => ue => {
          W(_ => _.map((pe, xe) => (xe === ne ? { ...pe, size: ue.target.value } : pe)))
        }
      return p.jsxs(iG, {
        onClose: ie,
        maxWidth: r ?? 'sm',
        ...s,
        children: [
          p.jsx(Gy, { children: 'Edit Connection' }),
          p.jsxs(aG, {
            id: K,
            children: [
              p.jsxs(Dr, { children: [p.jsx(zr, { children: 'Type' }), p.jsx(Us, { children: p.jsx(Vd, { items: CG, value: T, onChange: re, id: Z }) })] }),
              H && p.jsxs(Dr, { children: [p.jsx(zr, { children: 'Material' }), p.jsx(Us, { children: p.jsx(Vd, { items: H, value: D, onChange: J, id: oe }) })] }),
              p.jsxs(Dr, { children: [p.jsx(zr, { children: 'Diameter (inches)' }), p.jsx(Us, { children: p.jsx(Ks, { id: V, value: R, onIncrement: U, onDecrement: te, incrementStep: c, decrementStep: u }) })] }),
              p.jsxs(Dr, { children: [p.jsx(zr, { children: 'Length (feet)' }), p.jsx(Us, { children: p.jsx(Ks, { id: q, value: L, onIncrement: be, onDecrement: Ne, incrementStep: A, decrementStep: h }) })] }),
              p.jsxs(Dr, { children: [p.jsx(zr, { children: 'Parallel Sets' }), p.jsx(Us, { children: p.jsx(Ks, { id: ee, value: z, onIncrement: Me, onDecrement: Ue, incrementStep: m, decrementStep: v }) })] }),
              p.jsxs(cG, {
                children: [
                  p.jsx(zr, { children: 'Conductors' }),
                  O.slice(0, y).map((ne, ue) =>
                    p.jsxs(
                      uG,
                      {
                        children: [
                          p.jsx(Ks, { id: so(K, `conductor-amount-${ue}`), value: ne.amount, onIncrement: Se(ue), onDecrement: et(ue), incrementStep: k, decrementStep: E }),
                          p.jsx(Vd, { id: so(K, `conductor-material-${ue}`), value: ne.material, onChange: We(ue), items: BG }),
                          p.jsx(Tr, { id: so(K, `conductor-size-${ue}`), value: ne.size, label: 'Conductor Size', inputLabel: 'Conductor Size', onChange: Ie(ue), style: st({ width: 160 }), size: 'small', children: sO.map(_ => p.jsx(Fr, { value: _, children: rO[_] }, _)) }),
                        ],
                      },
                      ue
                    )
                  ),
                  y > O.length && p.jsx(Mt, { variant: 'outlined', onClick: we, children: 'Add Conductor Type' }),
                ],
              }),
              p.jsx(lG, { onClick: se, variant: 'contained', children: 'Save' }),
            ],
          }),
        ],
      })
    },
    Xn = { NONE: 'NONE', EDGE_EDIT: 'EDGE_EDIT', EDGE_EDIT_V2: 'EDGE_EDIT_V2', COPY_SUBNODE: 'COPY_SUBNODE' },
    kG = () => {
      const { invokeModal: e, closeModal: t, open: n } = tb(),
        o = C.useCallback(
          r => {
            e(Xn.EDGE_EDIT_V2, r)
          },
          [e]
        )
      return { open: n, invokeModal: o, closeModal: t }
    },
    qs = e => p.jsx(bo, { ...e }),
    St = { 100: '#DAECFF', 200: '#80BFFF', 400: '#3399FF', 500: '#007FFF', 600: '#0072E5', 700: '#0059B2' },
    at = { 50: '#F3F6F9', 100: '#E5EAF2', 200: '#DAE2ED', 300: '#C7D0DD', 400: '#B0B8C4', 500: '#9DA8B7', 600: '#6B7A90', 700: '#434D5B', 800: '#303740', 900: '#1C2025' },
    NG = j('div')(
      ({ theme: e }) => `
  font-family: 'IBM Plex Sans', sans-serif;
  font-weight: 400;
  border-radius: 8px;
  color: ${e.palette.mode === 'dark' ? at[300] : at[900]};
  background: ${e.palette.mode === 'dark' ? at[900] : '#fff'};
  border: 1px solid ${e.palette.mode === 'dark' ? at[700] : at[200]};
  box-shadow: 0 2px 4px ${e.palette.mode === 'dark' ? 'rgba(0,0,0, 0.5)' : 'rgba(0,0,0, 0.05)'};
  display: grid;
  grid-template-columns: 1fr 19px;
  grid-template-rows: 1fr 1fr;
  overflow: hidden;
  column-gap: 8px;
  padding: 4px;

  &.${bd.focused} {
    border-color: ${St[400]};
    box-shadow: 0 0 0 3px ${e.palette.mode === 'dark' ? St[700] : St[200]};
  }

  &:hover {
    border-color: ${St[400]};
  }

  /* firefox */
  &:focus-visible {
    outline: 0;
  }
`
    ),
    MG = j('input')(
      ({ theme: e }) => `
  font-size: 0.875rem;
  font-family: inherit;
  font-weight: 400;
  line-height: 1.5;
  grid-column: 1/2;
  grid-row: 1/3;
  color: ${e.palette.mode === 'dark' ? at[300] : at[900]};
  background: inherit;
  border: none;
  border-radius: inherit;
  padding: 8px 12px;
  outline: 0;
`
    ),
    ib = j('button')(
      ({ theme: e }) => `
  display: flex;
  flex-flow: row nowrap;
  justify-content: center;
  align-items: center;
  appearance: none;
  padding: 0;
  width: 19px;
  height: 19px;
  font-family: system-ui, sans-serif;
  font-size: 0.875rem;
  line-height: 1;
  box-sizing: border-box;
  background: ${e.palette.mode === 'dark' ? at[900] : '#fff'};
  border: 0;
  color: ${e.palette.mode === 'dark' ? at[300] : at[900]};
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 120ms;

  &:hover {
    cursor: pointer;
    color: #FFF;
    background: ${e.palette.mode === 'dark' ? St[600] : St[500]};
    border-color: ${e.palette.mode === 'dark' ? St[400] : St[600]};
  }

  &.${bd.incrementButton} {
    grid-column: 2/3;
    grid-row: 1/2;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    border: 1px solid;
    border-bottom: 0;
    border-color: ${e.palette.mode === 'dark' ? at[700] : at[200]};
    background: ${e.palette.mode === 'dark' ? at[900] : at[50]};
    color: ${e.palette.mode === 'dark' ? at[200] : at[900]};

    &:hover {
      cursor: pointer;
      color: #FFF;
      background: ${e.palette.mode === 'dark' ? St[600] : St[500]};
      border-color: ${e.palette.mode === 'dark' ? St[400] : St[600]};
    }
  }

  &.${bd.decrementButton} {
    grid-column: 2/3;
    grid-row: 2/3;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    border: 1px solid;
    border-color: ${e.palette.mode === 'dark' ? at[700] : at[200]};
    background: ${e.palette.mode === 'dark' ? at[900] : at[50]};
    color: ${e.palette.mode === 'dark' ? at[200] : at[900]};
    
    &:hover {
      cursor: pointer;
      color: #FFF;
      background: ${e.palette.mode === 'dark' ? St[600] : St[500]};
      border-color: ${e.palette.mode === 'dark' ? St[400] : St[600]};
    }
  }

  & .arrow {
    transform: translateY(-1px);
  }
`
    ),
    ab = C.forwardRef(function (t, n) {
      return p.jsx(gD, { slots: { root: NG, input: MG, incrementButton: ib, decrementButton: ib }, slotProps: { incrementButton: { children: '▴', type: 'button' }, decrementButton: { children: '▾', type: 'button' } }, ...t, ref: n })
    }),
    PG = j(Od)``,
    LG = j('div')`
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px 24px;
`,
    TG = j(qs)`
  font-size: 16px;
  font-weight: 500;
`,
    FG = j(ab)``,
    lb = j(Mt)``,
    DG = e => {
      const { node: t, onCopy: n, onCancel: o, onChange: r, open: s } = e,
        [i, a] = C.useState(1),
        { config: l } = Fs(),
        { minCopies: c, maxCopies: u } = l.subNodeParameters,
        d = (h, g) => {
          a(g), r == null || r(g)
        },
        f = () => {
          n == null || n(i, t)
        },
        A = () => {
          o == null || o(i, t)
        }
      return p.jsx(PG, { open: s, onClose: A, children: p.jsxs(LG, { children: [p.jsx(TG, { children: 'How many copies?' }), p.jsx(FG, { value: i, onChange: d, min: c, max: u }), p.jsx(lb, { onClick: f, variant: 'contained', children: 'Commit' }), p.jsx(lb, { onClick: A, variant: 'outlined', children: 'Cancel' })] }) })
    },
    cb = C.createContext({ open: !1, invokeModal: () => {}, closeModal: () => {} }),
    zG = ({ children: e }) => {
      const [t, n] = C.useState({}),
        [o, r] = C.useState(Xn.NONE),
        s = C.useMemo(() => o !== Xn.NONE, [o]),
        i = C.useCallback(
          (h, g) => {
            r(h), g && n(g)
          },
          [r, n]
        ),
        a = C.useCallback(() => {
          r(Xn.NONE), n({})
        }, []),
        l = C.useMemo(() => ({ open: s, invokeModal: i, closeModal: a }), [s, i, a]),
        { onClose: c, ...u } = C.useMemo(() => t, [t]),
        f = {
          open: !0,
          onClose: C.useCallback(
            (...h) => {
              l.closeModal(), c == null || c(...h)
            },
            [c, l]
          ),
        },
        A = { [Xn.NONE]: null, [Xn.EDGE_EDIT]: p.jsx(oG, { ...f, ...u }), [Xn.EDGE_EDIT_V2]: p.jsx(IG, { ...f, ...u }), [Xn.COPY_SUBNODE]: p.jsx(DG, { ...f, ...u }) }
      return p.jsxs(cb.Provider, { value: l, children: [e, A[o]] })
    },
    QG = ({ ...e }) => p.jsx($T, { autoClose: 3e3, limit: 5, ...e }),
    RG = ({ bootstrapped: e, services: t, config: n, theme: o, children: r }) =>
      e
        ? t
          ? p.jsx(JI, { config: n, children: p.jsx(qI.Provider, { value: t, children: p.jsx(W1, { theme: o, children: p.jsx(gm, { children: p.jsx(dW, { children: p.jsxs(yF, { children: [p.jsx(AW, { children: p.jsxs(zG, { children: [p.jsx(kE, {}), r] }) }), p.jsx(QG, {})] }) }) }) }) }) })
          : p.jsx('div', { children: 'Failed to initialize App services!' })
        : p.jsx('div', { children: 'Initializing App...' }),
    OG = e => p.jsx(H5, { ...e }),
    jG = e => p.jsx(uT, { ...e }),
    WG = C.forwardRef((e, t) => p.jsx(R5, { reconne: !0, ref: t, ...e })),
    GG = e => p.jsx(ts, { ...e }),
    VG = e => p.jsx(dp, { ...e }),
    ub = e => p.jsx(mB, { ...e }),
    db = e => p.jsx(CB, { ...e }),
    XG = e => p.jsx(ZA, { ...e }),
    Kd = ({ items: e, itemsAfterDivider: t, paperStyle: n }) =>
      p.jsx(GG, {
        style: n,
        sx: { width: 240, maxWidth: '100%' },
        children: p.jsxs(VG, {
          children: [
            e == null
              ? void 0
              : e.map(o =>
                  p.jsxs(
                    Fr,
                    {
                      onClick: r => {
                        var s
                        return (s = o.onClick) == null ? void 0 : s.call(o, r)
                      },
                      children: [p.jsx(ub, { color: o.color, children: o.icon }), p.jsx(db, { color: o.color, children: o.text }), o.command && p.jsx(qs, { variant: 'body2', color: o.color ?? 'text.secondary', children: o.command })],
                    },
                    o.text
                  )
                ),
            t && p.jsxs(p.Fragment, { children: [p.jsx(XG, {}), t.map(o => p.jsxs(Fr, { children: [p.jsx(ub, { children: o.icon }), p.jsx(db, { children: o.text }), o.command && p.jsx(qs, { variant: 'body2', color: 'text.secondary', children: o.command })] }, o.text))] }),
          ],
        }),
      }),
    YG = ({ iconMenuProps: e, onNodeCreate: t, ...n }) => {
      const o = C.useMemo(() => [{ text: 'Create Asset', icon: p.jsx(zl, {}), onClick: t }], [t])
      return p.jsx(Kd, { paperStyle: { position: 'absolute', zIndex: _u, top: n.top - 150, left: n.left - 250, bottom: n.bottom, right: n.right }, items: o, ...e })
    }
  var qd = {},
    HG = qr
  Object.defineProperty(qd, '__esModule', { value: !0 })
  var Zd = (qd.default = void 0),
    UG = HG(Hd()),
    KG = p
  Zd = qd.default = (0, UG.default)((0, KG.jsx)('path', { d: 'M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zm2.46-7.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14zM15.5 4l-1-1h-5l-1 1H5v2h14V4z' }), 'DeleteForever')
  const fb = Lc(p.jsx('path', { d: 'M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2m0 14H3V5h18zm-5-7v2h-3v3h-2v-3H8v-2h3V7h2v3z' }), 'AddToQueue'),
    qG = ({ iconMenuProps: e, onNodeDelete: t, onCreateDownstreamAsset: n, onLineSideSubNodeCreate: o, onLoadSideSubNodeCreate: r, targetNode: s, ...i }) => {
      const l = !Sl(s),
        c = C.useMemo(() => s.type === Fo.ElectricalPanelNode, [s.type]),
        u = c && s.data.electricalPanelType === Do.MCB,
        d = C.useMemo(
          () => [
            { text: 'Delete Asset', icon: p.jsx(Zd, {}), onClick: () => (t == null ? void 0 : t(i.id)), color: 'error.main' },
            ...(l ? [{ text: 'Create Downstream Asset', icon: p.jsx(zl, {}), onClick: () => (n == null ? void 0 : n(s)) }] : []),
            ...(l && c && u ? [{ text: 'Create New Line-Side Subcomponent', icon: p.jsx(fb, {}), onClick: () => (o == null ? void 0 : o(s)) }] : []),
            ...(l && c ? [{ text: 'Create New Load-Side Subcomponent', icon: p.jsx(fb, {}), onClick: () => (r == null ? void 0 : r(s)) }] : []),
          ],
          [l, c, t, i.id, n, s, o, r]
        )
      return p.jsx(Kd, { paperStyle: { position: 'absolute', zIndex: _u, top: i.top - 150, left: i.left - 250, bottom: i.bottom, right: i.right, width: 'fit-content' }, items: d, ...e })
    },
    ZG = ({ iconMenuProps: e, onEdgeDelete: t, ...n }) => {
      const o = C.useMemo(() => [{ text: 'Delete Edge', icon: p.jsx(Zd, {}), onClick: () => (t == null ? void 0 : t(n.id)), color: 'error.main' }], [n, t])
      return p.jsx(Kd, { paperStyle: { position: 'absolute', zIndex: _u, top: n.top - 150, left: n.left - 250, bottom: n.bottom, right: n.right }, items: o, ...e })
    },
    Ab = j(e => p.jsx(el, { ...e }))`
  display: flex;
  gap: 4px;
`,
    JG = j('input')`
  visibility: hidden;
  width: 0;
  height: 0;
`,
    _G = { width: '100%', height: '100%', position: 'absolute', zIndex: 10, pointerEvents: 'none' },
    $G = e => ({ width: e.width, height: e.height, transform: e.transform }),
    eV = ({ horizontal: e, vertical: t }) => {
      const { width: n, height: o, transform: r } = ke($G),
        s = C.useRef(null)
      return (
        C.useEffect(() => {
          const i = s.current,
            a = i == null ? void 0 : i.getContext('2d')
          if (!a || !i) return
          const l = window.devicePixelRatio
          ;(i.width = n * l), (i.height = o * l), a.scale(l, l), a.clearRect(0, 0, n, o), (a.strokeStyle = '#0041d0'), typeof t == 'number' && (a.moveTo(t * r[2] + r[0], 0), a.lineTo(t * r[2] + r[0], o), a.stroke()), typeof e == 'number' && (a.moveTo(0, e * r[2] + r[1]), a.lineTo(n, e * r[2] + r[1]), a.stroke())
        }, [n, o, r, e, t]),
        p.jsx('canvas', { ref: s, className: 'react-flow__canvas', style: _G })
      )
    },
    tV = C.forwardRef(
      (
        {
          paneMenu: e,
          onNodeCreate: t,
          nodeMenu: n,
          onNodeDelete: o,
          edgeMenu: r,
          onEdgeDelete: s,
          viewMode: i,
          editMode: a,
          horizontalHelperLine: l,
          verticalHelperLine: c,
          onCreateDownstreamAsset: u,
          onLineSideSubNodeCreate: d,
          onLoadSideSubNodeCreate: f,
          onHorizontalClick: A,
          onVerticalClick: h,
          onToggleViewMode: g,
          onExportFlow: x,
          onImportFlow: m,
          onToggleEditMode: v,
          onDataChange: y,
          ...b
        },
        w
      ) => {
        const k = C.useRef(null),
          E = a === Gn.unlocked,
          P = () => {
            var T
            ;(T = k.current) == null || T.click()
          }
        return p.jsx('div', {
          style: { width: 'calc(100% - 0px)', height: 'calc(100vh - 128px)' },
          children: p.jsxs(WG, {
            ref: w,
            ...b,
            children: [
              p.jsx(OG, { gap: nF }),
              p.jsx(jG, {}),
              p.jsx(eV, { horizontal: l, vertical: c }),
              e && E && p.jsx(YG, { onNodeCreate: t, ...e }),
              n && E && p.jsx(qG, { onNodeDelete: o, onCreateDownstreamAsset: u, onLineSideSubNodeCreate: d, onLoadSideSubNodeCreate: f, ...n }),
              r && E && p.jsx(ZG, { onEdgeDelete: s, ...r }),
              (A || h) && p.jsx(Ab, { position: 'top-right', children: h && p.jsx(Mt, { onClick: h, variant: 'contained', children: VR[pn.vertical] }) }),
              (g || x || m || v || y) &&
                p.jsxs(Ab, {
                  position: 'bottom-left',
                  children: [
                    g && p.jsx(Mt, { variant: 'contained', onClick: g, children: YR[i] }),
                    x && p.jsx(Mt, { variant: 'contained', onClick: x, children: 'Export' }),
                    m && p.jsxs(Mt, { variant: 'contained', onClick: P, children: [p.jsx(JG, { type: 'file', ref: k, onChange: m }), 'Import'] }),
                    v && p.jsx(p.Fragment, { children: p.jsx(Mt, { variant: 'contained', onClick: v, children: XR[a] }) }),
                  ],
                }),
            ],
          }),
        })
      }
    ),
    nV = e => p.jsx(BS, { ...e }),
    oV = j('div')`
  width: 360px;
  padding: 20px 32px;
  display: flex;
  flex-direction: column;
`,
    rV = ({ children: e, ...t }) => p.jsx(nV, { anchor: 'right', ...t, children: p.jsx(oV, { children: e }) }),
    sV = j('form')`
  display: flex;
  flex-direction: column;
  gap: 24px;

  .MuiSelect-select > span {
    display: none;
  }
`,
    iV = j(qs)`
  font-size: 24px;
  font-weight: 500;
`,
    aV = j(Mt)`
  width: 100%;
`,
    lV = j(Fr)`
  display: flex;
  justify-content: space-between;
  align-items: center;
`,
    cV = j('span')`
  color: #ccccff88;
`,
    uV = j(nb)`
  & > * {
    flex-grow: 1;
  }
`,
    pb = j('div')`
  display: flex;
  flex-direction: column;
  gap: 8px;
`,
    hb = j(qs)`
  font-size: 14px;
  font-weight: 500;
`,
    dV = j('div')`
  display: flex;
  gap: 12px;
`,
    gb = j(Mt)`
  flex-grow: 1;
`,
    fV = ZR.map(e => ({ label: qR[e], value: e })),
    AV = ({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s, onNodeArchetypeChange: i, onDeleteClick: a, onCopyClick: l }) => {
      const { config: c } = Fs(),
        { minAmpereRating: u = 0.01, maxAmpereRating: d = 1e3, polesIncrementStep: f, polesDecrementStep: A } = c.subNodeParameters,
        {
          name: h,
          code: g,
          nameExistsAlready: x,
          handleNameChange: m,
          handleNodeClassCodeChange: v,
          handleSave: y,
          archetype: b,
          handleArchetypeChange: w,
          ampereRating: k,
          handleAmpereRatingChange: E,
          poles: P,
          handlePolesIncrement: T,
          handlePolesDecrement: F,
          handleDeleteClick: D,
          handleCopyClick: Q,
        } = od({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s, onNodeArchetypeChange: i, onDeleteClick: a, onCopyClick: l }),
        R = x ? 'This node exists already' : '',
        S = C.useMemo(() => KR.map(L => p.jsxs(lV, { value: L, children: [M0[L], p.jsx(cV, { children: wd[L] })] }, L)))
      return p.jsxs(sV, {
        children: [
          p.jsx(iV, { children: 'Edit OCP Device' }),
          p.jsx(Hs, { value: h, onChange: m, label: 'Device Name', size: 'small', error: x, helperText: R }),
          p.jsx(uV, { items: fV, value: b, onChange: w }),
          p.jsx(Tr, { label: 'Asset Class', inputLabel: 'Asset Class', value: g, onChange: v, size: 'small', children: S }),
          p.jsxs(pb, { children: [p.jsx(hb, { children: 'Ampere Rating' }), p.jsx(ab, { value: k, onChange: E, min: u, max: d, placeholder: 'Ampere Rating' })] }),
          p.jsxs(pb, { children: [p.jsx(hb, { children: '# of Poles / Conductors' }), p.jsx(Ks, { value: P, onIncrement: T, onDecrement: F, incrementStep: f, decrementStep: A })] }),
          p.jsxs(dV, { children: [p.jsx(gb, { color: 'error', variant: 'contained', onClick: D, children: 'Delete' }), p.jsx(gb, { variant: 'contained', onClick: Q, children: 'Copy' })] }),
          p.jsx(aV, { onClick: y, variant: 'contained', children: 'Save' }),
        ],
      })
    },
    pV = j('form')`
  display: flex;
  flex-direction: column;
  gap: 24px;

  .MuiSelect-select > span {
    display: none;
  }
`,
    hV = j(Mt)`
  width: 100%;
`,
    mb = j(Fr)`
  display: flex;
  justify-content: space-between;
  align-items: center;
`,
    gV = j('span')`
  color: #ccccff88;
`,
    mV = ({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s }) => {
      const {
          name: i,
          color: a,
          code: l,
          nodeChildren: c,
          electricalPanelType: u,
          hasParent: d,
          isElectricalPanel: f,
          isWithImplicitClass: A,
          nodeParent: h,
          hasChildren: g,
          parentNodeInputLabel: x,
          handleChildNameChange: m,
          nameExistsAlready: v,
          handleNameChange: y,
          handleNodeClassCodeChange: b,
          handleColorChange: w,
          handleElectricalPanelTypeChange: k,
          handleSave: E,
        } = od({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s }),
        P = v ? 'This node exists already' : '',
        T = C.useMemo(() => UR.map(D => p.jsxs(mb, { value: D, children: [M0[D], p.jsx(gV, { children: wd[D] })] }, D))),
        F = C.useMemo(() => JR.map(D => p.jsx(mb, { value: D, children: D }, D)), [])
      return p.jsxs(pV, {
        children: [
          p.jsx(Tr, { label: 'Node Class Code', inputLabel: 'Node Class Code', value: l, onChange: b, size: 'small', children: T }),
          A && p.jsx(Hs, { value: i, onChange: y, label: 'Node Name', size: 'small', error: v, helperText: P }),
          f && p.jsx(Tr, { label: 'Electrical Panel Type', inputLabel: 'Electrical PanelType', value: u, onChange: k, size: 'small', children: F }),
          p.jsx(eb, { value: a, onChange: w, label: 'Node Color', size: 'small' }),
          d && h && p.jsx(Hs, { disabled: !0, label: x, size: 'small', value: `${Ar(h)}` }),
          g && c.map((D, Q) => p.jsx(Hs, { label: `Subcomponent ${Q + 1} `, size: 'small', value: Ar(D), onChange: m(D) }, D.id)),
          p.jsx(hV, { onClick: E, variant: 'contained', disabled: v, children: 'Save' }),
        ],
      })
    },
    yV = ({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s, onNodeArchetypeChange: i, onDeleteClick: a, onCopyClick: l }) => {
      const { isTopLevelNode: c } = od({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s })
      return c
        ? p.jsx(mV, { node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s, onNodeArchetypeChange: i, onDeleteClick: a, onCopyClick: l })
        : p.jsx(AV, { node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: s, onDeleteClick: a, onCopyClick: l })
    },
    yb = 'application/json',
    bV = () => {
      const { invokeModal: e, closeModal: t, open: n } = tb(),
        o = C.useCallback(
          r => {
            e(Xn.COPY_SUBNODE, r)
          },
          [e]
        )
      return { open: n, invokeModal: o, closeModal: t }
    },
    vV = ({ initialData: e, onDataChange: t, onSingleChange: n }) => {
      const { nodes: o, edges: r, viewMode: s, editMode: i, horizontalHelperLine: a, verticalHelperLine: l, changesEnabled: c, setNodes: u, setEdges: d, setViewMode: f, setEditMode: A, onNodesChange: h, onEdgesChange: g, onLayout: x, takeSnapshot: m } = oo(),
        [v, y] = C.useState(null),
        [b, w] = C.useState(null),
        [k, E] = C.useState(null),
        [P, T] = C.useState(null),
        [F, D] = C.useState({}),
        [Q, R] = C.useState([]),
        [S, L] = C.useState([]),
        [I, z] = C.useState({ isAdding: !1, isEditing: !1, isDeleting: !1, changeData: null }),
        { getNodes: B } = No(),
        { open: O, closeDrawer: W, openDrawer: K, nodeToEdit: Z } = vF(),
        { invokeModal: oe, closeModal: V } = kG(),
        { invokeModal: q, closeModal: ee } = bV(),
        re = C.useRef(null),
        J = le => {
          if (!c) return
          m(), Me(le), V()
          const de = S.find(ge => ge.id === le.id)
          ;(de == null ? void 0 : de.isNew) === !0 && (le.isNew = !0)
          const Be = S.filter(ge => ge.id !== (de == null ? void 0 : de.id))
          L([...Be, le])
        },
        ie = C.useCallback(
          le => {
            d(de => Lu(le, de)), L(de => Lu({ ...le, isNew: !0 }, de)), oe({ edge: eo({ ...le, id: `xy-edge__${le.source}-${le.target}` }), onSave: J })
          },
          [d, oe, J]
        ),
        { openMenu: Ae, closeMenu: ae } = fF(re, y),
        { openMenu: se, closeMenu: H } = AF(re, w, { onSet: le => E(le) }),
        { openMenu: U, closeMenu: te } = pF(re, T)
      dF(u)
      const be = hF(u),
        Ne = xF(u),
        Me = CF(d)
      SF(d)
      const Ue = gF(d),
        we = BF(u),
        Se = FF(d),
        { getViewport: et } = No(),
        We = le => {
          if (v && c) {
            const de = pO(le, et())
            ae()
            const Be = { ...I, isAdding: !0, changeData: de }
            n(Be)
          }
        },
        Ie = le => {
          if (b && c) {
            m()
            const de = we(le, b == null ? void 0 : b.position, { data: { archetype: He.lineSide } })
            Se(de, o, r), H()
            const Be = { ...I, isAddingLineSide: !0, changeData: { ...le, lineLoadSideId: 1 } }
            n(Be)
          }
        },
        Ze = le => {
          if (b && c) {
            m()
            const de = we(le, b == null ? void 0 : b.position, { data: { archetype: He.loadSide } })
            Se(de, o, r), H()
            const Be = { ...I, isAddingLineSide: !0, changeData: { ...le, lineLoadSideId: 2 } }
            n(Be)
          }
        },
        Ke = le => {
          if (b && c) {
            H()
            const de = { ...I, isAddingDownstream: !0, changeData: le }
            n(de)
          }
        },
        Ve = le => {
          if (b && c) {
            H()
            const de = { ...I, isDeleting: !0, changeData: le }
            n(de)
          }
        },
        X = le => {
          if (!c) return
          m(), be(le.id), W()
          const de = { ...I, isDeleting: !0, changeData: le.id }
          n(de)
        },
        G = (le, de) => {
          q({
            node: le,
            onCancel: ee,
            onCopy: (Be, ge) => {
              Array.from({ length: Be })
                .fill(null)
                .forEach(() => {
                  const Ce = we(de, k == null ? void 0 : k.position, { ...ge, id: Co(), data: { ...ge.data, label: `${ge.data.label} copy-${Co()}` } })
                  Se(Ce, o, r), ee(), W()
                })
            },
          })
        },
        ce = le => {
          var de
          if (P && c) {
            m(), Ue(le), te()
            const Be = S.filter(Ce => Ce.id !== le),
              ge = ((de = S.find(Ce => Ce.id === le)) == null ? void 0 : de.isNew) === !0
            L([...Be, ge ? null : { id: le, isDeleted: !0 }].filter(Boolean))
          }
        },
        ne = () => {
          v && c && ae(), b && c && H(), P && c && te(), W()
        },
        ue = le => {
          if ((c || H(), b && c)) {
            H()
            return
          }
          Ae(le)
        },
        _ = (le, de) => {
          if (v && c) {
            ae()
            return
          }
          se(le, de)
        },
        pe = (le, de) => {
          if (P && c) {
            te()
            return
          }
          U(le, de)
        },
        xe = le => {
          c && (m(), Ne(le))
        },
        Ee = le => {
          xe(le), W()
        },
        nt = le => {
          xe(le)
        },
        nn = le => {
          xe(le)
        },
        Hn = le => {
          xe(le)
        },
        Rr = (le, de) => {
          if (!c) return
          const Be = { ...I, isEditing: !0, changeData: de }
          n(Be)
        },
        Or = (le, de) => {
          !c || de.data.isInvisibleEdge || oe({ edge: de, onSave: J })
        },
        Wo = () => {
          x(pn.vertical)
        },
        Go = () => {
          x(pn.vertical)
        },
        Vo = () => {
          f(le => (le === no.standard ? no.enhanced : no.standard))
        },
        Xo = () => {
          const de = JSON.stringify({ nodes: o, edges: r }),
            Be = new Blob([de], { type: yb }),
            ge = URL.createObjectURL(Be)
          sk(ge, { filename: ck() }), URL.revokeObjectURL(ge)
        },
        Zs = le => {
          var ge
          const de = (ge = le.target.files) == null ? void 0 : ge[0]
          if (!de || de.type !== yb) return alert('Please upload a JSON file')
          const Be = new FileReader()
          ;(Be.onload = Ce => {
            var Te
            const Je = (Te = Ce.target) == null ? void 0 : Te.result
            if (!Je) return alert('Failed to read the file')
            if (typeof Je != 'string') return alert('File is not a string')
            const gt = JSON.parse(Je)
            ak(gt), u(gt.nodes), d(gt.edges)
          }),
            Be.readAsText(de)
        },
        Yo = () => {
          m()
        },
        Ho = () => {
          m()
        },
        Uo = () => {
          A(le => (le === Gn.locked ? Gn.unlocked : Gn.locked))
        },
        Js = le => {
          try {
            return JSON.parse(le)
          } catch {
            return console.error('Invalid JSON found:', le), null
          }
        }
      C.useEffect(() => {
        if (!u) {
          console.error('setNodes function is not available. Check FlowContext setup.')
          return
        }
        if (!d) {
          console.error('setEdges function is not available. Check FlowContext setup.')
          return
        }
        u([]),
          Object.keys(e).length > 0 &&
            (u(le => {
              var Be
              const de =
                (Be = e == null ? void 0 : e.list) == null
                  ? void 0
                  : Be.map(ge => {
                      var Je, gt, Te, tt, io, Un, Dt
                      let Ce
                      return (
                        ge.extent === 'parent' ? (Ce = P0[(Je = ge.data) == null ? void 0 : Je.code] || 'VCCB') : (Ce = Ed[(gt = ge.data) == null ? void 0 : gt.code] || 'MISC'),
                        hn({
                          id: ge.assetId,
                          type: Gs[Ce],
                          position: ge.position,
                          data: { archetype: (Te = ge.data) == null ? void 0 : Te.archetype, label: (tt = ge.data) == null ? void 0 : tt.label, background: (io = ge.data) == null ? void 0 : io.background, border: (Un = ge.data) == null ? void 0 : Un.border, code: (Dt = ge.data) == null ? void 0 : Dt.code },
                          style: ge.style,
                          parentId: ge.parentId,
                          selected: ge.selected,
                          dragging: ge.dragging,
                          ...(ge.extent === 'parent' && { extent: ge.extent }),
                        })
                      )
                    })
              return [...le, ...de]
            }),
            d(le => {
              var Be
              const de =
                (Be = e == null ? void 0 : e.initialEdges) == null
                  ? void 0
                  : Be.map(ge => {
                      const Ce = ge.fedbyDetailsJson ? Js(ge.fedbyDetailsJson) : null,
                        Je = {
                          id: ge.id,
                          source: ge.source,
                          target: ge.target,
                          parentAssetId: ge.parentAssetId,
                          assetId: ge.assetId,
                          viaSubcomponentAssetId: ge.viaSubcomponentAssetId,
                          fedByViaSubcomponantAssetId: ge.fedByViaSubcomponantAssetId,
                          label: ge.label,
                          fedbyDetailsJson: ge.fedbyDetailsJson,
                          style: ge.style,
                          type: ge.type,
                          ...(Ce && {
                            data: {
                              type: Ce.type === 'step' ? Ce.data.type : Ce.type ?? Ce.data.type,
                              material: Ce.material ?? Ce.data.material,
                              diameter: Ce.diameter ?? Ce.data.diameter,
                              length: Ce.length ?? Ce.data.length,
                              sets: Ce.sets ?? Ce.data.sets,
                              conductors: Ce.conductors ?? Ce.data.conductors,
                              label: Ce.label ?? Ce.data.label ?? ge.label,
                            },
                          }),
                        }
                      return eo(Je)
                    })
              return [...le, ...de]
            }))
      }, [e, u, d]),
        console.log(r)
      const _s = () => {
          const le = o,
            de = [...e.list],
            Be = le.filter(Je => {
              const gt = de.find(Te => Te.assetId === Je.id)
              return gt ? Je.position.x !== gt.position.x || Je.position.y !== gt.position.y : !0
            }),
            ge = r.filter(Je => !e.initialEdges.some(gt => gt.id === Je.id)).map(Je => ({ ...Je, isNew: !0 })),
            Ce = [...S, ...ge].filter((Je, gt, Te) => gt === Te.findIndex(tt => tt.id === Je.id))
          t ? (t({ changedNodes: Be, updatedEdgesMovement: Ce }), L([])) : console.error('onDataChange function is not defined.')
        },
        $s = () => {
          B().forEach(de => {
            const Be = F[de.id] || []
            ;(Be.length === 0 || de.position.x !== Be[Be.length - 1].x || de.position.y !== Be[Be.length - 1].y) && (D(Ce => ({ ...Ce, [de.id]: [...Be, { x: de.position.x, y: de.position.y }] })), R(Ce => [...Ce, de.id]))
          })
        },
        ei = () => {
          if (Q.length === 0) {
            console.log('Nothing to undo.')
            return
          }
          const le = Q[Q.length - 1],
            de = F[le]
          if (!de || de.length < 2) {
            console.log('Nothing to undo for this node.')
            return
          }
          const Be = de[de.length - 2]
          u(ge => ge.map(Ce => (Ce.id === le ? { ...Ce, position: Be } : Ce))), D(ge => ({ ...ge, [le]: de.slice(0, -1) })), R(ge => ge.slice(0, -1))
        }
      return (
        C.useEffect(() => {
          o.forEach(le => {
            F[le.id] || D(de => ({ ...de, [le.id]: [{ x: le.position.x, y: le.position.y }] }))
          })
        }, [o]),
        C.useEffect(() => {
          const le = setTimeout(() => {
            $s()
          }, 500)
          return () => {
            clearTimeout(le)
          }
        }, [o]),
        p.jsxs(p.Fragment, {
          children: [
            p.jsx(tV, {
              editMode: i,
              onToggleEditMode: Uo,
              nodesConnectable: c,
              edgesReconnectable: c,
              ref: re,
              nodes: o,
              edges: r,
              viewMode: s,
              setNodes: u,
              setEdges: d,
              horizontalHelperLine: a,
              verticalHelperLine: l,
              onNodesChange: h,
              onEdgesChange: g,
              onConnect: ie,
              nodeTypes: GR,
              edgeTypes: AT,
              onContextMenu: ue,
              onNodeContextMenu: _,
              onEdgeContextMenu: pe,
              onNodeClick: Rr,
              onPaneClick: ne,
              paneMenu: v,
              nodeMenu: b,
              edgeMenu: P,
              onNodeCreate: We,
              onNodeDelete: Ve,
              onEdgeDelete: ce,
              onEdgeClick: Or,
              onCreateDownstreamAsset: Ke,
              onLineSideSubNodeCreate: Ie,
              onLoadSideSubNodeCreate: Ze,
              onVerticalClick: Wo,
              onHorizontalClick: Go,
              onToggleViewMode: Vo,
              onExportFlow: Xo,
              onImportFlow: Zs,
              onNodeDragStart: Yo,
              onConnectStart: Ho,
              connectionLineType: Sn.Step,
              defaultEdgeOptions: { type: Sn.Step },
            }),
            p.jsxs('div', { style: { position: 'absolute', bottom: '16px', left: '677px' }, children: [p.jsx(Mt, { variant: 'contained', onClick: _s, children: 'Save' }), p.jsx(Mt, { id: 'undo', variant: 'contained', onClick: ei, disabled: Q.length === 0, sx: { marginLeft: '5px' }, children: 'Undo' })] }),
            p.jsx(rV, { className: 'nowheel nodrag nopan', open: O, children: Z && c && p.jsx(yV, { node: Z, onSave: Ee, onNodeClassCodeChange: nt, onNodeColorChange: nn, onNodeElectricalPanelTypeChange: Hn, onDeleteClick: X, onCopyClick: G }) }),
          ],
        })
      )
    },
    xV = ({ initialdata: e, ondatachange: t }) => {
      const { bootstrapped: n, config: o, services: r, theme: s } = Fs(),
        i = e ? JSON.parse(e) : { list: [], initialEdges: [] },
        a = c => {
          const u = new CustomEvent('datachange', { detail: c })
          document.dispatchEvent(u)
        },
        l = c => {
          const u = new CustomEvent('singlechange', { detail: c })
          document.dispatchEvent(u)
        }
      return p.jsx(RG, { bootstrapped: n, services: r, config: o, theme: s, children: p.jsx(vV, { initialData: i, onDataChange: a, onSingleChange: l }) })
    }
  var CV = Object.defineProperty,
    wV = (e, t, n) => (t in e ? CV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
    Ql = (e, t, n) => wV(e, typeof t != 'symbol' ? t + '' : t, n)
  const EV = { stringify: e => (e ? 'true' : 'false'), parse: e => /^[ty1-9]/i.test(e) },
    SV = {
      stringify: e => e.name,
      parse: (e, t, n) => {
        const o = (() => {
          if (typeof window < 'u' && e in window) return window[e]
          if (typeof global < 'u' && e in global) return global[e]
        })()
        return typeof o == 'function' ? o.bind(n) : void 0
      },
    },
    BV = { stringify: e => JSON.stringify(e), parse: e => JSON.parse(e) },
    IV = { stringify: e => `${e}`, parse: e => parseFloat(e) },
    kV = { stringify: e => e, parse: e => e },
    Jd = { string: kV, number: IV, boolean: EV, function: SV, json: BV }
  function NV(e) {
    return e.replace(/([a-z0-9])([A-Z])/g, (t, n, o) => `${n}-${o.toLowerCase()}`)
  }
  const Rl = Symbol.for('r2wc.render'),
    Ol = Symbol.for('r2wc.connected'),
    jo = Symbol.for('r2wc.context'),
    Yn = Symbol.for('r2wc.props')
  function MV(e, t, n) {
    var o, r, s
    t.props || (t.props = e.propTypes ? Object.keys(e.propTypes) : []), t.events || (t.events = [])
    const i = Array.isArray(t.props) ? t.props.slice() : Object.keys(t.props),
      a = Array.isArray(t.events) ? t.events.slice() : Object.keys(t.events),
      l = {},
      c = {},
      u = {},
      d = {}
    for (const A of i) {
      l[A] = Array.isArray(t.props) ? 'string' : t.props[A]
      const h = NV(A)
      ;(u[A] = h), (d[h] = A)
    }
    for (const A of a) c[A] = Array.isArray(t.events) ? {} : t.events[A]
    class f extends HTMLElement {
      constructor() {
        super(), Ql(this, s, !0), Ql(this, r), Ql(this, o, {}), Ql(this, 'container'), t.shadow ? (this.container = this.attachShadow({ mode: t.shadow })) : (this.container = this), (this[Yn].container = this.container)
        for (const h of i) {
          const g = u[h],
            x = this.getAttribute(g),
            m = l[h],
            v = m ? Jd[m] : null
          v != null && v.parse && x && (this[Yn][h] = v.parse(x, g, this))
        }
        for (const h of a)
          this[Yn][h] = g => {
            const x = h.replace(/^on/, '').toLowerCase()
            this.dispatchEvent(new CustomEvent(x, { detail: g, ...c[h] }))
          }
      }
      static get observedAttributes() {
        return Object.keys(d)
      }
      connectedCallback() {
        ;(this[Ol] = !0), this[Rl]()
      }
      disconnectedCallback() {
        ;(this[Ol] = !1), this[jo] && n.unmount(this[jo]), delete this[jo]
      }
      attributeChangedCallback(h, g, x) {
        const m = d[h],
          v = l[m],
          y = v ? Jd[v] : null
        m in l && y != null && y.parse && x && ((this[Yn][m] = y.parse(x, h, this)), this[Rl]())
      }
      [((s = Ol), (r = jo), (o = Yn), Rl)]() {
        this[Ol] && (this[jo] ? n.update(this[jo], this[Yn]) : (this[jo] = n.mount(this.container, e, this[Yn])))
      }
    }
    for (const A of i) {
      const h = u[A],
        g = l[A]
      Object.defineProperty(f.prototype, A, {
        enumerable: !0,
        configurable: !0,
        get() {
          return this[Yn][A]
        },
        set(x) {
          this[Yn][A] = x
          const m = g ? Jd[g] : null
          if (m != null && m.stringify) {
            const v = m.stringify(x, h, this)
            this.getAttribute(h) !== v && this.setAttribute(h, v)
          } else this[Rl]()
        },
      })
    }
    return f
  }
  function PV(e, t, n, o = {}) {
    function r(a, l, c) {
      const u = t.createElement(l, c)
      if ('createRoot' in n) {
        const d = n.createRoot(a)
        return d.render(u), { container: a, root: d, ReactComponent: l }
      }
      if ('render' in n) return n.render(u, a), { container: a, ReactComponent: l }
      throw new Error('Invalid ReactDOM instance provided.')
    }
    function s({ container: a, root: l, ReactComponent: c }, u) {
      const d = t.createElement(c, u)
      if (l) {
        l.render(d)
        return
      }
      if ('render' in n) {
        n.render(d, a)
        return
      }
    }
    function i({ container: a, root: l }) {
      if (l) {
        l.unmount()
        return
      }
      if ('unmountComponentAtNode' in n) {
        n.unmountComponentAtNode(a)
        return
      }
    }
    return MV(e, o, { mount: r, unmount: i, update: s })
  }
  const LV = PV(xV, C, pt, { props: ['initialdata', 'ondatachange', 'onsinglechange'] })
  customElements.define('react-flow', LV, { shadow: !0 })
})
