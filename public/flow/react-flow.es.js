var $b = Object.defineProperty
var ev = (e, t, n) => (t in e ? $b(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n))
var gt = (e, t, n) => ev(e, typeof t != 'symbol' ? t + '' : t, n)
import * as N from 'react'
import ve, { forwardRef as jr, useContext as qn, Children as tv, isValidElement as ao, cloneElement as Oo, createContext as po, memo as Te, useMemo as Pe, useState as be, useRef as Ne, useEffect as Ce, useCallback as ge, useLayoutEffect as Ma, useSyncExternalStore as nv, useId as Qh } from 'react'
import * as zu from 'react-dom'
import Ai, { createPortal as ov } from 'react-dom'
function Oh(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
}
function Zn(e) {
  if (e.__esModule) return e
  var t = e.default
  if (typeof t == 'function') {
    var n = function o() {
      return this instanceof o ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
    }
    n.prototype = t.prototype
  } else n = {}
  return (
    Object.defineProperty(n, '__esModule', { value: !0 }),
    Object.keys(e).forEach(function (o) {
      var r = Object.getOwnPropertyDescriptor(e, o)
      Object.defineProperty(
        n,
        o,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return e[o]
              },
            }
      )
    }),
    n
  )
}
var jh = { exports: {} },
  Pa = {}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rv = ve,
  iv = Symbol.for('react.element'),
  sv = Symbol.for('react.fragment'),
  av = Object.prototype.hasOwnProperty,
  lv = rv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  cv = { key: !0, ref: !0, __self: !0, __source: !0 }
function Wh(e, t, n) {
  var o,
    r = {},
    i = null,
    s = null
  n !== void 0 && (i = '' + n), t.key !== void 0 && (i = '' + t.key), t.ref !== void 0 && (s = t.ref)
  for (o in t) av.call(t, o) && !cv.hasOwnProperty(o) && (r[o] = t[o])
  if (e && e.defaultProps) for (o in ((t = e.defaultProps), t)) r[o] === void 0 && (r[o] = t[o])
  return { $$typeof: iv, type: e, key: i, ref: s, props: r, _owner: lv.current }
}
Pa.Fragment = sv
Pa.jsx = Wh
Pa.jsxs = Wh
jh.exports = Pa
var p = jh.exports
const xr = {
    black: '#000',
    white: '#fff',
  },
  Bo = {
    50: '#ffebee',
    100: '#ffcdd2',
    200: '#ef9a9a',
    300: '#e57373',
    400: '#ef5350',
    500: '#f44336',
    600: '#e53935',
    700: '#d32f2f',
    800: '#c62828',
    900: '#b71c1c',
    A100: '#ff8a80',
    A200: '#ff5252',
    A400: '#ff1744',
    A700: '#d50000',
  },
  uv = {
    50: '#fce4ec',
    100: '#f8bbd0',
    200: '#f48fb1',
    300: '#f06292',
    400: '#ec407a',
    500: '#e91e63',
    600: '#d81b60',
    700: '#c2185b',
    800: '#ad1457',
    900: '#880e4f',
    A100: '#ff80ab',
    A200: '#ff4081',
    A400: '#f50057',
    A700: '#c51162',
  },
  Io = {
    50: '#f3e5f5',
    100: '#e1bee7',
    200: '#ce93d8',
    300: '#ba68c8',
    400: '#ab47bc',
    500: '#9c27b0',
    600: '#8e24aa',
    700: '#7b1fa2',
    800: '#6a1b9a',
    900: '#4a148c',
    A100: '#ea80fc',
    A200: '#e040fb',
    A400: '#d500f9',
    A700: '#aa00ff',
  },
  dv = {
    50: '#ede7f6',
    100: '#d1c4e9',
    200: '#b39ddb',
    300: '#9575cd',
    400: '#7e57c2',
    500: '#673ab7',
    600: '#5e35b1',
    700: '#512da8',
    800: '#4527a0',
    900: '#311b92',
    A100: '#b388ff',
    A200: '#7c4dff',
    A400: '#651fff',
    A700: '#6200ea',
  },
  fv = {
    50: '#e8eaf6',
    100: '#c5cae9',
    200: '#9fa8da',
    300: '#7986cb',
    400: '#5c6bc0',
    500: '#3f51b5',
    600: '#3949ab',
    700: '#303f9f',
    800: '#283593',
    900: '#1a237e',
    A100: '#8c9eff',
    A200: '#536dfe',
    A400: '#3d5afe',
    A700: '#304ffe',
  },
  No = {
    50: '#e3f2fd',
    100: '#bbdefb',
    200: '#90caf9',
    300: '#64b5f6',
    400: '#42a5f5',
    500: '#2196f3',
    600: '#1e88e5',
    700: '#1976d2',
    800: '#1565c0',
    900: '#0d47a1',
    A100: '#82b1ff',
    A200: '#448aff',
    A400: '#2979ff',
    A700: '#2962ff',
  },
  ko = {
    50: '#e1f5fe',
    100: '#b3e5fc',
    200: '#81d4fa',
    300: '#4fc3f7',
    400: '#29b6f6',
    500: '#03a9f4',
    600: '#039be5',
    700: '#0288d1',
    800: '#0277bd',
    900: '#01579b',
    A100: '#80d8ff',
    A200: '#40c4ff',
    A400: '#00b0ff',
    A700: '#0091ea',
  },
  Av = {
    50: '#e0f7fa',
    100: '#b2ebf2',
    200: '#80deea',
    300: '#4dd0e1',
    400: '#26c6da',
    500: '#00bcd4',
    600: '#00acc1',
    700: '#0097a7',
    800: '#00838f',
    900: '#006064',
    A100: '#84ffff',
    A200: '#18ffff',
    A400: '#00e5ff',
    A700: '#00b8d4',
  },
  pv = {
    50: '#e0f2f1',
    100: '#b2dfdb',
    200: '#80cbc4',
    300: '#4db6ac',
    400: '#26a69a',
    500: '#009688',
    600: '#00897b',
    700: '#00796b',
    800: '#00695c',
    900: '#004d40',
    A100: '#a7ffeb',
    A200: '#64ffda',
    A400: '#1de9b6',
    A700: '#00bfa5',
  },
  Mo = {
    50: '#e8f5e9',
    100: '#c8e6c9',
    200: '#a5d6a7',
    300: '#81c784',
    400: '#66bb6a',
    500: '#4caf50',
    600: '#43a047',
    700: '#388e3c',
    800: '#2e7d32',
    900: '#1b5e20',
    A100: '#b9f6ca',
    A200: '#69f0ae',
    A400: '#00e676',
    A700: '#00c853',
  },
  hv = {
    50: '#f1f8e9',
    100: '#dcedc8',
    200: '#c5e1a5',
    300: '#aed581',
    400: '#9ccc65',
    500: '#8bc34a',
    600: '#7cb342',
    700: '#689f38',
    800: '#558b2f',
    900: '#33691e',
    A100: '#ccff90',
    A200: '#b2ff59',
    A400: '#76ff03',
    A700: '#64dd17',
  },
  gv = {
    50: '#f9fbe7',
    100: '#f0f4c3',
    200: '#e6ee9c',
    300: '#dce775',
    400: '#d4e157',
    500: '#cddc39',
    600: '#c0ca33',
    700: '#afb42b',
    800: '#9e9d24',
    900: '#827717',
    A100: '#f4ff81',
    A200: '#eeff41',
    A400: '#c6ff00',
    A700: '#aeea00',
  },
  mv = {
    50: '#fffde7',
    100: '#fff9c4',
    200: '#fff59d',
    300: '#fff176',
    400: '#ffee58',
    500: '#ffeb3b',
    600: '#fdd835',
    700: '#fbc02d',
    800: '#f9a825',
    900: '#f57f17',
    A100: '#ffff8d',
    A200: '#ffff00',
    A400: '#ffea00',
    A700: '#ffd600',
  },
  yv = {
    50: '#fff8e1',
    100: '#ffecb3',
    200: '#ffe082',
    300: '#ffd54f',
    400: '#ffca28',
    500: '#ffc107',
    600: '#ffb300',
    700: '#ffa000',
    800: '#ff8f00',
    900: '#ff6f00',
    A100: '#ffe57f',
    A200: '#ffd740',
    A400: '#ffc400',
    A700: '#ffab00',
  },
  lr = {
    50: '#fff3e0',
    100: '#ffe0b2',
    200: '#ffcc80',
    300: '#ffb74d',
    400: '#ffa726',
    500: '#ff9800',
    600: '#fb8c00',
    700: '#f57c00',
    800: '#ef6c00',
    900: '#e65100',
    A100: '#ffd180',
    A200: '#ffab40',
    A400: '#ff9100',
    A700: '#ff6d00',
  },
  bv = {
    50: '#fbe9e7',
    100: '#ffccbc',
    200: '#ffab91',
    300: '#ff8a65',
    400: '#ff7043',
    500: '#ff5722',
    600: '#f4511e',
    700: '#e64a19',
    800: '#d84315',
    900: '#bf360c',
    A100: '#ff9e80',
    A200: '#ff6e40',
    A400: '#ff3d00',
    A700: '#dd2c00',
  },
  vv = {
    50: '#efebe9',
    100: '#d7ccc8',
    200: '#bcaaa4',
    300: '#a1887f',
    400: '#8d6e63',
    500: '#795548',
    600: '#6d4c41',
    700: '#5d4037',
    800: '#4e342e',
    900: '#3e2723',
    A100: '#d7ccc8',
    A200: '#bcaaa4',
    A400: '#8d6e63',
    A700: '#5d4037',
  },
  Gh = {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e9e',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121',
    A100: '#f5f5f5',
    A200: '#eeeeee',
    A400: '#bdbdbd',
    A700: '#616161',
  },
  xv = {
    50: '#eceff1',
    100: '#cfd8dc',
    200: '#b0bec5',
    300: '#90a4ae',
    400: '#78909c',
    500: '#607d8b',
    600: '#546e7a',
    700: '#455a64',
    800: '#37474f',
    900: '#263238',
    A100: '#cfd8dc',
    A200: '#b0bec5',
    A400: '#78909c',
    A700: '#455a64',
  },
  Cv = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        amber: yv,
        blue: No,
        blueGrey: xv,
        brown: vv,
        common: xr,
        cyan: Av,
        deepOrange: bv,
        deepPurple: dv,
        green: Mo,
        grey: Gh,
        indigo: fv,
        lightBlue: ko,
        lightGreen: hv,
        lime: gv,
        orange: lr,
        pink: uv,
        purple: Io,
        red: Bo,
        teal: pv,
        yellow: mv,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function Cr(e) {
  let t = 'https://mui.com/production-error/?code=' + e
  for (let n = 1; n < arguments.length; n += 1) t += '&args[]=' + encodeURIComponent(arguments[n])
  return 'Minified MUI error #' + e + '; visit ' + t + ' for the full message.'
}
const wr = '$$material'
function k() {
  return (
    (k = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var o in n) ({}.hasOwnProperty.call(n, o) && (e[o] = n[o]))
          }
          return e
        }),
    k.apply(null, arguments)
  )
}
function pe(e, t) {
  if (e == null) return {}
  var n = {}
  for (var o in e)
    if ({}.hasOwnProperty.call(e, o)) {
      if (t.includes(o)) continue
      n[o] = e[o]
    }
  return n
}
function Vh(e) {
  let t = 'https://mui.com/production-error/?code=' + e
  for (let n = 1; n < arguments.length; n += 1) t += '&args[]=' + encodeURIComponent(arguments[n])
  return 'Minified MUI error #' + e + '; visit ' + t + ' for the full message.'
}
const wv = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      default: Vh,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
var Ev = !1
function Sv(e) {
  if (e.sheet) return e.sheet
  for (var t = 0; t < document.styleSheets.length; t++) if (document.styleSheets[t].ownerNode === e) return document.styleSheets[t]
}
function Bv(e) {
  var t = document.createElement('style')
  return t.setAttribute('data-emotion', e.key), e.nonce !== void 0 && t.setAttribute('nonce', e.nonce), t.appendChild(document.createTextNode('')), t.setAttribute('data-s', ''), t
}
var Iv = /* @__PURE__ */ (function () {
    function e(n) {
      var o = this
      ;(this._insertTag = function (r) {
        var i
        o.tags.length === 0 ? (o.insertionPoint ? (i = o.insertionPoint.nextSibling) : o.prepend ? (i = o.container.firstChild) : (i = o.before)) : (i = o.tags[o.tags.length - 1].nextSibling), o.container.insertBefore(r, i), o.tags.push(r)
      }),
        (this.isSpeedy = n.speedy === void 0 ? !Ev : n.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = n.nonce),
        (this.key = n.key),
        (this.container = n.container),
        (this.prepend = n.prepend),
        (this.insertionPoint = n.insertionPoint),
        (this.before = null)
    }
    var t = e.prototype
    return (
      (t.hydrate = function (o) {
        o.forEach(this._insertTag)
      }),
      (t.insert = function (o) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Bv(this))
        var r = this.tags[this.tags.length - 1]
        if (this.isSpeedy) {
          var i = Sv(r)
          try {
            i.insertRule(o, i.cssRules.length)
          } catch {}
        } else r.appendChild(document.createTextNode(o))
        this.ctr++
      }),
      (t.flush = function () {
        this.tags.forEach(function (o) {
          var r
          return (r = o.parentNode) == null ? void 0 : r.removeChild(o)
        }),
          (this.tags = []),
          (this.ctr = 0)
      }),
      e
    )
  })(),
  Nt = '-ms-',
  ta = '-moz-',
  Ge = '-webkit-',
  Xh = 'comm',
  Qu = 'rule',
  Ou = 'decl',
  Nv = '@import',
  Yh = '@keyframes',
  kv = '@layer',
  Mv = Math.abs,
  La = String.fromCharCode,
  Pv = Object.assign
function Lv(e, t) {
  return Bt(e, 0) ^ 45 ? (((((((t << 2) ^ Bt(e, 0)) << 2) ^ Bt(e, 1)) << 2) ^ Bt(e, 2)) << 2) ^ Bt(e, 3) : 0
}
function Hh(e) {
  return e.trim()
}
function Rv(e, t) {
  return (e = t.exec(e)) ? e[0] : e
}
function Ve(e, t, n) {
  return e.replace(t, n)
}
function Wc(e, t) {
  return e.indexOf(t)
}
function Bt(e, t) {
  return e.charCodeAt(t) | 0
}
function Mi(e, t, n) {
  return e.slice(t, n)
}
function Cn(e) {
  return e.length
}
function ju(e) {
  return e.length
}
function ds(e, t) {
  return t.push(e), e
}
function Tv(e, t) {
  return e.map(t).join('')
}
var Ra = 1,
  Er = 1,
  Uh = 0,
  jt = 0,
  mt = 0,
  Wr = ''
function Ta(e, t, n, o, r, i, s) {
  return { value: e, root: t, parent: n, type: o, props: r, children: i, line: Ra, column: Er, length: s, return: '' }
}
function ei(e, t) {
  return Pv(Ta('', null, null, '', null, null, 0), e, { length: -e.length }, t)
}
function Fv() {
  return mt
}
function Dv() {
  return (mt = jt > 0 ? Bt(Wr, --jt) : 0), Er--, mt === 10 && ((Er = 1), Ra--), mt
}
function Xt() {
  return (mt = jt < Uh ? Bt(Wr, jt++) : 0), Er++, mt === 10 && ((Er = 1), Ra++), mt
}
function Bn() {
  return Bt(Wr, jt)
}
function Ws() {
  return jt
}
function Ui(e, t) {
  return Mi(Wr, e, t)
}
function Pi(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4
    case 58:
      return 3
    case 34:
    case 39:
    case 40:
    case 91:
      return 2
    case 41:
    case 93:
      return 1
  }
  return 0
}
function Kh(e) {
  return (Ra = Er = 1), (Uh = Cn((Wr = e))), (jt = 0), []
}
function qh(e) {
  return (Wr = ''), e
}
function Gs(e) {
  return Hh(Ui(jt - 1, Gc(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}
function zv(e) {
  for (; (mt = Bn()) && mt < 33; ) Xt()
  return Pi(e) > 2 || Pi(mt) > 3 ? '' : ' '
}
function Qv(e, t) {
  for (; --t && Xt() && !(mt < 48 || mt > 102 || (mt > 57 && mt < 65) || (mt > 70 && mt < 97)); );
  return Ui(e, Ws() + (t < 6 && Bn() == 32 && Xt() == 32))
}
function Gc(e) {
  for (; Xt(); )
    switch (mt) {
      case e:
        return jt
      case 34:
      case 39:
        e !== 34 && e !== 39 && Gc(mt)
        break
      case 40:
        e === 41 && Gc(e)
        break
      case 92:
        Xt()
        break
    }
  return jt
}
function Ov(e, t) {
  for (; Xt() && e + mt !== 57; ) if (e + mt === 84 && Bn() === 47) break
  return '/*' + Ui(t, jt - 1) + '*' + La(e === 47 ? e : Xt())
}
function jv(e) {
  for (; !Pi(Bn()); ) Xt()
  return Ui(e, jt)
}
function Wv(e) {
  return qh(Vs('', null, null, null, [''], (e = Kh(e)), 0, [0], e))
}
function Vs(e, t, n, o, r, i, s, a, l) {
  for (var c = 0, u = 0, d = s, f = 0, A = 0, h = 0, g = 1, x = 1, m = 1, v = 0, y = '', b = r, C = i, I = o, w = y; x; )
    switch (((h = v), (v = Xt()))) {
      case 40:
        if (h != 108 && Bt(w, d - 1) == 58) {
          Wc((w += Ve(Gs(v), '&', '&\f')), '&\f') != -1 && (m = -1)
          break
        }
      case 34:
      case 39:
      case 91:
        w += Gs(v)
        break
      case 9:
      case 10:
      case 13:
      case 32:
        w += zv(h)
        break
      case 92:
        w += Qv(Ws() - 1, 7)
        continue
      case 47:
        switch (Bn()) {
          case 42:
          case 47:
            ds(Gv(Ov(Xt(), Ws()), t, n), l)
            break
          default:
            w += '/'
        }
        break
      case 123 * g:
        a[c++] = Cn(w) * m
      case 125 * g:
      case 59:
      case 0:
        switch (v) {
          case 0:
          case 125:
            x = 0
          case 59 + u:
            m == -1 && (w = Ve(w, /\f/g, '')), A > 0 && Cn(w) - d && ds(A > 32 ? pf(w + ';', o, n, d - 1) : pf(Ve(w, ' ', '') + ';', o, n, d - 2), l)
            break
          case 59:
            w += ';'
          default:
            if ((ds((I = Af(w, t, n, c, u, r, a, y, (b = []), (C = []), d)), i), v === 123))
              if (u === 0) Vs(w, t, I, I, b, i, d, a, C)
              else
                switch (f === 99 && Bt(w, 3) === 110 ? 100 : f) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Vs(e, I, I, o && ds(Af(e, I, I, 0, 0, r, a, y, r, (b = []), d), C), r, C, d, a, o ? b : C)
                    break
                  default:
                    Vs(w, I, I, I, [''], C, 0, a, C)
                }
        }
        ;(c = u = A = 0), (g = m = 1), (y = w = ''), (d = s)
        break
      case 58:
        ;(d = 1 + Cn(w)), (A = h)
      default:
        if (g < 1) {
          if (v == 123) --g
          else if (v == 125 && g++ == 0 && Dv() == 125) continue
        }
        switch (((w += La(v)), v * g)) {
          case 38:
            m = u > 0 ? 1 : ((w += '\f'), -1)
            break
          case 44:
            ;(a[c++] = (Cn(w) - 1) * m), (m = 1)
            break
          case 64:
            Bn() === 45 && (w += Gs(Xt())), (f = Bn()), (u = d = Cn((y = w += jv(Ws())))), v++
            break
          case 45:
            h === 45 && Cn(w) == 2 && (g = 0)
        }
    }
  return i
}
function Af(e, t, n, o, r, i, s, a, l, c, u) {
  for (var d = r - 1, f = r === 0 ? i : [''], A = ju(f), h = 0, g = 0, x = 0; h < o; ++h) for (var m = 0, v = Mi(e, d + 1, (d = Mv((g = s[h])))), y = e; m < A; ++m) (y = Hh(g > 0 ? f[m] + ' ' + v : Ve(v, /&\f/g, f[m]))) && (l[x++] = y)
  return Ta(e, t, n, r === 0 ? Qu : a, l, c, u)
}
function Gv(e, t, n) {
  return Ta(e, t, n, Xh, La(Fv()), Mi(e, 2, -2), 0)
}
function pf(e, t, n, o) {
  return Ta(e, t, n, Ou, Mi(e, 0, o), Mi(e, o + 1, -1), o)
}
function hr(e, t) {
  for (var n = '', o = ju(e), r = 0; r < o; r++) n += t(e[r], r, e, t) || ''
  return n
}
function Vv(e, t, n, o) {
  switch (e.type) {
    case kv:
      if (e.children.length) break
    case Nv:
    case Ou:
      return (e.return = e.return || e.value)
    case Xh:
      return ''
    case Yh:
      return (e.return = e.value + '{' + hr(e.children, o) + '}')
    case Qu:
      e.value = e.props.join(',')
  }
  return Cn((n = hr(e.children, o))) ? (e.return = e.value + '{' + n + '}') : ''
}
function Xv(e) {
  var t = ju(e)
  return function (n, o, r, i) {
    for (var s = '', a = 0; a < t; a++) s += e[a](n, o, r, i) || ''
    return s
  }
}
function Yv(e) {
  return function (t) {
    t.root || ((t = t.return) && e(t))
  }
}
function Zh(e) {
  var t = /* @__PURE__ */ Object.create(null)
  return function (n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n]
  }
}
var Hv = function (t, n, o) {
    for (var r = 0, i = 0; (r = i), (i = Bn()), r === 38 && i === 12 && (n[o] = 1), !Pi(i); ) Xt()
    return Ui(t, jt)
  },
  Uv = function (t, n) {
    var o = -1,
      r = 44
    do
      switch (Pi(r)) {
        case 0:
          r === 38 && Bn() === 12 && (n[o] = 1), (t[o] += Hv(jt - 1, n, o))
          break
        case 2:
          t[o] += Gs(r)
          break
        case 4:
          if (r === 44) {
            ;(t[++o] = Bn() === 58 ? '&\f' : ''), (n[o] = t[o].length)
            break
          }
        default:
          t[o] += La(r)
      }
    while ((r = Xt()))
    return t
  },
  Kv = function (t, n) {
    return qh(Uv(Kh(t), n))
  },
  hf = /* @__PURE__ */ new WeakMap(),
  qv = function (t) {
    if (
      !(
        t.type !== 'rule' ||
        !t.parent || // positive .length indicates that this rule contains pseudo
        // negative .length indicates that this rule has been already prefixed
        t.length < 1
      )
    ) {
      for (var n = t.value, o = t.parent, r = t.column === o.column && t.line === o.line; o.type !== 'rule'; ) if (((o = o.parent), !o)) return
      if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !hf.get(o)) && !r) {
        hf.set(t, !0)
        for (var i = [], s = Kv(n, i), a = o.props, l = 0, c = 0; l < s.length; l++) for (var u = 0; u < a.length; u++, c++) t.props[c] = i[l] ? s[l].replace(/&\f/g, a[u]) : a[u] + ' ' + s[l]
      }
    }
  },
  Zv = function (t) {
    if (t.type === 'decl') {
      var n = t.value
      // charcode for l
      n.charCodeAt(0) === 108 && // charcode for b
        n.charCodeAt(2) === 98 &&
        ((t.return = ''), (t.value = ''))
    }
  }
function Jh(e, t) {
  switch (Lv(e, t)) {
    case 5103:
      return Ge + 'print-' + e + e
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Ge + e + e
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Ge + e + ta + e + Nt + e + e
    case 6828:
    case 4268:
      return Ge + e + Nt + e + e
    case 6165:
      return Ge + e + Nt + 'flex-' + e + e
    case 5187:
      return Ge + e + Ve(e, /(\w+).+(:[^]+)/, Ge + 'box-$1$2' + Nt + 'flex-$1$2') + e
    case 5443:
      return Ge + e + Nt + 'flex-item-' + Ve(e, /flex-|-self/, '') + e
    case 4675:
      return Ge + e + Nt + 'flex-line-pack' + Ve(e, /align-content|flex-|-self/, '') + e
    case 5548:
      return Ge + e + Nt + Ve(e, 'shrink', 'negative') + e
    case 5292:
      return Ge + e + Nt + Ve(e, 'basis', 'preferred-size') + e
    case 6060:
      return Ge + 'box-' + Ve(e, '-grow', '') + Ge + e + Nt + Ve(e, 'grow', 'positive') + e
    case 4554:
      return Ge + Ve(e, /([^-])(transform)/g, '$1' + Ge + '$2') + e
    case 6187:
      return Ve(Ve(Ve(e, /(zoom-|grab)/, Ge + '$1'), /(image-set)/, Ge + '$1'), e, '') + e
    case 5495:
    case 3959:
      return Ve(e, /(image-set\([^]*)/, Ge + '$1$`$1')
    case 4968:
      return Ve(Ve(e, /(.+:)(flex-)?(.*)/, Ge + 'box-pack:$3' + Nt + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + Ge + e + e
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Ve(e, /(.+)-inline(.+)/, Ge + '$1$2') + e
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Cn(e) - 1 - t > 6)
        switch (Bt(e, t + 1)) {
          case 109:
            if (Bt(e, t + 4) !== 45) break
          case 102:
            return Ve(e, /(.+:)(.+)-([^]+)/, '$1' + Ge + '$2-$3$1' + ta + (Bt(e, t + 3) == 108 ? '$3' : '$2-$3')) + e
          case 115:
            return ~Wc(e, 'stretch') ? Jh(Ve(e, 'stretch', 'fill-available'), t) + e : e
        }
      break
    case 4949:
      if (Bt(e, t + 1) !== 115) break
    case 6444:
      switch (Bt(e, Cn(e) - 3 - (~Wc(e, '!important') && 10))) {
        case 107:
          return Ve(e, ':', ':' + Ge) + e
        case 101:
          return Ve(e, /(.+:)([^;!]+)(;|!.+)?/, '$1' + Ge + (Bt(e, 14) === 45 ? 'inline-' : '') + 'box$3$1' + Ge + '$2$3$1' + Nt + '$2box$3') + e
      }
      break
    case 5936:
      switch (Bt(e, t + 11)) {
        case 114:
          return Ge + e + Nt + Ve(e, /[svh]\w+-[tblr]{2}/, 'tb') + e
        case 108:
          return Ge + e + Nt + Ve(e, /[svh]\w+-[tblr]{2}/, 'tb-rl') + e
        case 45:
          return Ge + e + Nt + Ve(e, /[svh]\w+-[tblr]{2}/, 'lr') + e
      }
      return Ge + e + Nt + e + e
  }
  return e
}
var Jv = function (t, n, o, r) {
    if (t.length > -1 && !t.return)
      switch (t.type) {
        case Ou:
          t.return = Jh(t.value, t.length)
          break
        case Yh:
          return hr(
            [
              ei(t, {
                value: Ve(t.value, '@', '@' + Ge),
              }),
            ],
            r
          )
        case Qu:
          if (t.length)
            return Tv(t.props, function (i) {
              switch (Rv(i, /(::plac\w+|:read-\w+)/)) {
                case ':read-only':
                case ':read-write':
                  return hr(
                    [
                      ei(t, {
                        props: [Ve(i, /:(read-\w+)/, ':' + ta + '$1')],
                      }),
                    ],
                    r
                  )
                case '::placeholder':
                  return hr(
                    [
                      ei(t, {
                        props: [Ve(i, /:(plac\w+)/, ':' + Ge + 'input-$1')],
                      }),
                      ei(t, {
                        props: [Ve(i, /:(plac\w+)/, ':' + ta + '$1')],
                      }),
                      ei(t, {
                        props: [Ve(i, /:(plac\w+)/, Nt + 'input-$1')],
                      }),
                    ],
                    r
                  )
              }
              return ''
            })
      }
  },
  _v = [Jv],
  _h = function (t) {
    var n = t.key
    if (n === 'css') {
      var o = document.querySelectorAll('style[data-emotion]:not([data-s])')
      Array.prototype.forEach.call(o, function (g) {
        var x = g.getAttribute('data-emotion')
        x.indexOf(' ') !== -1 && (document.head.appendChild(g), g.setAttribute('data-s', ''))
      })
    }
    var r = t.stylisPlugins || _v,
      i = {},
      s,
      a = []
    ;(s = t.container || document.head),
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
        function (g) {
          for (var x = g.getAttribute('data-emotion').split(' '), m = 1; m < x.length; m++) i[x[m]] = !0
          a.push(g)
        }
      )
    var l,
      c = [qv, Zv]
    {
      var u,
        d = [
          Vv,
          Yv(function (g) {
            u.insert(g)
          }),
        ],
        f = Xv(c.concat(r, d)),
        A = function (x) {
          return hr(Wv(x), f)
        }
      l = function (x, m, v, y) {
        ;(u = v), A(x ? x + '{' + m.styles + '}' : m.styles), y && (h.inserted[m.name] = !0)
      }
    }
    var h = {
      key: n,
      sheet: new Iv({
        key: n,
        container: s,
        nonce: t.nonce,
        speedy: t.speedy,
        prepend: t.prepend,
        insertionPoint: t.insertionPoint,
      }),
      nonce: t.nonce,
      inserted: i,
      registered: {},
      insert: l,
    }
    return h.sheet.hydrate(a), h
  },
  $h = { exports: {} },
  Ue = {}
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Et = typeof Symbol == 'function' && Symbol.for,
  Wu = Et ? Symbol.for('react.element') : 60103,
  Gu = Et ? Symbol.for('react.portal') : 60106,
  Fa = Et ? Symbol.for('react.fragment') : 60107,
  Da = Et ? Symbol.for('react.strict_mode') : 60108,
  za = Et ? Symbol.for('react.profiler') : 60114,
  Qa = Et ? Symbol.for('react.provider') : 60109,
  Oa = Et ? Symbol.for('react.context') : 60110,
  Vu = Et ? Symbol.for('react.async_mode') : 60111,
  ja = Et ? Symbol.for('react.concurrent_mode') : 60111,
  Wa = Et ? Symbol.for('react.forward_ref') : 60112,
  Ga = Et ? Symbol.for('react.suspense') : 60113,
  $v = Et ? Symbol.for('react.suspense_list') : 60120,
  Va = Et ? Symbol.for('react.memo') : 60115,
  Xa = Et ? Symbol.for('react.lazy') : 60116,
  ex = Et ? Symbol.for('react.block') : 60121,
  tx = Et ? Symbol.for('react.fundamental') : 60117,
  nx = Et ? Symbol.for('react.responder') : 60118,
  ox = Et ? Symbol.for('react.scope') : 60119
function Ut(e) {
  if (typeof e == 'object' && e !== null) {
    var t = e.$$typeof
    switch (t) {
      case Wu:
        switch (((e = e.type), e)) {
          case Vu:
          case ja:
          case Fa:
          case za:
          case Da:
          case Ga:
            return e
          default:
            switch (((e = e && e.$$typeof), e)) {
              case Oa:
              case Wa:
              case Xa:
              case Va:
              case Qa:
                return e
              default:
                return t
            }
        }
      case Gu:
        return t
    }
  }
}
function eg(e) {
  return Ut(e) === ja
}
Ue.AsyncMode = Vu
Ue.ConcurrentMode = ja
Ue.ContextConsumer = Oa
Ue.ContextProvider = Qa
Ue.Element = Wu
Ue.ForwardRef = Wa
Ue.Fragment = Fa
Ue.Lazy = Xa
Ue.Memo = Va
Ue.Portal = Gu
Ue.Profiler = za
Ue.StrictMode = Da
Ue.Suspense = Ga
Ue.isAsyncMode = function (e) {
  return eg(e) || Ut(e) === Vu
}
Ue.isConcurrentMode = eg
Ue.isContextConsumer = function (e) {
  return Ut(e) === Oa
}
Ue.isContextProvider = function (e) {
  return Ut(e) === Qa
}
Ue.isElement = function (e) {
  return typeof e == 'object' && e !== null && e.$$typeof === Wu
}
Ue.isForwardRef = function (e) {
  return Ut(e) === Wa
}
Ue.isFragment = function (e) {
  return Ut(e) === Fa
}
Ue.isLazy = function (e) {
  return Ut(e) === Xa
}
Ue.isMemo = function (e) {
  return Ut(e) === Va
}
Ue.isPortal = function (e) {
  return Ut(e) === Gu
}
Ue.isProfiler = function (e) {
  return Ut(e) === za
}
Ue.isStrictMode = function (e) {
  return Ut(e) === Da
}
Ue.isSuspense = function (e) {
  return Ut(e) === Ga
}
Ue.isValidElementType = function (e) {
  return (
    typeof e == 'string' ||
    typeof e == 'function' ||
    e === Fa ||
    e === ja ||
    e === za ||
    e === Da ||
    e === Ga ||
    e === $v ||
    (typeof e == 'object' && e !== null && (e.$$typeof === Xa || e.$$typeof === Va || e.$$typeof === Qa || e.$$typeof === Oa || e.$$typeof === Wa || e.$$typeof === tx || e.$$typeof === nx || e.$$typeof === ox || e.$$typeof === ex))
  )
}
Ue.typeOf = Ut
$h.exports = Ue
var rx = $h.exports,
  tg = rx,
  ix = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
  },
  sx = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0,
  },
  ng = {}
ng[tg.ForwardRef] = ix
ng[tg.Memo] = sx
var ax = !0
function og(e, t, n) {
  var o = ''
  return (
    n.split(' ').forEach(function (r) {
      e[r] !== void 0 ? t.push(e[r] + ';') : r && (o += r + ' ')
    }),
    o
  )
}
var Xu = function (t, n, o) {
    var r = t.key + '-' + n.name
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    ;(o === !1 || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      ax === !1) &&
      t.registered[r] === void 0 &&
      (t.registered[r] = n.styles)
  },
  Yu = function (t, n, o) {
    Xu(t, n, o)
    var r = t.key + '-' + n.name
    if (t.inserted[n.name] === void 0) {
      var i = n
      do t.insert(n === i ? '.' + r : '', i, t.sheet, !0), (i = i.next)
      while (i !== void 0)
    }
  }
function lx(e) {
  for (var t = 0, n, o = 0, r = e.length; r >= 4; ++o, r -= 4)
    (n = (e.charCodeAt(o) & 255) | ((e.charCodeAt(++o) & 255) << 8) | ((e.charCodeAt(++o) & 255) << 16) | ((e.charCodeAt(++o) & 255) << 24)),
      (n = /* Math.imul(k, m): */ (n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)),
      (n ^= /* k >>> r: */ n >>> 24),
      (t = /* Math.imul(k, m): */ ((n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)) /* Math.imul(h, m): */ ^ ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)))
  switch (r) {
    case 3:
      t ^= (e.charCodeAt(o + 2) & 255) << 16
    case 2:
      t ^= (e.charCodeAt(o + 1) & 255) << 8
    case 1:
      ;(t ^= e.charCodeAt(o) & 255), (t = /* Math.imul(h, m): */ (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16))
  }
  return (t ^= t >>> 13), (t = /* Math.imul(h, m): */ (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)), ((t ^ (t >>> 15)) >>> 0).toString(36)
}
var cx = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  ux = /[A-Z]|^ms/g,
  dx = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  rg = function (t) {
    return t.charCodeAt(1) === 45
  },
  gf = function (t) {
    return t != null && typeof t != 'boolean'
  },
  _l = /* @__PURE__ */ Zh(function (e) {
    return rg(e) ? e : e.replace(ux, '-$&').toLowerCase()
  }),
  mf = function (t, n) {
    switch (t) {
      case 'animation':
      case 'animationName':
        if (typeof n == 'string')
          return n.replace(dx, function (o, r, i) {
            return (
              (wn = {
                name: r,
                styles: i,
                next: wn,
              }),
              r
            )
          })
    }
    return cx[t] !== 1 && !rg(t) && typeof n == 'number' && n !== 0 ? n + 'px' : n
  }
function Li(e, t, n) {
  if (n == null) return ''
  var o = n
  if (o.__emotion_styles !== void 0) return o
  switch (typeof n) {
    case 'boolean':
      return ''
    case 'object': {
      var r = n
      if (r.anim === 1)
        return (
          (wn = {
            name: r.name,
            styles: r.styles,
            next: wn,
          }),
          r.name
        )
      var i = n
      if (i.styles !== void 0) {
        var s = i.next
        if (s !== void 0)
          for (; s !== void 0; )
            (wn = {
              name: s.name,
              styles: s.styles,
              next: wn,
            }),
              (s = s.next)
        var a = i.styles + ';'
        return a
      }
      return fx(e, t, n)
    }
    case 'function': {
      if (e !== void 0) {
        var l = wn,
          c = n(e)
        return (wn = l), Li(e, t, c)
      }
      break
    }
  }
  var u = n
  if (t == null) return u
  var d = t[u]
  return d !== void 0 ? d : u
}
function fx(e, t, n) {
  var o = ''
  if (Array.isArray(n)) for (var r = 0; r < n.length; r++) o += Li(e, t, n[r]) + ';'
  else
    for (var i in n) {
      var s = n[i]
      if (typeof s != 'object') {
        var a = s
        t != null && t[a] !== void 0 ? (o += i + '{' + t[a] + '}') : gf(a) && (o += _l(i) + ':' + mf(i, a) + ';')
      } else if (Array.isArray(s) && typeof s[0] == 'string' && (t == null || t[s[0]] === void 0)) for (var l = 0; l < s.length; l++) gf(s[l]) && (o += _l(i) + ':' + mf(i, s[l]) + ';')
      else {
        var c = Li(e, t, s)
        switch (i) {
          case 'animation':
          case 'animationName': {
            o += _l(i) + ':' + c + ';'
            break
          }
          default:
            o += i + '{' + c + '}'
        }
      }
    }
  return o
}
var yf = /label:\s*([^\s;{]+)\s*(;|$)/g,
  wn
function Ya(e, t, n) {
  if (e.length === 1 && typeof e[0] == 'object' && e[0] !== null && e[0].styles !== void 0) return e[0]
  var o = !0,
    r = ''
  wn = void 0
  var i = e[0]
  if (i == null || i.raw === void 0) (o = !1), (r += Li(n, t, i))
  else {
    var s = i
    r += s[0]
  }
  for (var a = 1; a < e.length; a++)
    if (((r += Li(n, t, e[a])), o)) {
      var l = i
      r += l[a]
    }
  yf.lastIndex = 0
  for (var c = '', u; (u = yf.exec(r)) !== null; ) c += '-' + u[1]
  var d = lx(r) + c
  return {
    name: d,
    styles: r,
    next: wn,
  }
}
var Ax = function (t) {
    return t()
  },
  ig = N.useInsertionEffect ? N.useInsertionEffect : !1,
  sg = ig || Ax,
  bf = ig || N.useLayoutEffect,
  px = !1,
  ag = /* @__PURE__ */ N.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement < 'u'
      ? /* @__PURE__ */ _h({
          key: 'css',
        })
      : null
  ),
  hx = ag.Provider,
  Hu = function (t) {
    return /* @__PURE__ */ jr(function (n, o) {
      var r = qn(ag)
      return t(n, r, o)
    })
  },
  Gr = /* @__PURE__ */ N.createContext({}),
  Uu = {}.hasOwnProperty,
  Vc = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__',
  gx = function (t, n) {
    var o = {}
    for (var r in n) Uu.call(n, r) && (o[r] = n[r])
    return (o[Vc] = t), o
  },
  mx = function (t) {
    var n = t.cache,
      o = t.serialized,
      r = t.isStringTag
    return (
      Xu(n, o, r),
      sg(function () {
        return Yu(n, o, r)
      }),
      null
    )
  },
  yx = /* @__PURE__ */ Hu(function (e, t, n) {
    var o = e.css
    typeof o == 'string' && t.registered[o] !== void 0 && (o = t.registered[o])
    var r = e[Vc],
      i = [o],
      s = ''
    typeof e.className == 'string' ? (s = og(t.registered, i, e.className)) : e.className != null && (s = e.className + ' ')
    var a = Ya(i, void 0, N.useContext(Gr))
    s += t.key + '-' + a.name
    var l = {}
    for (var c in e) Uu.call(e, c) && c !== 'css' && c !== Vc && !px && (l[c] = e[c])
    return (
      (l.className = s),
      n && (l.ref = n),
      /* @__PURE__ */ N.createElement(
        N.Fragment,
        null,
        /* @__PURE__ */ N.createElement(mx, {
          cache: t,
          serialized: a,
          isStringTag: typeof r == 'string',
        }),
        /* @__PURE__ */ N.createElement(r, l)
      )
    )
  }),
  bx = yx,
  $l = { exports: {} },
  vf
function lg() {
  return (
    vf ||
      ((vf = 1),
      (function (e) {
        function t() {
          return (
            (e.exports = t =
              Object.assign
                ? Object.assign.bind()
                : function (n) {
                    for (var o = 1; o < arguments.length; o++) {
                      var r = arguments[o]
                      for (var i in r) ({}.hasOwnProperty.call(r, i) && (n[i] = r[i]))
                    }
                    return n
                  }),
            (e.exports.__esModule = !0),
            (e.exports.default = e.exports),
            t.apply(null, arguments)
          )
        }
        ;(e.exports = t), (e.exports.__esModule = !0), (e.exports.default = e.exports)
      })($l)),
    $l.exports
  )
}
lg()
var vx = function (t, n) {
  var o = arguments
  if (n == null || !Uu.call(n, 'css')) return N.createElement.apply(void 0, o)
  var r = o.length,
    i = new Array(r)
  ;(i[0] = bx), (i[1] = gx(t, n))
  for (var s = 2; s < r; s++) i[s] = o[s]
  return N.createElement.apply(null, i)
}
;(function (e) {
  var t
  t || (t = e.JSX || (e.JSX = {}))
})(vx)
var xx = /* @__PURE__ */ Hu(function (e, t) {
  var n = e.styles,
    o = Ya([n], void 0, N.useContext(Gr)),
    r = N.useRef()
  return (
    bf(
      function () {
        var i = t.key + '-global',
          s = new t.sheet.constructor({
            key: i,
            nonce: t.sheet.nonce,
            container: t.sheet.container,
            speedy: t.sheet.isSpeedy,
          }),
          a = !1,
          l = document.querySelector('style[data-emotion="' + i + ' ' + o.name + '"]')
        return (
          t.sheet.tags.length && (s.before = t.sheet.tags[0]),
          l !== null && ((a = !0), l.setAttribute('data-emotion', i), s.hydrate([l])),
          (r.current = [s, a]),
          function () {
            s.flush()
          }
        )
      },
      [t]
    ),
    bf(
      function () {
        var i = r.current,
          s = i[0],
          a = i[1]
        if (a) {
          i[1] = !1
          return
        }
        if ((o.next !== void 0 && Yu(t, o.next, !0), s.tags.length)) {
          var l = s.tags[s.tags.length - 1].nextElementSibling
          ;(s.before = l), s.flush()
        }
        t.insert('', o, s, !1)
      },
      [t, o.name]
    ),
    null
  )
})
function cg() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n]
  return Ya(t)
}
function Ha() {
  var e = cg.apply(void 0, arguments),
    t = 'animation-' + e.name
  return {
    name: t,
    styles: '@keyframes ' + t + '{' + e.styles + '}',
    anim: 1,
    toString: function () {
      return '_EMO_' + this.name + '_' + this.styles + '_EMO_'
    },
  }
}
var Cx =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  wx = /* @__PURE__ */ Zh(
    function (e) {
      return Cx.test(e) || (e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91)
    }
    /* Z+1 */
  ),
  Ex = wx,
  Sx = function (t) {
    return t !== 'theme'
  },
  xf = function (t) {
    return typeof t == 'string' && // 96 is one less than the char code
      // for "a" so this is checking that
      // it's a lowercase character
      t.charCodeAt(0) > 96
      ? Ex
      : Sx
  },
  Cf = function (t, n, o) {
    var r
    if (n) {
      var i = n.shouldForwardProp
      r =
        t.__emotion_forwardProp && i
          ? function (s) {
              return t.__emotion_forwardProp(s) && i(s)
            }
          : i
    }
    return typeof r != 'function' && o && (r = t.__emotion_forwardProp), r
  },
  Bx = function (t) {
    var n = t.cache,
      o = t.serialized,
      r = t.isStringTag
    return (
      Xu(n, o, r),
      sg(function () {
        return Yu(n, o, r)
      }),
      null
    )
  },
  Ix = function e(t, n) {
    var o = t.__emotion_real === t,
      r = (o && t.__emotion_base) || t,
      i,
      s
    n !== void 0 && ((i = n.label), (s = n.target))
    var a = Cf(t, n, o),
      l = a || xf(r),
      c = !l('as')
    return function () {
      var u = arguments,
        d = o && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : []
      if ((i !== void 0 && d.push('label:' + i + ';'), u[0] == null || u[0].raw === void 0)) d.push.apply(d, u)
      else {
        var f = u[0]
        d.push(f[0])
        for (var A = u.length, h = 1; h < A; h++) d.push(u[h], f[h])
      }
      var g = Hu(function (x, m, v) {
        var y = (c && x.as) || r,
          b = '',
          C = [],
          I = x
        if (x.theme == null) {
          I = {}
          for (var w in x) I[w] = x[w]
          I.theme = N.useContext(Gr)
        }
        typeof x.className == 'string' ? (b = og(m.registered, C, x.className)) : x.className != null && (b = x.className + ' ')
        var M = Ya(d.concat(C), m.registered, I)
        ;(b += m.key + '-' + M.name), s !== void 0 && (b += ' ' + s)
        var L = c && a === void 0 ? xf(y) : l,
          R = {}
        for (var T in x) (c && T === 'as') || (L(T) && (R[T] = x[T]))
        return (
          (R.className = b),
          v && (R.ref = v),
          /* @__PURE__ */ N.createElement(
            N.Fragment,
            null,
            /* @__PURE__ */ N.createElement(Bx, {
              cache: m,
              serialized: M,
              isStringTag: typeof y == 'string',
            }),
            /* @__PURE__ */ N.createElement(y, R)
          )
        )
      })
      return (
        (g.displayName = i !== void 0 ? i : 'Styled(' + (typeof r == 'string' ? r : r.displayName || r.name || 'Component') + ')'),
        (g.defaultProps = t.defaultProps),
        (g.__emotion_real = g),
        (g.__emotion_base = r),
        (g.__emotion_styles = d),
        (g.__emotion_forwardProp = a),
        Object.defineProperty(g, 'toString', {
          value: function () {
            return '.' + s
          },
        }),
        (g.withComponent = function (x, m) {
          var v = e(
            x,
            k({}, n, m, {
              shouldForwardProp: Cf(g, m, !0),
            })
          )
          return v.apply(void 0, d)
        }),
        g
      )
    }
  },
  Nx = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'big',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'marquee',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
    // SVG
    'circle',
    'clipPath',
    'defs',
    'ellipse',
    'foreignObject',
    'g',
    'image',
    'line',
    'linearGradient',
    'mask',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'stop',
    'svg',
    'text',
    'tspan',
  ],
  Xc = Ix.bind(null)
Nx.forEach(function (e) {
  Xc[e] = Xc(e)
})
let Yc
typeof document == 'object' &&
  (Yc = _h({
    key: 'css',
    prepend: !0,
  }))
function kx(e) {
  const { injectFirst: t, children: n } = e
  return t && Yc
    ? /* @__PURE__ */ p.jsx(hx, {
        value: Yc,
        children: n,
      })
    : n
}
function Mx(e) {
  return e == null || Object.keys(e).length === 0
}
function ug(e) {
  const { styles: t, defaultTheme: n = {} } = e,
    o = typeof t == 'function' ? r => t(Mx(r) ? n : r) : t
  return /* @__PURE__ */ p.jsx(xx, {
    styles: o,
  })
}
function Ku(e, t) {
  return Xc(e, t)
}
const dg = (e, t) => {
    Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles))
  },
  Px = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        GlobalStyles: ug,
        StyledEngineProvider: kx,
        ThemeContext: Gr,
        css: cg,
        default: Ku,
        internal_processStyles: dg,
        keyframes: Ha,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function jn(e) {
  if (typeof e != 'object' || e === null) return !1
  const t = Object.getPrototypeOf(e)
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
}
function fg(e) {
  if (/* @__PURE__ */ N.isValidElement(e) || !jn(e)) return e
  const t = {}
  return (
    Object.keys(e).forEach(n => {
      t[n] = fg(e[n])
    }),
    t
  )
}
function Xo(
  e,
  t,
  n = {
    clone: !0,
  }
) {
  const o = n.clone ? k({}, e) : e
  return (
    jn(e) &&
      jn(t) &&
      Object.keys(t).forEach(r => {
        /* @__PURE__ */ N.isValidElement(t[r])
          ? (o[r] = t[r])
          : jn(t[r]) && // Avoid prototype pollution
            Object.prototype.hasOwnProperty.call(e, r) &&
            jn(e[r])
          ? (o[r] = Xo(e[r], t[r], n))
          : n.clone
          ? (o[r] = jn(t[r]) ? fg(t[r]) : t[r])
          : (o[r] = t[r])
      }),
    o
  )
}
const Lx = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        default: Xo,
        isPlainObject: jn,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Rx = ['values', 'unit', 'step'],
  Tx = e => {
    const t =
      Object.keys(e).map(n => ({
        key: n,
        val: e[n],
      })) || []
    return (
      t.sort((n, o) => n.val - o.val),
      t.reduce(
        (n, o) =>
          k({}, n, {
            [o.key]: o.val,
          }),
        {}
      )
    )
  }
function Ag(e) {
  const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: t = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536,
        // large screen
      },
      unit: n = 'px',
      step: o = 5,
    } = e,
    r = pe(e, Rx),
    i = Tx(t),
    s = Object.keys(i)
  function a(f) {
    return `@media (min-width:${typeof t[f] == 'number' ? t[f] : f}${n})`
  }
  function l(f) {
    return `@media (max-width:${(typeof t[f] == 'number' ? t[f] : f) - o / 100}${n})`
  }
  function c(f, A) {
    const h = s.indexOf(A)
    return `@media (min-width:${typeof t[f] == 'number' ? t[f] : f}${n}) and (max-width:${(h !== -1 && typeof t[s[h]] == 'number' ? t[s[h]] : A) - o / 100}${n})`
  }
  function u(f) {
    return s.indexOf(f) + 1 < s.length ? c(f, s[s.indexOf(f) + 1]) : a(f)
  }
  function d(f) {
    const A = s.indexOf(f)
    return A === 0 ? a(s[1]) : A === s.length - 1 ? l(s[A]) : c(f, s[s.indexOf(f) + 1]).replace('@media', '@media not all and')
  }
  return k(
    {
      keys: s,
      values: i,
      up: a,
      down: l,
      between: c,
      only: u,
      not: d,
      unit: n,
    },
    r
  )
}
const Fx = {
  borderRadius: 4,
}
function xi(e, t) {
  return t
    ? Xo(e, t, {
        clone: !1,
        // No need to clone deep, it's way faster.
      })
    : e
}
const qu = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536,
    // large screen
  },
  wf = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ['xs', 'sm', 'md', 'lg', 'xl'],
    up: e => `@media (min-width:${qu[e]}px)`,
  }
function hn(e, t, n) {
  const o = e.theme || {}
  if (Array.isArray(t)) {
    const i = o.breakpoints || wf
    return t.reduce((s, a, l) => ((s[i.up(i.keys[l])] = n(t[l])), s), {})
  }
  if (typeof t == 'object') {
    const i = o.breakpoints || wf
    return Object.keys(t).reduce((s, a) => {
      if (Object.keys(i.values || qu).indexOf(a) !== -1) {
        const l = i.up(a)
        s[l] = n(t[a], a)
      } else {
        const l = a
        s[l] = t[l]
      }
      return s
    }, {})
  }
  return n(t)
}
function pg(e = {}) {
  var t
  return (
    ((t = e.keys) == null
      ? void 0
      : t.reduce((o, r) => {
          const i = e.up(r)
          return (o[i] = {}), o
        }, {})) || {}
  )
}
function hg(e, t) {
  return e.reduce((n, o) => {
    const r = n[o]
    return (!r || Object.keys(r).length === 0) && delete n[o], n
  }, t)
}
function Dx(e, ...t) {
  const n = pg(e),
    o = [n, ...t].reduce((r, i) => Xo(r, i), {})
  return hg(Object.keys(n), o)
}
function zx(e, t) {
  if (typeof e != 'object') return {}
  const n = {},
    o = Object.keys(t)
  return (
    Array.isArray(e)
      ? o.forEach((r, i) => {
          i < e.length && (n[r] = !0)
        })
      : o.forEach(r => {
          e[r] != null && (n[r] = !0)
        }),
    n
  )
}
function ec({ values: e, breakpoints: t, base: n }) {
  const o = n || zx(e, t),
    r = Object.keys(o)
  if (r.length === 0) return e
  let i
  return r.reduce((s, a, l) => (Array.isArray(e) ? ((s[a] = e[l] != null ? e[l] : e[i]), (i = l)) : typeof e == 'object' ? ((s[a] = e[a] != null ? e[a] : e[i]), (i = a)) : (s[a] = e), s), {})
}
function Zu(e) {
  if (typeof e != 'string') throw new Error(Vh(7))
  return e.charAt(0).toUpperCase() + e.slice(1)
}
const Qx = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      default: Zu,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function Ua(e, t, n = !0) {
  if (!t || typeof t != 'string') return null
  if (e && e.vars && n) {
    const o = `vars.${t}`.split('.').reduce((r, i) => (r && r[i] ? r[i] : null), e)
    if (o != null) return o
  }
  return t.split('.').reduce((o, r) => (o && o[r] != null ? o[r] : null), e)
}
function na(e, t, n, o = n) {
  let r
  return typeof e == 'function' ? (r = e(n)) : Array.isArray(e) ? (r = e[n] || o) : (r = Ua(e, n) || o), t && (r = t(r, o, e)), r
}
function pt(e) {
  const { prop: t, cssProperty: n = e.prop, themeKey: o, transform: r } = e,
    i = s => {
      if (s[t] == null) return null
      const a = s[t],
        l = s.theme,
        c = Ua(l, o) || {}
      return hn(s, a, d => {
        let f = na(c, r, d)
        return (
          d === f && typeof d == 'string' && (f = na(c, r, `${t}${d === 'default' ? '' : Zu(d)}`, d)),
          n === !1
            ? f
            : {
                [n]: f,
              }
        )
      })
    }
  return (i.propTypes = {}), (i.filterProps = [t]), i
}
function Ox(e) {
  const t = {}
  return n => (t[n] === void 0 && (t[n] = e(n)), t[n])
}
const jx = {
    m: 'margin',
    p: 'padding',
  },
  Wx = {
    t: 'Top',
    r: 'Right',
    b: 'Bottom',
    l: 'Left',
    x: ['Left', 'Right'],
    y: ['Top', 'Bottom'],
  },
  Ef = {
    marginX: 'mx',
    marginY: 'my',
    paddingX: 'px',
    paddingY: 'py',
  },
  Gx = Ox(e => {
    if (e.length > 2)
      if (Ef[e]) e = Ef[e]
      else return [e]
    const [t, n] = e.split(''),
      o = jx[t],
      r = Wx[n] || ''
    return Array.isArray(r) ? r.map(i => o + i) : [o + r]
  }),
  Ju = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'],
  _u = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd']
;[...Ju, ..._u]
function Ki(e, t, n, o) {
  var r
  const i = (r = Ua(e, t, !1)) != null ? r : n
  return typeof i == 'number' ? s => (typeof s == 'string' ? s : i * s) : Array.isArray(i) ? s => (typeof s == 'string' ? s : i[s]) : typeof i == 'function' ? i : () => {}
}
function $u(e) {
  return Ki(e, 'spacing', 8)
}
function Yo(e, t) {
  if (typeof t == 'string' || t == null) return t
  const n = Math.abs(t),
    o = e(n)
  return t >= 0 ? o : typeof o == 'number' ? -o : `-${o}`
}
function Vx(e, t) {
  return n => e.reduce((o, r) => ((o[r] = Yo(t, n)), o), {})
}
function Xx(e, t, n, o) {
  if (t.indexOf(n) === -1) return null
  const r = Gx(n),
    i = Vx(r, o),
    s = e[n]
  return hn(e, s, i)
}
function gg(e, t) {
  const n = $u(e.theme)
  return Object.keys(e)
    .map(o => Xx(e, t, o, n))
    .reduce(xi, {})
}
function ct(e) {
  return gg(e, Ju)
}
ct.propTypes = {}
ct.filterProps = Ju
function ut(e) {
  return gg(e, _u)
}
ut.propTypes = {}
ut.filterProps = _u
function Yx(e = 8) {
  if (e.mui) return e
  const t = $u({
      spacing: e,
    }),
    n = (...o) =>
      (o.length === 0 ? [1] : o)
        .map(i => {
          const s = t(i)
          return typeof s == 'number' ? `${s}px` : s
        })
        .join(' ')
  return (n.mui = !0), n
}
function Ka(...e) {
  const t = e.reduce(
      (o, r) => (
        r.filterProps.forEach(i => {
          o[i] = r
        }),
        o
      ),
      {}
    ),
    n = o => Object.keys(o).reduce((r, i) => (t[i] ? xi(r, t[i](o)) : r), {})
  return (n.propTypes = {}), (n.filterProps = e.reduce((o, r) => o.concat(r.filterProps), [])), n
}
function en(e) {
  return typeof e != 'number' ? e : `${e}px solid`
}
function rn(e, t) {
  return pt({
    prop: e,
    themeKey: 'borders',
    transform: t,
  })
}
const Hx = rn('border', en),
  Ux = rn('borderTop', en),
  Kx = rn('borderRight', en),
  qx = rn('borderBottom', en),
  Zx = rn('borderLeft', en),
  Jx = rn('borderColor'),
  _x = rn('borderTopColor'),
  $x = rn('borderRightColor'),
  eC = rn('borderBottomColor'),
  tC = rn('borderLeftColor'),
  nC = rn('outline', en),
  oC = rn('outlineColor'),
  qa = e => {
    if (e.borderRadius !== void 0 && e.borderRadius !== null) {
      const t = Ki(e.theme, 'shape.borderRadius', 4),
        n = o => ({
          borderRadius: Yo(t, o),
        })
      return hn(e, e.borderRadius, n)
    }
    return null
  }
qa.propTypes = {}
qa.filterProps = ['borderRadius']
Ka(Hx, Ux, Kx, qx, Zx, Jx, _x, $x, eC, tC, qa, nC, oC)
const Za = e => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Ki(e.theme, 'spacing', 8),
      n = o => ({
        gap: Yo(t, o),
      })
    return hn(e, e.gap, n)
  }
  return null
}
Za.propTypes = {}
Za.filterProps = ['gap']
const Ja = e => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Ki(e.theme, 'spacing', 8),
      n = o => ({
        columnGap: Yo(t, o),
      })
    return hn(e, e.columnGap, n)
  }
  return null
}
Ja.propTypes = {}
Ja.filterProps = ['columnGap']
const _a = e => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Ki(e.theme, 'spacing', 8),
      n = o => ({
        rowGap: Yo(t, o),
      })
    return hn(e, e.rowGap, n)
  }
  return null
}
_a.propTypes = {}
_a.filterProps = ['rowGap']
const rC = pt({
    prop: 'gridColumn',
  }),
  iC = pt({
    prop: 'gridRow',
  }),
  sC = pt({
    prop: 'gridAutoFlow',
  }),
  aC = pt({
    prop: 'gridAutoColumns',
  }),
  lC = pt({
    prop: 'gridAutoRows',
  }),
  cC = pt({
    prop: 'gridTemplateColumns',
  }),
  uC = pt({
    prop: 'gridTemplateRows',
  }),
  dC = pt({
    prop: 'gridTemplateAreas',
  }),
  fC = pt({
    prop: 'gridArea',
  })
Ka(Za, Ja, _a, rC, iC, sC, aC, lC, cC, uC, dC, fC)
function gr(e, t) {
  return t === 'grey' ? t : e
}
const AC = pt({
    prop: 'color',
    themeKey: 'palette',
    transform: gr,
  }),
  pC = pt({
    prop: 'bgcolor',
    cssProperty: 'backgroundColor',
    themeKey: 'palette',
    transform: gr,
  }),
  hC = pt({
    prop: 'backgroundColor',
    themeKey: 'palette',
    transform: gr,
  })
Ka(AC, pC, hC)
function Vt(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e
}
const gC = pt({
    prop: 'width',
    transform: Vt,
  }),
  ed = e => {
    if (e.maxWidth !== void 0 && e.maxWidth !== null) {
      const t = n => {
        var o, r
        const i = ((o = e.theme) == null || (o = o.breakpoints) == null || (o = o.values) == null ? void 0 : o[n]) || qu[n]
        return i
          ? ((r = e.theme) == null || (r = r.breakpoints) == null ? void 0 : r.unit) !== 'px'
            ? {
                maxWidth: `${i}${e.theme.breakpoints.unit}`,
              }
            : {
                maxWidth: i,
              }
          : {
              maxWidth: Vt(n),
            }
      }
      return hn(e, e.maxWidth, t)
    }
    return null
  }
ed.filterProps = ['maxWidth']
const mC = pt({
    prop: 'minWidth',
    transform: Vt,
  }),
  yC = pt({
    prop: 'height',
    transform: Vt,
  }),
  bC = pt({
    prop: 'maxHeight',
    transform: Vt,
  }),
  vC = pt({
    prop: 'minHeight',
    transform: Vt,
  })
pt({
  prop: 'size',
  cssProperty: 'width',
  transform: Vt,
})
pt({
  prop: 'size',
  cssProperty: 'height',
  transform: Vt,
})
const xC = pt({
  prop: 'boxSizing',
})
Ka(gC, ed, mC, yC, bC, vC, xC)
const qi = {
  // borders
  border: {
    themeKey: 'borders',
    transform: en,
  },
  borderTop: {
    themeKey: 'borders',
    transform: en,
  },
  borderRight: {
    themeKey: 'borders',
    transform: en,
  },
  borderBottom: {
    themeKey: 'borders',
    transform: en,
  },
  borderLeft: {
    themeKey: 'borders',
    transform: en,
  },
  borderColor: {
    themeKey: 'palette',
  },
  borderTopColor: {
    themeKey: 'palette',
  },
  borderRightColor: {
    themeKey: 'palette',
  },
  borderBottomColor: {
    themeKey: 'palette',
  },
  borderLeftColor: {
    themeKey: 'palette',
  },
  outline: {
    themeKey: 'borders',
    transform: en,
  },
  outlineColor: {
    themeKey: 'palette',
  },
  borderRadius: {
    themeKey: 'shape.borderRadius',
    style: qa,
  },
  // palette
  color: {
    themeKey: 'palette',
    transform: gr,
  },
  bgcolor: {
    themeKey: 'palette',
    cssProperty: 'backgroundColor',
    transform: gr,
  },
  backgroundColor: {
    themeKey: 'palette',
    transform: gr,
  },
  // spacing
  p: {
    style: ut,
  },
  pt: {
    style: ut,
  },
  pr: {
    style: ut,
  },
  pb: {
    style: ut,
  },
  pl: {
    style: ut,
  },
  px: {
    style: ut,
  },
  py: {
    style: ut,
  },
  padding: {
    style: ut,
  },
  paddingTop: {
    style: ut,
  },
  paddingRight: {
    style: ut,
  },
  paddingBottom: {
    style: ut,
  },
  paddingLeft: {
    style: ut,
  },
  paddingX: {
    style: ut,
  },
  paddingY: {
    style: ut,
  },
  paddingInline: {
    style: ut,
  },
  paddingInlineStart: {
    style: ut,
  },
  paddingInlineEnd: {
    style: ut,
  },
  paddingBlock: {
    style: ut,
  },
  paddingBlockStart: {
    style: ut,
  },
  paddingBlockEnd: {
    style: ut,
  },
  m: {
    style: ct,
  },
  mt: {
    style: ct,
  },
  mr: {
    style: ct,
  },
  mb: {
    style: ct,
  },
  ml: {
    style: ct,
  },
  mx: {
    style: ct,
  },
  my: {
    style: ct,
  },
  margin: {
    style: ct,
  },
  marginTop: {
    style: ct,
  },
  marginRight: {
    style: ct,
  },
  marginBottom: {
    style: ct,
  },
  marginLeft: {
    style: ct,
  },
  marginX: {
    style: ct,
  },
  marginY: {
    style: ct,
  },
  marginInline: {
    style: ct,
  },
  marginInlineStart: {
    style: ct,
  },
  marginInlineEnd: {
    style: ct,
  },
  marginBlock: {
    style: ct,
  },
  marginBlockStart: {
    style: ct,
  },
  marginBlockEnd: {
    style: ct,
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: e => ({
      '@media print': {
        display: e,
      },
    }),
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Za,
  },
  rowGap: {
    style: _a,
  },
  columnGap: {
    style: Ja,
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: 'zIndex',
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: 'shadows',
  },
  // sizing
  width: {
    transform: Vt,
  },
  maxWidth: {
    style: ed,
  },
  minWidth: {
    transform: Vt,
  },
  height: {
    transform: Vt,
  },
  maxHeight: {
    transform: Vt,
  },
  minHeight: {
    transform: Vt,
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: 'typography',
  },
  fontSize: {
    themeKey: 'typography',
  },
  fontStyle: {
    themeKey: 'typography',
  },
  fontWeight: {
    themeKey: 'typography',
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: 'typography',
  },
}
function CC(...e) {
  const t = e.reduce((o, r) => o.concat(Object.keys(r)), []),
    n = new Set(t)
  return e.every(o => n.size === Object.keys(o).length)
}
function wC(e, t) {
  return typeof e == 'function' ? e(t) : e
}
function mg() {
  function e(n, o, r, i) {
    const s = {
        [n]: o,
        theme: r,
      },
      a = i[n]
    if (!a)
      return {
        [n]: o,
      }
    const { cssProperty: l = n, themeKey: c, transform: u, style: d } = a
    if (o == null) return null
    if (c === 'typography' && o === 'inherit')
      return {
        [n]: o,
      }
    const f = Ua(r, c) || {}
    return d
      ? d(s)
      : hn(s, o, h => {
          let g = na(f, u, h)
          return (
            h === g && typeof h == 'string' && (g = na(f, u, `${n}${h === 'default' ? '' : Zu(h)}`, h)),
            l === !1
              ? g
              : {
                  [l]: g,
                }
          )
        })
  }
  function t(n) {
    var o
    const { sx: r, theme: i = {} } = n || {}
    if (!r) return null
    const s = (o = i.unstable_sxConfig) != null ? o : qi
    function a(l) {
      let c = l
      if (typeof l == 'function') c = l(i)
      else if (typeof l != 'object') return l
      if (!c) return null
      const u = pg(i.breakpoints),
        d = Object.keys(u)
      let f = u
      return (
        Object.keys(c).forEach(A => {
          const h = wC(c[A], i)
          if (h != null)
            if (typeof h == 'object')
              if (s[A]) f = xi(f, e(A, h, i, s))
              else {
                const g = hn(
                  {
                    theme: i,
                  },
                  h,
                  x => ({
                    [A]: x,
                  })
                )
                CC(g, h)
                  ? (f[A] = t({
                      sx: h,
                      theme: i,
                    }))
                  : (f = xi(f, g))
              }
            else f = xi(f, e(A, h, i, s))
        }),
        hg(d, f)
      )
    }
    return Array.isArray(r) ? r.map(a) : a(r)
  }
  return t
}
const Vr = mg()
Vr.filterProps = ['sx']
function yg(e, t) {
  const n = this
  return n.vars && typeof n.getColorSchemeSelector == 'function'
    ? {
        [n.getColorSchemeSelector(e).replace(/(\[[^\]]+\])/, '*:where($1)')]: t,
      }
    : n.palette.mode === e
    ? t
    : {}
}
const EC = ['breakpoints', 'palette', 'spacing', 'shape']
function Zi(e = {}, ...t) {
  const { breakpoints: n = {}, palette: o = {}, spacing: r, shape: i = {} } = e,
    s = pe(e, EC),
    a = Ag(n),
    l = Yx(r)
  let c = Xo(
    {
      breakpoints: a,
      direction: 'ltr',
      components: {},
      // Inject component definitions.
      palette: k(
        {
          mode: 'light',
        },
        o
      ),
      spacing: l,
      shape: k({}, Fx, i),
    },
    s
  )
  return (
    (c.applyStyles = yg),
    (c = t.reduce((u, d) => Xo(u, d), c)),
    (c.unstable_sxConfig = k({}, qi, s == null ? void 0 : s.unstable_sxConfig)),
    (c.unstable_sx = function (d) {
      return Vr({
        sx: d,
        theme: this,
      })
    }),
    c
  )
}
const SC = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      default: Zi,
      private_createBreakpoints: Ag,
      unstable_applyStyles: yg,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function BC(e) {
  return Object.keys(e).length === 0
}
function bg(e = null) {
  const t = N.useContext(Gr)
  return !t || BC(t) ? e : t
}
const IC = Zi()
function $a(e = IC) {
  return bg(e)
}
function NC({ styles: e, themeId: t, defaultTheme: n = {} }) {
  const o = $a(n),
    r = typeof e == 'function' ? e((t && o[t]) || o) : e
  return /* @__PURE__ */ p.jsx(ug, {
    styles: r,
  })
}
const kC = ['sx'],
  MC = e => {
    var t, n
    const o = {
        systemProps: {},
        otherProps: {},
      },
      r = (t = e == null || (n = e.theme) == null ? void 0 : n.unstable_sxConfig) != null ? t : qi
    return (
      Object.keys(e).forEach(i => {
        r[i] ? (o.systemProps[i] = e[i]) : (o.otherProps[i] = e[i])
      }),
      o
    )
  }
function el(e) {
  const { sx: t } = e,
    n = pe(e, kC),
    { systemProps: o, otherProps: r } = MC(n)
  let i
  return (
    Array.isArray(t)
      ? (i = [o, ...t])
      : typeof t == 'function'
      ? (i = (...s) => {
          const a = t(...s)
          return jn(a) ? k({}, o, a) : o
        })
      : (i = k({}, o, t)),
    k({}, r, {
      sx: i,
    })
  )
}
const PC = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        default: Vr,
        extendSxProp: el,
        unstable_createStyleFunctionSx: mg,
        unstable_defaultSxConfig: qi,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Sf = e => e,
  LC = () => {
    let e = Sf
    return {
      configure(t) {
        e = t
      },
      generate(t) {
        return e(t)
      },
      reset() {
        e = Sf
      },
    }
  },
  RC = LC()
function vg(e) {
  var t,
    n,
    o = ''
  if (typeof e == 'string' || typeof e == 'number') o += e
  else if (typeof e == 'object')
    if (Array.isArray(e)) {
      var r = e.length
      for (t = 0; t < r; t++) e[t] && (n = vg(e[t])) && (o && (o += ' '), (o += n))
    } else for (n in e) e[n] && (o && (o += ' '), (o += n))
  return o
}
function de() {
  for (var e, t, n = 0, o = '', r = arguments.length; n < r; n++) (e = arguments[n]) && (t = vg(e)) && (o && (o += ' '), (o += t))
  return o
}
const TC = ['className', 'component']
function FC(e = {}) {
  const { themeId: t, defaultTheme: n, defaultClassName: o = 'MuiBox-root', generateClassName: r } = e,
    i = Ku('div', {
      shouldForwardProp: a => a !== 'theme' && a !== 'sx' && a !== 'as',
    })(Vr)
  return /* @__PURE__ */ N.forwardRef(function (l, c) {
    const u = $a(n),
      d = el(l),
      { className: f, component: A = 'div' } = d,
      h = pe(d, TC)
    return /* @__PURE__ */ p.jsx(
      i,
      k(
        {
          as: A,
          ref: c,
          className: de(f, r ? r(o) : o),
          theme: (t && u[t]) || u,
        },
        h
      )
    )
  })
}
const DC = {
  active: 'active',
  checked: 'checked',
  completed: 'completed',
  disabled: 'disabled',
  error: 'error',
  expanded: 'expanded',
  focused: 'focused',
  focusVisible: 'focusVisible',
  open: 'open',
  readOnly: 'readOnly',
  required: 'required',
  selected: 'selected',
}
function zC(e, t, n = 'Mui') {
  const o = DC[t]
  return o ? `${n}-${o}` : `${RC.generate(e)}-${t}`
}
var xg = { exports: {} },
  Je = {}
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var td = Symbol.for('react.transitional.element'),
  nd = Symbol.for('react.portal'),
  tl = Symbol.for('react.fragment'),
  nl = Symbol.for('react.strict_mode'),
  ol = Symbol.for('react.profiler'),
  rl = Symbol.for('react.consumer'),
  il = Symbol.for('react.context'),
  sl = Symbol.for('react.forward_ref'),
  al = Symbol.for('react.suspense'),
  ll = Symbol.for('react.suspense_list'),
  cl = Symbol.for('react.memo'),
  ul = Symbol.for('react.lazy'),
  QC = Symbol.for('react.offscreen'),
  OC = Symbol.for('react.client.reference')
function sn(e) {
  if (typeof e == 'object' && e !== null) {
    var t = e.$$typeof
    switch (t) {
      case td:
        switch (((e = e.type), e)) {
          case tl:
          case ol:
          case nl:
          case al:
          case ll:
            return e
          default:
            switch (((e = e && e.$$typeof), e)) {
              case il:
              case sl:
              case ul:
              case cl:
                return e
              case rl:
                return e
              default:
                return t
            }
        }
      case nd:
        return t
    }
  }
}
Je.ContextConsumer = rl
Je.ContextProvider = il
Je.Element = td
Je.ForwardRef = sl
Je.Fragment = tl
Je.Lazy = ul
Je.Memo = cl
Je.Portal = nd
Je.Profiler = ol
Je.StrictMode = nl
Je.Suspense = al
Je.SuspenseList = ll
Je.isContextConsumer = function (e) {
  return sn(e) === rl
}
Je.isContextProvider = function (e) {
  return sn(e) === il
}
Je.isElement = function (e) {
  return typeof e == 'object' && e !== null && e.$$typeof === td
}
Je.isForwardRef = function (e) {
  return sn(e) === sl
}
Je.isFragment = function (e) {
  return sn(e) === tl
}
Je.isLazy = function (e) {
  return sn(e) === ul
}
Je.isMemo = function (e) {
  return sn(e) === cl
}
Je.isPortal = function (e) {
  return sn(e) === nd
}
Je.isProfiler = function (e) {
  return sn(e) === ol
}
Je.isStrictMode = function (e) {
  return sn(e) === nl
}
Je.isSuspense = function (e) {
  return sn(e) === al
}
Je.isSuspenseList = function (e) {
  return sn(e) === ll
}
Je.isValidElementType = function (e) {
  return typeof e == 'string' || typeof e == 'function' || e === tl || e === ol || e === nl || e === al || e === ll || e === QC || (typeof e == 'object' && e !== null && (e.$$typeof === ul || e.$$typeof === cl || e.$$typeof === il || e.$$typeof === rl || e.$$typeof === sl || e.$$typeof === OC || e.getModuleId !== void 0))
}
Je.typeOf = sn
xg.exports = Je
var Bf = xg.exports
const jC = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/
function Cg(e) {
  const t = `${e}`.match(jC)
  return (t && t[1]) || ''
}
function wg(e, t = '') {
  return e.displayName || e.name || Cg(e) || t
}
function If(e, t, n) {
  const o = wg(t)
  return e.displayName || (o !== '' ? `${n}(${o})` : n)
}
function WC(e) {
  if (e != null) {
    if (typeof e == 'string') return e
    if (typeof e == 'function') return wg(e, 'Component')
    if (typeof e == 'object')
      switch (e.$$typeof) {
        case Bf.ForwardRef:
          return If(e, e.render, 'ForwardRef')
        case Bf.Memo:
          return If(e, e.type, 'memo')
        default:
          return
      }
  }
}
const GC = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        default: WC,
        getFunctionName: Cg,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  VC = ['ownerState'],
  XC = ['variants'],
  YC = ['name', 'slot', 'skipVariantsResolver', 'skipSx', 'overridesResolver']
function HC(e) {
  return Object.keys(e).length === 0
}
function UC(e) {
  return (
    typeof e == 'string' && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    e.charCodeAt(0) > 96
  )
}
function tc(e) {
  return e !== 'ownerState' && e !== 'theme' && e !== 'sx' && e !== 'as'
}
const KC = Zi(),
  qC = e => e && e.charAt(0).toLowerCase() + e.slice(1)
function fs({ defaultTheme: e, theme: t, themeId: n }) {
  return HC(t) ? e : t[n] || t
}
function ZC(e) {
  return e ? (t, n) => n[e] : null
}
function Xs(e, t) {
  let { ownerState: n } = t,
    o = pe(t, VC)
  const r =
    typeof e == 'function'
      ? e(
          k(
            {
              ownerState: n,
            },
            o
          )
        )
      : e
  if (Array.isArray(r))
    return r.flatMap(i =>
      Xs(
        i,
        k(
          {
            ownerState: n,
          },
          o
        )
      )
    )
  if (r && typeof r == 'object' && Array.isArray(r.variants)) {
    const { variants: i = [] } = r
    let a = pe(r, XC)
    return (
      i.forEach(l => {
        let c = !0
        typeof l.props == 'function'
          ? (c = l.props(
              k(
                {
                  ownerState: n,
                },
                o,
                n
              )
            ))
          : Object.keys(l.props).forEach(u => {
              ;(n == null ? void 0 : n[u]) !== l.props[u] && o[u] !== l.props[u] && (c = !1)
            }),
          c &&
            (Array.isArray(a) || (a = [a]),
            a.push(
              typeof l.style == 'function'
                ? l.style(
                    k(
                      {
                        ownerState: n,
                      },
                      o,
                      n
                    )
                  )
                : l.style
            ))
      }),
      a
    )
  }
  return r
}
function JC(e = {}) {
  const { themeId: t, defaultTheme: n = KC, rootShouldForwardProp: o = tc, slotShouldForwardProp: r = tc } = e,
    i = s =>
      Vr(
        k({}, s, {
          theme: fs(
            k({}, s, {
              defaultTheme: n,
              themeId: t,
            })
          ),
        })
      )
  return (
    (i.__mui_systemSx = !0),
    (s, a = {}) => {
      dg(s, C => C.filter(I => !(I != null && I.__mui_systemSx)))
      const {
          name: l,
          slot: c,
          skipVariantsResolver: u,
          skipSx: d,
          // TODO v6: remove `lowercaseFirstLetter()` in the next major release
          // For more details: https://github.com/mui/material-ui/pull/37908
          overridesResolver: f = ZC(qC(c)),
        } = a,
        A = pe(a, YC),
        h =
          u !== void 0
            ? u
            : // TODO v6: remove `Root` in the next major release
              // For more details: https://github.com/mui/material-ui/pull/37908
              (c && c !== 'Root' && c !== 'root') || !1,
        g = d || !1
      let x,
        m = tc
      c === 'Root' || c === 'root' ? (m = o) : c ? (m = r) : UC(s) && (m = void 0)
      const v = Ku(
          s,
          k(
            {
              shouldForwardProp: m,
              label: x,
            },
            A
          )
        ),
        y = C =>
          (typeof C == 'function' && C.__emotion_real !== C) || jn(C)
            ? I =>
                Xs(
                  C,
                  k({}, I, {
                    theme: fs({
                      theme: I.theme,
                      defaultTheme: n,
                      themeId: t,
                    }),
                  })
                )
            : C,
        b = (C, ...I) => {
          let w = y(C)
          const M = I ? I.map(y) : []
          l &&
            f &&
            M.push(T => {
              const D = fs(
                k({}, T, {
                  defaultTheme: n,
                  themeId: t,
                })
              )
              if (!D.components || !D.components[l] || !D.components[l].styleOverrides) return null
              const z = D.components[l].styleOverrides,
                E = {}
              return (
                Object.entries(z).forEach(([P, B]) => {
                  E[P] = Xs(
                    B,
                    k({}, T, {
                      theme: D,
                    })
                  )
                }),
                f(T, E)
              )
            }),
            l &&
              !h &&
              M.push(T => {
                var D
                const z = fs(
                    k({}, T, {
                      defaultTheme: n,
                      themeId: t,
                    })
                  ),
                  E = z == null || (D = z.components) == null || (D = D[l]) == null ? void 0 : D.variants
                return Xs(
                  {
                    variants: E,
                  },
                  k({}, T, {
                    theme: z,
                  })
                )
              }),
            g || M.push(i)
          const L = M.length - I.length
          if (Array.isArray(C) && L > 0) {
            const T = new Array(L).fill('')
            ;(w = [...C, ...T]), (w.raw = [...C.raw, ...T])
          }
          const R = v(w, ...M)
          return s.muiName && (R.muiName = s.muiName), R
        }
      return v.withConfig && (b.withConfig = v.withConfig), b
    }
  )
}
const _C = JC()
function oa(e, t) {
  const n = k({}, t)
  return (
    Object.keys(e).forEach(o => {
      if (o.toString().match(/^(components|slots)$/)) n[o] = k({}, e[o], n[o])
      else if (o.toString().match(/^(componentsProps|slotProps)$/)) {
        const r = e[o] || {},
          i = t[o]
        ;(n[o] = {}),
          !i || !Object.keys(i)
            ? (n[o] = r)
            : !r || !Object.keys(r)
            ? (n[o] = i)
            : ((n[o] = k({}, i)),
              Object.keys(r).forEach(s => {
                n[o][s] = oa(r[s], i[s])
              }))
      } else n[o] === void 0 && (n[o] = e[o])
    }),
    n
  )
}
function $C(e) {
  const { theme: t, name: n, props: o } = e
  return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? o : oa(t.components[n].defaultProps, o)
}
function e1({ props: e, name: t, defaultTheme: n, themeId: o }) {
  let r = $a(n)
  return (
    o && (r = r[o] || r),
    $C({
      theme: r,
      name: t,
      props: e,
    })
  )
}
function t1(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n))
}
const n1 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        default: t1,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Eg = /* @__PURE__ */ N.createContext(null)
function Sg() {
  return N.useContext(Eg)
}
const o1 = typeof Symbol == 'function' && Symbol.for,
  r1 = o1 ? Symbol.for('mui.nested') : '__THEME_NESTED__'
function i1(e, t) {
  return typeof t == 'function' ? t(e) : k({}, e, t)
}
function s1(e) {
  const { children: t, theme: n } = e,
    o = Sg(),
    r = N.useMemo(() => {
      const i = o === null ? n : i1(o, n)
      return i != null && (i[r1] = o !== null), i
    }, [n, o])
  return /* @__PURE__ */ p.jsx(Eg.Provider, {
    value: r,
    children: t,
  })
}
const a1 = ['value'],
  Bg = /* @__PURE__ */ N.createContext()
function l1(e) {
  let { value: t } = e,
    n = pe(e, a1)
  return /* @__PURE__ */ p.jsx(
    Bg.Provider,
    k(
      {
        value: t ?? !0,
      },
      n
    )
  )
}
const od = () => {
    const e = N.useContext(Bg)
    return e ?? !1
  },
  Ig = /* @__PURE__ */ N.createContext(void 0)
function c1({ value: e, children: t }) {
  return /* @__PURE__ */ p.jsx(Ig.Provider, {
    value: e,
    children: t,
  })
}
function u1(e) {
  const { theme: t, name: n, props: o } = e
  if (!t || !t.components || !t.components[n]) return o
  const r = t.components[n]
  return r.defaultProps ? oa(r.defaultProps, o) : !r.styleOverrides && !r.variants ? oa(r, o) : o
}
function d1({ props: e, name: t }) {
  const n = N.useContext(Ig)
  return u1({
    props: e,
    name: t,
    theme: {
      components: n,
    },
  })
}
const Nf = {}
function kf(e, t, n, o = !1) {
  return N.useMemo(() => {
    const r = (e && t[e]) || t
    if (typeof n == 'function') {
      const i = n(r),
        s = e
          ? k({}, t, {
              [e]: i,
            })
          : i
      return o ? () => s : s
    }
    return e
      ? k({}, t, {
          [e]: n,
        })
      : k({}, t, n)
  }, [e, t, n, o])
}
function f1(e) {
  const { children: t, theme: n, themeId: o } = e,
    r = bg(Nf),
    i = Sg() || Nf,
    s = kf(o, r, n),
    a = kf(o, i, n, !0),
    l = s.direction === 'rtl'
  return /* @__PURE__ */ p.jsx(s1, {
    theme: a,
    children: /* @__PURE__ */ p.jsx(Gr.Provider, {
      value: s,
      children: /* @__PURE__ */ p.jsx(l1, {
        value: l,
        children: /* @__PURE__ */ p.jsx(c1, {
          value: s == null ? void 0 : s.components,
          children: t,
        }),
      }),
    }),
  })
}
function A1(e, t, n = void 0) {
  const o = {}
  return (
    Object.keys(e).forEach(
      // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
      // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
      r => {
        o[r] = e[r]
          .reduce((i, s) => {
            if (s) {
              const a = t(s)
              a !== '' && i.push(a), n && n[s] && i.push(n[s])
            }
            return i
          }, [])
          .join(' ')
      }
    ),
    o
  )
}
const p1 = ['component', 'direction', 'spacing', 'divider', 'children', 'className', 'useFlexGap'],
  h1 = Zi(),
  g1 = _C('div', {
    name: 'MuiStack',
    slot: 'Root',
    overridesResolver: (e, t) => t.root,
  })
function m1(e) {
  return e1({
    props: e,
    name: 'MuiStack',
    defaultTheme: h1,
  })
}
function y1(e, t) {
  const n = N.Children.toArray(e).filter(Boolean)
  return n.reduce(
    (o, r, i) => (
      o.push(r),
      i < n.length - 1 &&
        o.push(
          /* @__PURE__ */ N.cloneElement(t, {
            key: `separator-${i}`,
          })
        ),
      o
    ),
    []
  )
}
const b1 = e =>
    ({
      row: 'Left',
      'row-reverse': 'Right',
      column: 'Top',
      'column-reverse': 'Bottom',
    }[e]),
  v1 = ({ ownerState: e, theme: t }) => {
    let n = k(
      {
        display: 'flex',
        flexDirection: 'column',
      },
      hn(
        {
          theme: t,
        },
        ec({
          values: e.direction,
          breakpoints: t.breakpoints.values,
        }),
        o => ({
          flexDirection: o,
        })
      )
    )
    if (e.spacing) {
      const o = $u(t),
        r = Object.keys(t.breakpoints.values).reduce((l, c) => (((typeof e.spacing == 'object' && e.spacing[c] != null) || (typeof e.direction == 'object' && e.direction[c] != null)) && (l[c] = !0), l), {}),
        i = ec({
          values: e.direction,
          base: r,
        }),
        s = ec({
          values: e.spacing,
          base: r,
        })
      typeof i == 'object' &&
        Object.keys(i).forEach((l, c, u) => {
          if (!i[l]) {
            const f = c > 0 ? i[u[c - 1]] : 'column'
            i[l] = f
          }
        }),
        (n = Xo(
          n,
          hn(
            {
              theme: t,
            },
            s,
            (l, c) =>
              e.useFlexGap
                ? {
                    gap: Yo(o, l),
                  }
                : {
                    // The useFlexGap={false} implement relies on each child to give up control of the margin.
                    // We need to reset the margin to avoid double spacing.
                    '& > :not(style):not(style)': {
                      margin: 0,
                    },
                    '& > :not(style) ~ :not(style)': {
                      [`margin${b1(c ? i[c] : e.direction)}`]: Yo(o, l),
                    },
                  }
          )
        ))
    }
    return (n = Dx(t.breakpoints, n)), n
  }
function x1(e = {}) {
  const {
      // This will allow adding custom styled fn (for example for custom sx style function)
      createStyledComponent: t = g1,
      useThemeProps: n = m1,
      componentName: o = 'MuiStack',
    } = e,
    r = () =>
      A1(
        {
          root: ['root'],
        },
        l => zC(o, l),
        {}
      ),
    i = t(v1)
  return /* @__PURE__ */ N.forwardRef(function (l, c) {
    const u = n(l),
      d = el(u),
      { component: f = 'div', direction: A = 'column', spacing: h = 0, divider: g, children: x, className: m, useFlexGap: v = !1 } = d,
      y = pe(d, p1),
      b = {
        direction: A,
        spacing: h,
        useFlexGap: v,
      },
      C = r()
    return /* @__PURE__ */ p.jsx(
      i,
      k(
        {
          as: f,
          ownerState: b,
          ref: c,
          className: de(C.root, m),
        },
        y,
        {
          children: g ? y1(x, g) : x,
        }
      )
    )
  })
}
function cr(e) {
  if (typeof e != 'object' || e === null) return !1
  const t = Object.getPrototypeOf(e)
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
}
function Ng(e) {
  if (/* @__PURE__ */ N.isValidElement(e) || !cr(e)) return e
  const t = {}
  return (
    Object.keys(e).forEach(n => {
      t[n] = Ng(e[n])
    }),
    t
  )
}
function Vn(
  e,
  t,
  n = {
    clone: !0,
  }
) {
  const o = n.clone ? k({}, e) : e
  return (
    cr(e) &&
      cr(t) &&
      Object.keys(t).forEach(r => {
        /* @__PURE__ */ N.isValidElement(t[r])
          ? (o[r] = t[r])
          : cr(t[r]) && // Avoid prototype pollution
            Object.prototype.hasOwnProperty.call(e, r) &&
            cr(e[r])
          ? (o[r] = Vn(e[r], t[r], n))
          : n.clone
          ? (o[r] = cr(t[r]) ? Ng(t[r]) : t[r])
          : (o[r] = t[r])
      }),
    o
  )
}
const Mf = e => e,
  C1 = () => {
    let e = Mf
    return {
      configure(t) {
        e = t
      },
      generate(t) {
        return e(t)
      },
      reset() {
        e = Mf
      },
    }
  },
  rd = C1(),
  w1 = {
    active: 'active',
    checked: 'checked',
    completed: 'completed',
    disabled: 'disabled',
    error: 'error',
    expanded: 'expanded',
    focused: 'focused',
    focusVisible: 'focusVisible',
    open: 'open',
    readOnly: 'readOnly',
    required: 'required',
    selected: 'selected',
  }
function We(e, t, n = 'Mui') {
  const o = w1[t]
  return o ? `${n}-${o}` : `${rd.generate(e)}-${t}`
}
function E1(e, t) {
  return k(
    {
      toolbar: {
        minHeight: 56,
        [e.up('xs')]: {
          '@media (orientation: landscape)': {
            minHeight: 48,
          },
        },
        [e.up('sm')]: {
          minHeight: 64,
        },
      },
    },
    t
  )
}
var ht = {},
  kg = { exports: {} }
;(function (e) {
  function t(n) {
    return n && n.__esModule
      ? n
      : {
          default: n,
        }
  }
  ;(e.exports = t), (e.exports.__esModule = !0), (e.exports.default = e.exports)
})(kg)
var Ji = kg.exports
const S1 = /* @__PURE__ */ Zn(wv),
  B1 = /* @__PURE__ */ Zn(n1)
var Mg = Ji
Object.defineProperty(ht, '__esModule', {
  value: !0,
})
var Lt = (ht.alpha = Tg)
ht.blend = z1
ht.colorChannel = void 0
var Hc = (ht.darken = sd)
ht.decomposeColor = nn
ht.emphasize = Fg
var I1 = (ht.getContrastRatio = L1)
ht.getLuminance = ra
ht.hexToRgb = Pg
ht.hslToRgb = Rg
var Uc = (ht.lighten = ad)
ht.private_safeAlpha = R1
ht.private_safeColorChannel = void 0
ht.private_safeDarken = T1
ht.private_safeEmphasize = D1
ht.private_safeLighten = F1
ht.recomposeColor = Xr
ht.rgbToHex = P1
var Pf = Mg(S1),
  N1 = Mg(B1)
function id(e, t = 0, n = 1) {
  return (0, N1.default)(e, t, n)
}
function Pg(e) {
  e = e.slice(1)
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, 'g')
  let n = e.match(t)
  return n && n[0].length === 1 && (n = n.map(o => o + o)), n ? `rgb${n.length === 4 ? 'a' : ''}(${n.map((o, r) => (r < 3 ? parseInt(o, 16) : Math.round((parseInt(o, 16) / 255) * 1e3) / 1e3)).join(', ')})` : ''
}
function k1(e) {
  const t = e.toString(16)
  return t.length === 1 ? `0${t}` : t
}
function nn(e) {
  if (e.type) return e
  if (e.charAt(0) === '#') return nn(Pg(e))
  const t = e.indexOf('('),
    n = e.substring(0, t)
  if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(n) === -1) throw new Error((0, Pf.default)(9, e))
  let o = e.substring(t + 1, e.length - 1),
    r
  if (n === 'color') {
    if (((o = o.split(' ')), (r = o.shift()), o.length === 4 && o[3].charAt(0) === '/' && (o[3] = o[3].slice(1)), ['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(r) === -1)) throw new Error((0, Pf.default)(10, r))
  } else o = o.split(',')
  return (
    (o = o.map(i => parseFloat(i))),
    {
      type: n,
      values: o,
      colorSpace: r,
    }
  )
}
const Lg = e => {
  const t = nn(e)
  return t.values
    .slice(0, 3)
    .map((n, o) => (t.type.indexOf('hsl') !== -1 && o !== 0 ? `${n}%` : n))
    .join(' ')
}
ht.colorChannel = Lg
const M1 = (e, t) => {
  try {
    return Lg(e)
  } catch {
    return e
  }
}
ht.private_safeColorChannel = M1
function Xr(e) {
  const { type: t, colorSpace: n } = e
  let { values: o } = e
  return t.indexOf('rgb') !== -1 ? (o = o.map((r, i) => (i < 3 ? parseInt(r, 10) : r))) : t.indexOf('hsl') !== -1 && ((o[1] = `${o[1]}%`), (o[2] = `${o[2]}%`)), t.indexOf('color') !== -1 ? (o = `${n} ${o.join(' ')}`) : (o = `${o.join(', ')}`), `${t}(${o})`
}
function P1(e) {
  if (e.indexOf('#') === 0) return e
  const { values: t } = nn(e)
  return `#${t.map((n, o) => k1(o === 3 ? Math.round(255 * n) : n)).join('')}`
}
function Rg(e) {
  e = nn(e)
  const { values: t } = e,
    n = t[0],
    o = t[1] / 100,
    r = t[2] / 100,
    i = o * Math.min(r, 1 - r),
    s = (c, u = (c + n / 30) % 12) => r - i * Math.max(Math.min(u - 3, 9 - u, 1), -1)
  let a = 'rgb'
  const l = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)]
  return (
    e.type === 'hsla' && ((a += 'a'), l.push(t[3])),
    Xr({
      type: a,
      values: l,
    })
  )
}
function ra(e) {
  e = nn(e)
  let t = e.type === 'hsl' || e.type === 'hsla' ? nn(Rg(e)).values : e.values
  return (t = t.map(n => (e.type !== 'color' && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4))), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3))
}
function L1(e, t) {
  const n = ra(e),
    o = ra(t)
  return (Math.max(n, o) + 0.05) / (Math.min(n, o) + 0.05)
}
function Tg(e, t) {
  return (e = nn(e)), (t = id(t)), (e.type === 'rgb' || e.type === 'hsl') && (e.type += 'a'), e.type === 'color' ? (e.values[3] = `/${t}`) : (e.values[3] = t), Xr(e)
}
function R1(e, t, n) {
  try {
    return Tg(e, t)
  } catch {
    return e
  }
}
function sd(e, t) {
  if (((e = nn(e)), (t = id(t)), e.type.indexOf('hsl') !== -1)) e.values[2] *= 1 - t
  else if (e.type.indexOf('rgb') !== -1 || e.type.indexOf('color') !== -1) for (let n = 0; n < 3; n += 1) e.values[n] *= 1 - t
  return Xr(e)
}
function T1(e, t, n) {
  try {
    return sd(e, t)
  } catch {
    return e
  }
}
function ad(e, t) {
  if (((e = nn(e)), (t = id(t)), e.type.indexOf('hsl') !== -1)) e.values[2] += (100 - e.values[2]) * t
  else if (e.type.indexOf('rgb') !== -1) for (let n = 0; n < 3; n += 1) e.values[n] += (255 - e.values[n]) * t
  else if (e.type.indexOf('color') !== -1) for (let n = 0; n < 3; n += 1) e.values[n] += (1 - e.values[n]) * t
  return Xr(e)
}
function F1(e, t, n) {
  try {
    return ad(e, t)
  } catch {
    return e
  }
}
function Fg(e, t = 0.15) {
  return ra(e) > 0.5 ? sd(e, t) : ad(e, t)
}
function D1(e, t, n) {
  try {
    return Fg(e, t)
  } catch {
    return e
  }
}
function z1(e, t, n, o = 1) {
  const r = (l, c) => Math.round((l ** (1 / o) * (1 - n) + c ** (1 / o) * n) ** o),
    i = nn(e),
    s = nn(t),
    a = [r(i.values[0], s.values[0]), r(i.values[1], s.values[1]), r(i.values[2], s.values[2])]
  return Xr({
    type: 'rgb',
    values: a,
  })
}
const Q1 = ['mode', 'contrastThreshold', 'tonalOffset'],
  Lf = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: 'rgba(0, 0, 0, 0.87)',
      // Secondary text.
      secondary: 'rgba(0, 0, 0, 0.6)',
      // Disabled text have even lower visual prominence.
      disabled: 'rgba(0, 0, 0, 0.38)',
    },
    // The color used to divide different elements.
    divider: 'rgba(0, 0, 0, 0.12)',
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: xr.white,
      default: xr.white,
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: 'rgba(0, 0, 0, 0.54)',
      // The color of an hovered action.
      hover: 'rgba(0, 0, 0, 0.04)',
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: 'rgba(0, 0, 0, 0.08)',
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: 'rgba(0, 0, 0, 0.26)',
      // The background color of a disabled action.
      disabledBackground: 'rgba(0, 0, 0, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(0, 0, 0, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.12,
    },
  },
  nc = {
    text: {
      primary: xr.white,
      secondary: 'rgba(255, 255, 255, 0.7)',
      disabled: 'rgba(255, 255, 255, 0.5)',
      icon: 'rgba(255, 255, 255, 0.5)',
    },
    divider: 'rgba(255, 255, 255, 0.12)',
    background: {
      paper: '#121212',
      default: '#121212',
    },
    action: {
      active: xr.white,
      hover: 'rgba(255, 255, 255, 0.08)',
      hoverOpacity: 0.08,
      selected: 'rgba(255, 255, 255, 0.16)',
      selectedOpacity: 0.16,
      disabled: 'rgba(255, 255, 255, 0.3)',
      disabledBackground: 'rgba(255, 255, 255, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(255, 255, 255, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.24,
    },
  }
function Rf(e, t, n, o) {
  const r = o.light || o,
    i = o.dark || o * 1.5
  e[t] || (e.hasOwnProperty(n) ? (e[t] = e[n]) : t === 'light' ? (e.light = Uc(e.main, r)) : t === 'dark' && (e.dark = Hc(e.main, i)))
}
function O1(e = 'light') {
  return e === 'dark'
    ? {
        main: No[200],
        light: No[50],
        dark: No[400],
      }
    : {
        main: No[700],
        light: No[400],
        dark: No[800],
      }
}
function j1(e = 'light') {
  return e === 'dark'
    ? {
        main: Io[200],
        light: Io[50],
        dark: Io[400],
      }
    : {
        main: Io[500],
        light: Io[300],
        dark: Io[700],
      }
}
function W1(e = 'light') {
  return e === 'dark'
    ? {
        main: Bo[500],
        light: Bo[300],
        dark: Bo[700],
      }
    : {
        main: Bo[700],
        light: Bo[400],
        dark: Bo[800],
      }
}
function G1(e = 'light') {
  return e === 'dark'
    ? {
        main: ko[400],
        light: ko[300],
        dark: ko[700],
      }
    : {
        main: ko[700],
        light: ko[500],
        dark: ko[900],
      }
}
function V1(e = 'light') {
  return e === 'dark'
    ? {
        main: Mo[400],
        light: Mo[300],
        dark: Mo[700],
      }
    : {
        main: Mo[800],
        light: Mo[500],
        dark: Mo[900],
      }
}
function X1(e = 'light') {
  return e === 'dark'
    ? {
        main: lr[400],
        light: lr[300],
        dark: lr[700],
      }
    : {
        main: '#ed6c02',
        // closest to orange[800] that pass 3:1.
        light: lr[500],
        dark: lr[900],
      }
}
function Y1(e) {
  const { mode: t = 'light', contrastThreshold: n = 3, tonalOffset: o = 0.2 } = e,
    r = pe(e, Q1),
    i = e.primary || O1(t),
    s = e.secondary || j1(t),
    a = e.error || W1(t),
    l = e.info || G1(t),
    c = e.success || V1(t),
    u = e.warning || X1(t)
  function d(g) {
    return I1(g, nc.text.primary) >= n ? nc.text.primary : Lf.text.primary
  }
  const f = ({ color: g, name: x, mainShade: m = 500, lightShade: v = 300, darkShade: y = 700 }) => {
      if (((g = k({}, g)), !g.main && g[m] && (g.main = g[m]), !g.hasOwnProperty('main'))) throw new Error(Cr(11, x ? ` (${x})` : '', m))
      if (typeof g.main != 'string') throw new Error(Cr(12, x ? ` (${x})` : '', JSON.stringify(g.main)))
      return Rf(g, 'light', v, o), Rf(g, 'dark', y, o), g.contrastText || (g.contrastText = d(g.main)), g
    },
    A = {
      dark: nc,
      light: Lf,
    }
  return Vn(
    k(
      {
        // A collection of common colors.
        common: k({}, xr),
        // prevent mutable object.
        // The palette mode, can be light or dark.
        mode: t,
        // The colors used to represent primary interface elements for a user.
        primary: f({
          color: i,
          name: 'primary',
        }),
        // The colors used to represent secondary interface elements for a user.
        secondary: f({
          color: s,
          name: 'secondary',
          mainShade: 'A400',
          lightShade: 'A200',
          darkShade: 'A700',
        }),
        // The colors used to represent interface elements that the user should be made aware of.
        error: f({
          color: a,
          name: 'error',
        }),
        // The colors used to represent potentially dangerous actions or important messages.
        warning: f({
          color: u,
          name: 'warning',
        }),
        // The colors used to present information to the user that is neutral and not necessarily important.
        info: f({
          color: l,
          name: 'info',
        }),
        // The colors used to indicate the successful completion of an action that user triggered.
        success: f({
          color: c,
          name: 'success',
        }),
        // The grey colors.
        grey: Gh,
        // Used by `getContrastText()` to maximize the contrast between
        // the background and the text.
        contrastThreshold: n,
        // Takes a background color and returns the text color that maximizes the contrast.
        getContrastText: d,
        // Generate a rich color object.
        augmentColor: f,
        // Used by the functions below to shift a color's luminance by approximately
        // two indexes within its tonal palette.
        // E.g., shift from Red 500 to Red 300 or Red 700.
        tonalOffset: o,
      },
      A[t]
    ),
    r
  )
}
const H1 = ['fontFamily', 'fontSize', 'fontWeightLight', 'fontWeightRegular', 'fontWeightMedium', 'fontWeightBold', 'htmlFontSize', 'allVariants', 'pxToRem']
function U1(e) {
  return Math.round(e * 1e5) / 1e5
}
const Tf = {
    textTransform: 'uppercase',
  },
  Ff = '"Roboto", "Helvetica", "Arial", sans-serif'
function K1(e, t) {
  const n = typeof t == 'function' ? t(e) : t,
    {
      fontFamily: o = Ff,
      // The default font size of the Material Specification.
      fontSize: r = 14,
      // px
      fontWeightLight: i = 300,
      fontWeightRegular: s = 400,
      fontWeightMedium: a = 500,
      fontWeightBold: l = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize: c = 16,
      // Apply the CSS properties to all the variants.
      allVariants: u,
      pxToRem: d,
    } = n,
    f = pe(n, H1),
    A = r / 14,
    h = d || (m => `${(m / c) * A}rem`),
    g = (m, v, y, b, C) =>
      k(
        {
          fontFamily: o,
          fontWeight: m,
          fontSize: h(v),
          // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
          lineHeight: y,
        },
        o === Ff
          ? {
              letterSpacing: `${U1(b / v)}em`,
            }
          : {},
        C,
        u
      ),
    x = {
      h1: g(i, 96, 1.167, -1.5),
      h2: g(i, 60, 1.2, -0.5),
      h3: g(s, 48, 1.167, 0),
      h4: g(s, 34, 1.235, 0.25),
      h5: g(s, 24, 1.334, 0),
      h6: g(a, 20, 1.6, 0.15),
      subtitle1: g(s, 16, 1.75, 0.15),
      subtitle2: g(a, 14, 1.57, 0.1),
      body1: g(s, 16, 1.5, 0.15),
      body2: g(s, 14, 1.43, 0.15),
      button: g(a, 14, 1.75, 0.4, Tf),
      caption: g(s, 12, 1.66, 0.4),
      overline: g(s, 12, 2.66, 1, Tf),
      // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
      inherit: {
        fontFamily: 'inherit',
        fontWeight: 'inherit',
        fontSize: 'inherit',
        lineHeight: 'inherit',
        letterSpacing: 'inherit',
      },
    }
  return Vn(
    k(
      {
        htmlFontSize: c,
        pxToRem: h,
        fontFamily: o,
        fontSize: r,
        fontWeightLight: i,
        fontWeightRegular: s,
        fontWeightMedium: a,
        fontWeightBold: l,
      },
      x
    ),
    f,
    {
      clone: !1,
      // No need to clone deep
    }
  )
}
const q1 = 0.2,
  Z1 = 0.14,
  J1 = 0.12
function st(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${q1})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${Z1})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${J1})`].join(',')
}
const _1 = [
    'none',
    st(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    st(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    st(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    st(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    st(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    st(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    st(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    st(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    st(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    st(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    st(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    st(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    st(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    st(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    st(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    st(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    st(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    st(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    st(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    st(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    st(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    st(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    st(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    st(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
  ],
  $1 = ['duration', 'easing', 'delay'],
  ew = {
    // This is the most common easing curve.
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: 'cubic-bezier(0.4, 0, 0.6, 1)',
  },
  tw = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195,
  }
function Df(e) {
  return `${Math.round(e)}ms`
}
function nw(e) {
  if (!e) return 0
  const t = e / 36
  return Math.round((4 + 15 * t ** 0.25 + t / 5) * 10)
}
function ow(e) {
  const t = k({}, ew, e.easing),
    n = k({}, tw, e.duration)
  return k(
    {
      getAutoHeightDuration: nw,
      create: (r = ['all'], i = {}) => {
        const { duration: s = n.standard, easing: a = t.easeInOut, delay: l = 0 } = i
        return pe(i, $1), (Array.isArray(r) ? r : [r]).map(c => `${c} ${typeof s == 'string' ? s : Df(s)} ${a} ${typeof l == 'string' ? l : Df(l)}`).join(',')
      },
    },
    e,
    {
      easing: t,
      duration: n,
    }
  )
}
const rw = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500,
  },
  iw = ['breakpoints', 'mixins', 'spacing', 'palette', 'transitions', 'typography', 'shape']
function ld(e = {}, ...t) {
  const { mixins: n = {}, palette: o = {}, transitions: r = {}, typography: i = {} } = e,
    s = pe(e, iw)
  if (e.vars) throw new Error(Cr(18))
  const a = Y1(o),
    l = Zi(e)
  let c = Vn(l, {
    mixins: E1(l.breakpoints, n),
    palette: a,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: _1.slice(),
    typography: K1(a, i),
    transitions: ow(r),
    zIndex: k({}, rw),
  })
  return (
    (c = Vn(c, s)),
    (c = t.reduce((u, d) => Vn(u, d), c)),
    (c.unstable_sxConfig = k({}, qi, s == null ? void 0 : s.unstable_sxConfig)),
    (c.unstable_sx = function (d) {
      return Vr({
        sx: d,
        theme: this,
      })
    }),
    c
  )
}
const cd = ld()
function _i() {
  const e = $a(cd)
  return e[wr] || e
}
var $i = {},
  oc = { exports: {} },
  zf
function sw() {
  return (
    zf ||
      ((zf = 1),
      (function (e) {
        function t(n, o) {
          if (n == null) return {}
          var r = {}
          for (var i in n)
            if ({}.hasOwnProperty.call(n, i)) {
              if (o.includes(i)) continue
              r[i] = n[i]
            }
          return r
        }
        ;(e.exports = t), (e.exports.__esModule = !0), (e.exports.default = e.exports)
      })(oc)),
    oc.exports
  )
}
const aw = /* @__PURE__ */ Zn(Px),
  lw = /* @__PURE__ */ Zn(Lx),
  cw = /* @__PURE__ */ Zn(Qx),
  uw = /* @__PURE__ */ Zn(GC),
  dw = /* @__PURE__ */ Zn(SC),
  fw = /* @__PURE__ */ Zn(PC)
var Yr = Ji
Object.defineProperty($i, '__esModule', {
  value: !0,
})
var Aw = ($i.default = Bw)
$i.shouldForwardProp = Ys
$i.systemDefaultTheme = void 0
var _t = Yr(lg()),
  Kc = Yr(sw()),
  Qf = vw(aw),
  pw = lw
Yr(cw)
Yr(uw)
var hw = Yr(dw),
  gw = Yr(fw)
const mw = ['ownerState'],
  yw = ['variants'],
  bw = ['name', 'slot', 'skipVariantsResolver', 'skipSx', 'overridesResolver']
function Dg(e) {
  if (typeof WeakMap != 'function') return null
  var t = /* @__PURE__ */ new WeakMap(),
    n = /* @__PURE__ */ new WeakMap()
  return (Dg = function (o) {
    return o ? n : t
  })(e)
}
function vw(e, t) {
  if (e && e.__esModule) return e
  if (e === null || (typeof e != 'object' && typeof e != 'function')) return { default: e }
  var n = Dg(t)
  if (n && n.has(e)) return n.get(e)
  var o = { __proto__: null },
    r = Object.defineProperty && Object.getOwnPropertyDescriptor
  for (var i in e)
    if (i !== 'default' && Object.prototype.hasOwnProperty.call(e, i)) {
      var s = r ? Object.getOwnPropertyDescriptor(e, i) : null
      s && (s.get || s.set) ? Object.defineProperty(o, i, s) : (o[i] = e[i])
    }
  return (o.default = e), n && n.set(e, o), o
}
function xw(e) {
  return Object.keys(e).length === 0
}
function Cw(e) {
  return (
    typeof e == 'string' && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    e.charCodeAt(0) > 96
  )
}
function Ys(e) {
  return e !== 'ownerState' && e !== 'theme' && e !== 'sx' && e !== 'as'
}
const ww = ($i.systemDefaultTheme = (0, hw.default)()),
  Ew = e => e && e.charAt(0).toLowerCase() + e.slice(1)
function As({ defaultTheme: e, theme: t, themeId: n }) {
  return xw(t) ? e : t[n] || t
}
function Sw(e) {
  return e ? (t, n) => n[e] : null
}
function Hs(e, t) {
  let { ownerState: n } = t,
    o = (0, Kc.default)(t, mw)
  const r =
    typeof e == 'function'
      ? e(
          (0, _t.default)(
            {
              ownerState: n,
            },
            o
          )
        )
      : e
  if (Array.isArray(r))
    return r.flatMap(i =>
      Hs(
        i,
        (0, _t.default)(
          {
            ownerState: n,
          },
          o
        )
      )
    )
  if (r && typeof r == 'object' && Array.isArray(r.variants)) {
    const { variants: i = [] } = r
    let a = (0, Kc.default)(r, yw)
    return (
      i.forEach(l => {
        let c = !0
        typeof l.props == 'function'
          ? (c = l.props(
              (0, _t.default)(
                {
                  ownerState: n,
                },
                o,
                n
              )
            ))
          : Object.keys(l.props).forEach(u => {
              ;(n == null ? void 0 : n[u]) !== l.props[u] && o[u] !== l.props[u] && (c = !1)
            }),
          c &&
            (Array.isArray(a) || (a = [a]),
            a.push(
              typeof l.style == 'function'
                ? l.style(
                    (0, _t.default)(
                      {
                        ownerState: n,
                      },
                      o,
                      n
                    )
                  )
                : l.style
            ))
      }),
      a
    )
  }
  return r
}
function Bw(e = {}) {
  const { themeId: t, defaultTheme: n = ww, rootShouldForwardProp: o = Ys, slotShouldForwardProp: r = Ys } = e,
    i = s =>
      (0, gw.default)(
        (0, _t.default)({}, s, {
          theme: As(
            (0, _t.default)({}, s, {
              defaultTheme: n,
              themeId: t,
            })
          ),
        })
      )
  return (
    (i.__mui_systemSx = !0),
    (s, a = {}) => {
      ;(0, Qf.internal_processStyles)(s, C => C.filter(I => !(I != null && I.__mui_systemSx)))
      const {
          name: l,
          slot: c,
          skipVariantsResolver: u,
          skipSx: d,
          // TODO v6: remove `lowercaseFirstLetter()` in the next major release
          // For more details: https://github.com/mui/material-ui/pull/37908
          overridesResolver: f = Sw(Ew(c)),
        } = a,
        A = (0, Kc.default)(a, bw),
        h =
          u !== void 0
            ? u
            : // TODO v6: remove `Root` in the next major release
              // For more details: https://github.com/mui/material-ui/pull/37908
              (c && c !== 'Root' && c !== 'root') || !1,
        g = d || !1
      let x,
        m = Ys
      c === 'Root' || c === 'root' ? (m = o) : c ? (m = r) : Cw(s) && (m = void 0)
      const v = (0, Qf.default)(
          s,
          (0, _t.default)(
            {
              shouldForwardProp: m,
              label: x,
            },
            A
          )
        ),
        y = C =>
          (typeof C == 'function' && C.__emotion_real !== C) || (0, pw.isPlainObject)(C)
            ? I =>
                Hs(
                  C,
                  (0, _t.default)({}, I, {
                    theme: As({
                      theme: I.theme,
                      defaultTheme: n,
                      themeId: t,
                    }),
                  })
                )
            : C,
        b = (C, ...I) => {
          let w = y(C)
          const M = I ? I.map(y) : []
          l &&
            f &&
            M.push(T => {
              const D = As(
                (0, _t.default)({}, T, {
                  defaultTheme: n,
                  themeId: t,
                })
              )
              if (!D.components || !D.components[l] || !D.components[l].styleOverrides) return null
              const z = D.components[l].styleOverrides,
                E = {}
              return (
                Object.entries(z).forEach(([P, B]) => {
                  E[P] = Hs(
                    B,
                    (0, _t.default)({}, T, {
                      theme: D,
                    })
                  )
                }),
                f(T, E)
              )
            }),
            l &&
              !h &&
              M.push(T => {
                var D
                const z = As(
                    (0, _t.default)({}, T, {
                      defaultTheme: n,
                      themeId: t,
                    })
                  ),
                  E = z == null || (D = z.components) == null || (D = D[l]) == null ? void 0 : D.variants
                return Hs(
                  {
                    variants: E,
                  },
                  (0, _t.default)({}, T, {
                    theme: z,
                  })
                )
              }),
            g || M.push(i)
          const L = M.length - I.length
          if (Array.isArray(C) && L > 0) {
            const T = new Array(L).fill('')
            ;(w = [...C, ...T]), (w.raw = [...C.raw, ...T])
          }
          const R = v(w, ...M)
          return s.muiName && (R.muiName = s.muiName), R
        }
      return v.withConfig && (b.withConfig = v.withConfig), b
    }
  )
}
function dl(e) {
  return e !== 'ownerState' && e !== 'theme' && e !== 'sx' && e !== 'as'
}
const Kt = e => dl(e) && e !== 'classes',
  O = Aw({
    themeId: wr,
    defaultTheme: cd,
    rootShouldForwardProp: Kt,
  }),
  Iw = ['theme']
function Nw(e) {
  let { theme: t } = e,
    n = pe(e, Iw)
  const o = t[wr]
  return /* @__PURE__ */ p.jsx(
    f1,
    k({}, n, {
      themeId: o ? wr : void 0,
      theme: o || t,
    })
  )
}
const Of = e => {
  let t
  return e < 1 ? (t = 5.11916 * e ** 2) : (t = 4.5 * Math.log(e + 1) + 2), (t / 100).toFixed(2)
}
function me(e) {
  if (typeof e != 'string') throw new Error(Cr(7))
  return e.charAt(0).toUpperCase() + e.slice(1)
}
function qc(...e) {
  return e.reduce(
    (t, n) =>
      n == null
        ? t
        : function (...r) {
            t.apply(this, r), n.apply(this, r)
          },
    () => {}
  )
}
function fl(e, t = 166) {
  let n
  function o(...r) {
    const i = () => {
      e.apply(this, r)
    }
    clearTimeout(n), (n = setTimeout(i, t))
  }
  return (
    (o.clear = () => {
      clearTimeout(n)
    }),
    o
  )
}
function kw(e, t) {
  return () => null
}
function Us(e, t) {
  var n, o
  return (
    /* @__PURE__ */ N.isValidElement(e) &&
    t.indexOf(
      // For server components `muiName` is avaialble in element.type._payload.value.muiName
      // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
      // eslint-disable-next-line no-underscore-dangle
      (n = e.type.muiName) != null ? n : (o = e.type) == null || (o = o._payload) == null || (o = o.value) == null ? void 0 : o.muiName
    ) !== -1
  )
}
function wt(e) {
  return (e && e.ownerDocument) || document
}
function kn(e) {
  return wt(e).defaultView || window
}
function Mw(e, t) {
  return () => null
}
function ia(e, t) {
  typeof e == 'function' ? e(t) : e && (e.current = t)
}
const Mn = typeof window < 'u' ? N.useLayoutEffect : N.useEffect
let jf = 0
function Pw(e) {
  const [t, n] = N.useState(e),
    o = e || t
  return (
    N.useEffect(() => {
      t == null && ((jf += 1), n(`mui-${jf}`))
    }, [t]),
    o
  )
}
const Wf = N.useId
function Al(e) {
  if (Wf !== void 0) {
    const t = Wf()
    return e ?? t
  }
  return Pw(e)
}
function Lw(e, t, n, o, r) {
  return null
}
function sa({ controlled: e, default: t, name: n, state: o = 'value' }) {
  const { current: r } = N.useRef(e !== void 0),
    [i, s] = N.useState(t),
    a = r ? e : i,
    l = N.useCallback(c => {
      r || s(c)
    }, [])
  return [a, l]
}
function Sn(e) {
  const t = N.useRef(e)
  return (
    Mn(() => {
      t.current = e
    }),
    N.useRef((...n) =>
      // @ts-expect-error hide `this`
      (0, t.current)(...n)
    ).current
  )
}
function xt(...e) {
  return N.useMemo(
    () =>
      e.every(t => t == null)
        ? null
        : t => {
            e.forEach(n => {
              ia(n, t)
            })
          },
    e
  )
}
const Gf = {}
function Rw(e, t) {
  const n = N.useRef(Gf)
  return n.current === Gf && (n.current = e(t)), n
}
const Tw = []
function Fw(e) {
  N.useEffect(e, Tw)
}
class pl {
  constructor() {
    ;(this.currentId = null),
      (this.clear = () => {
        this.currentId !== null && (clearTimeout(this.currentId), (this.currentId = null))
      }),
      (this.disposeEffect = () => this.clear)
  }
  static create() {
    return new pl()
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(),
      (this.currentId = setTimeout(() => {
        ;(this.currentId = null), n()
      }, t))
  }
}
function zg() {
  const e = Rw(pl.create).current
  return Fw(e.disposeEffect), e
}
let hl = !0,
  Zc = !1
const Dw = new pl(),
  zw = {
    text: !0,
    search: !0,
    url: !0,
    tel: !0,
    email: !0,
    password: !0,
    number: !0,
    date: !0,
    month: !0,
    week: !0,
    time: !0,
    datetime: !0,
    'datetime-local': !0,
  }
function Qw(e) {
  const { type: t, tagName: n } = e
  return !!((n === 'INPUT' && zw[t] && !e.readOnly) || (n === 'TEXTAREA' && !e.readOnly) || e.isContentEditable)
}
function Ow(e) {
  e.metaKey || e.altKey || e.ctrlKey || (hl = !0)
}
function rc() {
  hl = !1
}
function jw() {
  this.visibilityState === 'hidden' && Zc && (hl = !0)
}
function Ww(e) {
  e.addEventListener('keydown', Ow, !0), e.addEventListener('mousedown', rc, !0), e.addEventListener('pointerdown', rc, !0), e.addEventListener('touchstart', rc, !0), e.addEventListener('visibilitychange', jw, !0)
}
function Gw(e) {
  const { target: t } = e
  try {
    return t.matches(':focus-visible')
  } catch {}
  return hl || Qw(t)
}
function ud() {
  const e = N.useCallback(r => {
      r != null && Ww(r.ownerDocument)
    }, []),
    t = N.useRef(!1)
  function n() {
    return t.current
      ? ((Zc = !0),
        Dw.start(100, () => {
          Zc = !1
        }),
        (t.current = !1),
        !0)
      : !1
  }
  function o(r) {
    return Gw(r) ? ((t.current = !0), !0) : !1
  }
  return {
    isFocusVisibleRef: t,
    onFocus: o,
    onBlur: n,
    ref: e,
  }
}
function Qg(e) {
  const t = e.documentElement.clientWidth
  return Math.abs(window.innerWidth - t)
}
const Vw = {
  border: 0,
  clip: 'rect(0 0 0 0)',
  height: '1px',
  margin: '-1px',
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  whiteSpace: 'nowrap',
  width: '1px',
}
function Og(e, t) {
  const n = k({}, t)
  return (
    Object.keys(e).forEach(o => {
      if (o.toString().match(/^(components|slots)$/)) n[o] = k({}, e[o], n[o])
      else if (o.toString().match(/^(componentsProps|slotProps)$/)) {
        const r = e[o] || {},
          i = t[o]
        ;(n[o] = {}),
          !i || !Object.keys(i)
            ? (n[o] = r)
            : !r || !Object.keys(r)
            ? (n[o] = i)
            : ((n[o] = k({}, i)),
              Object.keys(r).forEach(s => {
                n[o][s] = Og(r[s], i[s])
              }))
      } else n[o] === void 0 && (n[o] = e[o])
    }),
    n
  )
}
function Ye(e, t, n = void 0) {
  const o = {}
  return (
    Object.keys(e).forEach(
      // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
      // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
      r => {
        o[r] = e[r]
          .reduce((i, s) => {
            if (s) {
              const a = t(s)
              a !== '' && i.push(a), n && n[s] && i.push(n[s])
            }
            return i
          }, [])
          .join(' ')
      }
    ),
    o
  )
}
function Qe(e, t, n = 'Mui') {
  const o = {}
  return (
    t.forEach(r => {
      o[r] = We(e, r, n)
    }),
    o
  )
}
function ti(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n))
}
function lo(e) {
  return typeof e == 'string'
}
function Xw(e, t, n) {
  return e === void 0 || lo(e)
    ? t
    : k({}, t, {
        ownerState: k({}, t.ownerState, n),
      })
}
function Ci(e, t = []) {
  if (e === void 0) return {}
  const n = {}
  return (
    Object.keys(e)
      .filter(o => o.match(/^on[A-Z]/) && typeof e[o] == 'function' && !t.includes(o))
      .forEach(o => {
        n[o] = e[o]
      }),
    n
  )
}
function Vf(e) {
  if (e === void 0) return {}
  const t = {}
  return (
    Object.keys(e)
      .filter(n => !(n.match(/^on[A-Z]/) && typeof e[n] == 'function'))
      .forEach(n => {
        t[n] = e[n]
      }),
    t
  )
}
function Yw(e) {
  const { getSlotProps: t, additionalProps: n, externalSlotProps: o, externalForwardedProps: r, className: i } = e
  if (!t) {
    const A = de(n == null ? void 0 : n.className, i, r == null ? void 0 : r.className, o == null ? void 0 : o.className),
      h = k({}, n == null ? void 0 : n.style, r == null ? void 0 : r.style, o == null ? void 0 : o.style),
      g = k({}, n, r, o)
    return (
      A.length > 0 && (g.className = A),
      Object.keys(h).length > 0 && (g.style = h),
      {
        props: g,
        internalRef: void 0,
      }
    )
  }
  const s = Ci(k({}, r, o)),
    a = Vf(o),
    l = Vf(r),
    c = t(s),
    u = de(c == null ? void 0 : c.className, n == null ? void 0 : n.className, i, r == null ? void 0 : r.className, o == null ? void 0 : o.className),
    d = k({}, c == null ? void 0 : c.style, n == null ? void 0 : n.style, r == null ? void 0 : r.style, o == null ? void 0 : o.style),
    f = k({}, c, n, l, a)
  return (
    u.length > 0 && (f.className = u),
    Object.keys(d).length > 0 && (f.style = d),
    {
      props: f,
      internalRef: c.ref,
    }
  )
}
function Hw(e, t, n) {
  return typeof e == 'function' ? e(t, n) : e
}
const Uw = ['elementType', 'externalSlotProps', 'ownerState', 'skipResolvingSlotProps']
function zt(e) {
  var t
  const { elementType: n, externalSlotProps: o, ownerState: r, skipResolvingSlotProps: i = !1 } = e,
    s = pe(e, Uw),
    a = i ? {} : Hw(o, r),
    { props: l, internalRef: c } = Yw(
      k({}, s, {
        externalSlotProps: a,
      })
    ),
    u = xt(c, a == null ? void 0 : a.ref, (t = e.additionalProps) == null ? void 0 : t.ref)
  return Xw(
    n,
    k({}, l, {
      ref: u,
    }),
    r
  )
}
function Hr(e) {
  if (parseInt(N.version, 10) >= 19) {
    var t
    return (e == null || (t = e.props) == null ? void 0 : t.ref) || null
  }
  return (e == null ? void 0 : e.ref) || null
}
function Oe(e) {
  return d1(e)
}
function Kw(e) {
  return We('MuiSvgIcon', e)
}
Qe('MuiSvgIcon', ['root', 'colorPrimary', 'colorSecondary', 'colorAction', 'colorError', 'colorDisabled', 'fontSizeInherit', 'fontSizeSmall', 'fontSizeMedium', 'fontSizeLarge'])
const qw = ['children', 'className', 'color', 'component', 'fontSize', 'htmlColor', 'inheritViewBox', 'titleAccess', 'viewBox'],
  Zw = e => {
    const { color: t, fontSize: n, classes: o } = e,
      r = {
        root: ['root', t !== 'inherit' && `color${me(t)}`, `fontSize${me(n)}`],
      }
    return Ye(r, Kw, o)
  },
  Jw = O('svg', {
    name: 'MuiSvgIcon',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, n.color !== 'inherit' && t[`color${me(n.color)}`], t[`fontSize${me(n.fontSize)}`]]
    },
  })(({ theme: e, ownerState: t }) => {
    var n, o, r, i, s, a, l, c, u, d, f, A, h
    return {
      userSelect: 'none',
      width: '1em',
      height: '1em',
      display: 'inline-block',
      // the <svg> will define the property that has `currentColor`
      // for example heroicons uses fill="none" and stroke="currentColor"
      fill: t.hasSvgAsChild ? void 0 : 'currentColor',
      flexShrink: 0,
      transition:
        (n = e.transitions) == null || (o = n.create) == null
          ? void 0
          : o.call(n, 'fill', {
              duration: (r = e.transitions) == null || (r = r.duration) == null ? void 0 : r.shorter,
            }),
      fontSize: {
        inherit: 'inherit',
        small: ((i = e.typography) == null || (s = i.pxToRem) == null ? void 0 : s.call(i, 20)) || '1.25rem',
        medium: ((a = e.typography) == null || (l = a.pxToRem) == null ? void 0 : l.call(a, 24)) || '1.5rem',
        large: ((c = e.typography) == null || (u = c.pxToRem) == null ? void 0 : u.call(c, 35)) || '2.1875rem',
      }[t.fontSize],
      // TODO v5 deprecate, v6 remove for sx
      color:
        (d = (f = (e.vars || e).palette) == null || (f = f[t.color]) == null ? void 0 : f.main) != null
          ? d
          : {
              action: (A = (e.vars || e).palette) == null || (A = A.action) == null ? void 0 : A.active,
              disabled: (h = (e.vars || e).palette) == null || (h = h.action) == null ? void 0 : h.disabled,
              inherit: void 0,
            }[t.color],
    }
  }),
  Jc = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiSvgIcon',
      }),
      { children: r, className: i, color: s = 'inherit', component: a = 'svg', fontSize: l = 'medium', htmlColor: c, inheritViewBox: u = !1, titleAccess: d, viewBox: f = '0 0 24 24' } = o,
      A = pe(o, qw),
      h = /* @__PURE__ */ N.isValidElement(r) && r.type === 'svg',
      g = k({}, o, {
        color: s,
        component: a,
        fontSize: l,
        instanceFontSize: t.fontSize,
        inheritViewBox: u,
        viewBox: f,
        hasSvgAsChild: h,
      }),
      x = {}
    u || (x.viewBox = f)
    const m = Zw(g)
    return /* @__PURE__ */ p.jsxs(
      Jw,
      k(
        {
          as: a,
          className: de(m.root, i),
          focusable: 'false',
          color: c,
          'aria-hidden': d ? void 0 : !0,
          role: d ? 'img' : void 0,
          ref: n,
        },
        x,
        A,
        h && r.props,
        {
          ownerState: g,
          children: [
            h ? r.props.children : r,
            d
              ? /* @__PURE__ */ p.jsx('title', {
                  children: d,
                })
              : null,
          ],
        }
      )
    )
  })
Jc.muiName = 'SvgIcon'
function dd(e, t) {
  function n(o, r) {
    return /* @__PURE__ */ p.jsx(
      Jc,
      k(
        {
          'data-testid': `${t}Icon`,
          ref: r,
        },
        o,
        {
          children: e,
        }
      )
    )
  }
  return (n.muiName = Jc.muiName), /* @__PURE__ */ N.memo(/* @__PURE__ */ N.forwardRef(n))
}
const _w = {
    configure: e => {
      rd.configure(e)
    },
  },
  $w = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        capitalize: me,
        createChainedFunction: qc,
        createSvgIcon: dd,
        debounce: fl,
        deprecatedPropType: kw,
        isMuiElement: Us,
        ownerDocument: wt,
        ownerWindow: kn,
        requirePropFactory: Mw,
        setRef: ia,
        unstable_ClassNameGenerator: _w,
        unstable_useEnhancedEffect: Mn,
        unstable_useId: Al,
        unsupportedProp: Lw,
        useControlled: sa,
        useEventCallback: Sn,
        useForkRef: xt,
        useIsFocusVisible: ud,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function _c(e, t) {
  return (
    (_c = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (n, o) {
          return (n.__proto__ = o), n
        }),
    _c(e, t)
  )
}
function jg(e, t) {
  ;(e.prototype = Object.create(t.prototype)), (e.prototype.constructor = e), _c(e, t)
}
const Xf = {
    disabled: !1,
  },
  aa = ve.createContext(null)
var eE = function (t) {
    return t.scrollTop
  },
  pi = 'unmounted',
  Po = 'exited',
  Lo = 'entering',
  ur = 'entered',
  $c = 'exiting',
  bn = /* @__PURE__ */ (function (e) {
    jg(t, e)
    function t(o, r) {
      var i
      i = e.call(this, o, r) || this
      var s = r,
        a = s && !s.isMounting ? o.enter : o.appear,
        l
      return (
        (i.appearStatus = null),
        o.in ? (a ? ((l = Po), (i.appearStatus = Lo)) : (l = ur)) : o.unmountOnExit || o.mountOnEnter ? (l = pi) : (l = Po),
        (i.state = {
          status: l,
        }),
        (i.nextCallback = null),
        i
      )
    }
    t.getDerivedStateFromProps = function (r, i) {
      var s = r.in
      return s && i.status === pi
        ? {
            status: Po,
          }
        : null
    }
    var n = t.prototype
    return (
      (n.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus)
      }),
      (n.componentDidUpdate = function (r) {
        var i = null
        if (r !== this.props) {
          var s = this.state.status
          this.props.in ? s !== Lo && s !== ur && (i = Lo) : (s === Lo || s === ur) && (i = $c)
        }
        this.updateStatus(!1, i)
      }),
      (n.componentWillUnmount = function () {
        this.cancelNextCallback()
      }),
      (n.getTimeouts = function () {
        var r = this.props.timeout,
          i,
          s,
          a
        return (
          (i = s = a = r),
          r != null && typeof r != 'number' && ((i = r.exit), (s = r.enter), (a = r.appear !== void 0 ? r.appear : s)),
          {
            exit: i,
            enter: s,
            appear: a,
          }
        )
      }),
      (n.updateStatus = function (r, i) {
        if ((r === void 0 && (r = !1), i !== null))
          if ((this.cancelNextCallback(), i === Lo)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var s = this.props.nodeRef ? this.props.nodeRef.current : Ai.findDOMNode(this)
              s && eE(s)
            }
            this.performEnter(r)
          } else this.performExit()
        else
          this.props.unmountOnExit &&
            this.state.status === Po &&
            this.setState({
              status: pi,
            })
      }),
      (n.performEnter = function (r) {
        var i = this,
          s = this.props.enter,
          a = this.context ? this.context.isMounting : r,
          l = this.props.nodeRef ? [a] : [Ai.findDOMNode(this), a],
          c = l[0],
          u = l[1],
          d = this.getTimeouts(),
          f = a ? d.appear : d.enter
        if ((!r && !s) || Xf.disabled) {
          this.safeSetState(
            {
              status: ur,
            },
            function () {
              i.props.onEntered(c)
            }
          )
          return
        }
        this.props.onEnter(c, u),
          this.safeSetState(
            {
              status: Lo,
            },
            function () {
              i.props.onEntering(c, u),
                i.onTransitionEnd(f, function () {
                  i.safeSetState(
                    {
                      status: ur,
                    },
                    function () {
                      i.props.onEntered(c, u)
                    }
                  )
                })
            }
          )
      }),
      (n.performExit = function () {
        var r = this,
          i = this.props.exit,
          s = this.getTimeouts(),
          a = this.props.nodeRef ? void 0 : Ai.findDOMNode(this)
        if (!i || Xf.disabled) {
          this.safeSetState(
            {
              status: Po,
            },
            function () {
              r.props.onExited(a)
            }
          )
          return
        }
        this.props.onExit(a),
          this.safeSetState(
            {
              status: $c,
            },
            function () {
              r.props.onExiting(a),
                r.onTransitionEnd(s.exit, function () {
                  r.safeSetState(
                    {
                      status: Po,
                    },
                    function () {
                      r.props.onExited(a)
                    }
                  )
                })
            }
          )
      }),
      (n.cancelNextCallback = function () {
        this.nextCallback !== null && (this.nextCallback.cancel(), (this.nextCallback = null))
      }),
      (n.safeSetState = function (r, i) {
        ;(i = this.setNextCallback(i)), this.setState(r, i)
      }),
      (n.setNextCallback = function (r) {
        var i = this,
          s = !0
        return (
          (this.nextCallback = function (a) {
            s && ((s = !1), (i.nextCallback = null), r(a))
          }),
          (this.nextCallback.cancel = function () {
            s = !1
          }),
          this.nextCallback
        )
      }),
      (n.onTransitionEnd = function (r, i) {
        this.setNextCallback(i)
        var s = this.props.nodeRef ? this.props.nodeRef.current : Ai.findDOMNode(this),
          a = r == null && !this.props.addEndListener
        if (!s || a) {
          setTimeout(this.nextCallback, 0)
          return
        }
        if (this.props.addEndListener) {
          var l = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback],
            c = l[0],
            u = l[1]
          this.props.addEndListener(c, u)
        }
        r != null && setTimeout(this.nextCallback, r)
      }),
      (n.render = function () {
        var r = this.state.status
        if (r === pi) return null
        var i = this.props,
          s = i.children
        i.in, i.mountOnEnter, i.unmountOnExit, i.appear, i.enter, i.exit, i.timeout, i.addEndListener, i.onEnter, i.onEntering, i.onEntered, i.onExit, i.onExiting, i.onExited, i.nodeRef
        var a = pe(i, ['children', 'in', 'mountOnEnter', 'unmountOnExit', 'appear', 'enter', 'exit', 'timeout', 'addEndListener', 'onEnter', 'onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited', 'nodeRef'])
        return (
          // allows for nested Transitions
          /* @__PURE__ */ ve.createElement(
            aa.Provider,
            {
              value: null,
            },
            typeof s == 'function' ? s(r, a) : ve.cloneElement(ve.Children.only(s), a)
          )
        )
      }),
      t
    )
  })(ve.Component)
bn.contextType = aa
bn.propTypes = {}
function rr() {}
bn.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: rr,
  onEntering: rr,
  onEntered: rr,
  onExit: rr,
  onExiting: rr,
  onExited: rr,
}
bn.UNMOUNTED = pi
bn.EXITED = Po
bn.ENTERING = Lo
bn.ENTERED = ur
bn.EXITING = $c
function tE(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
  return e
}
function fd(e, t) {
  var n = function (i) {
      return t && ao(i) ? t(i) : i
    },
    o = /* @__PURE__ */ Object.create(null)
  return (
    e &&
      tv
        .map(e, function (r) {
          return r
        })
        .forEach(function (r) {
          o[r.key] = n(r)
        }),
    o
  )
}
function nE(e, t) {
  ;(e = e || {}), (t = t || {})
  function n(u) {
    return u in t ? t[u] : e[u]
  }
  var o = /* @__PURE__ */ Object.create(null),
    r = []
  for (var i in e) i in t ? r.length && ((o[i] = r), (r = [])) : r.push(i)
  var s,
    a = {}
  for (var l in t) {
    if (o[l])
      for (s = 0; s < o[l].length; s++) {
        var c = o[l][s]
        a[o[l][s]] = n(c)
      }
    a[l] = n(l)
  }
  for (s = 0; s < r.length; s++) a[r[s]] = n(r[s])
  return a
}
function Fo(e, t, n) {
  return n[t] != null ? n[t] : e.props[t]
}
function oE(e, t) {
  return fd(e.children, function (n) {
    return Oo(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: Fo(n, 'appear', e),
      enter: Fo(n, 'enter', e),
      exit: Fo(n, 'exit', e),
    })
  })
}
function rE(e, t, n) {
  var o = fd(e.children),
    r = nE(t, o)
  return (
    Object.keys(r).forEach(function (i) {
      var s = r[i]
      if (ao(s)) {
        var a = i in t,
          l = i in o,
          c = t[i],
          u = ao(c) && !c.props.in
        l && (!a || u)
          ? (r[i] = Oo(s, {
              onExited: n.bind(null, s),
              in: !0,
              exit: Fo(s, 'exit', e),
              enter: Fo(s, 'enter', e),
            }))
          : !l && a && !u
          ? (r[i] = Oo(s, {
              in: !1,
            }))
          : l &&
            a &&
            ao(c) &&
            (r[i] = Oo(s, {
              onExited: n.bind(null, s),
              in: c.props.in,
              exit: Fo(s, 'exit', e),
              enter: Fo(s, 'enter', e),
            }))
      }
    }),
    r
  )
}
var iE =
    Object.values ||
    function (e) {
      return Object.keys(e).map(function (t) {
        return e[t]
      })
    },
  sE = {
    component: 'div',
    childFactory: function (t) {
      return t
    },
  },
  Ad = /* @__PURE__ */ (function (e) {
    jg(t, e)
    function t(o, r) {
      var i
      i = e.call(this, o, r) || this
      var s = i.handleExited.bind(tE(i))
      return (
        (i.state = {
          contextValue: {
            isMounting: !0,
          },
          handleExited: s,
          firstRender: !0,
        }),
        i
      )
    }
    var n = t.prototype
    return (
      (n.componentDidMount = function () {
        ;(this.mounted = !0),
          this.setState({
            contextValue: {
              isMounting: !1,
            },
          })
      }),
      (n.componentWillUnmount = function () {
        this.mounted = !1
      }),
      (t.getDerivedStateFromProps = function (r, i) {
        var s = i.children,
          a = i.handleExited,
          l = i.firstRender
        return {
          children: l ? oE(r, a) : rE(r, s, a),
          firstRender: !1,
        }
      }),
      (n.handleExited = function (r, i) {
        var s = fd(this.props.children)
        r.key in s ||
          (r.props.onExited && r.props.onExited(i),
          this.mounted &&
            this.setState(function (a) {
              var l = k({}, a.children)
              return (
                delete l[r.key],
                {
                  children: l,
                }
              )
            }))
      }),
      (n.render = function () {
        var r = this.props,
          i = r.component,
          s = r.childFactory,
          a = pe(r, ['component', 'childFactory']),
          l = this.state.contextValue,
          c = iE(this.state.children).map(s)
        return (
          delete a.appear,
          delete a.enter,
          delete a.exit,
          i === null
            ? /* @__PURE__ */ ve.createElement(
                aa.Provider,
                {
                  value: l,
                },
                c
              )
            : /* @__PURE__ */ ve.createElement(
                aa.Provider,
                {
                  value: l,
                },
                /* @__PURE__ */ ve.createElement(i, a, c)
              )
        )
      }),
      t
    )
  })(ve.Component)
Ad.propTypes = {}
Ad.defaultProps = sE
const pd = e => e.scrollTop
function Sr(e, t) {
  var n, o
  const { timeout: r, easing: i, style: s = {} } = e
  return {
    duration: (n = s.transitionDuration) != null ? n : typeof r == 'number' ? r : r[t.mode] || 0,
    easing: (o = s.transitionTimingFunction) != null ? o : typeof i == 'object' ? i[t.mode] : i,
    delay: s.transitionDelay,
  }
}
function aE(e) {
  return We('MuiPaper', e)
}
Qe('MuiPaper', [
  'root',
  'rounded',
  'outlined',
  'elevation',
  'elevation0',
  'elevation1',
  'elevation2',
  'elevation3',
  'elevation4',
  'elevation5',
  'elevation6',
  'elevation7',
  'elevation8',
  'elevation9',
  'elevation10',
  'elevation11',
  'elevation12',
  'elevation13',
  'elevation14',
  'elevation15',
  'elevation16',
  'elevation17',
  'elevation18',
  'elevation19',
  'elevation20',
  'elevation21',
  'elevation22',
  'elevation23',
  'elevation24',
])
const lE = ['className', 'component', 'elevation', 'square', 'variant'],
  cE = e => {
    const { square: t, elevation: n, variant: o, classes: r } = e,
      i = {
        root: ['root', o, !t && 'rounded', o === 'elevation' && `elevation${n}`],
      }
    return Ye(i, aE, r)
  },
  uE = O('div', {
    name: 'MuiPaper',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, t[n.variant], !n.square && t.rounded, n.variant === 'elevation' && t[`elevation${n.elevation}`]]
    },
  })(({ theme: e, ownerState: t }) => {
    var n
    return k(
      {
        backgroundColor: (e.vars || e).palette.background.paper,
        color: (e.vars || e).palette.text.primary,
        transition: e.transitions.create('box-shadow'),
      },
      !t.square && {
        borderRadius: e.shape.borderRadius,
      },
      t.variant === 'outlined' && {
        border: `1px solid ${(e.vars || e).palette.divider}`,
      },
      t.variant === 'elevation' &&
        k(
          {
            boxShadow: (e.vars || e).shadows[t.elevation],
          },
          !e.vars &&
            e.palette.mode === 'dark' && {
              backgroundImage: `linear-gradient(${Lt('#fff', Of(t.elevation))}, ${Lt('#fff', Of(t.elevation))})`,
            },
          e.vars && {
            backgroundImage: (n = e.vars.overlays) == null ? void 0 : n[t.elevation],
          }
        )
    )
  }),
  es = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiPaper',
      }),
      { className: r, component: i = 'div', elevation: s = 1, square: a = !1, variant: l = 'elevation' } = o,
      c = pe(o, lE),
      u = k({}, o, {
        component: i,
        elevation: s,
        square: a,
        variant: l,
      }),
      d = cE(u)
    return /* @__PURE__ */ p.jsx(
      uE,
      k(
        {
          as: i,
          ownerState: u,
          className: de(d.root, r),
          ref: n,
        },
        c
      )
    )
  })
function dE(e) {
  const { className: t, classes: n, pulsate: o = !1, rippleX: r, rippleY: i, rippleSize: s, in: a, onExited: l, timeout: c } = e,
    [u, d] = N.useState(!1),
    f = de(t, n.ripple, n.rippleVisible, o && n.ripplePulsate),
    A = {
      width: s,
      height: s,
      top: -(s / 2) + i,
      left: -(s / 2) + r,
    },
    h = de(n.child, u && n.childLeaving, o && n.childPulsate)
  return (
    !a && !u && d(!0),
    N.useEffect(() => {
      if (!a && l != null) {
        const g = setTimeout(l, c)
        return () => {
          clearTimeout(g)
        }
      }
    }, [l, a, c]),
    /* @__PURE__ */ p.jsx('span', {
      className: f,
      style: A,
      children: /* @__PURE__ */ p.jsx('span', {
        className: h,
      }),
    })
  )
}
const $t = Qe('MuiTouchRipple', ['root', 'ripple', 'rippleVisible', 'ripplePulsate', 'child', 'childLeaving', 'childPulsate']),
  fE = ['center', 'classes', 'className']
let gl = e => e,
  Yf,
  Hf,
  Uf,
  Kf
const eu = 550,
  AE = 80,
  pE = Ha(
    Yf ||
      (Yf = gl`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)
  ),
  hE = Ha(
    Hf ||
      (Hf = gl`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)
  ),
  gE = Ha(
    Uf ||
      (Uf = gl`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)
  ),
  mE = O('span', {
    name: 'MuiTouchRipple',
    slot: 'Root',
  })({
    overflow: 'hidden',
    pointerEvents: 'none',
    position: 'absolute',
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: 'inherit',
  }),
  yE = O(dE, {
    name: 'MuiTouchRipple',
    slot: 'Ripple',
  })(
    Kf ||
      (Kf = gl`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),
    $t.rippleVisible,
    pE,
    eu,
    ({ theme: e }) => e.transitions.easing.easeInOut,
    $t.ripplePulsate,
    ({ theme: e }) => e.transitions.duration.shorter,
    $t.child,
    $t.childLeaving,
    hE,
    eu,
    ({ theme: e }) => e.transitions.easing.easeInOut,
    $t.childPulsate,
    gE,
    ({ theme: e }) => e.transitions.easing.easeInOut
  ),
  bE = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiTouchRipple',
      }),
      { center: r = !1, classes: i = {}, className: s } = o,
      a = pe(o, fE),
      [l, c] = N.useState([]),
      u = N.useRef(0),
      d = N.useRef(null)
    N.useEffect(() => {
      d.current && (d.current(), (d.current = null))
    }, [l])
    const f = N.useRef(!1),
      A = zg(),
      h = N.useRef(null),
      g = N.useRef(null),
      x = N.useCallback(
        b => {
          const { pulsate: C, rippleX: I, rippleY: w, rippleSize: M, cb: L } = b
          c(R => [
            ...R,
            /* @__PURE__ */ p.jsx(
              yE,
              {
                classes: {
                  ripple: de(i.ripple, $t.ripple),
                  rippleVisible: de(i.rippleVisible, $t.rippleVisible),
                  ripplePulsate: de(i.ripplePulsate, $t.ripplePulsate),
                  child: de(i.child, $t.child),
                  childLeaving: de(i.childLeaving, $t.childLeaving),
                  childPulsate: de(i.childPulsate, $t.childPulsate),
                },
                timeout: eu,
                pulsate: C,
                rippleX: I,
                rippleY: w,
                rippleSize: M,
              },
              u.current
            ),
          ]),
            (u.current += 1),
            (d.current = L)
        },
        [i]
      ),
      m = N.useCallback(
        (b = {}, C = {}, I = () => {}) => {
          const {
            pulsate: w = !1,
            center: M = r || C.pulsate,
            fakeElement: L = !1,
            // For test purposes
          } = C
          if ((b == null ? void 0 : b.type) === 'mousedown' && f.current) {
            f.current = !1
            return
          }
          ;(b == null ? void 0 : b.type) === 'touchstart' && (f.current = !0)
          const R = L ? null : g.current,
            T = R
              ? R.getBoundingClientRect()
              : {
                  width: 0,
                  height: 0,
                  left: 0,
                  top: 0,
                }
          let D, z, E
          if (M || b === void 0 || (b.clientX === 0 && b.clientY === 0) || (!b.clientX && !b.touches)) (D = Math.round(T.width / 2)), (z = Math.round(T.height / 2))
          else {
            const { clientX: P, clientY: B } = b.touches && b.touches.length > 0 ? b.touches[0] : b
            ;(D = Math.round(P - T.left)), (z = Math.round(B - T.top))
          }
          if (M) (E = Math.sqrt((2 * T.width ** 2 + T.height ** 2) / 3)), E % 2 === 0 && (E += 1)
          else {
            const P = Math.max(Math.abs((R ? R.clientWidth : 0) - D), D) * 2 + 2,
              B = Math.max(Math.abs((R ? R.clientHeight : 0) - z), z) * 2 + 2
            E = Math.sqrt(P ** 2 + B ** 2)
          }
          b != null && b.touches
            ? h.current === null &&
              ((h.current = () => {
                x({
                  pulsate: w,
                  rippleX: D,
                  rippleY: z,
                  rippleSize: E,
                  cb: I,
                })
              }),
              A.start(AE, () => {
                h.current && (h.current(), (h.current = null))
              }))
            : x({
                pulsate: w,
                rippleX: D,
                rippleY: z,
                rippleSize: E,
                cb: I,
              })
        },
        [r, x, A]
      ),
      v = N.useCallback(() => {
        m(
          {},
          {
            pulsate: !0,
          }
        )
      }, [m]),
      y = N.useCallback(
        (b, C) => {
          if ((A.clear(), (b == null ? void 0 : b.type) === 'touchend' && h.current)) {
            h.current(),
              (h.current = null),
              A.start(0, () => {
                y(b, C)
              })
            return
          }
          ;(h.current = null), c(I => (I.length > 0 ? I.slice(1) : I)), (d.current = C)
        },
        [A]
      )
    return (
      N.useImperativeHandle(
        n,
        () => ({
          pulsate: v,
          start: m,
          stop: y,
        }),
        [v, m, y]
      ),
      /* @__PURE__ */ p.jsx(
        mE,
        k(
          {
            className: de($t.root, i.root, s),
            ref: g,
          },
          a,
          {
            children: /* @__PURE__ */ p.jsx(Ad, {
              component: null,
              exit: !0,
              children: l,
            }),
          }
        )
      )
    )
  })
function vE(e) {
  return We('MuiButtonBase', e)
}
const xE = Qe('MuiButtonBase', ['root', 'disabled', 'focusVisible']),
  CE = [
    'action',
    'centerRipple',
    'children',
    'className',
    'component',
    'disabled',
    'disableRipple',
    'disableTouchRipple',
    'focusRipple',
    'focusVisibleClassName',
    'LinkComponent',
    'onBlur',
    'onClick',
    'onContextMenu',
    'onDragLeave',
    'onFocus',
    'onFocusVisible',
    'onKeyDown',
    'onKeyUp',
    'onMouseDown',
    'onMouseLeave',
    'onMouseUp',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'tabIndex',
    'TouchRippleProps',
    'touchRippleRef',
    'type',
  ],
  wE = e => {
    const { disabled: t, focusVisible: n, focusVisibleClassName: o, classes: r } = e,
      s = Ye(
        {
          root: ['root', t && 'disabled', n && 'focusVisible'],
        },
        vE,
        r
      )
    return n && o && (s.root += ` ${o}`), s
  },
  EE = O('button', {
    name: 'MuiButtonBase',
    slot: 'Root',
    overridesResolver: (e, t) => t.root,
  })({
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    boxSizing: 'border-box',
    WebkitTapHighlightColor: 'transparent',
    backgroundColor: 'transparent',
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: 'pointer',
    userSelect: 'none',
    verticalAlign: 'middle',
    MozAppearance: 'none',
    // Reset
    WebkitAppearance: 'none',
    // Reset
    textDecoration: 'none',
    // So we take precedent over the style of a native <a /> element.
    color: 'inherit',
    '&::-moz-focus-inner': {
      borderStyle: 'none',
      // Remove Firefox dotted outline.
    },
    [`&.${xE.disabled}`]: {
      pointerEvents: 'none',
      // Disable link interactions
      cursor: 'default',
    },
    '@media print': {
      colorAdjust: 'exact',
    },
  }),
  hd = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiButtonBase',
      }),
      {
        action: r,
        centerRipple: i = !1,
        children: s,
        className: a,
        component: l = 'button',
        disabled: c = !1,
        disableRipple: u = !1,
        disableTouchRipple: d = !1,
        focusRipple: f = !1,
        LinkComponent: A = 'a',
        onBlur: h,
        onClick: g,
        onContextMenu: x,
        onDragLeave: m,
        onFocus: v,
        onFocusVisible: y,
        onKeyDown: b,
        onKeyUp: C,
        onMouseDown: I,
        onMouseLeave: w,
        onMouseUp: M,
        onTouchEnd: L,
        onTouchMove: R,
        onTouchStart: T,
        tabIndex: D = 0,
        TouchRippleProps: z,
        touchRippleRef: E,
        type: P,
      } = o,
      B = pe(o, CE),
      F = N.useRef(null),
      S = N.useRef(null),
      Q = xt(S, E),
      { isFocusVisibleRef: j, onFocus: U, onBlur: q, ref: ne } = ud(),
      [G, K] = N.useState(!1)
    c && G && K(!1),
      N.useImperativeHandle(
        r,
        () => ({
          focusVisible: () => {
            K(!0), F.current.focus()
          },
        }),
        []
      )
    const [$, oe] = N.useState(!1)
    N.useEffect(() => {
      oe(!0)
    }, [])
    const Z = $ && !u && !c
    N.useEffect(() => {
      G && f && !u && $ && S.current.pulsate()
    }, [u, f, G, $])
    function ie(W, le, te = d) {
      return Sn(ce => (le && le(ce), !te && S.current && S.current[W](ce), !0))
    }
    const fe = ie('start', I),
      se = ie('stop', x),
      re = ie('stop', m),
      Y = ie('stop', M),
      H = ie('stop', W => {
        G && W.preventDefault(), w && w(W)
      }),
      ee = ie('start', T),
      xe = ie('stop', L),
      Fe = ie('stop', R),
      De = ie(
        'stop',
        W => {
          q(W), j.current === !1 && K(!1), h && h(W)
        },
        !1
      ),
      _e = Sn(W => {
        F.current || (F.current = W.currentTarget), U(W), j.current === !0 && (K(!0), y && y(W)), v && v(W)
      }),
      Be = () => {
        const W = F.current
        return l && l !== 'button' && !(W.tagName === 'A' && W.href)
      },
      ke = N.useRef(!1),
      rt = Sn(W => {
        f &&
          !ke.current &&
          G &&
          S.current &&
          W.key === ' ' &&
          ((ke.current = !0),
          S.current.stop(W, () => {
            S.current.start(W)
          })),
          W.target === W.currentTarget && Be() && W.key === ' ' && W.preventDefault(),
          b && b(W),
          W.target === W.currentTarget && Be() && W.key === 'Enter' && !c && (W.preventDefault(), g && g(W))
      }),
      He = Sn(W => {
        f &&
          W.key === ' ' &&
          S.current &&
          G &&
          !W.defaultPrevented &&
          ((ke.current = !1),
          S.current.stop(W, () => {
            S.current.pulsate(W)
          })),
          C && C(W),
          g && W.target === W.currentTarget && Be() && W.key === ' ' && !W.defaultPrevented && g(W)
      })
    let Le = l
    Le === 'button' && (B.href || B.to) && (Le = A)
    const tt = {}
    Le === 'button' ? ((tt.type = P === void 0 ? 'button' : P), (tt.disabled = c)) : (!B.href && !B.to && (tt.role = 'button'), c && (tt['aria-disabled'] = c))
    const $e = xt(n, ne, F),
      Ke = k({}, o, {
        centerRipple: i,
        component: l,
        disabled: c,
        disableRipple: u,
        disableTouchRipple: d,
        focusRipple: f,
        tabIndex: D,
        focusVisible: G,
      }),
      V = wE(Ke)
    return /* @__PURE__ */ p.jsxs(
      EE,
      k(
        {
          as: Le,
          className: de(V.root, a),
          ownerState: Ke,
          onBlur: De,
          onClick: g,
          onContextMenu: se,
          onFocus: _e,
          onKeyDown: rt,
          onKeyUp: He,
          onMouseDown: fe,
          onMouseLeave: H,
          onMouseUp: Y,
          onDragLeave: re,
          onTouchEnd: xe,
          onTouchMove: Fe,
          onTouchStart: ee,
          ref: $e,
          tabIndex: c ? -1 : D,
          type: P,
        },
        tt,
        B,
        {
          children: [
            s,
            Z
              ? /* TouchRipple is only needed client-side, x2 boost on the server. */
                /* @__PURE__ */ p.jsx(
                  bE,
                  k(
                    {
                      ref: Q,
                      center: i,
                    },
                    z
                  )
                )
              : null,
          ],
        }
      )
    )
  })
function SE(e) {
  return We('MuiIconButton', e)
}
const BE = Qe('MuiIconButton', ['root', 'disabled', 'colorInherit', 'colorPrimary', 'colorSecondary', 'colorError', 'colorInfo', 'colorSuccess', 'colorWarning', 'edgeStart', 'edgeEnd', 'sizeSmall', 'sizeMedium', 'sizeLarge']),
  IE = ['edge', 'children', 'className', 'color', 'disabled', 'disableFocusRipple', 'size'],
  NE = e => {
    const { classes: t, disabled: n, color: o, edge: r, size: i } = e,
      s = {
        root: ['root', n && 'disabled', o !== 'default' && `color${me(o)}`, r && `edge${me(r)}`, `size${me(i)}`],
      }
    return Ye(s, SE, t)
  },
  kE = O(hd, {
    name: 'MuiIconButton',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, n.color !== 'default' && t[`color${me(n.color)}`], n.edge && t[`edge${me(n.edge)}`], t[`size${me(n.size)}`]]
    },
  })(
    ({ theme: e, ownerState: t }) =>
      k(
        {
          textAlign: 'center',
          flex: '0 0 auto',
          fontSize: e.typography.pxToRem(24),
          padding: 8,
          borderRadius: '50%',
          overflow: 'visible',
          // Explicitly set the default value to solve a bug on IE11.
          color: (e.vars || e).palette.action.active,
          transition: e.transitions.create('background-color', {
            duration: e.transitions.duration.shortest,
          }),
        },
        !t.disableRipple && {
          '&:hover': {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Lt(e.palette.action.active, e.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent',
            },
          },
        },
        t.edge === 'start' && {
          marginLeft: t.size === 'small' ? -3 : -12,
        },
        t.edge === 'end' && {
          marginRight: t.size === 'small' ? -3 : -12,
        }
      ),
    ({ theme: e, ownerState: t }) => {
      var n
      const o = (n = (e.vars || e).palette) == null ? void 0 : n[t.color]
      return k(
        {},
        t.color === 'inherit' && {
          color: 'inherit',
        },
        t.color !== 'inherit' &&
          t.color !== 'default' &&
          k(
            {
              color: o == null ? void 0 : o.main,
            },
            !t.disableRipple && {
              '&:hover': k(
                {},
                o && {
                  backgroundColor: e.vars ? `rgba(${o.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Lt(o.main, e.palette.action.hoverOpacity),
                },
                {
                  // Reset on touch devices, it doesn't add specificity
                  '@media (hover: none)': {
                    backgroundColor: 'transparent',
                  },
                }
              ),
            }
          ),
        t.size === 'small' && {
          padding: 5,
          fontSize: e.typography.pxToRem(18),
        },
        t.size === 'large' && {
          padding: 12,
          fontSize: e.typography.pxToRem(28),
        },
        {
          [`&.${BE.disabled}`]: {
            backgroundColor: 'transparent',
            color: (e.vars || e).palette.action.disabled,
          },
        }
      )
    }
  ),
  Wg = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiIconButton',
      }),
      { edge: r = !1, children: i, className: s, color: a = 'default', disabled: l = !1, disableFocusRipple: c = !1, size: u = 'medium' } = o,
      d = pe(o, IE),
      f = k({}, o, {
        edge: r,
        color: a,
        disabled: l,
        disableFocusRipple: c,
        size: u,
      }),
      A = NE(f)
    return /* @__PURE__ */ p.jsx(
      kE,
      k(
        {
          className: de(A.root, s),
          centerRipple: !0,
          focusRipple: !c,
          disabled: l,
          ref: n,
        },
        d,
        {
          ownerState: f,
          children: i,
        }
      )
    )
  })
function ME(e) {
  return We('MuiTypography', e)
}
Qe('MuiTypography', ['root', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'inherit', 'button', 'caption', 'overline', 'alignLeft', 'alignRight', 'alignCenter', 'alignJustify', 'noWrap', 'gutterBottom', 'paragraph'])
const PE = ['align', 'className', 'component', 'gutterBottom', 'noWrap', 'paragraph', 'variant', 'variantMapping'],
  LE = e => {
    const { align: t, gutterBottom: n, noWrap: o, paragraph: r, variant: i, classes: s } = e,
      a = {
        root: ['root', i, e.align !== 'inherit' && `align${me(t)}`, n && 'gutterBottom', o && 'noWrap', r && 'paragraph'],
      }
    return Ye(a, ME, s)
  },
  RE = O('span', {
    name: 'MuiTypography',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, n.variant && t[n.variant], n.align !== 'inherit' && t[`align${me(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph]
    },
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        margin: 0,
      },
      t.variant === 'inherit' && {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: 'inherit',
      },
      t.variant !== 'inherit' && e.typography[t.variant],
      t.align !== 'inherit' && {
        textAlign: t.align,
      },
      t.noWrap && {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
      },
      t.gutterBottom && {
        marginBottom: '0.35em',
      },
      t.paragraph && {
        marginBottom: 16,
      }
    )
  ),
  qf = {
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6',
    subtitle1: 'h6',
    subtitle2: 'h6',
    body1: 'p',
    body2: 'p',
    inherit: 'p',
  },
  TE = {
    primary: 'primary.main',
    textPrimary: 'text.primary',
    secondary: 'secondary.main',
    textSecondary: 'text.secondary',
    error: 'error.main',
  },
  FE = e => TE[e] || e,
  Do = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiTypography',
      }),
      r = FE(o.color),
      i = el(
        k({}, o, {
          color: r,
        })
      ),
      { align: s = 'inherit', className: a, component: l, gutterBottom: c = !1, noWrap: u = !1, paragraph: d = !1, variant: f = 'body1', variantMapping: A = qf } = i,
      h = pe(i, PE),
      g = k({}, i, {
        align: s,
        color: r,
        className: a,
        component: l,
        gutterBottom: c,
        noWrap: u,
        paragraph: d,
        variant: f,
        variantMapping: A,
      }),
      x = l || (d ? 'p' : A[f] || qf[f]) || 'span',
      m = LE(g)
    return /* @__PURE__ */ p.jsx(
      RE,
      k(
        {
          as: x,
          ref: n,
          ownerState: g,
          className: de(m.root, a),
        },
        h
      )
    )
  })
function DE(e) {
  return typeof e == 'function' ? e() : e
}
const zE = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const { children: o, container: r, disablePortal: i = !1 } = t,
      [s, a] = N.useState(null),
      l = xt(/* @__PURE__ */ N.isValidElement(o) ? Hr(o) : null, n)
    if (
      (Mn(() => {
        i || a(DE(r) || document.body)
      }, [r, i]),
      Mn(() => {
        if (s && !i)
          return (
            ia(n, s),
            () => {
              ia(n, null)
            }
          )
      }, [n, s, i]),
      i)
    ) {
      if (/* @__PURE__ */ N.isValidElement(o)) {
        const c = {
          ref: l,
        }
        return /* @__PURE__ */ N.cloneElement(o, c)
      }
      return /* @__PURE__ */ p.jsx(N.Fragment, {
        children: o,
      })
    }
    return /* @__PURE__ */ p.jsx(N.Fragment, {
      children: s && /* @__PURE__ */ zu.createPortal(o, s),
    })
  }),
  QE = ['onChange', 'maxRows', 'minRows', 'style', 'value']
function ps(e) {
  return parseInt(e, 10) || 0
}
const OE = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: 'hidden',
    // Remove from the content flow
    position: 'absolute',
    // Ignore the scrollbar width
    overflow: 'hidden',
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: 'translateZ(0)',
  },
}
function jE(e) {
  return e == null || Object.keys(e).length === 0 || (e.outerHeightStyle === 0 && !e.overflowing)
}
const WE = /* @__PURE__ */ N.forwardRef(function (t, n) {
  const { onChange: o, maxRows: r, minRows: i = 1, style: s, value: a } = t,
    l = pe(t, QE),
    { current: c } = N.useRef(a != null),
    u = N.useRef(null),
    d = xt(n, u),
    f = N.useRef(null),
    A = N.useRef(null),
    h = N.useCallback(() => {
      const m = u.current,
        y = kn(m).getComputedStyle(m)
      if (y.width === '0px')
        return {
          outerHeightStyle: 0,
          overflowing: !1,
        }
      const b = A.current
      ;(b.style.width = y.width),
        (b.value = m.value || t.placeholder || 'x'),
        b.value.slice(-1) ===
          `
` && (b.value += ' ')
      const C = y.boxSizing,
        I = ps(y.paddingBottom) + ps(y.paddingTop),
        w = ps(y.borderBottomWidth) + ps(y.borderTopWidth),
        M = b.scrollHeight
      b.value = 'x'
      const L = b.scrollHeight
      let R = M
      i && (R = Math.max(Number(i) * L, R)), r && (R = Math.min(Number(r) * L, R)), (R = Math.max(R, L))
      const T = R + (C === 'border-box' ? I + w : 0),
        D = Math.abs(R - M) <= 1
      return {
        outerHeightStyle: T,
        overflowing: D,
      }
    }, [r, i, t.placeholder]),
    g = N.useCallback(() => {
      const m = h()
      if (jE(m)) return
      const v = m.outerHeightStyle,
        y = u.current
      f.current !== v && ((f.current = v), (y.style.height = `${v}px`)), (y.style.overflow = m.overflowing ? 'hidden' : '')
    }, [h])
  Mn(() => {
    const m = () => {
      g()
    }
    let v
    const y = fl(m),
      b = u.current,
      C = kn(b)
    C.addEventListener('resize', y)
    let I
    return (
      typeof ResizeObserver < 'u' && ((I = new ResizeObserver(m)), I.observe(b)),
      () => {
        y.clear(), cancelAnimationFrame(v), C.removeEventListener('resize', y), I && I.disconnect()
      }
    )
  }, [h, g]),
    Mn(() => {
      g()
    })
  const x = m => {
    c || g(), o && o(m)
  }
  return /* @__PURE__ */ p.jsxs(N.Fragment, {
    children: [
      /* @__PURE__ */ p.jsx(
        'textarea',
        k(
          {
            value: a,
            onChange: x,
            ref: d,
            rows: i,
            style: s,
          },
          l
        )
      ),
      /* @__PURE__ */ p.jsx('textarea', {
        'aria-hidden': !0,
        className: t.className,
        readOnly: !0,
        ref: A,
        tabIndex: -1,
        style: k({}, OE.shadow, s, {
          paddingTop: 0,
          paddingBottom: 0,
        }),
      }),
    ],
  })
})
function Ur({ props: e, states: t, muiFormControl: n }) {
  return t.reduce((o, r) => ((o[r] = e[r]), n && typeof e[r] > 'u' && (o[r] = n[r]), o), {})
}
const ml = /* @__PURE__ */ N.createContext(void 0)
function er() {
  return N.useContext(ml)
}
function Gg(e) {
  return /* @__PURE__ */ p.jsx(
    NC,
    k({}, e, {
      defaultTheme: cd,
      themeId: wr,
    })
  )
}
function Zf(e) {
  return e != null && !(Array.isArray(e) && e.length === 0)
}
function la(e, t = !1) {
  return e && ((Zf(e.value) && e.value !== '') || (t && Zf(e.defaultValue) && e.defaultValue !== ''))
}
function GE(e) {
  return e.startAdornment
}
function VE(e) {
  return We('MuiInputBase', e)
}
const Br = Qe('MuiInputBase', ['root', 'formControl', 'focused', 'disabled', 'adornedStart', 'adornedEnd', 'error', 'sizeSmall', 'multiline', 'colorSecondary', 'fullWidth', 'hiddenLabel', 'readOnly', 'input', 'inputSizeSmall', 'inputMultiline', 'inputTypeSearch', 'inputAdornedStart', 'inputAdornedEnd', 'inputHiddenLabel']),
  XE = [
    'aria-describedby',
    'autoComplete',
    'autoFocus',
    'className',
    'color',
    'components',
    'componentsProps',
    'defaultValue',
    'disabled',
    'disableInjectingGlobalStyles',
    'endAdornment',
    'error',
    'fullWidth',
    'id',
    'inputComponent',
    'inputProps',
    'inputRef',
    'margin',
    'maxRows',
    'minRows',
    'multiline',
    'name',
    'onBlur',
    'onChange',
    'onClick',
    'onFocus',
    'onKeyDown',
    'onKeyUp',
    'placeholder',
    'readOnly',
    'renderSuffix',
    'rows',
    'size',
    'slotProps',
    'slots',
    'startAdornment',
    'type',
    'value',
  ],
  yl = (e, t) => {
    const { ownerState: n } = e
    return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === 'small' && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${me(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel]
  },
  bl = (e, t) => {
    const { ownerState: n } = e
    return [t.input, n.size === 'small' && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === 'search' && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel]
  },
  YE = e => {
    const { classes: t, color: n, disabled: o, error: r, endAdornment: i, focused: s, formControl: a, fullWidth: l, hiddenLabel: c, multiline: u, readOnly: d, size: f, startAdornment: A, type: h } = e,
      g = {
        root: ['root', `color${me(n)}`, o && 'disabled', r && 'error', l && 'fullWidth', s && 'focused', a && 'formControl', f && f !== 'medium' && `size${me(f)}`, u && 'multiline', A && 'adornedStart', i && 'adornedEnd', c && 'hiddenLabel', d && 'readOnly'],
        input: ['input', o && 'disabled', h === 'search' && 'inputTypeSearch', u && 'inputMultiline', f === 'small' && 'inputSizeSmall', c && 'inputHiddenLabel', A && 'inputAdornedStart', i && 'inputAdornedEnd', d && 'readOnly'],
      }
    return Ye(g, VE, t)
  },
  vl = O('div', {
    name: 'MuiInputBase',
    slot: 'Root',
    overridesResolver: yl,
  })(({ theme: e, ownerState: t }) =>
    k(
      {},
      e.typography.body1,
      {
        color: (e.vars || e).palette.text.primary,
        lineHeight: '1.4375em',
        // 23px
        boxSizing: 'border-box',
        // Prevent padding issue with fullWidth.
        position: 'relative',
        cursor: 'text',
        display: 'inline-flex',
        alignItems: 'center',
        [`&.${Br.disabled}`]: {
          color: (e.vars || e).palette.text.disabled,
          cursor: 'default',
        },
      },
      t.multiline &&
        k(
          {
            padding: '4px 0 5px',
          },
          t.size === 'small' && {
            paddingTop: 1,
          }
        ),
      t.fullWidth && {
        width: '100%',
      }
    )
  ),
  xl = O('input', {
    name: 'MuiInputBase',
    slot: 'Input',
    overridesResolver: bl,
  })(({ theme: e, ownerState: t }) => {
    const n = e.palette.mode === 'light',
      o = k(
        {
          color: 'currentColor',
        },
        e.vars
          ? {
              opacity: e.vars.opacity.inputPlaceholder,
            }
          : {
              opacity: n ? 0.42 : 0.5,
            },
        {
          transition: e.transitions.create('opacity', {
            duration: e.transitions.duration.shorter,
          }),
        }
      ),
      r = {
        opacity: '0 !important',
      },
      i = e.vars
        ? {
            opacity: e.vars.opacity.inputPlaceholder,
          }
        : {
            opacity: n ? 0.42 : 0.5,
          }
    return k(
      {
        font: 'inherit',
        letterSpacing: 'inherit',
        color: 'currentColor',
        padding: '4px 0 5px',
        border: 0,
        boxSizing: 'content-box',
        background: 'none',
        height: '1.4375em',
        // Reset 23pxthe native input line-height
        margin: 0,
        // Reset for Safari
        WebkitTapHighlightColor: 'transparent',
        display: 'block',
        // Make the flex item shrink with Firefox
        minWidth: 0,
        width: '100%',
        // Fix IE11 width issue
        animationName: 'mui-auto-fill-cancel',
        animationDuration: '10ms',
        '&::-webkit-input-placeholder': o,
        '&::-moz-placeholder': o,
        // Firefox 19+
        '&:-ms-input-placeholder': o,
        // IE11
        '&::-ms-input-placeholder': o,
        // Edge
        '&:focus': {
          outline: 0,
        },
        // Reset Firefox invalid required input style
        '&:invalid': {
          boxShadow: 'none',
        },
        '&::-webkit-search-decoration': {
          // Remove the padding when type=search.
          WebkitAppearance: 'none',
        },
        // Show and hide the placeholder logic
        [`label[data-shrink=false] + .${Br.formControl} &`]: {
          '&::-webkit-input-placeholder': r,
          '&::-moz-placeholder': r,
          // Firefox 19+
          '&:-ms-input-placeholder': r,
          // IE11
          '&::-ms-input-placeholder': r,
          // Edge
          '&:focus::-webkit-input-placeholder': i,
          '&:focus::-moz-placeholder': i,
          // Firefox 19+
          '&:focus:-ms-input-placeholder': i,
          // IE11
          '&:focus::-ms-input-placeholder': i,
          // Edge
        },
        [`&.${Br.disabled}`]: {
          opacity: 1,
          // Reset iOS opacity
          WebkitTextFillColor: (e.vars || e).palette.text.disabled,
          // Fix opacity Safari bug
        },
        '&:-webkit-autofill': {
          animationDuration: '5000s',
          animationName: 'mui-auto-fill',
        },
      },
      t.size === 'small' && {
        paddingTop: 1,
      },
      t.multiline && {
        height: 'auto',
        resize: 'none',
        padding: 0,
        paddingTop: 0,
      },
      t.type === 'search' && {
        // Improve type search style.
        MozAppearance: 'textfield',
      }
    )
  }),
  HE = /* @__PURE__ */ p.jsx(Gg, {
    styles: {
      '@keyframes mui-auto-fill': {
        from: {
          display: 'block',
        },
      },
      '@keyframes mui-auto-fill-cancel': {
        from: {
          display: 'block',
        },
      },
    },
  }),
  gd = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o
    const r = Oe({
        props: t,
        name: 'MuiInputBase',
      }),
      {
        'aria-describedby': i,
        autoComplete: s,
        autoFocus: a,
        className: l,
        components: c = {},
        componentsProps: u = {},
        defaultValue: d,
        disabled: f,
        disableInjectingGlobalStyles: A,
        endAdornment: h,
        fullWidth: g = !1,
        id: x,
        inputComponent: m = 'input',
        inputProps: v = {},
        inputRef: y,
        maxRows: b,
        minRows: C,
        multiline: I = !1,
        name: w,
        onBlur: M,
        onChange: L,
        onClick: R,
        onFocus: T,
        onKeyDown: D,
        onKeyUp: z,
        placeholder: E,
        readOnly: P,
        renderSuffix: B,
        rows: F,
        slotProps: S = {},
        slots: Q = {},
        startAdornment: j,
        type: U = 'text',
        value: q,
      } = r,
      ne = pe(r, XE),
      G = v.value != null ? v.value : q,
      { current: K } = N.useRef(G != null),
      $ = N.useRef(),
      oe = N.useCallback(V => {}, []),
      Z = xt($, y, v.ref, oe),
      [ie, fe] = N.useState(!1),
      se = er(),
      re = Ur({
        props: r,
        muiFormControl: se,
        states: ['color', 'disabled', 'error', 'hiddenLabel', 'size', 'required', 'filled'],
      })
    ;(re.focused = se ? se.focused : ie),
      N.useEffect(() => {
        !se && f && ie && (fe(!1), M && M())
      }, [se, f, ie, M])
    const Y = se && se.onFilled,
      H = se && se.onEmpty,
      ee = N.useCallback(
        V => {
          la(V) ? Y && Y() : H && H()
        },
        [Y, H]
      )
    Mn(() => {
      K &&
        ee({
          value: G,
        })
    }, [G, ee, K])
    const xe = V => {
        if (re.disabled) {
          V.stopPropagation()
          return
        }
        T && T(V), v.onFocus && v.onFocus(V), se && se.onFocus ? se.onFocus(V) : fe(!0)
      },
      Fe = V => {
        M && M(V), v.onBlur && v.onBlur(V), se && se.onBlur ? se.onBlur(V) : fe(!1)
      },
      De = (V, ...W) => {
        if (!K) {
          const le = V.target || $.current
          if (le == null) throw new Error(Cr(1))
          ee({
            value: le.value,
          })
        }
        v.onChange && v.onChange(V, ...W), L && L(V, ...W)
      }
    N.useEffect(() => {
      ee($.current)
    }, [])
    const _e = V => {
      $.current && V.currentTarget === V.target && $.current.focus(), R && R(V)
    }
    let Be = m,
      ke = v
    I &&
      Be === 'input' &&
      (F
        ? (ke = k(
            {
              type: void 0,
              minRows: F,
              maxRows: F,
            },
            ke
          ))
        : (ke = k(
            {
              type: void 0,
              maxRows: b,
              minRows: C,
            },
            ke
          )),
      (Be = WE))
    const rt = V => {
      ee(
        V.animationName === 'mui-auto-fill-cancel'
          ? $.current
          : {
              value: 'x',
            }
      )
    }
    N.useEffect(() => {
      se && se.setAdornedStart(!!j)
    }, [se, j])
    const He = k({}, r, {
        color: re.color || 'primary',
        disabled: re.disabled,
        endAdornment: h,
        error: re.error,
        focused: re.focused,
        formControl: se,
        fullWidth: g,
        hiddenLabel: re.hiddenLabel,
        multiline: I,
        size: re.size,
        startAdornment: j,
        type: U,
      }),
      Le = YE(He),
      tt = Q.root || c.Root || vl,
      $e = S.root || u.root || {},
      Ke = Q.input || c.Input || xl
    return (
      (ke = k({}, ke, (o = S.input) != null ? o : u.input)),
      /* @__PURE__ */ p.jsxs(N.Fragment, {
        children: [
          !A && HE,
          /* @__PURE__ */ p.jsxs(
            tt,
            k(
              {},
              $e,
              !lo(tt) && {
                ownerState: k({}, He, $e.ownerState),
              },
              {
                ref: n,
                onClick: _e,
              },
              ne,
              {
                className: de(Le.root, $e.className, l, P && 'MuiInputBase-readOnly'),
                children: [
                  j,
                  /* @__PURE__ */ p.jsx(ml.Provider, {
                    value: null,
                    children: /* @__PURE__ */ p.jsx(
                      Ke,
                      k(
                        {
                          ownerState: He,
                          'aria-invalid': re.error,
                          'aria-describedby': i,
                          autoComplete: s,
                          autoFocus: a,
                          defaultValue: d,
                          disabled: re.disabled,
                          id: x,
                          onAnimationStart: rt,
                          name: w,
                          placeholder: E,
                          readOnly: P,
                          required: re.required,
                          rows: F,
                          value: G,
                          onKeyDown: D,
                          onKeyUp: z,
                          type: U,
                        },
                        ke,
                        !lo(Ke) && {
                          as: Be,
                          ownerState: k({}, He, ke.ownerState),
                        },
                        {
                          ref: Z,
                          className: de(Le.input, ke.className, P && 'MuiInputBase-readOnly'),
                          onBlur: Fe,
                          onChange: De,
                          onFocus: xe,
                        }
                      )
                    ),
                  }),
                  h,
                  B
                    ? B(
                        k({}, re, {
                          startAdornment: j,
                        })
                      )
                    : null,
                ],
              }
            )
          ),
        ],
      })
    )
  })
function UE(e) {
  return We('MuiInput', e)
}
const ni = k({}, Br, Qe('MuiInput', ['root', 'underline', 'input']))
function KE(e) {
  return We('MuiOutlinedInput', e)
}
const to = k({}, Br, Qe('MuiOutlinedInput', ['root', 'notchedOutline', 'input']))
function qE(e) {
  return We('MuiFilledInput', e)
}
const wo = k({}, Br, Qe('MuiFilledInput', ['root', 'underline', 'input'])),
  ZE = dd(
    /* @__PURE__ */ p.jsx('path', {
      d: 'M7 10l5 5 5-5z',
    }),
    'ArrowDropDown'
  ),
  JE = ['addEndListener', 'appear', 'children', 'easing', 'in', 'onEnter', 'onEntered', 'onEntering', 'onExit', 'onExited', 'onExiting', 'style', 'timeout', 'TransitionComponent'],
  _E = {
    entering: {
      opacity: 1,
    },
    entered: {
      opacity: 1,
    },
  },
  Vg = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = _i(),
      r = {
        enter: o.transitions.duration.enteringScreen,
        exit: o.transitions.duration.leavingScreen,
      },
      {
        addEndListener: i,
        appear: s = !0,
        children: a,
        easing: l,
        in: c,
        onEnter: u,
        onEntered: d,
        onEntering: f,
        onExit: A,
        onExited: h,
        onExiting: g,
        style: x,
        timeout: m = r,
        // eslint-disable-next-line react/prop-types
        TransitionComponent: v = bn,
      } = t,
      y = pe(t, JE),
      b = N.useRef(null),
      C = xt(b, Hr(a), n),
      I = E => P => {
        if (E) {
          const B = b.current
          P === void 0 ? E(B) : E(B, P)
        }
      },
      w = I(f),
      M = I((E, P) => {
        pd(E)
        const B = Sr(
          {
            style: x,
            timeout: m,
            easing: l,
          },
          {
            mode: 'enter',
          }
        )
        ;(E.style.webkitTransition = o.transitions.create('opacity', B)), (E.style.transition = o.transitions.create('opacity', B)), u && u(E, P)
      }),
      L = I(d),
      R = I(g),
      T = I(E => {
        const P = Sr(
          {
            style: x,
            timeout: m,
            easing: l,
          },
          {
            mode: 'exit',
          }
        )
        ;(E.style.webkitTransition = o.transitions.create('opacity', P)), (E.style.transition = o.transitions.create('opacity', P)), A && A(E)
      }),
      D = I(h),
      z = E => {
        i && i(b.current, E)
      }
    return /* @__PURE__ */ p.jsx(
      v,
      k(
        {
          appear: s,
          in: c,
          nodeRef: b,
          onEnter: M,
          onEntered: L,
          onEntering: w,
          onExit: T,
          onExited: D,
          onExiting: R,
          addEndListener: z,
          timeout: m,
        },
        y,
        {
          children: (E, P) =>
            /* @__PURE__ */ N.cloneElement(
              a,
              k(
                {
                  style: k(
                    {
                      opacity: 0,
                      visibility: E === 'exited' && !c ? 'hidden' : void 0,
                    },
                    _E[E],
                    x,
                    a.props.style
                  ),
                  ref: C,
                },
                P
              )
            ),
        }
      )
    )
  })
function $E(e) {
  return We('MuiBackdrop', e)
}
Qe('MuiBackdrop', ['root', 'invisible'])
const eS = ['children', 'className', 'component', 'components', 'componentsProps', 'invisible', 'open', 'slotProps', 'slots', 'TransitionComponent', 'transitionDuration'],
  tS = e => {
    const { classes: t, invisible: n } = e
    return Ye(
      {
        root: ['root', n && 'invisible'],
      },
      $E,
      t
    )
  },
  nS = O('div', {
    name: 'MuiBackdrop',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, n.invisible && t.invisible]
    },
  })(({ ownerState: e }) =>
    k(
      {
        position: 'fixed',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        WebkitTapHighlightColor: 'transparent',
      },
      e.invisible && {
        backgroundColor: 'transparent',
      }
    )
  ),
  Xg = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o, r, i
    const s = Oe({
        props: t,
        name: 'MuiBackdrop',
      }),
      { children: a, className: l, component: c = 'div', components: u = {}, componentsProps: d = {}, invisible: f = !1, open: A, slotProps: h = {}, slots: g = {}, TransitionComponent: x = Vg, transitionDuration: m } = s,
      v = pe(s, eS),
      y = k({}, s, {
        component: c,
        invisible: f,
      }),
      b = tS(y),
      C = (o = h.root) != null ? o : d.root
    return /* @__PURE__ */ p.jsx(
      x,
      k(
        {
          in: A,
          timeout: m,
        },
        v,
        {
          children: /* @__PURE__ */ p.jsx(
            nS,
            k(
              {
                'aria-hidden': !0,
              },
              C,
              {
                as: (r = (i = g.root) != null ? i : u.Root) != null ? r : c,
                className: de(b.root, l, C == null ? void 0 : C.className),
                ownerState: k({}, y, C == null ? void 0 : C.ownerState),
                classes: b,
                ref: n,
                children: a,
              }
            )
          ),
        }
      )
    )
  }),
  oS = Qe('MuiBox', ['root']),
  rS = ld(),
  ic = FC({
    themeId: wr,
    defaultTheme: rS,
    defaultClassName: oS.root,
    generateClassName: rd.generate,
  })
function iS(e) {
  return We('MuiButton', e)
}
const hs = Qe('MuiButton', [
    'root',
    'text',
    'textInherit',
    'textPrimary',
    'textSecondary',
    'textSuccess',
    'textError',
    'textInfo',
    'textWarning',
    'outlined',
    'outlinedInherit',
    'outlinedPrimary',
    'outlinedSecondary',
    'outlinedSuccess',
    'outlinedError',
    'outlinedInfo',
    'outlinedWarning',
    'contained',
    'containedInherit',
    'containedPrimary',
    'containedSecondary',
    'containedSuccess',
    'containedError',
    'containedInfo',
    'containedWarning',
    'disableElevation',
    'focusVisible',
    'disabled',
    'colorInherit',
    'colorPrimary',
    'colorSecondary',
    'colorSuccess',
    'colorError',
    'colorInfo',
    'colorWarning',
    'textSizeSmall',
    'textSizeMedium',
    'textSizeLarge',
    'outlinedSizeSmall',
    'outlinedSizeMedium',
    'outlinedSizeLarge',
    'containedSizeSmall',
    'containedSizeMedium',
    'containedSizeLarge',
    'sizeMedium',
    'sizeSmall',
    'sizeLarge',
    'fullWidth',
    'startIcon',
    'endIcon',
    'icon',
    'iconSizeSmall',
    'iconSizeMedium',
    'iconSizeLarge',
  ]),
  sS = /* @__PURE__ */ N.createContext({}),
  aS = /* @__PURE__ */ N.createContext(void 0),
  lS = ['children', 'color', 'component', 'className', 'disabled', 'disableElevation', 'disableFocusRipple', 'endIcon', 'focusVisibleClassName', 'fullWidth', 'size', 'startIcon', 'type', 'variant'],
  cS = e => {
    const { color: t, disableElevation: n, fullWidth: o, size: r, variant: i, classes: s } = e,
      a = {
        root: ['root', i, `${i}${me(t)}`, `size${me(r)}`, `${i}Size${me(r)}`, `color${me(t)}`, n && 'disableElevation', o && 'fullWidth'],
        label: ['label'],
        startIcon: ['icon', 'startIcon', `iconSize${me(r)}`],
        endIcon: ['icon', 'endIcon', `iconSize${me(r)}`],
      },
      l = Ye(a, iS, s)
    return k({}, s, l)
  },
  Yg = e =>
    k(
      {},
      e.size === 'small' && {
        '& > *:nth-of-type(1)': {
          fontSize: 18,
        },
      },
      e.size === 'medium' && {
        '& > *:nth-of-type(1)': {
          fontSize: 20,
        },
      },
      e.size === 'large' && {
        '& > *:nth-of-type(1)': {
          fontSize: 22,
        },
      }
    ),
  uS = O(hd, {
    shouldForwardProp: e => Kt(e) || e === 'classes',
    name: 'MuiButton',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, t[n.variant], t[`${n.variant}${me(n.color)}`], t[`size${me(n.size)}`], t[`${n.variant}Size${me(n.size)}`], n.color === 'inherit' && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth]
    },
  })(
    ({ theme: e, ownerState: t }) => {
      var n, o
      const r = e.palette.mode === 'light' ? e.palette.grey[300] : e.palette.grey[800],
        i = e.palette.mode === 'light' ? e.palette.grey.A100 : e.palette.grey[700]
      return k(
        {},
        e.typography.button,
        {
          minWidth: 64,
          padding: '6px 16px',
          borderRadius: (e.vars || e).shape.borderRadius,
          transition: e.transitions.create(['background-color', 'box-shadow', 'border-color', 'color'], {
            duration: e.transitions.duration.short,
          }),
          '&:hover': k(
            {
              textDecoration: 'none',
              backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : Lt(e.palette.text.primary, e.palette.action.hoverOpacity),
              // Reset on touch devices, it doesn't add specificity
              '@media (hover: none)': {
                backgroundColor: 'transparent',
              },
            },
            t.variant === 'text' &&
              t.color !== 'inherit' && {
                backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Lt(e.palette[t.color].main, e.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                  backgroundColor: 'transparent',
                },
              },
            t.variant === 'outlined' &&
              t.color !== 'inherit' && {
                border: `1px solid ${(e.vars || e).palette[t.color].main}`,
                backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Lt(e.palette[t.color].main, e.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                  backgroundColor: 'transparent',
                },
              },
            t.variant === 'contained' && {
              backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedHoverBg : i,
              boxShadow: (e.vars || e).shadows[4],
              // Reset on touch devices, it doesn't add specificity
              '@media (hover: none)': {
                boxShadow: (e.vars || e).shadows[2],
                backgroundColor: (e.vars || e).palette.grey[300],
              },
            },
            t.variant === 'contained' &&
              t.color !== 'inherit' && {
                backgroundColor: (e.vars || e).palette[t.color].dark,
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                  backgroundColor: (e.vars || e).palette[t.color].main,
                },
              }
          ),
          '&:active': k(
            {},
            t.variant === 'contained' && {
              boxShadow: (e.vars || e).shadows[8],
            }
          ),
          [`&.${hs.focusVisible}`]: k(
            {},
            t.variant === 'contained' && {
              boxShadow: (e.vars || e).shadows[6],
            }
          ),
          [`&.${hs.disabled}`]: k(
            {
              color: (e.vars || e).palette.action.disabled,
            },
            t.variant === 'outlined' && {
              border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`,
            },
            t.variant === 'contained' && {
              color: (e.vars || e).palette.action.disabled,
              boxShadow: (e.vars || e).shadows[0],
              backgroundColor: (e.vars || e).palette.action.disabledBackground,
            }
          ),
        },
        t.variant === 'text' && {
          padding: '6px 8px',
        },
        t.variant === 'text' &&
          t.color !== 'inherit' && {
            color: (e.vars || e).palette[t.color].main,
          },
        t.variant === 'outlined' && {
          padding: '5px 15px',
          border: '1px solid currentColor',
        },
        t.variant === 'outlined' &&
          t.color !== 'inherit' && {
            color: (e.vars || e).palette[t.color].main,
            border: e.vars ? `1px solid rgba(${e.vars.palette[t.color].mainChannel} / 0.5)` : `1px solid ${Lt(e.palette[t.color].main, 0.5)}`,
          },
        t.variant === 'contained' && {
          color: e.vars
            ? // this is safe because grey does not change between default light/dark mode
              e.vars.palette.text.primary
            : (n = (o = e.palette).getContrastText) == null
            ? void 0
            : n.call(o, e.palette.grey[300]),
          backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedBg : r,
          boxShadow: (e.vars || e).shadows[2],
        },
        t.variant === 'contained' &&
          t.color !== 'inherit' && {
            color: (e.vars || e).palette[t.color].contrastText,
            backgroundColor: (e.vars || e).palette[t.color].main,
          },
        t.color === 'inherit' && {
          color: 'inherit',
          borderColor: 'currentColor',
        },
        t.size === 'small' &&
          t.variant === 'text' && {
            padding: '4px 5px',
            fontSize: e.typography.pxToRem(13),
          },
        t.size === 'large' &&
          t.variant === 'text' && {
            padding: '8px 11px',
            fontSize: e.typography.pxToRem(15),
          },
        t.size === 'small' &&
          t.variant === 'outlined' && {
            padding: '3px 9px',
            fontSize: e.typography.pxToRem(13),
          },
        t.size === 'large' &&
          t.variant === 'outlined' && {
            padding: '7px 21px',
            fontSize: e.typography.pxToRem(15),
          },
        t.size === 'small' &&
          t.variant === 'contained' && {
            padding: '4px 10px',
            fontSize: e.typography.pxToRem(13),
          },
        t.size === 'large' &&
          t.variant === 'contained' && {
            padding: '8px 22px',
            fontSize: e.typography.pxToRem(15),
          },
        t.fullWidth && {
          width: '100%',
        }
      )
    },
    ({ ownerState: e }) =>
      e.disableElevation && {
        boxShadow: 'none',
        '&:hover': {
          boxShadow: 'none',
        },
        [`&.${hs.focusVisible}`]: {
          boxShadow: 'none',
        },
        '&:active': {
          boxShadow: 'none',
        },
        [`&.${hs.disabled}`]: {
          boxShadow: 'none',
        },
      }
  ),
  dS = O('span', {
    name: 'MuiButton',
    slot: 'StartIcon',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.startIcon, t[`iconSize${me(n.size)}`]]
    },
  })(({ ownerState: e }) =>
    k(
      {
        display: 'inherit',
        marginRight: 8,
        marginLeft: -4,
      },
      e.size === 'small' && {
        marginLeft: -2,
      },
      Yg(e)
    )
  ),
  fS = O('span', {
    name: 'MuiButton',
    slot: 'EndIcon',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.endIcon, t[`iconSize${me(n.size)}`]]
    },
  })(({ ownerState: e }) =>
    k(
      {
        display: 'inherit',
        marginRight: -4,
        marginLeft: 8,
      },
      e.size === 'small' && {
        marginRight: -2,
      },
      Yg(e)
    )
  ),
  Hg = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = N.useContext(sS),
      r = N.useContext(aS),
      i = Og(o, t),
      s = Oe({
        props: i,
        name: 'MuiButton',
      }),
      { children: a, color: l = 'primary', component: c = 'button', className: u, disabled: d = !1, disableElevation: f = !1, disableFocusRipple: A = !1, endIcon: h, focusVisibleClassName: g, fullWidth: x = !1, size: m = 'medium', startIcon: v, type: y, variant: b = 'text' } = s,
      C = pe(s, lS),
      I = k({}, s, {
        color: l,
        component: c,
        disabled: d,
        disableElevation: f,
        disableFocusRipple: A,
        fullWidth: x,
        size: m,
        type: y,
        variant: b,
      }),
      w = cS(I),
      M =
        v &&
        /* @__PURE__ */ p.jsx(dS, {
          className: w.startIcon,
          ownerState: I,
          children: v,
        }),
      L =
        h &&
        /* @__PURE__ */ p.jsx(fS, {
          className: w.endIcon,
          ownerState: I,
          children: h,
        }),
      R = r || ''
    return /* @__PURE__ */ p.jsxs(
      uS,
      k(
        {
          ownerState: I,
          className: de(o.className, w.root, u, R),
          component: c,
          disabled: d,
          focusRipple: !A,
          focusVisibleClassName: de(w.focusVisible, g),
          ref: n,
          type: y,
        },
        C,
        {
          classes: w,
          children: [M, a, L],
        }
      )
    )
  }),
  AS = (e, t) =>
    k(
      {
        WebkitFontSmoothing: 'antialiased',
        // Antialiasing.
        MozOsxFontSmoothing: 'grayscale',
        // Antialiasing.
        // Change from `box-sizing: content-box` so that `width`
        // is not affected by `padding` or `border`.
        boxSizing: 'border-box',
        // Fix font resize problem in iOS
        WebkitTextSizeAdjust: '100%',
      },
      t &&
        !e.vars && {
          colorScheme: e.palette.mode,
        }
    ),
  pS = e =>
    k(
      {
        color: (e.vars || e).palette.text.primary,
      },
      e.typography.body1,
      {
        backgroundColor: (e.vars || e).palette.background.default,
        '@media print': {
          // Save printer ink.
          backgroundColor: (e.vars || e).palette.common.white,
        },
      }
    ),
  hS = (e, t = !1) => {
    var n
    const o = {}
    t &&
      e.colorSchemes &&
      Object.entries(e.colorSchemes).forEach(([s, a]) => {
        var l
        o[e.getColorSchemeSelector(s).replace(/\s*&/, '')] = {
          colorScheme: (l = a.palette) == null ? void 0 : l.mode,
        }
      })
    let r = k(
      {
        html: AS(e, t),
        '*, *::before, *::after': {
          boxSizing: 'inherit',
        },
        'strong, b': {
          fontWeight: e.typography.fontWeightBold,
        },
        body: k(
          {
            margin: 0,
          },
          pS(e),
          {
            // Add support for document.body.requestFullScreen().
            // Other elements, if background transparent, are not supported.
            '&::backdrop': {
              backgroundColor: (e.vars || e).palette.background.default,
            },
          }
        ),
      },
      o
    )
    const i = (n = e.components) == null || (n = n.MuiCssBaseline) == null ? void 0 : n.styleOverrides
    return i && (r = [r, i]), r
  }
function gS(e) {
  const t = Oe({
      props: e,
      name: 'MuiCssBaseline',
    }),
    { children: n, enableColorScheme: o = !1 } = t
  return /* @__PURE__ */ p.jsxs(N.Fragment, {
    children: [
      /* @__PURE__ */ p.jsx(Gg, {
        styles: r => hS(r, o),
      }),
      n,
    ],
  })
}
function mS(e) {
  const t = wt(e)
  return t.body === e ? kn(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight
}
function wi(e, t) {
  t ? e.setAttribute('aria-hidden', 'true') : e.removeAttribute('aria-hidden')
}
function Jf(e) {
  return parseInt(kn(e).getComputedStyle(e).paddingRight, 10) || 0
}
function yS(e) {
  const n = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'].indexOf(e.tagName) !== -1,
    o = e.tagName === 'INPUT' && e.getAttribute('type') === 'hidden'
  return n || o
}
function _f(e, t, n, o, r) {
  const i = [t, n, ...o]
  ;[].forEach.call(e.children, s => {
    const a = i.indexOf(s) === -1,
      l = !yS(s)
    a && l && wi(s, r)
  })
}
function sc(e, t) {
  let n = -1
  return e.some((o, r) => (t(o) ? ((n = r), !0) : !1)), n
}
function bS(e, t) {
  const n = [],
    o = e.container
  if (!t.disableScrollLock) {
    if (mS(o)) {
      const s = Qg(wt(o))
      n.push({
        value: o.style.paddingRight,
        property: 'padding-right',
        el: o,
      }),
        (o.style.paddingRight = `${Jf(o) + s}px`)
      const a = wt(o).querySelectorAll('.mui-fixed')
      ;[].forEach.call(a, l => {
        n.push({
          value: l.style.paddingRight,
          property: 'padding-right',
          el: l,
        }),
          (l.style.paddingRight = `${Jf(l) + s}px`)
      })
    }
    let i
    if (o.parentNode instanceof DocumentFragment) i = wt(o).body
    else {
      const s = o.parentElement,
        a = kn(o)
      i = (s == null ? void 0 : s.nodeName) === 'HTML' && a.getComputedStyle(s).overflowY === 'scroll' ? s : o
    }
    n.push(
      {
        value: i.style.overflow,
        property: 'overflow',
        el: i,
      },
      {
        value: i.style.overflowX,
        property: 'overflow-x',
        el: i,
      },
      {
        value: i.style.overflowY,
        property: 'overflow-y',
        el: i,
      }
    ),
      (i.style.overflow = 'hidden')
  }
  return () => {
    n.forEach(({ value: i, el: s, property: a }) => {
      i ? s.style.setProperty(a, i) : s.style.removeProperty(a)
    })
  }
}
function vS(e) {
  const t = []
  return (
    [].forEach.call(e.children, n => {
      n.getAttribute('aria-hidden') === 'true' && t.push(n)
    }),
    t
  )
}
class xS {
  constructor() {
    ;(this.containers = void 0), (this.modals = void 0), (this.modals = []), (this.containers = [])
  }
  add(t, n) {
    let o = this.modals.indexOf(t)
    if (o !== -1) return o
    ;(o = this.modals.length), this.modals.push(t), t.modalRef && wi(t.modalRef, !1)
    const r = vS(n)
    _f(n, t.mount, t.modalRef, r, !0)
    const i = sc(this.containers, s => s.container === n)
    return i !== -1
      ? (this.containers[i].modals.push(t), o)
      : (this.containers.push({
          modals: [t],
          container: n,
          restore: null,
          hiddenSiblings: r,
        }),
        o)
  }
  mount(t, n) {
    const o = sc(this.containers, i => i.modals.indexOf(t) !== -1),
      r = this.containers[o]
    r.restore || (r.restore = bS(r, n))
  }
  remove(t, n = !0) {
    const o = this.modals.indexOf(t)
    if (o === -1) return o
    const r = sc(this.containers, s => s.modals.indexOf(t) !== -1),
      i = this.containers[r]
    if ((i.modals.splice(i.modals.indexOf(t), 1), this.modals.splice(o, 1), i.modals.length === 0)) i.restore && i.restore(), t.modalRef && wi(t.modalRef, n), _f(i.container, t.mount, t.modalRef, i.hiddenSiblings, !1), this.containers.splice(r, 1)
    else {
      const s = i.modals[i.modals.length - 1]
      s.modalRef && wi(s.modalRef, !1)
    }
    return o
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t
  }
}
const CS = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'].join(',')
function wS(e) {
  const t = parseInt(e.getAttribute('tabindex') || '', 10)
  return Number.isNaN(t) ? (e.contentEditable === 'true' || ((e.nodeName === 'AUDIO' || e.nodeName === 'VIDEO' || e.nodeName === 'DETAILS') && e.getAttribute('tabindex') === null) ? 0 : e.tabIndex) : t
}
function ES(e) {
  if (e.tagName !== 'INPUT' || e.type !== 'radio' || !e.name) return !1
  const t = o => e.ownerDocument.querySelector(`input[type="radio"]${o}`)
  let n = t(`[name="${e.name}"]:checked`)
  return n || (n = t(`[name="${e.name}"]`)), n !== e
}
function SS(e) {
  return !(e.disabled || (e.tagName === 'INPUT' && e.type === 'hidden') || ES(e))
}
function BS(e) {
  const t = [],
    n = []
  return (
    Array.from(e.querySelectorAll(CS)).forEach((o, r) => {
      const i = wS(o)
      i === -1 ||
        !SS(o) ||
        (i === 0
          ? t.push(o)
          : n.push({
              documentOrder: r,
              tabIndex: i,
              node: o,
            }))
    }),
    n
      .sort((o, r) => (o.tabIndex === r.tabIndex ? o.documentOrder - r.documentOrder : o.tabIndex - r.tabIndex))
      .map(o => o.node)
      .concat(t)
  )
}
function IS() {
  return !0
}
function NS(e) {
  const { children: t, disableAutoFocus: n = !1, disableEnforceFocus: o = !1, disableRestoreFocus: r = !1, getTabbable: i = BS, isEnabled: s = IS, open: a } = e,
    l = N.useRef(!1),
    c = N.useRef(null),
    u = N.useRef(null),
    d = N.useRef(null),
    f = N.useRef(null),
    A = N.useRef(!1),
    h = N.useRef(null),
    g = xt(Hr(t), h),
    x = N.useRef(null)
  N.useEffect(() => {
    !a || !h.current || (A.current = !n)
  }, [n, a]),
    N.useEffect(() => {
      if (!a || !h.current) return
      const y = wt(h.current)
      return (
        h.current.contains(y.activeElement) || (h.current.hasAttribute('tabIndex') || h.current.setAttribute('tabIndex', '-1'), A.current && h.current.focus()),
        () => {
          r || (d.current && d.current.focus && ((l.current = !0), d.current.focus()), (d.current = null))
        }
      )
    }, [a]),
    N.useEffect(() => {
      if (!a || !h.current) return
      const y = wt(h.current),
        b = w => {
          ;(x.current = w), !(o || !s() || w.key !== 'Tab') && y.activeElement === h.current && w.shiftKey && ((l.current = !0), u.current && u.current.focus())
        },
        C = () => {
          const w = h.current
          if (w === null) return
          if (!y.hasFocus() || !s() || l.current) {
            l.current = !1
            return
          }
          if (w.contains(y.activeElement) || (o && y.activeElement !== c.current && y.activeElement !== u.current)) return
          if (y.activeElement !== f.current) f.current = null
          else if (f.current !== null) return
          if (!A.current) return
          let M = []
          if (((y.activeElement === c.current || y.activeElement === u.current) && (M = i(h.current)), M.length > 0)) {
            var L, R
            const T = !!((L = x.current) != null && L.shiftKey && ((R = x.current) == null ? void 0 : R.key) === 'Tab'),
              D = M[0],
              z = M[M.length - 1]
            typeof D != 'string' && typeof z != 'string' && (T ? z.focus() : D.focus())
          } else w.focus()
        }
      y.addEventListener('focusin', C), y.addEventListener('keydown', b, !0)
      const I = setInterval(() => {
        y.activeElement && y.activeElement.tagName === 'BODY' && C()
      }, 50)
      return () => {
        clearInterval(I), y.removeEventListener('focusin', C), y.removeEventListener('keydown', b, !0)
      }
    }, [n, o, r, s, a, i])
  const m = y => {
      d.current === null && (d.current = y.relatedTarget), (A.current = !0), (f.current = y.target)
      const b = t.props.onFocus
      b && b(y)
    },
    v = y => {
      d.current === null && (d.current = y.relatedTarget), (A.current = !0)
    }
  return /* @__PURE__ */ p.jsxs(N.Fragment, {
    children: [
      /* @__PURE__ */ p.jsx('div', {
        tabIndex: a ? 0 : -1,
        onFocus: v,
        ref: c,
        'data-testid': 'sentinelStart',
      }),
      /* @__PURE__ */ N.cloneElement(t, {
        ref: g,
        onFocus: m,
      }),
      /* @__PURE__ */ p.jsx('div', {
        tabIndex: a ? 0 : -1,
        onFocus: v,
        ref: u,
        'data-testid': 'sentinelEnd',
      }),
    ],
  })
}
function kS(e) {
  return typeof e == 'function' ? e() : e
}
function MS(e) {
  return e ? e.props.hasOwnProperty('in') : !1
}
const PS = new xS()
function LS(e) {
  const {
      container: t,
      disableEscapeKeyDown: n = !1,
      disableScrollLock: o = !1,
      // @ts-ignore internal logic - Base UI supports the manager as a prop too
      manager: r = PS,
      closeAfterTransition: i = !1,
      onTransitionEnter: s,
      onTransitionExited: a,
      children: l,
      onClose: c,
      open: u,
      rootRef: d,
    } = e,
    f = N.useRef({}),
    A = N.useRef(null),
    h = N.useRef(null),
    g = xt(h, d),
    [x, m] = N.useState(!u),
    v = MS(l)
  let y = !0
  ;(e['aria-hidden'] === 'false' || e['aria-hidden'] === !1) && (y = !1)
  const b = () => wt(A.current),
    C = () => ((f.current.modalRef = h.current), (f.current.mount = A.current), f.current),
    I = () => {
      r.mount(C(), {
        disableScrollLock: o,
      }),
        h.current && (h.current.scrollTop = 0)
    },
    w = Sn(() => {
      const B = kS(t) || b().body
      r.add(C(), B), h.current && I()
    }),
    M = N.useCallback(() => r.isTopModal(C()), [r]),
    L = Sn(B => {
      ;(A.current = B), B && (u && M() ? I() : h.current && wi(h.current, y))
    }),
    R = N.useCallback(() => {
      r.remove(C(), y)
    }, [y, r])
  N.useEffect(
    () => () => {
      R()
    },
    [R]
  ),
    N.useEffect(() => {
      u ? w() : (!v || !i) && R()
    }, [u, R, v, i, w])
  const T = B => F => {
      var S
      ;(S = B.onKeyDown) == null || S.call(B, F),
        !(
          F.key !== 'Escape' ||
          F.which === 229 || // Wait until IME is settled.
          !M()
        ) &&
          (n || (F.stopPropagation(), c && c(F, 'escapeKeyDown')))
    },
    D = B => F => {
      var S
      ;(S = B.onClick) == null || S.call(B, F), F.target === F.currentTarget && c && c(F, 'backdropClick')
    }
  return {
    getRootProps: (B = {}) => {
      const F = Ci(e)
      delete F.onTransitionEnter, delete F.onTransitionExited
      const S = k({}, F, B)
      return k(
        {
          role: 'presentation',
        },
        S,
        {
          onKeyDown: T(S),
          ref: g,
        }
      )
    },
    getBackdropProps: (B = {}) => {
      const F = B
      return k(
        {
          'aria-hidden': !0,
        },
        F,
        {
          onClick: D(F),
          open: u,
        }
      )
    },
    getTransitionProps: () => {
      const B = () => {
          m(!1), s && s()
        },
        F = () => {
          m(!0), a && a(), i && R()
        }
      return {
        onEnter: qc(B, l == null ? void 0 : l.props.onEnter),
        onExited: qc(F, l == null ? void 0 : l.props.onExited),
      }
    },
    rootRef: g,
    portalRef: L,
    isTopModal: M,
    exited: x,
    hasTransition: v,
  }
}
function RS(e) {
  return We('MuiModal', e)
}
Qe('MuiModal', ['root', 'hidden', 'backdrop'])
const TS = [
    'BackdropComponent',
    'BackdropProps',
    'classes',
    'className',
    'closeAfterTransition',
    'children',
    'container',
    'component',
    'components',
    'componentsProps',
    'disableAutoFocus',
    'disableEnforceFocus',
    'disableEscapeKeyDown',
    'disablePortal',
    'disableRestoreFocus',
    'disableScrollLock',
    'hideBackdrop',
    'keepMounted',
    'onBackdropClick',
    'onClose',
    'onTransitionEnter',
    'onTransitionExited',
    'open',
    'slotProps',
    'slots',
    'theme',
  ],
  FS = e => {
    const { open: t, exited: n, classes: o } = e
    return Ye(
      {
        root: ['root', !t && n && 'hidden'],
        backdrop: ['backdrop'],
      },
      RS,
      o
    )
  },
  DS = O('div', {
    name: 'MuiModal',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, !n.open && n.exited && t.hidden]
    },
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        position: 'fixed',
        zIndex: (e.vars || e).zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
      },
      !t.open &&
        t.exited && {
          visibility: 'hidden',
        }
    )
  ),
  zS = O(Xg, {
    name: 'MuiModal',
    slot: 'Backdrop',
    overridesResolver: (e, t) => t.backdrop,
  })({
    zIndex: -1,
  }),
  md = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o, r, i, s, a, l
    const c = Oe({
        name: 'MuiModal',
        props: t,
      }),
      {
        BackdropComponent: u = zS,
        BackdropProps: d,
        className: f,
        closeAfterTransition: A = !1,
        children: h,
        container: g,
        component: x,
        components: m = {},
        componentsProps: v = {},
        disableAutoFocus: y = !1,
        disableEnforceFocus: b = !1,
        disableEscapeKeyDown: C = !1,
        disablePortal: I = !1,
        disableRestoreFocus: w = !1,
        disableScrollLock: M = !1,
        hideBackdrop: L = !1,
        keepMounted: R = !1,
        onBackdropClick: T,
        open: D,
        slotProps: z,
        slots: E,
        // eslint-disable-next-line react/prop-types
      } = c,
      P = pe(c, TS),
      B = k({}, c, {
        closeAfterTransition: A,
        disableAutoFocus: y,
        disableEnforceFocus: b,
        disableEscapeKeyDown: C,
        disablePortal: I,
        disableRestoreFocus: w,
        disableScrollLock: M,
        hideBackdrop: L,
        keepMounted: R,
      }),
      {
        getRootProps: F,
        getBackdropProps: S,
        getTransitionProps: Q,
        portalRef: j,
        isTopModal: U,
        exited: q,
        hasTransition: ne,
      } = LS(
        k({}, B, {
          rootRef: n,
        })
      ),
      G = k({}, B, {
        exited: q,
      }),
      K = FS(G),
      $ = {}
    if ((h.props.tabIndex === void 0 && ($.tabIndex = '-1'), ne)) {
      const { onEnter: Y, onExited: H } = Q()
      ;($.onEnter = Y), ($.onExited = H)
    }
    const oe = (o = (r = E == null ? void 0 : E.root) != null ? r : m.Root) != null ? o : DS,
      Z = (i = (s = E == null ? void 0 : E.backdrop) != null ? s : m.Backdrop) != null ? i : u,
      ie = (a = z == null ? void 0 : z.root) != null ? a : v.root,
      fe = (l = z == null ? void 0 : z.backdrop) != null ? l : v.backdrop,
      se = zt({
        elementType: oe,
        externalSlotProps: ie,
        externalForwardedProps: P,
        getSlotProps: F,
        additionalProps: {
          ref: n,
          as: x,
        },
        ownerState: G,
        className: de(f, ie == null ? void 0 : ie.className, K == null ? void 0 : K.root, !G.open && G.exited && (K == null ? void 0 : K.hidden)),
      }),
      re = zt({
        elementType: Z,
        externalSlotProps: fe,
        additionalProps: d,
        getSlotProps: Y =>
          S(
            k({}, Y, {
              onClick: H => {
                T && T(H), Y != null && Y.onClick && Y.onClick(H)
              },
            })
          ),
        className: de(fe == null ? void 0 : fe.className, d == null ? void 0 : d.className, K == null ? void 0 : K.backdrop),
        ownerState: G,
      })
    return !R && !D && (!ne || q)
      ? null
      : /* @__PURE__ */ p.jsx(zE, {
          ref: j,
          container: g,
          disablePortal: I,
          children: /* @__PURE__ */ p.jsxs(
            oe,
            k({}, se, {
              children: [
                !L && u ? /* @__PURE__ */ p.jsx(Z, k({}, re)) : null,
                /* @__PURE__ */ p.jsx(NS, {
                  disableEnforceFocus: b,
                  disableAutoFocus: y,
                  disableRestoreFocus: w,
                  isEnabled: U,
                  open: D,
                  children: /* @__PURE__ */ N.cloneElement(h, $),
                }),
              ],
            })
          ),
        })
  })
function QS(e) {
  return We('MuiDialog', e)
}
const ac = Qe('MuiDialog', ['root', 'scrollPaper', 'scrollBody', 'container', 'paper', 'paperScrollPaper', 'paperScrollBody', 'paperWidthFalse', 'paperWidthXs', 'paperWidthSm', 'paperWidthMd', 'paperWidthLg', 'paperWidthXl', 'paperFullWidth', 'paperFullScreen']),
  Ug = /* @__PURE__ */ N.createContext({}),
  OS = ['aria-describedby', 'aria-labelledby', 'BackdropComponent', 'BackdropProps', 'children', 'className', 'disableEscapeKeyDown', 'fullScreen', 'fullWidth', 'maxWidth', 'onBackdropClick', 'onClick', 'onClose', 'open', 'PaperComponent', 'PaperProps', 'scroll', 'TransitionComponent', 'transitionDuration', 'TransitionProps'],
  jS = O(Xg, {
    name: 'MuiDialog',
    slot: 'Backdrop',
    overrides: (e, t) => t.backdrop,
  })({
    // Improve scrollable dialog support.
    zIndex: -1,
  }),
  WS = e => {
    const { classes: t, scroll: n, maxWidth: o, fullWidth: r, fullScreen: i } = e,
      s = {
        root: ['root'],
        container: ['container', `scroll${me(n)}`],
        paper: ['paper', `paperScroll${me(n)}`, `paperWidth${me(String(o))}`, r && 'paperFullWidth', i && 'paperFullScreen'],
      }
    return Ye(s, QS, t)
  },
  GS = O(md, {
    name: 'MuiDialog',
    slot: 'Root',
    overridesResolver: (e, t) => t.root,
  })({
    '@media print': {
      // Use !important to override the Modal inline-style.
      position: 'absolute !important',
    },
  }),
  VS = O('div', {
    name: 'MuiDialog',
    slot: 'Container',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.container, t[`scroll${me(n.scroll)}`]]
    },
  })(({ ownerState: e }) =>
    k(
      {
        height: '100%',
        '@media print': {
          height: 'auto',
        },
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0,
      },
      e.scroll === 'paper' && {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
      },
      e.scroll === 'body' && {
        overflowY: 'auto',
        overflowX: 'hidden',
        textAlign: 'center',
        '&::after': {
          content: '""',
          display: 'inline-block',
          verticalAlign: 'middle',
          height: '100%',
          width: '0',
        },
      }
    )
  ),
  XS = O(es, {
    name: 'MuiDialog',
    slot: 'Paper',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.paper, t[`scrollPaper${me(n.scroll)}`], t[`paperWidth${me(String(n.maxWidth))}`], n.fullWidth && t.paperFullWidth, n.fullScreen && t.paperFullScreen]
    },
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        margin: 32,
        position: 'relative',
        overflowY: 'auto',
        // Fix IE11 issue, to remove at some point.
        '@media print': {
          overflowY: 'visible',
          boxShadow: 'none',
        },
      },
      t.scroll === 'paper' && {
        display: 'flex',
        flexDirection: 'column',
        maxHeight: 'calc(100% - 64px)',
      },
      t.scroll === 'body' && {
        display: 'inline-block',
        verticalAlign: 'middle',
        textAlign: 'left',
        // 'initial' doesn't work on IE11
      },
      !t.maxWidth && {
        maxWidth: 'calc(100% - 64px)',
      },
      t.maxWidth === 'xs' && {
        maxWidth: e.breakpoints.unit === 'px' ? Math.max(e.breakpoints.values.xs, 444) : `max(${e.breakpoints.values.xs}${e.breakpoints.unit}, 444px)`,
        [`&.${ac.paperScrollBody}`]: {
          [e.breakpoints.down(Math.max(e.breakpoints.values.xs, 444) + 32 * 2)]: {
            maxWidth: 'calc(100% - 64px)',
          },
        },
      },
      t.maxWidth &&
        t.maxWidth !== 'xs' && {
          maxWidth: `${e.breakpoints.values[t.maxWidth]}${e.breakpoints.unit}`,
          [`&.${ac.paperScrollBody}`]: {
            [e.breakpoints.down(e.breakpoints.values[t.maxWidth] + 32 * 2)]: {
              maxWidth: 'calc(100% - 64px)',
            },
          },
        },
      t.fullWidth && {
        width: 'calc(100% - 64px)',
      },
      t.fullScreen && {
        margin: 0,
        width: '100%',
        maxWidth: '100%',
        height: '100%',
        maxHeight: 'none',
        borderRadius: 0,
        [`&.${ac.paperScrollBody}`]: {
          margin: 0,
          maxWidth: '100%',
        },
      }
    )
  ),
  YS = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiDialog',
      }),
      r = _i(),
      i = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen,
      },
      {
        'aria-describedby': s,
        'aria-labelledby': a,
        BackdropComponent: l,
        BackdropProps: c,
        children: u,
        className: d,
        disableEscapeKeyDown: f = !1,
        fullScreen: A = !1,
        fullWidth: h = !1,
        maxWidth: g = 'sm',
        onBackdropClick: x,
        onClick: m,
        onClose: v,
        open: y,
        PaperComponent: b = es,
        PaperProps: C = {},
        scroll: I = 'paper',
        TransitionComponent: w = Vg,
        transitionDuration: M = i,
        TransitionProps: L,
      } = o,
      R = pe(o, OS),
      T = k({}, o, {
        disableEscapeKeyDown: f,
        fullScreen: A,
        fullWidth: h,
        maxWidth: g,
        scroll: I,
      }),
      D = WS(T),
      z = N.useRef(),
      E = S => {
        z.current = S.target === S.currentTarget
      },
      P = S => {
        m && m(S), z.current && ((z.current = null), x && x(S), v && v(S, 'backdropClick'))
      },
      B = Al(a),
      F = N.useMemo(
        () => ({
          titleId: B,
        }),
        [B]
      )
    return /* @__PURE__ */ p.jsx(
      GS,
      k(
        {
          className: de(D.root, d),
          closeAfterTransition: !0,
          components: {
            Backdrop: jS,
          },
          componentsProps: {
            backdrop: k(
              {
                transitionDuration: M,
                as: l,
              },
              c
            ),
          },
          disableEscapeKeyDown: f,
          onClose: v,
          open: y,
          ref: n,
          onClick: P,
          ownerState: T,
        },
        R,
        {
          children: /* @__PURE__ */ p.jsx(
            w,
            k(
              {
                appear: !0,
                in: y,
                timeout: M,
                role: 'presentation',
              },
              L,
              {
                children: /* @__PURE__ */ p.jsx(VS, {
                  className: de(D.container),
                  onMouseDown: E,
                  ownerState: T,
                  children: /* @__PURE__ */ p.jsx(
                    XS,
                    k(
                      {
                        as: b,
                        elevation: 24,
                        role: 'dialog',
                        'aria-describedby': s,
                        'aria-labelledby': B,
                      },
                      C,
                      {
                        className: de(D.paper, C.className),
                        ownerState: T,
                        children: /* @__PURE__ */ p.jsx(Ug.Provider, {
                          value: F,
                          children: u,
                        }),
                      }
                    )
                  ),
                }),
              }
            )
          ),
        }
      )
    )
  })
function HS(e) {
  return We('MuiDialogTitle', e)
}
Qe('MuiDialogTitle', ['root'])
const US = ['className', 'id'],
  KS = e => {
    const { classes: t } = e
    return Ye(
      {
        root: ['root'],
      },
      HS,
      t
    )
  },
  qS = O(Do, {
    name: 'MuiDialogTitle',
    slot: 'Root',
    overridesResolver: (e, t) => t.root,
  })({
    padding: '16px 24px',
    flex: '0 0 auto',
  }),
  ZS = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiDialogTitle',
      }),
      { className: r, id: i } = o,
      s = pe(o, US),
      a = o,
      l = KS(a),
      { titleId: c = i } = N.useContext(Ug)
    return /* @__PURE__ */ p.jsx(
      qS,
      k(
        {
          component: 'h2',
          className: de(l.root, r),
          ownerState: a,
          ref: n,
          variant: 'h6',
          id: i ?? c,
        },
        s
      )
    )
  })
function JS(e) {
  return We('MuiDivider', e)
}
const $f = Qe('MuiDivider', ['root', 'absolute', 'fullWidth', 'inset', 'middle', 'flexItem', 'light', 'vertical', 'withChildren', 'withChildrenVertical', 'textAlignRight', 'textAlignLeft', 'wrapper', 'wrapperVertical']),
  _S = ['absolute', 'children', 'className', 'component', 'flexItem', 'light', 'orientation', 'role', 'textAlign', 'variant'],
  $S = e => {
    const { absolute: t, children: n, classes: o, flexItem: r, light: i, orientation: s, textAlign: a, variant: l } = e
    return Ye(
      {
        root: ['root', t && 'absolute', l, i && 'light', s === 'vertical' && 'vertical', r && 'flexItem', n && 'withChildren', n && s === 'vertical' && 'withChildrenVertical', a === 'right' && s !== 'vertical' && 'textAlignRight', a === 'left' && s !== 'vertical' && 'textAlignLeft'],
        wrapper: ['wrapper', s === 'vertical' && 'wrapperVertical'],
      },
      JS,
      o
    )
  },
  eB = O('div', {
    name: 'MuiDivider',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [
        t.root,
        n.absolute && t.absolute,
        t[n.variant],
        n.light && t.light,
        n.orientation === 'vertical' && t.vertical,
        n.flexItem && t.flexItem,
        n.children && t.withChildren,
        n.children && n.orientation === 'vertical' && t.withChildrenVertical,
        n.textAlign === 'right' && n.orientation !== 'vertical' && t.textAlignRight,
        n.textAlign === 'left' && n.orientation !== 'vertical' && t.textAlignLeft,
      ]
    },
  })(
    ({ theme: e, ownerState: t }) =>
      k(
        {
          margin: 0,
          // Reset browser default style.
          flexShrink: 0,
          borderWidth: 0,
          borderStyle: 'solid',
          borderColor: (e.vars || e).palette.divider,
          borderBottomWidth: 'thin',
        },
        t.absolute && {
          position: 'absolute',
          bottom: 0,
          left: 0,
          width: '100%',
        },
        t.light && {
          borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : Lt(e.palette.divider, 0.08),
        },
        t.variant === 'inset' && {
          marginLeft: 72,
        },
        t.variant === 'middle' &&
          t.orientation === 'horizontal' && {
            marginLeft: e.spacing(2),
            marginRight: e.spacing(2),
          },
        t.variant === 'middle' &&
          t.orientation === 'vertical' && {
            marginTop: e.spacing(1),
            marginBottom: e.spacing(1),
          },
        t.orientation === 'vertical' && {
          height: '100%',
          borderBottomWidth: 0,
          borderRightWidth: 'thin',
        },
        t.flexItem && {
          alignSelf: 'stretch',
          height: 'auto',
        }
      ),
    ({ ownerState: e }) =>
      k(
        {},
        e.children && {
          display: 'flex',
          whiteSpace: 'nowrap',
          textAlign: 'center',
          border: 0,
          borderTopStyle: 'solid',
          borderLeftStyle: 'solid',
          '&::before, &::after': {
            content: '""',
            alignSelf: 'center',
          },
        }
      ),
    ({ theme: e, ownerState: t }) =>
      k(
        {},
        t.children &&
          t.orientation !== 'vertical' && {
            '&::before, &::after': {
              width: '100%',
              borderTop: `thin solid ${(e.vars || e).palette.divider}`,
              borderTopStyle: 'inherit',
            },
          }
      ),
    ({ theme: e, ownerState: t }) =>
      k(
        {},
        t.children &&
          t.orientation === 'vertical' && {
            flexDirection: 'column',
            '&::before, &::after': {
              height: '100%',
              borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
              borderLeftStyle: 'inherit',
            },
          }
      ),
    ({ ownerState: e }) =>
      k(
        {},
        e.textAlign === 'right' &&
          e.orientation !== 'vertical' && {
            '&::before': {
              width: '90%',
            },
            '&::after': {
              width: '10%',
            },
          },
        e.textAlign === 'left' &&
          e.orientation !== 'vertical' && {
            '&::before': {
              width: '10%',
            },
            '&::after': {
              width: '90%',
            },
          }
      )
  ),
  tB = O('span', {
    name: 'MuiDivider',
    slot: 'Wrapper',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.wrapper, n.orientation === 'vertical' && t.wrapperVertical]
    },
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        display: 'inline-block',
        paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
        paddingRight: `calc(${e.spacing(1)} * 1.2)`,
      },
      t.orientation === 'vertical' && {
        paddingTop: `calc(${e.spacing(1)} * 1.2)`,
        paddingBottom: `calc(${e.spacing(1)} * 1.2)`,
      }
    )
  ),
  Kg = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiDivider',
      }),
      { absolute: r = !1, children: i, className: s, component: a = i ? 'div' : 'hr', flexItem: l = !1, light: c = !1, orientation: u = 'horizontal', role: d = a !== 'hr' ? 'separator' : void 0, textAlign: f = 'center', variant: A = 'fullWidth' } = o,
      h = pe(o, _S),
      g = k({}, o, {
        absolute: r,
        component: a,
        flexItem: l,
        light: c,
        orientation: u,
        role: d,
        textAlign: f,
        variant: A,
      }),
      x = $S(g)
    return /* @__PURE__ */ p.jsx(
      eB,
      k(
        {
          as: a,
          className: de(x.root, s),
          role: d,
          ref: n,
          ownerState: g,
        },
        h,
        {
          children: i
            ? /* @__PURE__ */ p.jsx(tB, {
                className: x.wrapper,
                ownerState: g,
                children: i,
              })
            : null,
        }
      )
    )
  })
Kg.muiSkipListHighlight = !0
const nB = ['addEndListener', 'appear', 'children', 'container', 'direction', 'easing', 'in', 'onEnter', 'onEntered', 'onEntering', 'onExit', 'onExited', 'onExiting', 'style', 'timeout', 'TransitionComponent']
function oB(e, t, n) {
  const o = t.getBoundingClientRect(),
    r = n && n.getBoundingClientRect(),
    i = kn(t)
  let s
  if (t.fakeTransform) s = t.fakeTransform
  else {
    const c = i.getComputedStyle(t)
    s = c.getPropertyValue('-webkit-transform') || c.getPropertyValue('transform')
  }
  let a = 0,
    l = 0
  if (s && s !== 'none' && typeof s == 'string') {
    const c = s.split('(')[1].split(')')[0].split(',')
    ;(a = parseInt(c[4], 10)), (l = parseInt(c[5], 10))
  }
  return e === 'left'
    ? r
      ? `translateX(${r.right + a - o.left}px)`
      : `translateX(${i.innerWidth + a - o.left}px)`
    : e === 'right'
    ? r
      ? `translateX(-${o.right - r.left - a}px)`
      : `translateX(-${o.left + o.width - a}px)`
    : e === 'up'
    ? r
      ? `translateY(${r.bottom + l - o.top}px)`
      : `translateY(${i.innerHeight + l - o.top}px)`
    : r
    ? `translateY(-${o.top - r.top + o.height - l}px)`
    : `translateY(-${o.top + o.height - l}px)`
}
function rB(e) {
  return typeof e == 'function' ? e() : e
}
function gs(e, t, n) {
  const o = rB(n),
    r = oB(e, t, o)
  r && ((t.style.webkitTransform = r), (t.style.transform = r))
}
const iB = /* @__PURE__ */ N.forwardRef(function (t, n) {
  const o = _i(),
    r = {
      enter: o.transitions.easing.easeOut,
      exit: o.transitions.easing.sharp,
    },
    i = {
      enter: o.transitions.duration.enteringScreen,
      exit: o.transitions.duration.leavingScreen,
    },
    {
      addEndListener: s,
      appear: a = !0,
      children: l,
      container: c,
      direction: u = 'down',
      easing: d = r,
      in: f,
      onEnter: A,
      onEntered: h,
      onEntering: g,
      onExit: x,
      onExited: m,
      onExiting: v,
      style: y,
      timeout: b = i,
      // eslint-disable-next-line react/prop-types
      TransitionComponent: C = bn,
    } = t,
    I = pe(t, nB),
    w = N.useRef(null),
    M = xt(Hr(l), w, n),
    L = S => Q => {
      S && (Q === void 0 ? S(w.current) : S(w.current, Q))
    },
    R = L((S, Q) => {
      gs(u, S, c), pd(S), A && A(S, Q)
    }),
    T = L((S, Q) => {
      const j = Sr(
        {
          timeout: b,
          style: y,
          easing: d,
        },
        {
          mode: 'enter',
        }
      )
      ;(S.style.webkitTransition = o.transitions.create('-webkit-transform', k({}, j))), (S.style.transition = o.transitions.create('transform', k({}, j))), (S.style.webkitTransform = 'none'), (S.style.transform = 'none'), g && g(S, Q)
    }),
    D = L(h),
    z = L(v),
    E = L(S => {
      const Q = Sr(
        {
          timeout: b,
          style: y,
          easing: d,
        },
        {
          mode: 'exit',
        }
      )
      ;(S.style.webkitTransition = o.transitions.create('-webkit-transform', Q)), (S.style.transition = o.transitions.create('transform', Q)), gs(u, S, c), x && x(S)
    }),
    P = L(S => {
      ;(S.style.webkitTransition = ''), (S.style.transition = ''), m && m(S)
    }),
    B = S => {
      s && s(w.current, S)
    },
    F = N.useCallback(() => {
      w.current && gs(u, w.current, c)
    }, [u, c])
  return (
    N.useEffect(() => {
      if (f || u === 'down' || u === 'right') return
      const S = fl(() => {
          w.current && gs(u, w.current, c)
        }),
        Q = kn(w.current)
      return (
        Q.addEventListener('resize', S),
        () => {
          S.clear(), Q.removeEventListener('resize', S)
        }
      )
    }, [u, f, c]),
    N.useEffect(() => {
      f || F()
    }, [f, F]),
    /* @__PURE__ */ p.jsx(
      C,
      k(
        {
          nodeRef: w,
          onEnter: R,
          onEntered: D,
          onEntering: T,
          onExit: E,
          onExited: P,
          onExiting: z,
          addEndListener: B,
          appear: a,
          in: f,
          timeout: b,
        },
        I,
        {
          children: (S, Q) =>
            /* @__PURE__ */ N.cloneElement(
              l,
              k(
                {
                  ref: M,
                  style: k(
                    {
                      visibility: S === 'exited' && !f ? 'hidden' : void 0,
                    },
                    y,
                    l.props.style
                  ),
                },
                Q
              )
            ),
        }
      )
    )
  )
})
function sB(e) {
  return We('MuiDrawer', e)
}
Qe('MuiDrawer', ['root', 'docked', 'paper', 'paperAnchorLeft', 'paperAnchorRight', 'paperAnchorTop', 'paperAnchorBottom', 'paperAnchorDockedLeft', 'paperAnchorDockedRight', 'paperAnchorDockedTop', 'paperAnchorDockedBottom', 'modal'])
const aB = ['BackdropProps'],
  lB = ['anchor', 'BackdropProps', 'children', 'className', 'elevation', 'hideBackdrop', 'ModalProps', 'onClose', 'open', 'PaperProps', 'SlideProps', 'TransitionComponent', 'transitionDuration', 'variant'],
  qg = (e, t) => {
    const { ownerState: n } = e
    return [t.root, (n.variant === 'permanent' || n.variant === 'persistent') && t.docked, t.modal]
  },
  cB = e => {
    const { classes: t, anchor: n, variant: o } = e,
      r = {
        root: ['root'],
        docked: [(o === 'permanent' || o === 'persistent') && 'docked'],
        modal: ['modal'],
        paper: ['paper', `paperAnchor${me(n)}`, o !== 'temporary' && `paperAnchorDocked${me(n)}`],
      }
    return Ye(r, sB, t)
  },
  uB = O(md, {
    name: 'MuiDrawer',
    slot: 'Root',
    overridesResolver: qg,
  })(({ theme: e }) => ({
    zIndex: (e.vars || e).zIndex.drawer,
  })),
  eA = O('div', {
    shouldForwardProp: Kt,
    name: 'MuiDrawer',
    slot: 'Docked',
    skipVariantsResolver: !1,
    overridesResolver: qg,
  })({
    flex: '0 0 auto',
  }),
  dB = O(es, {
    name: 'MuiDrawer',
    slot: 'Paper',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.paper, t[`paperAnchor${me(n.anchor)}`], n.variant !== 'temporary' && t[`paperAnchorDocked${me(n.anchor)}`]]
    },
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        overflowY: 'auto',
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
        flex: '1 0 auto',
        zIndex: (e.vars || e).zIndex.drawer,
        // Add iOS momentum scrolling for iOS < 13.0
        WebkitOverflowScrolling: 'touch',
        // temporary style
        position: 'fixed',
        top: 0,
        // We disable the focus ring for mouse, touch and keyboard users.
        // At some point, it would be better to keep it for keyboard users.
        // :focus-ring CSS pseudo-class will help.
        outline: 0,
      },
      t.anchor === 'left' && {
        left: 0,
      },
      t.anchor === 'top' && {
        top: 0,
        left: 0,
        right: 0,
        height: 'auto',
        maxHeight: '100%',
      },
      t.anchor === 'right' && {
        right: 0,
      },
      t.anchor === 'bottom' && {
        top: 'auto',
        left: 0,
        bottom: 0,
        right: 0,
        height: 'auto',
        maxHeight: '100%',
      },
      t.anchor === 'left' &&
        t.variant !== 'temporary' && {
          borderRight: `1px solid ${(e.vars || e).palette.divider}`,
        },
      t.anchor === 'top' &&
        t.variant !== 'temporary' && {
          borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
        },
      t.anchor === 'right' &&
        t.variant !== 'temporary' && {
          borderLeft: `1px solid ${(e.vars || e).palette.divider}`,
        },
      t.anchor === 'bottom' &&
        t.variant !== 'temporary' && {
          borderTop: `1px solid ${(e.vars || e).palette.divider}`,
        }
    )
  ),
  Zg = {
    left: 'right',
    right: 'left',
    top: 'down',
    bottom: 'up',
  }
function fB(e) {
  return ['left', 'right'].indexOf(e) !== -1
}
function AB({ direction: e }, t) {
  return e === 'rtl' && fB(t) ? Zg[t] : t
}
const pB = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiDrawer',
      }),
      r = _i(),
      i = od(),
      s = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen,
      },
      {
        anchor: a = 'left',
        BackdropProps: l,
        children: c,
        className: u,
        elevation: d = 16,
        hideBackdrop: f = !1,
        ModalProps: { BackdropProps: A } = {},
        onClose: h,
        open: g = !1,
        PaperProps: x = {},
        SlideProps: m,
        // eslint-disable-next-line react/prop-types
        TransitionComponent: v = iB,
        transitionDuration: y = s,
        variant: b = 'temporary',
      } = o,
      C = pe(o.ModalProps, aB),
      I = pe(o, lB),
      w = N.useRef(!1)
    N.useEffect(() => {
      w.current = !0
    }, [])
    const M = AB(
        {
          direction: i ? 'rtl' : 'ltr',
        },
        a
      ),
      R = k(
        {},
        o,
        {
          anchor: a,
          elevation: d,
          open: g,
          variant: b,
        },
        I
      ),
      T = cB(R),
      D = /* @__PURE__ */ p.jsx(
        dB,
        k(
          {
            elevation: b === 'temporary' ? d : 0,
            square: !0,
          },
          x,
          {
            className: de(T.paper, x.className),
            ownerState: R,
            children: c,
          }
        )
      )
    if (b === 'permanent')
      return /* @__PURE__ */ p.jsx(
        eA,
        k(
          {
            className: de(T.root, T.docked, u),
            ownerState: R,
            ref: n,
          },
          I,
          {
            children: D,
          }
        )
      )
    const z = /* @__PURE__ */ p.jsx(
      v,
      k(
        {
          in: g,
          direction: Zg[M],
          timeout: y,
          appear: w.current,
        },
        m,
        {
          children: D,
        }
      )
    )
    return b === 'persistent'
      ? /* @__PURE__ */ p.jsx(
          eA,
          k(
            {
              className: de(T.root, T.docked, u),
              ownerState: R,
              ref: n,
            },
            I,
            {
              children: z,
            }
          )
        )
      : /* @__PURE__ */ p.jsx(
          uB,
          k(
            {
              BackdropProps: k({}, l, A, {
                transitionDuration: y,
              }),
              className: de(T.root, T.modal, u),
              open: g,
              ownerState: R,
              onClose: h,
              hideBackdrop: f,
              ref: n,
            },
            I,
            C,
            {
              children: z,
            }
          )
        )
  }),
  hB = ['disableUnderline', 'components', 'componentsProps', 'fullWidth', 'hiddenLabel', 'inputComponent', 'multiline', 'slotProps', 'slots', 'type'],
  gB = e => {
    const { classes: t, disableUnderline: n } = e,
      r = Ye(
        {
          root: ['root', !n && 'underline'],
          input: ['input'],
        },
        qE,
        t
      )
    return k({}, t, r)
  },
  mB = O(vl, {
    shouldForwardProp: e => Kt(e) || e === 'classes',
    name: 'MuiFilledInput',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [...yl(e, t), !n.disableUnderline && t.underline]
    },
  })(({ theme: e, ownerState: t }) => {
    var n
    const o = e.palette.mode === 'light',
      r = o ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)',
      i = o ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.09)',
      s = o ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.13)',
      a = o ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'
    return k(
      {
        position: 'relative',
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : i,
        borderTopLeftRadius: (e.vars || e).shape.borderRadius,
        borderTopRightRadius: (e.vars || e).shape.borderRadius,
        transition: e.transitions.create('background-color', {
          duration: e.transitions.duration.shorter,
          easing: e.transitions.easing.easeOut,
        }),
        '&:hover': {
          backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : s,
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : i,
          },
        },
        [`&.${wo.focused}`]: {
          backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : i,
        },
        [`&.${wo.disabled}`]: {
          backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : a,
        },
      },
      !t.disableUnderline && {
        '&::after': {
          borderBottom: `2px solid ${(n = (e.vars || e).palette[t.color || 'primary']) == null ? void 0 : n.main}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: 'absolute',
          right: 0,
          transform: 'scaleX(0)',
          transition: e.transitions.create('transform', {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut,
          }),
          pointerEvents: 'none',
          // Transparent to the hover style.
        },
        [`&.${wo.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: 'scaleX(1) translateX(0)',
        },
        [`&.${wo.error}`]: {
          '&::before, &::after': {
            borderBottomColor: (e.vars || e).palette.error.main,
          },
        },
        '&::before': {
          borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : r}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: 'absolute',
          right: 0,
          transition: e.transitions.create('border-bottom-color', {
            duration: e.transitions.duration.shorter,
          }),
          pointerEvents: 'none',
          // Transparent to the hover style.
        },
        [`&:hover:not(.${wo.disabled}, .${wo.error}):before`]: {
          borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`,
        },
        [`&.${wo.disabled}:before`]: {
          borderBottomStyle: 'dotted',
        },
      },
      t.startAdornment && {
        paddingLeft: 12,
      },
      t.endAdornment && {
        paddingRight: 12,
      },
      t.multiline &&
        k(
          {
            padding: '25px 12px 8px',
          },
          t.size === 'small' && {
            paddingTop: 21,
            paddingBottom: 4,
          },
          t.hiddenLabel && {
            paddingTop: 16,
            paddingBottom: 17,
          },
          t.hiddenLabel &&
            t.size === 'small' && {
              paddingTop: 8,
              paddingBottom: 9,
            }
        )
    )
  }),
  yB = O(xl, {
    name: 'MuiFilledInput',
    slot: 'Input',
    overridesResolver: bl,
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        paddingTop: 25,
        paddingRight: 12,
        paddingBottom: 8,
        paddingLeft: 12,
      },
      !e.vars && {
        '&:-webkit-autofill': {
          WebkitBoxShadow: e.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset',
          WebkitTextFillColor: e.palette.mode === 'light' ? null : '#fff',
          caretColor: e.palette.mode === 'light' ? null : '#fff',
          borderTopLeftRadius: 'inherit',
          borderTopRightRadius: 'inherit',
        },
      },
      e.vars && {
        '&:-webkit-autofill': {
          borderTopLeftRadius: 'inherit',
          borderTopRightRadius: 'inherit',
        },
        [e.getColorSchemeSelector('dark')]: {
          '&:-webkit-autofill': {
            WebkitBoxShadow: '0 0 0 100px #266798 inset',
            WebkitTextFillColor: '#fff',
            caretColor: '#fff',
          },
        },
      },
      t.size === 'small' && {
        paddingTop: 21,
        paddingBottom: 4,
      },
      t.hiddenLabel && {
        paddingTop: 16,
        paddingBottom: 17,
      },
      t.startAdornment && {
        paddingLeft: 0,
      },
      t.endAdornment && {
        paddingRight: 0,
      },
      t.hiddenLabel &&
        t.size === 'small' && {
          paddingTop: 8,
          paddingBottom: 9,
        },
      t.multiline && {
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0,
      }
    )
  ),
  yd = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o, r, i, s
    const a = Oe({
        props: t,
        name: 'MuiFilledInput',
      }),
      {
        components: l = {},
        componentsProps: c,
        fullWidth: u = !1,
        // declare here to prevent spreading to DOM
        inputComponent: d = 'input',
        multiline: f = !1,
        slotProps: A,
        slots: h = {},
        type: g = 'text',
      } = a,
      x = pe(a, hB),
      m = k({}, a, {
        fullWidth: u,
        inputComponent: d,
        multiline: f,
        type: g,
      }),
      v = gB(a),
      y = {
        root: {
          ownerState: m,
        },
        input: {
          ownerState: m,
        },
      },
      b = A ?? c ? Vn(y, A ?? c) : y,
      C = (o = (r = h.root) != null ? r : l.Root) != null ? o : mB,
      I = (i = (s = h.input) != null ? s : l.Input) != null ? i : yB
    return /* @__PURE__ */ p.jsx(
      gd,
      k(
        {
          slots: {
            root: C,
            input: I,
          },
          componentsProps: b,
          fullWidth: u,
          inputComponent: d,
          multiline: f,
          ref: n,
          type: g,
        },
        x,
        {
          classes: v,
        }
      )
    )
  })
yd.muiName = 'Input'
function bB(e) {
  return We('MuiFormControl', e)
}
Qe('MuiFormControl', ['root', 'marginNone', 'marginNormal', 'marginDense', 'fullWidth', 'disabled'])
const vB = ['children', 'className', 'color', 'component', 'disabled', 'error', 'focused', 'fullWidth', 'hiddenLabel', 'margin', 'required', 'size', 'variant'],
  xB = e => {
    const { classes: t, margin: n, fullWidth: o } = e,
      r = {
        root: ['root', n !== 'none' && `margin${me(n)}`, o && 'fullWidth'],
      }
    return Ye(r, bB, t)
  },
  CB = O('div', {
    name: 'MuiFormControl',
    slot: 'Root',
    overridesResolver: ({ ownerState: e }, t) => k({}, t.root, t[`margin${me(e.margin)}`], e.fullWidth && t.fullWidth),
  })(({ ownerState: e }) =>
    k(
      {
        display: 'inline-flex',
        flexDirection: 'column',
        position: 'relative',
        // Reset fieldset default style.
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: 'top',
      },
      e.margin === 'normal' && {
        marginTop: 16,
        marginBottom: 8,
      },
      e.margin === 'dense' && {
        marginTop: 8,
        marginBottom: 4,
      },
      e.fullWidth && {
        width: '100%',
      }
    )
  ),
  Jg = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiFormControl',
      }),
      { children: r, className: i, color: s = 'primary', component: a = 'div', disabled: l = !1, error: c = !1, focused: u, fullWidth: d = !1, hiddenLabel: f = !1, margin: A = 'none', required: h = !1, size: g = 'medium', variant: x = 'outlined' } = o,
      m = pe(o, vB),
      v = k({}, o, {
        color: s,
        component: a,
        disabled: l,
        error: c,
        fullWidth: d,
        hiddenLabel: f,
        margin: A,
        required: h,
        size: g,
        variant: x,
      }),
      y = xB(v),
      [b, C] = N.useState(() => {
        let z = !1
        return (
          r &&
            N.Children.forEach(r, E => {
              if (!Us(E, ['Input', 'Select'])) return
              const P = Us(E, ['Select']) ? E.props.input : E
              P && GE(P.props) && (z = !0)
            }),
          z
        )
      }),
      [I, w] = N.useState(() => {
        let z = !1
        return (
          r &&
            N.Children.forEach(r, E => {
              Us(E, ['Input', 'Select']) && (la(E.props, !0) || la(E.props.inputProps, !0)) && (z = !0)
            }),
          z
        )
      }),
      [M, L] = N.useState(!1)
    l && M && L(!1)
    const R = u !== void 0 && !l ? u : M
    let T
    const D = N.useMemo(
      () => ({
        adornedStart: b,
        setAdornedStart: C,
        color: s,
        disabled: l,
        error: c,
        filled: I,
        focused: R,
        fullWidth: d,
        hiddenLabel: f,
        size: g,
        onBlur: () => {
          L(!1)
        },
        onEmpty: () => {
          w(!1)
        },
        onFilled: () => {
          w(!0)
        },
        onFocus: () => {
          L(!0)
        },
        registerEffect: T,
        required: h,
        variant: x,
      }),
      [b, s, l, c, I, R, d, f, T, h, g, x]
    )
    return /* @__PURE__ */ p.jsx(ml.Provider, {
      value: D,
      children: /* @__PURE__ */ p.jsx(
        CB,
        k(
          {
            as: a,
            ownerState: v,
            className: de(y.root, i),
            ref: n,
          },
          m,
          {
            children: r,
          }
        )
      ),
    })
  }),
  wB = x1({
    createStyledComponent: O('div', {
      name: 'MuiStack',
      slot: 'Root',
      overridesResolver: (e, t) => t.root,
    }),
    useThemeProps: e =>
      Oe({
        props: e,
        name: 'MuiStack',
      }),
  })
function EB(e) {
  return We('MuiFormHelperText', e)
}
const tA = Qe('MuiFormHelperText', ['root', 'error', 'disabled', 'sizeSmall', 'sizeMedium', 'contained', 'focused', 'filled', 'required'])
var nA
const SB = ['children', 'className', 'component', 'disabled', 'error', 'filled', 'focused', 'margin', 'required', 'variant'],
  BB = e => {
    const { classes: t, contained: n, size: o, disabled: r, error: i, filled: s, focused: a, required: l } = e,
      c = {
        root: ['root', r && 'disabled', i && 'error', o && `size${me(o)}`, n && 'contained', a && 'focused', s && 'filled', l && 'required'],
      }
    return Ye(c, EB, t)
  },
  IB = O('p', {
    name: 'MuiFormHelperText',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, n.size && t[`size${me(n.size)}`], n.contained && t.contained, n.filled && t.filled]
    },
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        color: (e.vars || e).palette.text.secondary,
      },
      e.typography.caption,
      {
        textAlign: 'left',
        marginTop: 3,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        [`&.${tA.disabled}`]: {
          color: (e.vars || e).palette.text.disabled,
        },
        [`&.${tA.error}`]: {
          color: (e.vars || e).palette.error.main,
        },
      },
      t.size === 'small' && {
        marginTop: 4,
      },
      t.contained && {
        marginLeft: 14,
        marginRight: 14,
      }
    )
  ),
  _g = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiFormHelperText',
      }),
      { children: r, className: i, component: s = 'p' } = o,
      a = pe(o, SB),
      l = er(),
      c = Ur({
        props: o,
        muiFormControl: l,
        states: ['variant', 'size', 'disabled', 'error', 'filled', 'focused', 'required'],
      }),
      u = k({}, o, {
        component: s,
        contained: c.variant === 'filled' || c.variant === 'outlined',
        variant: c.variant,
        size: c.size,
        disabled: c.disabled,
        error: c.error,
        filled: c.filled,
        focused: c.focused,
        required: c.required,
      }),
      d = BB(u)
    return /* @__PURE__ */ p.jsx(
      IB,
      k(
        {
          as: s,
          ownerState: u,
          className: de(d.root, i),
          ref: n,
        },
        a,
        {
          children:
            r === ' '
              ? // notranslate needed while Google Translate will not fix zero-width space issue
                nA ||
                (nA = /* @__PURE__ */ p.jsx('span', {
                  className: 'notranslate',
                  children: '​',
                }))
              : r,
        }
      )
    )
  })
function NB(e) {
  return We('MuiFormLabel', e)
}
const Ei = Qe('MuiFormLabel', ['root', 'colorSecondary', 'focused', 'disabled', 'error', 'filled', 'required', 'asterisk']),
  kB = ['children', 'className', 'color', 'component', 'disabled', 'error', 'filled', 'focused', 'required'],
  MB = e => {
    const { classes: t, color: n, focused: o, disabled: r, error: i, filled: s, required: a } = e,
      l = {
        root: ['root', `color${me(n)}`, r && 'disabled', i && 'error', s && 'filled', o && 'focused', a && 'required'],
        asterisk: ['asterisk', i && 'error'],
      }
    return Ye(l, NB, t)
  },
  PB = O('label', {
    name: 'MuiFormLabel',
    slot: 'Root',
    overridesResolver: ({ ownerState: e }, t) => k({}, t.root, e.color === 'secondary' && t.colorSecondary, e.filled && t.filled),
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        color: (e.vars || e).palette.text.secondary,
      },
      e.typography.body1,
      {
        lineHeight: '1.4375em',
        padding: 0,
        position: 'relative',
        [`&.${Ei.focused}`]: {
          color: (e.vars || e).palette[t.color].main,
        },
        [`&.${Ei.disabled}`]: {
          color: (e.vars || e).palette.text.disabled,
        },
        [`&.${Ei.error}`]: {
          color: (e.vars || e).palette.error.main,
        },
      }
    )
  ),
  LB = O('span', {
    name: 'MuiFormLabel',
    slot: 'Asterisk',
    overridesResolver: (e, t) => t.asterisk,
  })(({ theme: e }) => ({
    [`&.${Ei.error}`]: {
      color: (e.vars || e).palette.error.main,
    },
  })),
  RB = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiFormLabel',
      }),
      { children: r, className: i, component: s = 'label' } = o,
      a = pe(o, kB),
      l = er(),
      c = Ur({
        props: o,
        muiFormControl: l,
        states: ['color', 'required', 'focused', 'disabled', 'error', 'filled'],
      }),
      u = k({}, o, {
        color: c.color || 'primary',
        component: s,
        disabled: c.disabled,
        error: c.error,
        filled: c.filled,
        focused: c.focused,
        required: c.required,
      }),
      d = MB(u)
    return /* @__PURE__ */ p.jsxs(
      PB,
      k(
        {
          as: s,
          ownerState: u,
          className: de(d.root, i),
          ref: n,
        },
        a,
        {
          children: [
            r,
            c.required &&
              /* @__PURE__ */ p.jsxs(LB, {
                ownerState: u,
                'aria-hidden': !0,
                className: d.asterisk,
                children: [' ', '*'],
              }),
          ],
        }
      )
    )
  }),
  TB = ['addEndListener', 'appear', 'children', 'easing', 'in', 'onEnter', 'onEntered', 'onEntering', 'onExit', 'onExited', 'onExiting', 'style', 'timeout', 'TransitionComponent']
function tu(e) {
  return `scale(${e}, ${e ** 2})`
}
const FB = {
    entering: {
      opacity: 1,
      transform: tu(1),
    },
    entered: {
      opacity: 1,
      transform: 'none',
    },
  },
  lc = typeof navigator < 'u' && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  $g = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const {
        addEndListener: o,
        appear: r = !0,
        children: i,
        easing: s,
        in: a,
        onEnter: l,
        onEntered: c,
        onEntering: u,
        onExit: d,
        onExited: f,
        onExiting: A,
        style: h,
        timeout: g = 'auto',
        // eslint-disable-next-line react/prop-types
        TransitionComponent: x = bn,
      } = t,
      m = pe(t, TB),
      v = zg(),
      y = N.useRef(),
      b = _i(),
      C = N.useRef(null),
      I = xt(C, Hr(i), n),
      w = P => B => {
        if (P) {
          const F = C.current
          B === void 0 ? P(F) : P(F, B)
        }
      },
      M = w(u),
      L = w((P, B) => {
        pd(P)
        const {
          duration: F,
          delay: S,
          easing: Q,
        } = Sr(
          {
            style: h,
            timeout: g,
            easing: s,
          },
          {
            mode: 'enter',
          }
        )
        let j
        g === 'auto' ? ((j = b.transitions.getAutoHeightDuration(P.clientHeight)), (y.current = j)) : (j = F),
          (P.style.transition = [
            b.transitions.create('opacity', {
              duration: j,
              delay: S,
            }),
            b.transitions.create('transform', {
              duration: lc ? j : j * 0.666,
              delay: S,
              easing: Q,
            }),
          ].join(',')),
          l && l(P, B)
      }),
      R = w(c),
      T = w(A),
      D = w(P => {
        const {
          duration: B,
          delay: F,
          easing: S,
        } = Sr(
          {
            style: h,
            timeout: g,
            easing: s,
          },
          {
            mode: 'exit',
          }
        )
        let Q
        g === 'auto' ? ((Q = b.transitions.getAutoHeightDuration(P.clientHeight)), (y.current = Q)) : (Q = B),
          (P.style.transition = [
            b.transitions.create('opacity', {
              duration: Q,
              delay: F,
            }),
            b.transitions.create('transform', {
              duration: lc ? Q : Q * 0.666,
              delay: lc ? F : F || Q * 0.333,
              easing: S,
            }),
          ].join(',')),
          (P.style.opacity = 0),
          (P.style.transform = tu(0.75)),
          d && d(P)
      }),
      z = w(f),
      E = P => {
        g === 'auto' && v.start(y.current || 0, P), o && o(C.current, P)
      }
    return /* @__PURE__ */ p.jsx(
      x,
      k(
        {
          appear: r,
          in: a,
          nodeRef: C,
          onEnter: L,
          onEntered: R,
          onEntering: M,
          onExit: D,
          onExited: z,
          onExiting: T,
          addEndListener: E,
          timeout: g === 'auto' ? null : g,
        },
        m,
        {
          children: (P, B) =>
            /* @__PURE__ */ N.cloneElement(
              i,
              k(
                {
                  style: k(
                    {
                      opacity: 0,
                      transform: tu(0.75),
                      visibility: P === 'exited' && !a ? 'hidden' : void 0,
                    },
                    FB[P],
                    h,
                    i.props.style
                  ),
                  ref: I,
                },
                B
              )
            ),
        }
      )
    )
  })
$g.muiSupportAuto = !0
const DB = ['disableUnderline', 'components', 'componentsProps', 'fullWidth', 'inputComponent', 'multiline', 'slotProps', 'slots', 'type'],
  zB = e => {
    const { classes: t, disableUnderline: n } = e,
      r = Ye(
        {
          root: ['root', !n && 'underline'],
          input: ['input'],
        },
        UE,
        t
      )
    return k({}, t, r)
  },
  QB = O(vl, {
    shouldForwardProp: e => Kt(e) || e === 'classes',
    name: 'MuiInput',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [...yl(e, t), !n.disableUnderline && t.underline]
    },
  })(({ theme: e, ownerState: t }) => {
    let o = e.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)'
    return (
      e.vars && (o = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`),
      k(
        {
          position: 'relative',
        },
        t.formControl && {
          'label + &': {
            marginTop: 16,
          },
        },
        !t.disableUnderline && {
          '&::after': {
            borderBottom: `2px solid ${(e.vars || e).palette[t.color].main}`,
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
            content: '""',
            position: 'absolute',
            right: 0,
            transform: 'scaleX(0)',
            transition: e.transitions.create('transform', {
              duration: e.transitions.duration.shorter,
              easing: e.transitions.easing.easeOut,
            }),
            pointerEvents: 'none',
            // Transparent to the hover style.
          },
          [`&.${ni.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: 'scaleX(1) translateX(0)',
          },
          [`&.${ni.error}`]: {
            '&::before, &::after': {
              borderBottomColor: (e.vars || e).palette.error.main,
            },
          },
          '&::before': {
            borderBottom: `1px solid ${o}`,
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
            content: '"\\00a0"',
            position: 'absolute',
            right: 0,
            transition: e.transitions.create('border-bottom-color', {
              duration: e.transitions.duration.shorter,
            }),
            pointerEvents: 'none',
            // Transparent to the hover style.
          },
          [`&:hover:not(.${ni.disabled}, .${ni.error}):before`]: {
            borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              borderBottom: `1px solid ${o}`,
            },
          },
          [`&.${ni.disabled}:before`]: {
            borderBottomStyle: 'dotted',
          },
        }
      )
    )
  }),
  OB = O(xl, {
    name: 'MuiInput',
    slot: 'Input',
    overridesResolver: bl,
  })({}),
  bd = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o, r, i, s
    const a = Oe({
        props: t,
        name: 'MuiInput',
      }),
      { disableUnderline: l, components: c = {}, componentsProps: u, fullWidth: d = !1, inputComponent: f = 'input', multiline: A = !1, slotProps: h, slots: g = {}, type: x = 'text' } = a,
      m = pe(a, DB),
      v = zB(a),
      b = {
        root: {
          ownerState: {
            disableUnderline: l,
          },
        },
      },
      C = h ?? u ? Vn(h ?? u, b) : b,
      I = (o = (r = g.root) != null ? r : c.Root) != null ? o : QB,
      w = (i = (s = g.input) != null ? s : c.Input) != null ? i : OB
    return /* @__PURE__ */ p.jsx(
      gd,
      k(
        {
          slots: {
            root: I,
            input: w,
          },
          slotProps: C,
          fullWidth: d,
          inputComponent: f,
          multiline: A,
          ref: n,
          type: x,
        },
        m,
        {
          classes: v,
        }
      )
    )
  })
bd.muiName = 'Input'
function jB(e) {
  return We('MuiInputAdornment', e)
}
const oA = Qe('MuiInputAdornment', ['root', 'filled', 'standard', 'outlined', 'positionStart', 'positionEnd', 'disablePointerEvents', 'hiddenLabel', 'sizeSmall'])
var rA
const WB = ['children', 'className', 'component', 'disablePointerEvents', 'disableTypography', 'position', 'variant'],
  GB = (e, t) => {
    const { ownerState: n } = e
    return [t.root, t[`position${me(n.position)}`], n.disablePointerEvents === !0 && t.disablePointerEvents, t[n.variant]]
  },
  VB = e => {
    const { classes: t, disablePointerEvents: n, hiddenLabel: o, position: r, size: i, variant: s } = e,
      a = {
        root: ['root', n && 'disablePointerEvents', r && `position${me(r)}`, s, o && 'hiddenLabel', i && `size${me(i)}`],
      }
    return Ye(a, jB, t)
  },
  XB = O('div', {
    name: 'MuiInputAdornment',
    slot: 'Root',
    overridesResolver: GB,
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        display: 'flex',
        height: '0.01em',
        // Fix IE11 flexbox alignment. To remove at some point.
        maxHeight: '2em',
        alignItems: 'center',
        whiteSpace: 'nowrap',
        color: (e.vars || e).palette.action.active,
      },
      t.variant === 'filled' && {
        // Styles applied to the root element if `variant="filled"`.
        [`&.${oA.positionStart}&:not(.${oA.hiddenLabel})`]: {
          marginTop: 16,
        },
      },
      t.position === 'start' && {
        // Styles applied to the root element if `position="start"`.
        marginRight: 8,
      },
      t.position === 'end' && {
        // Styles applied to the root element if `position="end"`.
        marginLeft: 8,
      },
      t.disablePointerEvents === !0 && {
        // Styles applied to the root element if `disablePointerEvents={true}`.
        pointerEvents: 'none',
      }
    )
  ),
  YB = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiInputAdornment',
      }),
      { children: r, className: i, component: s = 'div', disablePointerEvents: a = !1, disableTypography: l = !1, position: c, variant: u } = o,
      d = pe(o, WB),
      f = er() || {}
    let A = u
    u && f.variant, A || (A = f.variant)
    const h = k({}, o, {
        hiddenLabel: f.hiddenLabel,
        size: f.size,
        disablePointerEvents: a,
        position: c,
        variant: A,
      }),
      g = VB(h)
    return /* @__PURE__ */ p.jsx(ml.Provider, {
      value: null,
      children: /* @__PURE__ */ p.jsx(
        XB,
        k(
          {
            as: s,
            ownerState: h,
            className: de(g.root, i),
            ref: n,
          },
          d,
          {
            children:
              typeof r == 'string' && !l
                ? /* @__PURE__ */ p.jsx(Do, {
                    color: 'text.secondary',
                    children: r,
                  })
                : /* @__PURE__ */ p.jsxs(N.Fragment, {
                    children: [
                      c === 'start'
                        ? /* notranslate needed while Google Translate will not fix zero-width space issue */
                          rA ||
                          (rA = /* @__PURE__ */ p.jsx('span', {
                            className: 'notranslate',
                            children: '​',
                          }))
                        : null,
                      r,
                    ],
                  }),
          }
        )
      ),
    })
  })
function HB(e) {
  return We('MuiInputLabel', e)
}
Qe('MuiInputLabel', ['root', 'focused', 'disabled', 'error', 'required', 'asterisk', 'formControl', 'sizeSmall', 'shrink', 'animated', 'standard', 'filled', 'outlined'])
const UB = ['disableAnimation', 'margin', 'shrink', 'variant', 'className'],
  KB = e => {
    const { classes: t, formControl: n, size: o, shrink: r, disableAnimation: i, variant: s, required: a } = e,
      l = {
        root: ['root', n && 'formControl', !i && 'animated', r && 'shrink', o && o !== 'normal' && `size${me(o)}`, s],
        asterisk: [a && 'asterisk'],
      },
      c = Ye(l, HB, t)
    return k({}, t, c)
  },
  qB = O(RB, {
    shouldForwardProp: e => Kt(e) || e === 'classes',
    name: 'MuiInputLabel',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [
        {
          [`& .${Ei.asterisk}`]: t.asterisk,
        },
        t.root,
        n.formControl && t.formControl,
        n.size === 'small' && t.sizeSmall,
        n.shrink && t.shrink,
        !n.disableAnimation && t.animated,
        n.focused && t.focused,
        t[n.variant],
      ]
    },
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        display: 'block',
        transformOrigin: 'top left',
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        maxWidth: '100%',
      },
      t.formControl && {
        position: 'absolute',
        left: 0,
        top: 0,
        // slight alteration to spec spacing to match visual spec result
        transform: 'translate(0, 20px) scale(1)',
      },
      t.size === 'small' && {
        // Compensation for the `Input.inputSizeSmall` style.
        transform: 'translate(0, 17px) scale(1)',
      },
      t.shrink && {
        transform: 'translate(0, -1.5px) scale(0.75)',
        transformOrigin: 'top left',
        maxWidth: '133%',
      },
      !t.disableAnimation && {
        transition: e.transitions.create(['color', 'transform', 'max-width'], {
          duration: e.transitions.duration.shorter,
          easing: e.transitions.easing.easeOut,
        }),
      },
      t.variant === 'filled' &&
        k(
          {
            // Chrome's autofill feature gives the input field a yellow background.
            // Since the input field is behind the label in the HTML tree,
            // the input field is drawn last and hides the label with an opaque background color.
            // zIndex: 1 will raise the label above opaque background-colors of input.
            zIndex: 1,
            pointerEvents: 'none',
            transform: 'translate(12px, 16px) scale(1)',
            maxWidth: 'calc(100% - 24px)',
          },
          t.size === 'small' && {
            transform: 'translate(12px, 13px) scale(1)',
          },
          t.shrink &&
            k(
              {
                userSelect: 'none',
                pointerEvents: 'auto',
                transform: 'translate(12px, 7px) scale(0.75)',
                maxWidth: 'calc(133% - 24px)',
              },
              t.size === 'small' && {
                transform: 'translate(12px, 4px) scale(0.75)',
              }
            )
        ),
      t.variant === 'outlined' &&
        k(
          {
            // see comment above on filled.zIndex
            zIndex: 1,
            pointerEvents: 'none',
            transform: 'translate(14px, 16px) scale(1)',
            maxWidth: 'calc(100% - 24px)',
          },
          t.size === 'small' && {
            transform: 'translate(14px, 9px) scale(1)',
          },
          t.shrink && {
            userSelect: 'none',
            pointerEvents: 'auto',
            // Theoretically, we should have (8+5)*2/0.75 = 34px
            // but it feels a better when it bleeds a bit on the left, so 32px.
            maxWidth: 'calc(133% - 32px)',
            transform: 'translate(14px, -9px) scale(0.75)',
          }
        )
    )
  ),
  em = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        name: 'MuiInputLabel',
        props: t,
      }),
      { disableAnimation: r = !1, shrink: i, className: s } = o,
      a = pe(o, UB),
      l = er()
    let c = i
    typeof c > 'u' && l && (c = l.filled || l.focused || l.adornedStart)
    const u = Ur({
        props: o,
        muiFormControl: l,
        states: ['size', 'variant', 'required', 'focused'],
      }),
      d = k({}, o, {
        disableAnimation: r,
        formControl: l,
        shrink: c,
        size: u.size,
        variant: u.variant,
        required: u.required,
        focused: u.focused,
      }),
      f = KB(d)
    return /* @__PURE__ */ p.jsx(
      qB,
      k(
        {
          'data-shrink': c,
          ownerState: d,
          ref: n,
          className: de(f.root, s),
        },
        a,
        {
          classes: f,
        }
      )
    )
  }),
  Ri = /* @__PURE__ */ N.createContext({})
function ZB(e) {
  return We('MuiList', e)
}
Qe('MuiList', ['root', 'padding', 'dense', 'subheader'])
const JB = ['children', 'className', 'component', 'dense', 'disablePadding', 'subheader'],
  _B = e => {
    const { classes: t, disablePadding: n, dense: o, subheader: r } = e
    return Ye(
      {
        root: ['root', !n && 'padding', o && 'dense', r && 'subheader'],
      },
      ZB,
      t
    )
  },
  $B = O('ul', {
    name: 'MuiList',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader]
    },
  })(({ ownerState: e }) =>
    k(
      {
        listStyle: 'none',
        margin: 0,
        padding: 0,
        position: 'relative',
      },
      !e.disablePadding && {
        paddingTop: 8,
        paddingBottom: 8,
      },
      e.subheader && {
        paddingTop: 0,
      }
    )
  ),
  eI = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiList',
      }),
      { children: r, className: i, component: s = 'ul', dense: a = !1, disablePadding: l = !1, subheader: c } = o,
      u = pe(o, JB),
      d = N.useMemo(
        () => ({
          dense: a,
        }),
        [a]
      ),
      f = k({}, o, {
        component: s,
        dense: a,
        disablePadding: l,
      }),
      A = _B(f)
    return /* @__PURE__ */ p.jsx(Ri.Provider, {
      value: d,
      children: /* @__PURE__ */ p.jsxs(
        $B,
        k(
          {
            as: s,
            className: de(A.root, i),
            ref: n,
            ownerState: f,
          },
          u,
          {
            children: [c, r],
          }
        )
      ),
    })
  })
function tI(e) {
  return We('MuiListItemIcon', e)
}
const iA = Qe('MuiListItemIcon', ['root', 'alignItemsFlexStart']),
  nI = ['className'],
  oI = e => {
    const { alignItems: t, classes: n } = e
    return Ye(
      {
        root: ['root', t === 'flex-start' && 'alignItemsFlexStart'],
      },
      tI,
      n
    )
  },
  rI = O('div', {
    name: 'MuiListItemIcon',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, n.alignItems === 'flex-start' && t.alignItemsFlexStart]
    },
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        minWidth: 56,
        color: (e.vars || e).palette.action.active,
        flexShrink: 0,
        display: 'inline-flex',
      },
      t.alignItems === 'flex-start' && {
        marginTop: 8,
      }
    )
  ),
  iI = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiListItemIcon',
      }),
      { className: r } = o,
      i = pe(o, nI),
      s = N.useContext(Ri),
      a = k({}, o, {
        alignItems: s.alignItems,
      }),
      l = oI(a)
    return /* @__PURE__ */ p.jsx(
      rI,
      k(
        {
          className: de(l.root, r),
          ownerState: a,
          ref: n,
        },
        i
      )
    )
  })
function sI(e) {
  return We('MuiListItemText', e)
}
const ca = Qe('MuiListItemText', ['root', 'multiline', 'dense', 'inset', 'primary', 'secondary']),
  aI = ['children', 'className', 'disableTypography', 'inset', 'primary', 'primaryTypographyProps', 'secondary', 'secondaryTypographyProps'],
  lI = e => {
    const { classes: t, inset: n, primary: o, secondary: r, dense: i } = e
    return Ye(
      {
        root: ['root', n && 'inset', i && 'dense', o && r && 'multiline'],
        primary: ['primary'],
        secondary: ['secondary'],
      },
      sI,
      t
    )
  },
  cI = O('div', {
    name: 'MuiListItemText',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [
        {
          [`& .${ca.primary}`]: t.primary,
        },
        {
          [`& .${ca.secondary}`]: t.secondary,
        },
        t.root,
        n.inset && t.inset,
        n.primary && n.secondary && t.multiline,
        n.dense && t.dense,
      ]
    },
  })(({ ownerState: e }) =>
    k(
      {
        flex: '1 1 auto',
        minWidth: 0,
        marginTop: 4,
        marginBottom: 4,
      },
      e.primary &&
        e.secondary && {
          marginTop: 6,
          marginBottom: 6,
        },
      e.inset && {
        paddingLeft: 56,
      }
    )
  ),
  uI = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiListItemText',
      }),
      { children: r, className: i, disableTypography: s = !1, inset: a = !1, primary: l, primaryTypographyProps: c, secondary: u, secondaryTypographyProps: d } = o,
      f = pe(o, aI),
      { dense: A } = N.useContext(Ri)
    let h = l ?? r,
      g = u
    const x = k({}, o, {
        disableTypography: s,
        inset: a,
        primary: !!h,
        secondary: !!g,
        dense: A,
      }),
      m = lI(x)
    return (
      h != null &&
        h.type !== Do &&
        !s &&
        (h = /* @__PURE__ */ p.jsx(
          Do,
          k(
            {
              variant: A ? 'body2' : 'body1',
              className: m.primary,
              component: c != null && c.variant ? void 0 : 'span',
              display: 'block',
            },
            c,
            {
              children: h,
            }
          )
        )),
      g != null &&
        g.type !== Do &&
        !s &&
        (g = /* @__PURE__ */ p.jsx(
          Do,
          k(
            {
              variant: 'body2',
              className: m.secondary,
              color: 'text.secondary',
              display: 'block',
            },
            d,
            {
              children: g,
            }
          )
        )),
      /* @__PURE__ */ p.jsxs(
        cI,
        k(
          {
            className: de(m.root, i),
            ownerState: x,
            ref: n,
          },
          f,
          {
            children: [h, g],
          }
        )
      )
    )
  }),
  dI = ['actions', 'autoFocus', 'autoFocusItem', 'children', 'className', 'disabledItemsFocusable', 'disableListWrap', 'onKeyDown', 'variant']
function cc(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild
}
function sA(e, t, n) {
  return e === t ? (n ? e.firstChild : e.lastChild) : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild
}
function tm(e, t) {
  if (t === void 0) return !0
  let n = e.innerText
  return n === void 0 && (n = e.textContent), (n = n.trim().toLowerCase()), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.indexOf(t.keys.join('')) === 0
}
function oi(e, t, n, o, r, i) {
  let s = !1,
    a = r(e, t, t ? n : !1)
  for (; a; ) {
    if (a === e.firstChild) {
      if (s) return !1
      s = !0
    }
    const l = o ? !1 : a.disabled || a.getAttribute('aria-disabled') === 'true'
    if (!a.hasAttribute('tabindex') || !tm(a, i) || l) a = r(e, a, n)
    else return a.focus(), !0
  }
  return !1
}
const nm = /* @__PURE__ */ N.forwardRef(function (t, n) {
  const {
      // private
      // eslint-disable-next-line react/prop-types
      actions: o,
      autoFocus: r = !1,
      autoFocusItem: i = !1,
      children: s,
      className: a,
      disabledItemsFocusable: l = !1,
      disableListWrap: c = !1,
      onKeyDown: u,
      variant: d = 'selectedMenu',
    } = t,
    f = pe(t, dI),
    A = N.useRef(null),
    h = N.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null,
    })
  Mn(() => {
    r && A.current.focus()
  }, [r]),
    N.useImperativeHandle(
      o,
      () => ({
        adjustStyleForScrollbar: (y, { direction: b }) => {
          const C = !A.current.style.width
          if (y.clientHeight < A.current.clientHeight && C) {
            const I = `${Qg(wt(y))}px`
            ;(A.current.style[b === 'rtl' ? 'paddingLeft' : 'paddingRight'] = I), (A.current.style.width = `calc(100% + ${I})`)
          }
          return A.current
        },
      }),
      []
    )
  const g = y => {
      const b = A.current,
        C = y.key,
        I = wt(b).activeElement
      if (C === 'ArrowDown') y.preventDefault(), oi(b, I, c, l, cc)
      else if (C === 'ArrowUp') y.preventDefault(), oi(b, I, c, l, sA)
      else if (C === 'Home') y.preventDefault(), oi(b, null, c, l, cc)
      else if (C === 'End') y.preventDefault(), oi(b, null, c, l, sA)
      else if (C.length === 1) {
        const w = h.current,
          M = C.toLowerCase(),
          L = performance.now()
        w.keys.length > 0 && (L - w.lastTime > 500 ? ((w.keys = []), (w.repeating = !0), (w.previousKeyMatched = !0)) : w.repeating && M !== w.keys[0] && (w.repeating = !1)), (w.lastTime = L), w.keys.push(M)
        const R = I && !w.repeating && tm(I, w)
        w.previousKeyMatched && (R || oi(b, I, !1, l, cc, w)) ? y.preventDefault() : (w.previousKeyMatched = !1)
      }
      u && u(y)
    },
    x = xt(A, n)
  let m = -1
  N.Children.forEach(s, (y, b) => {
    if (!(/* @__PURE__ */ N.isValidElement(y))) {
      m === b && ((m += 1), m >= s.length && (m = -1))
      return
    }
    y.props.disabled || (((d === 'selectedMenu' && y.props.selected) || m === -1) && (m = b)), m === b && (y.props.disabled || y.props.muiSkipListHighlight || y.type.muiSkipListHighlight) && ((m += 1), m >= s.length && (m = -1))
  })
  const v = N.Children.map(s, (y, b) => {
    if (b === m) {
      const C = {}
      return i && (C.autoFocus = !0), y.props.tabIndex === void 0 && d === 'selectedMenu' && (C.tabIndex = 0), /* @__PURE__ */ N.cloneElement(y, C)
    }
    return y
  })
  return /* @__PURE__ */ p.jsx(
    eI,
    k(
      {
        role: 'menu',
        ref: x,
        className: a,
        onKeyDown: g,
        tabIndex: r ? 0 : -1,
      },
      f,
      {
        children: v,
      }
    )
  )
})
function fI(e) {
  return We('MuiPopover', e)
}
Qe('MuiPopover', ['root', 'paper'])
const AI = ['onEntering'],
  pI = ['action', 'anchorEl', 'anchorOrigin', 'anchorPosition', 'anchorReference', 'children', 'className', 'container', 'elevation', 'marginThreshold', 'open', 'PaperProps', 'slots', 'slotProps', 'transformOrigin', 'TransitionComponent', 'transitionDuration', 'TransitionProps', 'disableScrollLock'],
  hI = ['slotProps']
function aA(e, t) {
  let n = 0
  return typeof t == 'number' ? (n = t) : t === 'center' ? (n = e.height / 2) : t === 'bottom' && (n = e.height), n
}
function lA(e, t) {
  let n = 0
  return typeof t == 'number' ? (n = t) : t === 'center' ? (n = e.width / 2) : t === 'right' && (n = e.width), n
}
function cA(e) {
  return [e.horizontal, e.vertical].map(t => (typeof t == 'number' ? `${t}px` : t)).join(' ')
}
function uc(e) {
  return typeof e == 'function' ? e() : e
}
const gI = e => {
    const { classes: t } = e
    return Ye(
      {
        root: ['root'],
        paper: ['paper'],
      },
      fI,
      t
    )
  },
  mI = O(md, {
    name: 'MuiPopover',
    slot: 'Root',
    overridesResolver: (e, t) => t.root,
  })({}),
  om = O(es, {
    name: 'MuiPopover',
    slot: 'Paper',
    overridesResolver: (e, t) => t.paper,
  })({
    position: 'absolute',
    overflowY: 'auto',
    overflowX: 'hidden',
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: 'calc(100% - 32px)',
    maxHeight: 'calc(100% - 32px)',
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
  }),
  rm = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o, r, i
    const s = Oe({
        props: t,
        name: 'MuiPopover',
      }),
      {
        action: a,
        anchorEl: l,
        anchorOrigin: c = {
          vertical: 'top',
          horizontal: 'left',
        },
        anchorPosition: u,
        anchorReference: d = 'anchorEl',
        children: f,
        className: A,
        container: h,
        elevation: g = 8,
        marginThreshold: x = 16,
        open: m,
        PaperProps: v = {},
        slots: y,
        slotProps: b,
        transformOrigin: C = {
          vertical: 'top',
          horizontal: 'left',
        },
        TransitionComponent: I = $g,
        transitionDuration: w = 'auto',
        TransitionProps: { onEntering: M } = {},
        disableScrollLock: L = !1,
      } = s,
      R = pe(s.TransitionProps, AI),
      T = pe(s, pI),
      D = (o = b == null ? void 0 : b.paper) != null ? o : v,
      z = N.useRef(),
      E = xt(z, D.ref),
      P = k({}, s, {
        anchorOrigin: c,
        anchorReference: d,
        elevation: g,
        marginThreshold: x,
        externalPaperSlotProps: D,
        transformOrigin: C,
        TransitionComponent: I,
        transitionDuration: w,
        TransitionProps: R,
      }),
      B = gI(P),
      F = N.useCallback(() => {
        if (d === 'anchorPosition') return u
        const Y = uc(l),
          ee = (Y && Y.nodeType === 1 ? Y : wt(z.current).body).getBoundingClientRect()
        return {
          top: ee.top + aA(ee, c.vertical),
          left: ee.left + lA(ee, c.horizontal),
        }
      }, [l, c.horizontal, c.vertical, u, d]),
      S = N.useCallback(
        Y => ({
          vertical: aA(Y, C.vertical),
          horizontal: lA(Y, C.horizontal),
        }),
        [C.horizontal, C.vertical]
      ),
      Q = N.useCallback(
        Y => {
          const H = {
              width: Y.offsetWidth,
              height: Y.offsetHeight,
            },
            ee = S(H)
          if (d === 'none')
            return {
              top: null,
              left: null,
              transformOrigin: cA(ee),
            }
          const xe = F()
          let Fe = xe.top - ee.vertical,
            De = xe.left - ee.horizontal
          const _e = Fe + H.height,
            Be = De + H.width,
            ke = kn(uc(l)),
            rt = ke.innerHeight - x,
            He = ke.innerWidth - x
          if (x !== null && Fe < x) {
            const Le = Fe - x
            ;(Fe -= Le), (ee.vertical += Le)
          } else if (x !== null && _e > rt) {
            const Le = _e - rt
            ;(Fe -= Le), (ee.vertical += Le)
          }
          if (x !== null && De < x) {
            const Le = De - x
            ;(De -= Le), (ee.horizontal += Le)
          } else if (Be > He) {
            const Le = Be - He
            ;(De -= Le), (ee.horizontal += Le)
          }
          return {
            top: `${Math.round(Fe)}px`,
            left: `${Math.round(De)}px`,
            transformOrigin: cA(ee),
          }
        },
        [l, d, F, S, x]
      ),
      [j, U] = N.useState(m),
      q = N.useCallback(() => {
        const Y = z.current
        if (!Y) return
        const H = Q(Y)
        H.top !== null && (Y.style.top = H.top), H.left !== null && (Y.style.left = H.left), (Y.style.transformOrigin = H.transformOrigin), U(!0)
      }, [Q])
    N.useEffect(() => (L && window.addEventListener('scroll', q), () => window.removeEventListener('scroll', q)), [l, L, q])
    const ne = (Y, H) => {
        M && M(Y, H), q()
      },
      G = () => {
        U(!1)
      }
    N.useEffect(() => {
      m && q()
    }),
      N.useImperativeHandle(
        a,
        () =>
          m
            ? {
                updatePosition: () => {
                  q()
                },
              }
            : null,
        [m, q]
      ),
      N.useEffect(() => {
        if (!m) return
        const Y = fl(() => {
            q()
          }),
          H = kn(l)
        return (
          H.addEventListener('resize', Y),
          () => {
            Y.clear(), H.removeEventListener('resize', Y)
          }
        )
      }, [l, m, q])
    let K = w
    w === 'auto' && !I.muiSupportAuto && (K = void 0)
    const $ = h || (l ? wt(uc(l)).body : void 0),
      oe = (r = y == null ? void 0 : y.root) != null ? r : mI,
      Z = (i = y == null ? void 0 : y.paper) != null ? i : om,
      ie = zt({
        elementType: Z,
        externalSlotProps: k({}, D, {
          style: j
            ? D.style
            : k({}, D.style, {
                opacity: 0,
              }),
        }),
        additionalProps: {
          elevation: g,
          ref: E,
        },
        ownerState: P,
        className: de(B.paper, D == null ? void 0 : D.className),
      }),
      fe = zt({
        elementType: oe,
        externalSlotProps: (b == null ? void 0 : b.root) || {},
        externalForwardedProps: T,
        additionalProps: {
          ref: n,
          slotProps: {
            backdrop: {
              invisible: !0,
            },
          },
          container: $,
          open: m,
        },
        ownerState: P,
        className: de(B.root, A),
      }),
      { slotProps: se } = fe,
      re = pe(fe, hI)
    return /* @__PURE__ */ p.jsx(
      oe,
      k(
        {},
        re,
        !lo(oe) && {
          slotProps: se,
          disableScrollLock: L,
        },
        {
          children: /* @__PURE__ */ p.jsx(
            I,
            k(
              {
                appear: !0,
                in: m,
                onEntering: ne,
                onExited: G,
                timeout: K,
              },
              R,
              {
                children: /* @__PURE__ */ p.jsx(
                  Z,
                  k({}, ie, {
                    children: f,
                  })
                ),
              }
            )
          ),
        }
      )
    )
  })
function yI(e) {
  return We('MuiMenu', e)
}
Qe('MuiMenu', ['root', 'paper', 'list'])
const bI = ['onEntering'],
  vI = ['autoFocus', 'children', 'className', 'disableAutoFocusItem', 'MenuListProps', 'onClose', 'open', 'PaperProps', 'PopoverClasses', 'transitionDuration', 'TransitionProps', 'variant', 'slots', 'slotProps'],
  xI = {
    vertical: 'top',
    horizontal: 'right',
  },
  CI = {
    vertical: 'top',
    horizontal: 'left',
  },
  wI = e => {
    const { classes: t } = e
    return Ye(
      {
        root: ['root'],
        paper: ['paper'],
        list: ['list'],
      },
      yI,
      t
    )
  },
  EI = O(rm, {
    shouldForwardProp: e => Kt(e) || e === 'classes',
    name: 'MuiMenu',
    slot: 'Root',
    overridesResolver: (e, t) => t.root,
  })({}),
  SI = O(om, {
    name: 'MuiMenu',
    slot: 'Paper',
    overridesResolver: (e, t) => t.paper,
  })({
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tappable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: 'calc(100% - 96px)',
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: 'touch',
  }),
  BI = O(nm, {
    name: 'MuiMenu',
    slot: 'List',
    overridesResolver: (e, t) => t.list,
  })({
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
  }),
  II = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o, r
    const i = Oe({
        props: t,
        name: 'MuiMenu',
      }),
      { autoFocus: s = !0, children: a, className: l, disableAutoFocusItem: c = !1, MenuListProps: u = {}, onClose: d, open: f, PaperProps: A = {}, PopoverClasses: h, transitionDuration: g = 'auto', TransitionProps: { onEntering: x } = {}, variant: m = 'selectedMenu', slots: v = {}, slotProps: y = {} } = i,
      b = pe(i.TransitionProps, bI),
      C = pe(i, vI),
      I = od(),
      w = k({}, i, {
        autoFocus: s,
        disableAutoFocusItem: c,
        MenuListProps: u,
        onEntering: x,
        PaperProps: A,
        transitionDuration: g,
        TransitionProps: b,
        variant: m,
      }),
      M = wI(w),
      L = s && !c && f,
      R = N.useRef(null),
      T = (S, Q) => {
        R.current &&
          R.current.adjustStyleForScrollbar(S, {
            direction: I ? 'rtl' : 'ltr',
          }),
          x && x(S, Q)
      },
      D = S => {
        S.key === 'Tab' && (S.preventDefault(), d && d(S, 'tabKeyDown'))
      }
    let z = -1
    N.Children.map(a, (S, Q) => {
      /* @__PURE__ */ N.isValidElement(S) && (S.props.disabled || (((m === 'selectedMenu' && S.props.selected) || z === -1) && (z = Q)))
    })
    const E = (o = v.paper) != null ? o : SI,
      P = (r = y.paper) != null ? r : A,
      B = zt({
        elementType: v.root,
        externalSlotProps: y.root,
        ownerState: w,
        className: [M.root, l],
      }),
      F = zt({
        elementType: E,
        externalSlotProps: P,
        ownerState: w,
        className: M.paper,
      })
    return /* @__PURE__ */ p.jsx(
      EI,
      k(
        {
          onClose: d,
          anchorOrigin: {
            vertical: 'bottom',
            horizontal: I ? 'right' : 'left',
          },
          transformOrigin: I ? xI : CI,
          slots: {
            paper: E,
            root: v.root,
          },
          slotProps: {
            root: B,
            paper: F,
          },
          open: f,
          ref: n,
          transitionDuration: g,
          TransitionProps: k(
            {
              onEntering: T,
            },
            b
          ),
          ownerState: w,
        },
        C,
        {
          classes: h,
          children: /* @__PURE__ */ p.jsx(
            BI,
            k(
              {
                onKeyDown: D,
                actions: R,
                autoFocus: s && (z === -1 || c),
                autoFocusItem: L,
                variant: m,
              },
              u,
              {
                className: de(M.list, u.className),
                children: a,
              }
            )
          ),
        }
      )
    )
  })
function NI(e) {
  return We('MuiMenuItem', e)
}
const ri = Qe('MuiMenuItem', ['root', 'focusVisible', 'dense', 'disabled', 'divider', 'gutters', 'selected']),
  kI = ['autoFocus', 'component', 'dense', 'divider', 'disableGutters', 'focusVisibleClassName', 'role', 'tabIndex', 'className'],
  MI = (e, t) => {
    const { ownerState: n } = e
    return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters]
  },
  PI = e => {
    const { disabled: t, dense: n, divider: o, disableGutters: r, selected: i, classes: s } = e,
      l = Ye(
        {
          root: ['root', n && 'dense', t && 'disabled', !r && 'gutters', o && 'divider', i && 'selected'],
        },
        NI,
        s
      )
    return k({}, s, l)
  },
  LI = O(hd, {
    shouldForwardProp: e => Kt(e) || e === 'classes',
    name: 'MuiMenuItem',
    slot: 'Root',
    overridesResolver: MI,
  })(({ theme: e, ownerState: t }) =>
    k(
      {},
      e.typography.body1,
      {
        display: 'flex',
        justifyContent: 'flex-start',
        alignItems: 'center',
        position: 'relative',
        textDecoration: 'none',
        minHeight: 48,
        paddingTop: 6,
        paddingBottom: 6,
        boxSizing: 'border-box',
        whiteSpace: 'nowrap',
      },
      !t.disableGutters && {
        paddingLeft: 16,
        paddingRight: 16,
      },
      t.divider && {
        borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
        backgroundClip: 'padding-box',
      },
      {
        '&:hover': {
          textDecoration: 'none',
          backgroundColor: (e.vars || e).palette.action.hover,
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent',
          },
        },
        [`&.${ri.selected}`]: {
          backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Lt(e.palette.primary.main, e.palette.action.selectedOpacity),
          [`&.${ri.focusVisible}`]: {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Lt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity),
          },
        },
        [`&.${ri.selected}:hover`]: {
          backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Lt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Lt(e.palette.primary.main, e.palette.action.selectedOpacity),
          },
        },
        [`&.${ri.focusVisible}`]: {
          backgroundColor: (e.vars || e).palette.action.focus,
        },
        [`&.${ri.disabled}`]: {
          opacity: (e.vars || e).palette.action.disabledOpacity,
        },
        [`& + .${$f.root}`]: {
          marginTop: e.spacing(1),
          marginBottom: e.spacing(1),
        },
        [`& + .${$f.inset}`]: {
          marginLeft: 52,
        },
        [`& .${ca.root}`]: {
          marginTop: 0,
          marginBottom: 0,
        },
        [`& .${ca.inset}`]: {
          paddingLeft: 36,
        },
        [`& .${iA.root}`]: {
          minWidth: 36,
        },
      },
      !t.dense && {
        [e.breakpoints.up('sm')]: {
          minHeight: 'auto',
        },
      },
      t.dense &&
        k(
          {
            minHeight: 32,
            // https://m2.material.io/components/menus#specs > Dense
            paddingTop: 4,
            paddingBottom: 4,
          },
          e.typography.body2,
          {
            [`& .${iA.root} svg`]: {
              fontSize: '1.25rem',
            },
          }
        )
    )
  ),
  RI = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiMenuItem',
      }),
      { autoFocus: r = !1, component: i = 'li', dense: s = !1, divider: a = !1, disableGutters: l = !1, focusVisibleClassName: c, role: u = 'menuitem', tabIndex: d, className: f } = o,
      A = pe(o, kI),
      h = N.useContext(Ri),
      g = N.useMemo(
        () => ({
          dense: s || h.dense || !1,
          disableGutters: l,
        }),
        [h.dense, s, l]
      ),
      x = N.useRef(null)
    Mn(() => {
      r && x.current && x.current.focus()
    }, [r])
    const m = k({}, o, {
        dense: g.dense,
        divider: a,
        disableGutters: l,
      }),
      v = PI(o),
      y = xt(x, n)
    let b
    return (
      o.disabled || (b = d !== void 0 ? d : -1),
      /* @__PURE__ */ p.jsx(Ri.Provider, {
        value: g,
        children: /* @__PURE__ */ p.jsx(
          LI,
          k(
            {
              ref: y,
              role: u,
              tabIndex: b,
              component: i,
              focusVisibleClassName: de(v.focusVisible, c),
              className: de(v.root, f),
            },
            A,
            {
              ownerState: m,
              classes: v,
            }
          )
        ),
      })
    )
  })
function TI(e) {
  return We('MuiNativeSelect', e)
}
const vd = Qe('MuiNativeSelect', ['root', 'select', 'multiple', 'filled', 'outlined', 'standard', 'disabled', 'icon', 'iconOpen', 'iconFilled', 'iconOutlined', 'iconStandard', 'nativeInput', 'error']),
  FI = ['className', 'disabled', 'error', 'IconComponent', 'inputRef', 'variant'],
  DI = e => {
    const { classes: t, variant: n, disabled: o, multiple: r, open: i, error: s } = e,
      a = {
        select: ['select', n, o && 'disabled', r && 'multiple', s && 'error'],
        icon: ['icon', `icon${me(n)}`, i && 'iconOpen', o && 'disabled'],
      }
    return Ye(a, TI, t)
  },
  im = ({ ownerState: e, theme: t }) =>
    k(
      {
        MozAppearance: 'none',
        // Reset
        WebkitAppearance: 'none',
        // Reset
        // When interacting quickly, the text can end up selected.
        // Native select can't be selected either.
        userSelect: 'none',
        borderRadius: 0,
        // Reset
        cursor: 'pointer',
        '&:focus': k(
          {},
          t.vars
            ? {
                backgroundColor: `rgba(${t.vars.palette.common.onBackgroundChannel} / 0.05)`,
              }
            : {
                backgroundColor: t.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)',
              },
          {
            borderRadius: 0,
            // Reset Chrome style
          }
        ),
        // Remove IE11 arrow
        '&::-ms-expand': {
          display: 'none',
        },
        [`&.${vd.disabled}`]: {
          cursor: 'default',
        },
        '&[multiple]': {
          height: 'auto',
        },
        '&:not([multiple]) option, &:not([multiple]) optgroup': {
          backgroundColor: (t.vars || t).palette.background.paper,
        },
        // Bump specificity to allow extending custom inputs
        '&&&': {
          paddingRight: 24,
          minWidth: 16,
          // So it doesn't collapse.
        },
      },
      e.variant === 'filled' && {
        '&&&': {
          paddingRight: 32,
        },
      },
      e.variant === 'outlined' && {
        borderRadius: (t.vars || t).shape.borderRadius,
        '&:focus': {
          borderRadius: (t.vars || t).shape.borderRadius,
          // Reset the reset for Chrome style
        },
        '&&&': {
          paddingRight: 32,
        },
      }
    ),
  zI = O('select', {
    name: 'MuiNativeSelect',
    slot: 'Select',
    shouldForwardProp: Kt,
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [
        t.select,
        t[n.variant],
        n.error && t.error,
        {
          [`&.${vd.multiple}`]: t.multiple,
        },
      ]
    },
  })(im),
  sm = ({ ownerState: e, theme: t }) =>
    k(
      {
        // We use a position absolute over a flexbox in order to forward the pointer events
        // to the input and to support wrapping tags..
        position: 'absolute',
        right: 0,
        top: 'calc(50% - .5em)',
        // Center vertically, height is 1em
        pointerEvents: 'none',
        // Don't block pointer events on the select under the icon.
        color: (t.vars || t).palette.action.active,
        [`&.${vd.disabled}`]: {
          color: (t.vars || t).palette.action.disabled,
        },
      },
      e.open && {
        transform: 'rotate(180deg)',
      },
      e.variant === 'filled' && {
        right: 7,
      },
      e.variant === 'outlined' && {
        right: 7,
      }
    ),
  QI = O('svg', {
    name: 'MuiNativeSelect',
    slot: 'Icon',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.icon, n.variant && t[`icon${me(n.variant)}`], n.open && t.iconOpen]
    },
  })(sm),
  OI = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const { className: o, disabled: r, error: i, IconComponent: s, inputRef: a, variant: l = 'standard' } = t,
      c = pe(t, FI),
      u = k({}, t, {
        disabled: r,
        variant: l,
        error: i,
      }),
      d = DI(u)
    return /* @__PURE__ */ p.jsxs(N.Fragment, {
      children: [
        /* @__PURE__ */ p.jsx(
          zI,
          k(
            {
              ownerState: u,
              className: de(d.select, o),
              disabled: r,
              ref: a || n,
            },
            c
          )
        ),
        t.multiple
          ? null
          : /* @__PURE__ */ p.jsx(QI, {
              as: s,
              ownerState: u,
              className: d.icon,
            }),
      ],
    })
  })
var uA
const jI = ['children', 'classes', 'className', 'label', 'notched'],
  WI = O('fieldset', {
    shouldForwardProp: Kt,
  })({
    textAlign: 'left',
    position: 'absolute',
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: '0 8px',
    pointerEvents: 'none',
    borderRadius: 'inherit',
    borderStyle: 'solid',
    borderWidth: 1,
    overflow: 'hidden',
    minWidth: '0%',
  }),
  GI = O('legend', {
    shouldForwardProp: Kt,
  })(({ ownerState: e, theme: t }) =>
    k(
      {
        float: 'unset',
        // Fix conflict with bootstrap
        width: 'auto',
        // Fix conflict with bootstrap
        overflow: 'hidden',
      },
      !e.withLabel && {
        padding: 0,
        lineHeight: '11px',
        // sync with `height` in `legend` styles
        transition: t.transitions.create('width', {
          duration: 150,
          easing: t.transitions.easing.easeOut,
        }),
      },
      e.withLabel &&
        k(
          {
            display: 'block',
            // Fix conflict with normalize.css and sanitize.css
            padding: 0,
            height: 11,
            // sync with `lineHeight` in `legend` styles
            fontSize: '0.75em',
            visibility: 'hidden',
            maxWidth: 0.01,
            transition: t.transitions.create('max-width', {
              duration: 50,
              easing: t.transitions.easing.easeOut,
            }),
            whiteSpace: 'nowrap',
            '& > span': {
              paddingLeft: 5,
              paddingRight: 5,
              display: 'inline-block',
              opacity: 0,
              visibility: 'visible',
            },
          },
          e.notched && {
            maxWidth: '100%',
            transition: t.transitions.create('max-width', {
              duration: 100,
              easing: t.transitions.easing.easeOut,
              delay: 50,
            }),
          }
        )
    )
  )
function VI(e) {
  const { className: t, label: n, notched: o } = e,
    r = pe(e, jI),
    i = n != null && n !== '',
    s = k({}, e, {
      notched: o,
      withLabel: i,
    })
  return /* @__PURE__ */ p.jsx(
    WI,
    k(
      {
        'aria-hidden': !0,
        className: t,
        ownerState: s,
      },
      r,
      {
        children: /* @__PURE__ */ p.jsx(GI, {
          ownerState: s,
          children: i
            ? /* @__PURE__ */ p.jsx('span', {
                children: n,
              })
            : // notranslate needed while Google Translate will not fix zero-width space issue
              uA ||
              (uA = /* @__PURE__ */ p.jsx('span', {
                className: 'notranslate',
                children: '​',
              })),
        }),
      }
    )
  )
}
const XI = ['components', 'fullWidth', 'inputComponent', 'label', 'multiline', 'notched', 'slots', 'type'],
  YI = e => {
    const { classes: t } = e,
      o = Ye(
        {
          root: ['root'],
          notchedOutline: ['notchedOutline'],
          input: ['input'],
        },
        KE,
        t
      )
    return k({}, t, o)
  },
  HI = O(vl, {
    shouldForwardProp: e => Kt(e) || e === 'classes',
    name: 'MuiOutlinedInput',
    slot: 'Root',
    overridesResolver: yl,
  })(({ theme: e, ownerState: t }) => {
    const n = e.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'
    return k(
      {
        position: 'relative',
        borderRadius: (e.vars || e).shape.borderRadius,
        [`&:hover .${to.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.text.primary,
        },
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          [`&:hover .${to.notchedOutline}`]: {
            borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : n,
          },
        },
        [`&.${to.focused} .${to.notchedOutline}`]: {
          borderColor: (e.vars || e).palette[t.color].main,
          borderWidth: 2,
        },
        [`&.${to.error} .${to.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.error.main,
        },
        [`&.${to.disabled} .${to.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.action.disabled,
        },
      },
      t.startAdornment && {
        paddingLeft: 14,
      },
      t.endAdornment && {
        paddingRight: 14,
      },
      t.multiline &&
        k(
          {
            padding: '16.5px 14px',
          },
          t.size === 'small' && {
            padding: '8.5px 14px',
          }
        )
    )
  }),
  UI = O(VI, {
    name: 'MuiOutlinedInput',
    slot: 'NotchedOutline',
    overridesResolver: (e, t) => t.notchedOutline,
  })(({ theme: e }) => {
    const t = e.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'
    return {
      borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t,
    }
  }),
  KI = O(xl, {
    name: 'MuiOutlinedInput',
    slot: 'Input',
    overridesResolver: bl,
  })(({ theme: e, ownerState: t }) =>
    k(
      {
        padding: '16.5px 14px',
      },
      !e.vars && {
        '&:-webkit-autofill': {
          WebkitBoxShadow: e.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset',
          WebkitTextFillColor: e.palette.mode === 'light' ? null : '#fff',
          caretColor: e.palette.mode === 'light' ? null : '#fff',
          borderRadius: 'inherit',
        },
      },
      e.vars && {
        '&:-webkit-autofill': {
          borderRadius: 'inherit',
        },
        [e.getColorSchemeSelector('dark')]: {
          '&:-webkit-autofill': {
            WebkitBoxShadow: '0 0 0 100px #266798 inset',
            WebkitTextFillColor: '#fff',
            caretColor: '#fff',
          },
        },
      },
      t.size === 'small' && {
        padding: '8.5px 14px',
      },
      t.multiline && {
        padding: 0,
      },
      t.startAdornment && {
        paddingLeft: 0,
      },
      t.endAdornment && {
        paddingRight: 0,
      }
    )
  ),
  xd = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o, r, i, s, a
    const l = Oe({
        props: t,
        name: 'MuiOutlinedInput',
      }),
      { components: c = {}, fullWidth: u = !1, inputComponent: d = 'input', label: f, multiline: A = !1, notched: h, slots: g = {}, type: x = 'text' } = l,
      m = pe(l, XI),
      v = YI(l),
      y = er(),
      b = Ur({
        props: l,
        muiFormControl: y,
        states: ['color', 'disabled', 'error', 'focused', 'hiddenLabel', 'size', 'required'],
      }),
      C = k({}, l, {
        color: b.color || 'primary',
        disabled: b.disabled,
        error: b.error,
        focused: b.focused,
        formControl: y,
        fullWidth: u,
        hiddenLabel: b.hiddenLabel,
        multiline: A,
        size: b.size,
        type: x,
      }),
      I = (o = (r = g.root) != null ? r : c.Root) != null ? o : HI,
      w = (i = (s = g.input) != null ? s : c.Input) != null ? i : KI
    return /* @__PURE__ */ p.jsx(
      gd,
      k(
        {
          slots: {
            root: I,
            input: w,
          },
          renderSuffix: M =>
            /* @__PURE__ */ p.jsx(UI, {
              ownerState: C,
              className: v.notchedOutline,
              label:
                f != null && f !== '' && b.required
                  ? a ||
                    (a = /* @__PURE__ */ p.jsxs(N.Fragment, {
                      children: [f, ' ', '*'],
                    }))
                  : f,
              notched: typeof h < 'u' ? h : !!(M.startAdornment || M.filled || M.focused),
            }),
          fullWidth: u,
          inputComponent: d,
          multiline: A,
          ref: n,
          type: x,
        },
        m,
        {
          classes: k({}, v, {
            notchedOutline: null,
          }),
        }
      )
    )
  })
xd.muiName = 'Input'
function qI(e) {
  return We('MuiSelect', e)
}
const ii = Qe('MuiSelect', ['root', 'select', 'multiple', 'filled', 'outlined', 'standard', 'disabled', 'focused', 'icon', 'iconOpen', 'iconFilled', 'iconOutlined', 'iconStandard', 'nativeInput', 'error'])
var dA
const ZI = [
    'aria-describedby',
    'aria-label',
    'autoFocus',
    'autoWidth',
    'children',
    'className',
    'defaultOpen',
    'defaultValue',
    'disabled',
    'displayEmpty',
    'error',
    'IconComponent',
    'inputRef',
    'labelId',
    'MenuProps',
    'multiple',
    'name',
    'onBlur',
    'onChange',
    'onClose',
    'onFocus',
    'onOpen',
    'open',
    'readOnly',
    'renderValue',
    'SelectDisplayProps',
    'tabIndex',
    'type',
    'value',
    'variant',
  ],
  JI = O('div', {
    name: 'MuiSelect',
    slot: 'Select',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [
        // Win specificity over the input base
        {
          [`&.${ii.select}`]: t.select,
        },
        {
          [`&.${ii.select}`]: t[n.variant],
        },
        {
          [`&.${ii.error}`]: t.error,
        },
        {
          [`&.${ii.multiple}`]: t.multiple,
        },
      ]
    },
  })(im, {
    // Win specificity over the input base
    [`&.${ii.select}`]: {
      height: 'auto',
      // Resets for multiple select with chips
      minHeight: '1.4375em',
      // Required for select\text-field height consistency
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      overflow: 'hidden',
    },
  }),
  _I = O('svg', {
    name: 'MuiSelect',
    slot: 'Icon',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.icon, n.variant && t[`icon${me(n.variant)}`], n.open && t.iconOpen]
    },
  })(sm),
  $I = O('input', {
    shouldForwardProp: e => dl(e) && e !== 'classes',
    name: 'MuiSelect',
    slot: 'NativeInput',
    overridesResolver: (e, t) => t.nativeInput,
  })({
    bottom: 0,
    left: 0,
    position: 'absolute',
    opacity: 0,
    pointerEvents: 'none',
    width: '100%',
    boxSizing: 'border-box',
  })
function fA(e, t) {
  return typeof t == 'object' && t !== null ? e === t : String(e) === String(t)
}
function eN(e) {
  return e == null || (typeof e == 'string' && !e.trim())
}
const tN = e => {
    const { classes: t, variant: n, disabled: o, multiple: r, open: i, error: s } = e,
      a = {
        select: ['select', n, o && 'disabled', r && 'multiple', s && 'error'],
        icon: ['icon', `icon${me(n)}`, i && 'iconOpen', o && 'disabled'],
        nativeInput: ['nativeInput'],
      }
    return Ye(a, qI, t)
  },
  nN = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o
    const {
        'aria-describedby': r,
        'aria-label': i,
        autoFocus: s,
        autoWidth: a,
        children: l,
        className: c,
        defaultOpen: u,
        defaultValue: d,
        disabled: f,
        displayEmpty: A,
        error: h = !1,
        IconComponent: g,
        inputRef: x,
        labelId: m,
        MenuProps: v = {},
        multiple: y,
        name: b,
        onBlur: C,
        onChange: I,
        onClose: w,
        onFocus: M,
        onOpen: L,
        open: R,
        readOnly: T,
        renderValue: D,
        SelectDisplayProps: z = {},
        tabIndex: E,
        value: P,
        variant: B = 'standard',
      } = t,
      F = pe(t, ZI),
      [S, Q] = sa({
        controlled: P,
        default: d,
        name: 'Select',
      }),
      [j, U] = sa({
        controlled: R,
        default: u,
        name: 'Select',
      }),
      q = N.useRef(null),
      ne = N.useRef(null),
      [G, K] = N.useState(null),
      { current: $ } = N.useRef(R != null),
      [oe, Z] = N.useState(),
      ie = xt(n, x),
      fe = N.useCallback(J => {
        ;(ne.current = J), J && K(J)
      }, []),
      se = G == null ? void 0 : G.parentNode
    N.useImperativeHandle(
      ie,
      () => ({
        focus: () => {
          ne.current.focus()
        },
        node: q.current,
        value: S,
      }),
      [S]
    ),
      N.useEffect(() => {
        u && j && G && !$ && (Z(a ? null : se.clientWidth), ne.current.focus())
      }, [G, a]),
      N.useEffect(() => {
        s && ne.current.focus()
      }, [s]),
      N.useEffect(() => {
        if (!m) return
        const J = wt(ne.current).getElementById(m)
        if (J) {
          const Ae = () => {
            getSelection().isCollapsed && ne.current.focus()
          }
          return (
            J.addEventListener('click', Ae),
            () => {
              J.removeEventListener('click', Ae)
            }
          )
        }
      }, [m])
    const re = (J, Ae) => {
        J ? L && L(Ae) : w && w(Ae), $ || (Z(a ? null : se.clientWidth), U(J))
      },
      Y = J => {
        J.button === 0 && (J.preventDefault(), ne.current.focus(), re(!0, J))
      },
      H = J => {
        re(!1, J)
      },
      ee = N.Children.toArray(l),
      xe = J => {
        const Ae = ee.find(we => we.props.value === J.target.value)
        Ae !== void 0 && (Q(Ae.props.value), I && I(J, Ae))
      },
      Fe = J => Ae => {
        let we
        if (Ae.currentTarget.hasAttribute('tabindex')) {
          if (y) {
            we = Array.isArray(S) ? S.slice() : []
            const Ie = S.indexOf(J.props.value)
            Ie === -1 ? we.push(J.props.value) : we.splice(Ie, 1)
          } else we = J.props.value
          if ((J.props.onClick && J.props.onClick(Ae), S !== we && (Q(we), I))) {
            const Ie = Ae.nativeEvent || Ae,
              lt = new Ie.constructor(Ie.type, Ie)
            Object.defineProperty(lt, 'target', {
              writable: !0,
              value: {
                value: we,
                name: b,
              },
            }),
              I(lt, J)
          }
          y || re(!1, Ae)
        }
      },
      De = J => {
        T ||
          ([
            ' ',
            'ArrowUp',
            'ArrowDown',
            // The native select doesn't respond to enter on macOS, but it's recommended by
            // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
            'Enter',
          ].indexOf(J.key) !== -1 &&
            (J.preventDefault(), re(!0, J)))
      },
      _e = G !== null && j,
      Be = J => {
        !_e &&
          C &&
          (Object.defineProperty(J, 'target', {
            writable: !0,
            value: {
              value: S,
              name: b,
            },
          }),
          C(J))
      }
    delete F['aria-invalid']
    let ke, rt
    const He = []
    let Le = !1
    ;(la({
      value: S,
    }) ||
      A) &&
      (D ? (ke = D(S)) : (Le = !0))
    const tt = ee.map(J => {
      if (!(/* @__PURE__ */ N.isValidElement(J))) return null
      let Ae
      if (y) {
        if (!Array.isArray(S)) throw new Error(Cr(2))
        ;(Ae = S.some(we => fA(we, J.props.value))), Ae && Le && He.push(J.props.children)
      } else (Ae = fA(S, J.props.value)), Ae && Le && (rt = J.props.children)
      return /* @__PURE__ */ N.cloneElement(J, {
        'aria-selected': Ae ? 'true' : 'false',
        onClick: Fe(J),
        onKeyUp: we => {
          we.key === ' ' && we.preventDefault(), J.props.onKeyUp && J.props.onKeyUp(we)
        },
        role: 'option',
        selected: Ae,
        value: void 0,
        // The value is most likely not a valid HTML attribute.
        'data-value': J.props.value,
        // Instead, we provide it as a data attribute.
      })
    })
    Le && (y ? (He.length === 0 ? (ke = null) : (ke = He.reduce((J, Ae, we) => (J.push(Ae), we < He.length - 1 && J.push(', '), J), []))) : (ke = rt))
    let $e = oe
    !a && $ && G && ($e = se.clientWidth)
    let Ke
    typeof E < 'u' ? (Ke = E) : (Ke = f ? null : 0)
    const V = z.id || (b ? `mui-component-select-${b}` : void 0),
      W = k({}, t, {
        variant: B,
        value: S,
        open: _e,
        error: h,
      }),
      le = tN(W),
      te = k({}, v.PaperProps, (o = v.slotProps) == null ? void 0 : o.paper),
      ce = Al()
    return /* @__PURE__ */ p.jsxs(N.Fragment, {
      children: [
        /* @__PURE__ */ p.jsx(
          JI,
          k(
            {
              ref: fe,
              tabIndex: Ke,
              role: 'combobox',
              'aria-controls': ce,
              'aria-disabled': f ? 'true' : void 0,
              'aria-expanded': _e ? 'true' : 'false',
              'aria-haspopup': 'listbox',
              'aria-label': i,
              'aria-labelledby': [m, V].filter(Boolean).join(' ') || void 0,
              'aria-describedby': r,
              onKeyDown: De,
              onMouseDown: f || T ? null : Y,
              onBlur: Be,
              onFocus: M,
            },
            z,
            {
              ownerState: W,
              className: de(z.className, le.select, c),
              id: V,
              children: eN(ke)
                ? // notranslate needed while Google Translate will not fix zero-width space issue
                  dA ||
                  (dA = /* @__PURE__ */ p.jsx('span', {
                    className: 'notranslate',
                    children: '​',
                  }))
                : ke,
            }
          )
        ),
        /* @__PURE__ */ p.jsx(
          $I,
          k(
            {
              'aria-invalid': h,
              value: Array.isArray(S) ? S.join(',') : S,
              name: b,
              ref: q,
              'aria-hidden': !0,
              onChange: xe,
              tabIndex: -1,
              disabled: f,
              className: le.nativeInput,
              autoFocus: s,
              ownerState: W,
            },
            F
          )
        ),
        /* @__PURE__ */ p.jsx(_I, {
          as: g,
          className: le.icon,
          ownerState: W,
        }),
        /* @__PURE__ */ p.jsx(
          II,
          k(
            {
              id: `menu-${b || ''}`,
              anchorEl: se,
              open: _e,
              onClose: H,
              anchorOrigin: {
                vertical: 'bottom',
                horizontal: 'center',
              },
              transformOrigin: {
                vertical: 'top',
                horizontal: 'center',
              },
            },
            v,
            {
              MenuListProps: k(
                {
                  'aria-labelledby': m,
                  role: 'listbox',
                  'aria-multiselectable': y ? 'true' : void 0,
                  disableListWrap: !0,
                  id: ce,
                },
                v.MenuListProps
              ),
              slotProps: k({}, v.slotProps, {
                paper: k({}, te, {
                  style: k(
                    {
                      minWidth: $e,
                    },
                    te != null ? te.style : null
                  ),
                }),
              }),
              children: tt,
            }
          )
        ),
      ],
    })
  }),
  oN = ['autoWidth', 'children', 'classes', 'className', 'defaultOpen', 'displayEmpty', 'IconComponent', 'id', 'input', 'inputProps', 'label', 'labelId', 'MenuProps', 'multiple', 'native', 'onClose', 'onOpen', 'open', 'renderValue', 'SelectDisplayProps', 'variant'],
  rN = ['root'],
  iN = e => {
    const { classes: t } = e
    return t
  },
  Cd = {
    name: 'MuiSelect',
    overridesResolver: (e, t) => t.root,
    shouldForwardProp: e => Kt(e) && e !== 'variant',
    slot: 'Root',
  },
  sN = O(bd, Cd)(''),
  aN = O(xd, Cd)(''),
  lN = O(yd, Cd)(''),
  wd = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        name: 'MuiSelect',
        props: t,
      }),
      { autoWidth: r = !1, children: i, classes: s = {}, className: a, defaultOpen: l = !1, displayEmpty: c = !1, IconComponent: u = ZE, id: d, input: f, inputProps: A, label: h, labelId: g, MenuProps: x, multiple: m = !1, native: v = !1, onClose: y, onOpen: b, open: C, renderValue: I, SelectDisplayProps: w, variant: M = 'outlined' } = o,
      L = pe(o, oN),
      R = v ? OI : nN,
      T = er(),
      D = Ur({
        props: o,
        muiFormControl: T,
        states: ['variant', 'error'],
      }),
      z = D.variant || M,
      E = k({}, o, {
        variant: z,
        classes: s,
      }),
      P = iN(E),
      B = pe(P, rN),
      F =
        f ||
        {
          standard: /* @__PURE__ */ p.jsx(sN, {
            ownerState: E,
          }),
          outlined: /* @__PURE__ */ p.jsx(aN, {
            label: h,
            ownerState: E,
          }),
          filled: /* @__PURE__ */ p.jsx(lN, {
            ownerState: E,
          }),
        }[z],
      S = xt(n, Hr(F))
    return /* @__PURE__ */ p.jsx(N.Fragment, {
      children: /* @__PURE__ */ N.cloneElement(
        F,
        k(
          {
            // Most of the logic is implemented in `SelectInput`.
            // The `Select` component is a simple API wrapper to expose something better to play with.
            inputComponent: R,
            inputProps: k(
              {
                children: i,
                error: D.error,
                IconComponent: u,
                variant: z,
                type: void 0,
                // We render a select. We can ignore the type provided by the `Input`.
                multiple: m,
              },
              v
                ? {
                    id: d,
                  }
                : {
                    autoWidth: r,
                    defaultOpen: l,
                    displayEmpty: c,
                    labelId: g,
                    MenuProps: x,
                    onClose: y,
                    onOpen: b,
                    open: C,
                    renderValue: I,
                    SelectDisplayProps: k(
                      {
                        id: d,
                      },
                      w
                    ),
                  },
              A,
              {
                classes: A ? Vn(B, A.classes) : B,
              },
              f ? f.props.inputProps : {}
            ),
          },
          ((m && v) || c) && z === 'outlined'
            ? {
                notched: !0,
              }
            : {},
          {
            ref: S,
            className: de(F.props.className, a, P.root),
          },
          !f && {
            variant: z,
          },
          L
        )
      ),
    })
  })
wd.muiName = 'Select'
function cN(e, t, n = (o, r) => o === r) {
  return e.length === t.length && e.every((o, r) => n(o, t[r]))
}
const uN = 2
function am(e, t) {
  return e - t
}
function AA(e, t) {
  var n
  const { index: o } =
    (n = e.reduce((r, i, s) => {
      const a = Math.abs(t - i)
      return r === null || a < r.distance || a === r.distance
        ? {
            distance: a,
            index: s,
          }
        : r
    }, null)) != null
      ? n
      : {}
  return o
}
function ms(e, t) {
  if (t.current !== void 0 && e.changedTouches) {
    const n = e
    for (let o = 0; o < n.changedTouches.length; o += 1) {
      const r = n.changedTouches[o]
      if (r.identifier === t.current)
        return {
          x: r.clientX,
          y: r.clientY,
        }
    }
    return !1
  }
  return {
    x: e.clientX,
    y: e.clientY,
  }
}
function ua(e, t, n) {
  return ((e - t) * 100) / (n - t)
}
function dN(e, t, n) {
  return (n - t) * e + t
}
function fN(e) {
  if (Math.abs(e) < 1) {
    const n = e.toExponential().split('e-'),
      o = n[0].split('.')[1]
    return (o ? o.length : 0) + parseInt(n[1], 10)
  }
  const t = e.toString().split('.')[1]
  return t ? t.length : 0
}
function AN(e, t, n) {
  const o = Math.round((e - n) / t) * t + n
  return Number(o.toFixed(fN(t)))
}
function pA({ values: e, newValue: t, index: n }) {
  const o = e.slice()
  return (o[n] = t), o.sort(am)
}
function ys({ sliderRef: e, activeIndex: t, setActive: n }) {
  var o, r
  const i = wt(e.current)
  if (!((o = e.current) != null && o.contains(i.activeElement)) || Number(i == null || (r = i.activeElement) == null ? void 0 : r.getAttribute('data-index')) !== t) {
    var s
    ;(s = e.current) == null || s.querySelector(`[type="range"][data-index="${t}"]`).focus()
  }
  n && n(t)
}
function bs(e, t) {
  return typeof e == 'number' && typeof t == 'number' ? e === t : typeof e == 'object' && typeof t == 'object' ? cN(e, t) : !1
}
const pN = {
    horizontal: {
      offset: e => ({
        left: `${e}%`,
      }),
      leap: e => ({
        width: `${e}%`,
      }),
    },
    'horizontal-reverse': {
      offset: e => ({
        right: `${e}%`,
      }),
      leap: e => ({
        width: `${e}%`,
      }),
    },
    vertical: {
      offset: e => ({
        bottom: `${e}%`,
      }),
      leap: e => ({
        height: `${e}%`,
      }),
    },
  },
  hN = e => e
let vs
function hA() {
  return vs === void 0 && (typeof CSS < 'u' && typeof CSS.supports == 'function' ? (vs = CSS.supports('touch-action', 'none')) : (vs = !0)), vs
}
function gN(e) {
  const { 'aria-labelledby': t, defaultValue: n, disabled: o = !1, disableSwap: r = !1, isRtl: i = !1, marks: s = !1, max: a = 100, min: l = 0, name: c, onChange: u, onChangeCommitted: d, orientation: f = 'horizontal', rootRef: A, scale: h = hN, step: g = 1, shiftStep: x = 10, tabIndex: m, value: v } = e,
    y = N.useRef(void 0),
    [b, C] = N.useState(-1),
    [I, w] = N.useState(-1),
    [M, L] = N.useState(!1),
    R = N.useRef(0),
    [T, D] = sa({
      controlled: v,
      default: n ?? l,
      name: 'Slider',
    }),
    z =
      u &&
      ((V, W, le) => {
        const te = V.nativeEvent || V,
          ce = new te.constructor(te.type, te)
        Object.defineProperty(ce, 'target', {
          writable: !0,
          value: {
            value: W,
            name: c,
          },
        }),
          u(ce, W, le)
      }),
    E = Array.isArray(T)
  let P = E ? T.slice().sort(am) : [T]
  P = P.map(V => (V == null ? l : ti(V, l, a)))
  const B =
      s === !0 && g !== null
        ? [...Array(Math.floor((a - l) / g) + 1)].map((V, W) => ({
            value: l + g * W,
          }))
        : s || [],
    F = B.map(V => V.value),
    { isFocusVisibleRef: S, onBlur: Q, onFocus: j, ref: U } = ud(),
    [q, ne] = N.useState(-1),
    G = N.useRef(null),
    K = xt(U, G),
    $ = xt(A, K),
    oe = V => W => {
      var le
      const te = Number(W.currentTarget.getAttribute('data-index'))
      j(W), S.current === !0 && ne(te), w(te), V == null || (le = V.onFocus) == null || le.call(V, W)
    },
    Z = V => W => {
      var le
      Q(W), S.current === !1 && ne(-1), w(-1), V == null || (le = V.onBlur) == null || le.call(V, W)
    },
    ie = (V, W) => {
      const le = Number(V.currentTarget.getAttribute('data-index')),
        te = P[le],
        ce = F.indexOf(te)
      let J = W
      if (B && g == null) {
        const Ae = F[F.length - 1]
        J > Ae ? (J = Ae) : J < F[0] ? (J = F[0]) : (J = J < te ? F[ce - 1] : F[ce + 1])
      }
      if (((J = ti(J, l, a)), E)) {
        r && (J = ti(J, P[le - 1] || -1 / 0, P[le + 1] || 1 / 0))
        const Ae = J
        J = pA({
          values: P,
          newValue: J,
          index: le,
        })
        let we = le
        r || (we = J.indexOf(Ae)),
          ys({
            sliderRef: G,
            activeIndex: we,
          })
      }
      D(J), ne(le), z && !bs(J, T) && z(V, J, le), d && d(V, J)
    },
    fe = V => W => {
      var le
      if (g !== null) {
        const te = Number(W.currentTarget.getAttribute('data-index')),
          ce = P[te]
        let J = null
        ;((W.key === 'ArrowLeft' || W.key === 'ArrowDown') && W.shiftKey) || W.key === 'PageDown' ? (J = Math.max(ce - x, l)) : (((W.key === 'ArrowRight' || W.key === 'ArrowUp') && W.shiftKey) || W.key === 'PageUp') && (J = Math.min(ce + x, a)), J !== null && (ie(W, J), W.preventDefault())
      }
      V == null || (le = V.onKeyDown) == null || le.call(V, W)
    }
  Mn(() => {
    if (o && G.current.contains(document.activeElement)) {
      var V
      ;(V = document.activeElement) == null || V.blur()
    }
  }, [o]),
    o && b !== -1 && C(-1),
    o && q !== -1 && ne(-1)
  const se = V => W => {
      var le
      ;(le = V.onChange) == null || le.call(V, W), ie(W, W.target.valueAsNumber)
    },
    re = N.useRef(void 0)
  let Y = f
  i && f === 'horizontal' && (Y += '-reverse')
  const H = ({ finger: V, move: W = !1 }) => {
      const { current: le } = G,
        { width: te, height: ce, bottom: J, left: Ae } = le.getBoundingClientRect()
      let we
      Y.indexOf('vertical') === 0 ? (we = (J - V.y) / ce) : (we = (V.x - Ae) / te), Y.indexOf('-reverse') !== -1 && (we = 1 - we)
      let Ie
      if (((Ie = dN(we, l, a)), g)) Ie = AN(Ie, g, l)
      else {
        const Zt = AA(F, Ie)
        Ie = F[Zt]
      }
      Ie = ti(Ie, l, a)
      let lt = 0
      if (E) {
        W ? (lt = re.current) : (lt = AA(P, Ie)), r && (Ie = ti(Ie, P[lt - 1] || -1 / 0, P[lt + 1] || 1 / 0))
        const Zt = Ie
        ;(Ie = pA({
          values: P,
          newValue: Ie,
          index: lt,
        })),
          (r && W) || ((lt = Ie.indexOf(Zt)), (re.current = lt))
      }
      return {
        newValue: Ie,
        activeIndex: lt,
      }
    },
    ee = Sn(V => {
      const W = ms(V, y)
      if (!W) return
      if (((R.current += 1), V.type === 'mousemove' && V.buttons === 0)) {
        xe(V)
        return
      }
      const { newValue: le, activeIndex: te } = H({
        finger: W,
        move: !0,
      })
      ys({
        sliderRef: G,
        activeIndex: te,
        setActive: C,
      }),
        D(le),
        !M && R.current > uN && L(!0),
        z && !bs(le, T) && z(V, le, te)
    }),
    xe = Sn(V => {
      const W = ms(V, y)
      if ((L(!1), !W)) return
      const { newValue: le } = H({
        finger: W,
        move: !0,
      })
      C(-1), V.type === 'touchend' && w(-1), d && d(V, le), (y.current = void 0), De()
    }),
    Fe = Sn(V => {
      if (o) return
      hA() || V.preventDefault()
      const W = V.changedTouches[0]
      W != null && (y.current = W.identifier)
      const le = ms(V, y)
      if (le !== !1) {
        const { newValue: ce, activeIndex: J } = H({
          finger: le,
        })
        ys({
          sliderRef: G,
          activeIndex: J,
          setActive: C,
        }),
          D(ce),
          z && !bs(ce, T) && z(V, ce, J)
      }
      R.current = 0
      const te = wt(G.current)
      te.addEventListener('touchmove', ee, {
        passive: !0,
      }),
        te.addEventListener('touchend', xe, {
          passive: !0,
        })
    }),
    De = N.useCallback(() => {
      const V = wt(G.current)
      V.removeEventListener('mousemove', ee), V.removeEventListener('mouseup', xe), V.removeEventListener('touchmove', ee), V.removeEventListener('touchend', xe)
    }, [xe, ee])
  N.useEffect(() => {
    const { current: V } = G
    return (
      V.addEventListener('touchstart', Fe, {
        passive: hA(),
      }),
      () => {
        V.removeEventListener('touchstart', Fe), De()
      }
    )
  }, [De, Fe]),
    N.useEffect(() => {
      o && De()
    }, [o, De])
  const _e = V => W => {
      var le
      if (((le = V.onMouseDown) == null || le.call(V, W), o || W.defaultPrevented || W.button !== 0)) return
      W.preventDefault()
      const te = ms(W, y)
      if (te !== !1) {
        const { newValue: J, activeIndex: Ae } = H({
          finger: te,
        })
        ys({
          sliderRef: G,
          activeIndex: Ae,
          setActive: C,
        }),
          D(J),
          z && !bs(J, T) && z(W, J, Ae)
      }
      R.current = 0
      const ce = wt(G.current)
      ce.addEventListener('mousemove', ee, {
        passive: !0,
      }),
        ce.addEventListener('mouseup', xe)
    },
    Be = ua(E ? P[0] : l, l, a),
    ke = ua(P[P.length - 1], l, a) - Be,
    rt = (V = {}) => {
      const W = Ci(V),
        le = {
          onMouseDown: _e(W || {}),
        },
        te = k({}, W, le)
      return k(
        {},
        V,
        {
          ref: $,
        },
        te
      )
    },
    He = V => W => {
      var le
      ;(le = V.onMouseOver) == null || le.call(V, W)
      const te = Number(W.currentTarget.getAttribute('data-index'))
      w(te)
    },
    Le = V => W => {
      var le
      ;(le = V.onMouseLeave) == null || le.call(V, W), w(-1)
    }
  return {
    active: b,
    axis: Y,
    axisProps: pN,
    dragging: M,
    focusedThumbIndex: q,
    getHiddenInputProps: (V = {}) => {
      var W
      const le = Ci(V),
        te = {
          onChange: se(le || {}),
          onFocus: oe(le || {}),
          onBlur: Z(le || {}),
          onKeyDown: fe(le || {}),
        },
        ce = k({}, le, te)
      return k(
        {
          tabIndex: m,
          'aria-labelledby': t,
          'aria-orientation': f,
          'aria-valuemax': h(a),
          'aria-valuemin': h(l),
          name: c,
          type: 'range',
          min: e.min,
          max: e.max,
          step: e.step === null && e.marks ? 'any' : (W = e.step) != null ? W : void 0,
          disabled: o,
        },
        V,
        ce,
        {
          style: k({}, Vw, {
            direction: i ? 'rtl' : 'ltr',
            // So that VoiceOver's focus indicator matches the thumb's dimensions
            width: '100%',
            height: '100%',
          }),
        }
      )
    },
    getRootProps: rt,
    getThumbProps: (V = {}) => {
      const W = Ci(V),
        le = {
          onMouseOver: He(W || {}),
          onMouseLeave: Le(W || {}),
        }
      return k({}, V, W, le)
    },
    marks: B,
    open: I,
    range: E,
    rootRef: $,
    trackLeap: ke,
    trackOffset: Be,
    values: P,
    getThumbStyle: V => ({
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: b !== -1 && b !== V ? 'none' : void 0,
    }),
  }
}
const mN = e => !e || !lo(e)
function yN(e) {
  return We('MuiSlider', e)
}
const tn = Qe('MuiSlider', [
    'root',
    'active',
    'colorPrimary',
    'colorSecondary',
    'colorError',
    'colorInfo',
    'colorSuccess',
    'colorWarning',
    'disabled',
    'dragging',
    'focusVisible',
    'mark',
    'markActive',
    'marked',
    'markLabel',
    'markLabelActive',
    'rail',
    'sizeSmall',
    'thumb',
    'thumbColorPrimary',
    'thumbColorSecondary',
    'thumbColorError',
    'thumbColorSuccess',
    'thumbColorInfo',
    'thumbColorWarning',
    'track',
    'trackInverted',
    'trackFalse',
    'thumbSizeSmall',
    'valueLabel',
    'valueLabelOpen',
    'valueLabelCircle',
    'valueLabelLabel',
    'vertical',
  ]),
  bN = e => {
    const { open: t } = e
    return {
      offset: de(t && tn.valueLabelOpen),
      circle: tn.valueLabelCircle,
      label: tn.valueLabelLabel,
    }
  }
function vN(e) {
  const { children: t, className: n, value: o } = e,
    r = bN(e)
  return t
    ? /* @__PURE__ */ N.cloneElement(
        t,
        {
          className: de(t.props.className),
        },
        /* @__PURE__ */ p.jsxs(N.Fragment, {
          children: [
            t.props.children,
            /* @__PURE__ */ p.jsx('span', {
              className: de(r.offset, n),
              'aria-hidden': !0,
              children: /* @__PURE__ */ p.jsx('span', {
                className: r.circle,
                children: /* @__PURE__ */ p.jsx('span', {
                  className: r.label,
                  children: o,
                }),
              }),
            }),
          ],
        })
      )
    : null
}
const xN = [
  'aria-label',
  'aria-valuetext',
  'aria-labelledby',
  'component',
  'components',
  'componentsProps',
  'color',
  'classes',
  'className',
  'disableSwap',
  'disabled',
  'getAriaLabel',
  'getAriaValueText',
  'marks',
  'max',
  'min',
  'name',
  'onChange',
  'onChangeCommitted',
  'orientation',
  'shiftStep',
  'size',
  'step',
  'scale',
  'slotProps',
  'slots',
  'tabIndex',
  'track',
  'value',
  'valueLabelDisplay',
  'valueLabelFormat',
]
function gA(e) {
  return e
}
const CN = O('span', {
    name: 'MuiSlider',
    slot: 'Root',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.root, t[`color${me(n.color)}`], n.size !== 'medium' && t[`size${me(n.size)}`], n.marked && t.marked, n.orientation === 'vertical' && t.vertical, n.track === 'inverted' && t.trackInverted, n.track === !1 && t.trackFalse]
    },
  })(({ theme: e }) => {
    var t
    return {
      borderRadius: 12,
      boxSizing: 'content-box',
      display: 'inline-block',
      position: 'relative',
      cursor: 'pointer',
      touchAction: 'none',
      WebkitTapHighlightColor: 'transparent',
      '@media print': {
        colorAdjust: 'exact',
      },
      [`&.${tn.disabled}`]: {
        pointerEvents: 'none',
        cursor: 'default',
        color: (e.vars || e).palette.grey[400],
      },
      [`&.${tn.dragging}`]: {
        [`& .${tn.thumb}, & .${tn.track}`]: {
          transition: 'none',
        },
      },
      variants: [
        ...Object.keys(((t = e.vars) != null ? t : e).palette)
          .filter(n => {
            var o
            return ((o = e.vars) != null ? o : e).palette[n].main
          })
          .map(n => ({
            props: {
              color: n,
            },
            style: {
              color: (e.vars || e).palette[n].main,
            },
          })),
        {
          props: {
            orientation: 'horizontal',
          },
          style: {
            height: 4,
            width: '100%',
            padding: '13px 0',
            // The primary input mechanism of the device includes a pointing device of limited accuracy.
            '@media (pointer: coarse)': {
              // Reach 42px touch target, about ~8mm on screen.
              padding: '20px 0',
            },
          },
        },
        {
          props: {
            orientation: 'horizontal',
            size: 'small',
          },
          style: {
            height: 2,
          },
        },
        {
          props: {
            orientation: 'horizontal',
            marked: !0,
          },
          style: {
            marginBottom: 20,
          },
        },
        {
          props: {
            orientation: 'vertical',
          },
          style: {
            height: '100%',
            width: 4,
            padding: '0 13px',
            // The primary input mechanism of the device includes a pointing device of limited accuracy.
            '@media (pointer: coarse)': {
              // Reach 42px touch target, about ~8mm on screen.
              padding: '0 20px',
            },
          },
        },
        {
          props: {
            orientation: 'vertical',
            size: 'small',
          },
          style: {
            width: 2,
          },
        },
        {
          props: {
            orientation: 'vertical',
            marked: !0,
          },
          style: {
            marginRight: 44,
          },
        },
      ],
    }
  }),
  wN = O('span', {
    name: 'MuiSlider',
    slot: 'Rail',
    overridesResolver: (e, t) => t.rail,
  })({
    display: 'block',
    position: 'absolute',
    borderRadius: 'inherit',
    backgroundColor: 'currentColor',
    opacity: 0.38,
    variants: [
      {
        props: {
          orientation: 'horizontal',
        },
        style: {
          width: '100%',
          height: 'inherit',
          top: '50%',
          transform: 'translateY(-50%)',
        },
      },
      {
        props: {
          orientation: 'vertical',
        },
        style: {
          height: '100%',
          width: 'inherit',
          left: '50%',
          transform: 'translateX(-50%)',
        },
      },
      {
        props: {
          track: 'inverted',
        },
        style: {
          opacity: 1,
        },
      },
    ],
  }),
  EN = O('span', {
    name: 'MuiSlider',
    slot: 'Track',
    overridesResolver: (e, t) => t.track,
  })(({ theme: e }) => {
    var t
    return {
      display: 'block',
      position: 'absolute',
      borderRadius: 'inherit',
      border: '1px solid currentColor',
      backgroundColor: 'currentColor',
      transition: e.transitions.create(['left', 'width', 'bottom', 'height'], {
        duration: e.transitions.duration.shortest,
      }),
      variants: [
        {
          props: {
            size: 'small',
          },
          style: {
            border: 'none',
          },
        },
        {
          props: {
            orientation: 'horizontal',
          },
          style: {
            height: 'inherit',
            top: '50%',
            transform: 'translateY(-50%)',
          },
        },
        {
          props: {
            orientation: 'vertical',
          },
          style: {
            width: 'inherit',
            left: '50%',
            transform: 'translateX(-50%)',
          },
        },
        {
          props: {
            track: !1,
          },
          style: {
            display: 'none',
          },
        },
        ...Object.keys(((t = e.vars) != null ? t : e).palette)
          .filter(n => {
            var o
            return ((o = e.vars) != null ? o : e).palette[n].main
          })
          .map(n => ({
            props: {
              color: n,
              track: 'inverted',
            },
            style: k(
              {},
              e.vars
                ? {
                    backgroundColor: e.vars.palette.Slider[`${n}Track`],
                    borderColor: e.vars.palette.Slider[`${n}Track`],
                  }
                : k(
                    {
                      backgroundColor: Uc(e.palette[n].main, 0.62),
                      borderColor: Uc(e.palette[n].main, 0.62),
                    },
                    e.applyStyles('dark', {
                      backgroundColor: Hc(e.palette[n].main, 0.5),
                    }),
                    e.applyStyles('dark', {
                      borderColor: Hc(e.palette[n].main, 0.5),
                    })
                  )
            ),
          })),
      ],
    }
  }),
  SN = O('span', {
    name: 'MuiSlider',
    slot: 'Thumb',
    overridesResolver: (e, t) => {
      const { ownerState: n } = e
      return [t.thumb, t[`thumbColor${me(n.color)}`], n.size !== 'medium' && t[`thumbSize${me(n.size)}`]]
    },
  })(({ theme: e }) => {
    var t
    return {
      position: 'absolute',
      width: 20,
      height: 20,
      boxSizing: 'border-box',
      borderRadius: '50%',
      outline: 0,
      backgroundColor: 'currentColor',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      transition: e.transitions.create(['box-shadow', 'left', 'bottom'], {
        duration: e.transitions.duration.shortest,
      }),
      '&::before': {
        position: 'absolute',
        content: '""',
        borderRadius: 'inherit',
        width: '100%',
        height: '100%',
        boxShadow: (e.vars || e).shadows[2],
      },
      '&::after': {
        position: 'absolute',
        content: '""',
        borderRadius: '50%',
        // 42px is the hit target
        width: 42,
        height: 42,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
      },
      [`&.${tn.disabled}`]: {
        '&:hover': {
          boxShadow: 'none',
        },
      },
      variants: [
        {
          props: {
            size: 'small',
          },
          style: {
            width: 12,
            height: 12,
            '&::before': {
              boxShadow: 'none',
            },
          },
        },
        {
          props: {
            orientation: 'horizontal',
          },
          style: {
            top: '50%',
            transform: 'translate(-50%, -50%)',
          },
        },
        {
          props: {
            orientation: 'vertical',
          },
          style: {
            left: '50%',
            transform: 'translate(-50%, 50%)',
          },
        },
        ...Object.keys(((t = e.vars) != null ? t : e).palette)
          .filter(n => {
            var o
            return ((o = e.vars) != null ? o : e).palette[n].main
          })
          .map(n => ({
            props: {
              color: n,
            },
            style: {
              [`&:hover, &.${tn.focusVisible}`]: k(
                {},
                e.vars
                  ? {
                      boxShadow: `0px 0px 0px 8px rgba(${e.vars.palette[n].mainChannel} / 0.16)`,
                    }
                  : {
                      boxShadow: `0px 0px 0px 8px ${Lt(e.palette[n].main, 0.16)}`,
                    },
                {
                  '@media (hover: none)': {
                    boxShadow: 'none',
                  },
                }
              ),
              [`&.${tn.active}`]: k(
                {},
                e.vars
                  ? {
                      boxShadow: `0px 0px 0px 14px rgba(${e.vars.palette[n].mainChannel} / 0.16)`,
                    }
                  : {
                      boxShadow: `0px 0px 0px 14px ${Lt(e.palette[n].main, 0.16)}`,
                    }
              ),
            },
          })),
      ],
    }
  }),
  BN = O(vN, {
    name: 'MuiSlider',
    slot: 'ValueLabel',
    overridesResolver: (e, t) => t.valueLabel,
  })(({ theme: e }) =>
    k(
      {
        zIndex: 1,
        whiteSpace: 'nowrap',
      },
      e.typography.body2,
      {
        fontWeight: 500,
        transition: e.transitions.create(['transform'], {
          duration: e.transitions.duration.shortest,
        }),
        position: 'absolute',
        backgroundColor: (e.vars || e).palette.grey[600],
        borderRadius: 2,
        color: (e.vars || e).palette.common.white,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '0.25rem 0.75rem',
        variants: [
          {
            props: {
              orientation: 'horizontal',
            },
            style: {
              transform: 'translateY(-100%) scale(0)',
              top: '-10px',
              transformOrigin: 'bottom center',
              '&::before': {
                position: 'absolute',
                content: '""',
                width: 8,
                height: 8,
                transform: 'translate(-50%, 50%) rotate(45deg)',
                backgroundColor: 'inherit',
                bottom: 0,
                left: '50%',
              },
              [`&.${tn.valueLabelOpen}`]: {
                transform: 'translateY(-100%) scale(1)',
              },
            },
          },
          {
            props: {
              orientation: 'vertical',
            },
            style: {
              transform: 'translateY(-50%) scale(0)',
              right: '30px',
              top: '50%',
              transformOrigin: 'right center',
              '&::before': {
                position: 'absolute',
                content: '""',
                width: 8,
                height: 8,
                transform: 'translate(-50%, -50%) rotate(45deg)',
                backgroundColor: 'inherit',
                right: -8,
                top: '50%',
              },
              [`&.${tn.valueLabelOpen}`]: {
                transform: 'translateY(-50%) scale(1)',
              },
            },
          },
          {
            props: {
              size: 'small',
            },
            style: {
              fontSize: e.typography.pxToRem(12),
              padding: '0.25rem 0.5rem',
            },
          },
          {
            props: {
              orientation: 'vertical',
              size: 'small',
            },
            style: {
              right: '20px',
            },
          },
        ],
      }
    )
  ),
  IN = O('span', {
    name: 'MuiSlider',
    slot: 'Mark',
    shouldForwardProp: e => dl(e) && e !== 'markActive',
    overridesResolver: (e, t) => {
      const { markActive: n } = e
      return [t.mark, n && t.markActive]
    },
  })(({ theme: e }) => ({
    position: 'absolute',
    width: 2,
    height: 2,
    borderRadius: 1,
    backgroundColor: 'currentColor',
    variants: [
      {
        props: {
          orientation: 'horizontal',
        },
        style: {
          top: '50%',
          transform: 'translate(-1px, -50%)',
        },
      },
      {
        props: {
          orientation: 'vertical',
        },
        style: {
          left: '50%',
          transform: 'translate(-50%, 1px)',
        },
      },
      {
        props: {
          markActive: !0,
        },
        style: {
          backgroundColor: (e.vars || e).palette.background.paper,
          opacity: 0.8,
        },
      },
    ],
  })),
  NN = O('span', {
    name: 'MuiSlider',
    slot: 'MarkLabel',
    shouldForwardProp: e => dl(e) && e !== 'markLabelActive',
    overridesResolver: (e, t) => t.markLabel,
  })(({ theme: e }) =>
    k({}, e.typography.body2, {
      color: (e.vars || e).palette.text.secondary,
      position: 'absolute',
      whiteSpace: 'nowrap',
      variants: [
        {
          props: {
            orientation: 'horizontal',
          },
          style: {
            top: 30,
            transform: 'translateX(-50%)',
            '@media (pointer: coarse)': {
              top: 40,
            },
          },
        },
        {
          props: {
            orientation: 'vertical',
          },
          style: {
            left: 36,
            transform: 'translateY(50%)',
            '@media (pointer: coarse)': {
              left: 44,
            },
          },
        },
        {
          props: {
            markLabelActive: !0,
          },
          style: {
            color: (e.vars || e).palette.text.primary,
          },
        },
      ],
    })
  ),
  kN = e => {
    const { disabled: t, dragging: n, marked: o, orientation: r, track: i, classes: s, color: a, size: l } = e,
      c = {
        root: ['root', t && 'disabled', n && 'dragging', o && 'marked', r === 'vertical' && 'vertical', i === 'inverted' && 'trackInverted', i === !1 && 'trackFalse', a && `color${me(a)}`, l && `size${me(l)}`],
        rail: ['rail'],
        track: ['track'],
        mark: ['mark'],
        markActive: ['markActive'],
        markLabel: ['markLabel'],
        markLabelActive: ['markLabelActive'],
        valueLabel: ['valueLabel'],
        thumb: ['thumb', t && 'disabled', l && `thumbSize${me(l)}`, a && `thumbColor${me(a)}`],
        active: ['active'],
        disabled: ['disabled'],
        focusVisible: ['focusVisible'],
      }
    return Ye(c, yN, s)
  },
  MN = ({ children: e }) => e,
  lm = /* @__PURE__ */ N.forwardRef(function (t, n) {
    var o, r, i, s, a, l, c, u, d, f, A, h, g, x, m, v, y, b, C, I, w, M, L, R
    const T = Oe({
        props: t,
        name: 'MuiSlider',
      }),
      D = od(),
      {
        'aria-label': z,
        'aria-valuetext': E,
        'aria-labelledby': P,
        // eslint-disable-next-line react/prop-types
        component: B = 'span',
        components: F = {},
        componentsProps: S = {},
        color: Q = 'primary',
        classes: j,
        className: U,
        disableSwap: q = !1,
        disabled: ne = !1,
        getAriaLabel: G,
        getAriaValueText: K,
        marks: $ = !1,
        max: oe = 100,
        min: Z = 0,
        orientation: ie = 'horizontal',
        shiftStep: fe = 10,
        size: se = 'medium',
        step: re = 1,
        scale: Y = gA,
        slotProps: H,
        slots: ee,
        track: xe = 'normal',
        valueLabelDisplay: Fe = 'off',
        valueLabelFormat: De = gA,
      } = T,
      _e = pe(T, xN),
      Be = k({}, T, {
        isRtl: D,
        max: oe,
        min: Z,
        classes: j,
        disabled: ne,
        disableSwap: q,
        orientation: ie,
        marks: $,
        color: Q,
        size: se,
        step: re,
        shiftStep: fe,
        scale: Y,
        track: xe,
        valueLabelDisplay: Fe,
        valueLabelFormat: De,
      }),
      {
        axisProps: ke,
        getRootProps: rt,
        getHiddenInputProps: He,
        getThumbProps: Le,
        open: tt,
        active: $e,
        axis: Ke,
        focusedThumbIndex: V,
        range: W,
        dragging: le,
        marks: te,
        values: ce,
        trackOffset: J,
        trackLeap: Ae,
        getThumbStyle: we,
      } = gN(
        k({}, Be, {
          rootRef: n,
        })
      )
    ;(Be.marked = te.length > 0 && te.some(ze => ze.label)), (Be.dragging = le), (Be.focusedThumbIndex = V)
    const Ie = kN(Be),
      lt = (o = (r = ee == null ? void 0 : ee.root) != null ? r : F.Root) != null ? o : CN,
      Zt = (i = (s = ee == null ? void 0 : ee.rail) != null ? s : F.Rail) != null ? i : wN,
      Fn = (a = (l = ee == null ? void 0 : ee.track) != null ? l : F.Track) != null ? a : EN,
      nr = (c = (u = ee == null ? void 0 : ee.thumb) != null ? u : F.Thumb) != null ? c : SN,
      or = (d = (f = ee == null ? void 0 : ee.valueLabel) != null ? f : F.ValueLabel) != null ? d : BN,
      go = (A = (h = ee == null ? void 0 : ee.mark) != null ? h : F.Mark) != null ? A : IN,
      mo = (g = (x = ee == null ? void 0 : ee.markLabel) != null ? x : F.MarkLabel) != null ? g : NN,
      yo = (m = (v = ee == null ? void 0 : ee.input) != null ? v : F.Input) != null ? m : 'input',
      bo = (y = H == null ? void 0 : H.root) != null ? y : S.root,
      qr = (b = H == null ? void 0 : H.rail) != null ? b : S.rail,
      vo = (C = H == null ? void 0 : H.track) != null ? C : S.track,
      xo = (I = H == null ? void 0 : H.thumb) != null ? I : S.thumb,
      Co = (w = H == null ? void 0 : H.valueLabel) != null ? w : S.valueLabel,
      Zr = (M = H == null ? void 0 : H.mark) != null ? M : S.mark,
      Jr = (L = H == null ? void 0 : H.markLabel) != null ? L : S.markLabel,
      _r = (R = H == null ? void 0 : H.input) != null ? R : S.input,
      $r = zt({
        elementType: lt,
        getSlotProps: rt,
        externalSlotProps: bo,
        externalForwardedProps: _e,
        additionalProps: k(
          {},
          mN(lt) && {
            as: B,
          }
        ),
        ownerState: k({}, Be, bo == null ? void 0 : bo.ownerState),
        className: [Ie.root, U],
      }),
      ae = zt({
        elementType: Zt,
        externalSlotProps: qr,
        ownerState: Be,
        className: Ie.rail,
      }),
      ue = zt({
        elementType: Fn,
        externalSlotProps: vo,
        additionalProps: {
          style: k({}, ke[Ke].offset(J), ke[Ke].leap(Ae)),
        },
        ownerState: k({}, Be, vo == null ? void 0 : vo.ownerState),
        className: Ie.track,
      }),
      Me = zt({
        elementType: nr,
        getSlotProps: Le,
        externalSlotProps: xo,
        ownerState: k({}, Be, xo == null ? void 0 : xo.ownerState),
        className: Ie.thumb,
      }),
      he = zt({
        elementType: or,
        externalSlotProps: Co,
        ownerState: k({}, Be, Co == null ? void 0 : Co.ownerState),
        className: Ie.valueLabel,
      }),
      Ee = zt({
        elementType: go,
        externalSlotProps: Zr,
        ownerState: Be,
        className: Ie.mark,
      }),
      nt = zt({
        elementType: mo,
        externalSlotProps: Jr,
        ownerState: Be,
        className: Ie.markLabel,
      }),
      vt = zt({
        elementType: yo,
        getSlotProps: He,
        externalSlotProps: _r,
        ownerState: Be,
      })
    return /* @__PURE__ */ p.jsxs(
      lt,
      k({}, $r, {
        children: [
          /* @__PURE__ */ p.jsx(Zt, k({}, ae)),
          /* @__PURE__ */ p.jsx(Fn, k({}, ue)),
          te
            .filter(ze => ze.value >= Z && ze.value <= oe)
            .map((ze, it) => {
              const eo = ua(ze.value, Z, oe),
                Dn = ke[Ke].offset(eo)
              let Dt
              return (
                xe === !1 ? (Dt = ce.indexOf(ze.value) !== -1) : (Dt = (xe === 'normal' && (W ? ze.value >= ce[0] && ze.value <= ce[ce.length - 1] : ze.value <= ce[0])) || (xe === 'inverted' && (W ? ze.value <= ce[0] || ze.value >= ce[ce.length - 1] : ze.value >= ce[0]))),
                /* @__PURE__ */ p.jsxs(
                  N.Fragment,
                  {
                    children: [
                      /* @__PURE__ */ p.jsx(
                        go,
                        k(
                          {
                            'data-index': it,
                          },
                          Ee,
                          !lo(go) && {
                            markActive: Dt,
                          },
                          {
                            style: k({}, Dn, Ee.style),
                            className: de(Ee.className, Dt && Ie.markActive),
                          }
                        )
                      ),
                      ze.label != null
                        ? /* @__PURE__ */ p.jsx(
                            mo,
                            k(
                              {
                                'aria-hidden': !0,
                                'data-index': it,
                              },
                              nt,
                              !lo(mo) && {
                                markLabelActive: Dt,
                              },
                              {
                                style: k({}, Dn, nt.style),
                                className: de(Ie.markLabel, nt.className, Dt && Ie.markLabelActive),
                                children: ze.label,
                              }
                            )
                          )
                        : null,
                    ],
                  },
                  it
                )
              )
            }),
          ce.map((ze, it) => {
            const eo = ua(ze, Z, oe),
              Dn = ke[Ke].offset(eo),
              Dt = Fe === 'off' ? MN : or
            return (
              /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
              /* @__PURE__ */ p.jsx(
                Dt,
                k(
                  {},
                  !lo(Dt) && {
                    valueLabelFormat: De,
                    valueLabelDisplay: Fe,
                    value: typeof De == 'function' ? De(Y(ze), it) : De,
                    index: it,
                    open: tt === it || $e === it || Fe === 'on',
                    disabled: ne,
                  },
                  he,
                  {
                    children: /* @__PURE__ */ p.jsx(
                      nr,
                      k(
                        {
                          'data-index': it,
                        },
                        Me,
                        {
                          className: de(Ie.thumb, Me.className, $e === it && Ie.active, V === it && Ie.focusVisible),
                          style: k({}, Dn, we(it), Me.style),
                          children: /* @__PURE__ */ p.jsx(
                            yo,
                            k(
                              {
                                'data-index': it,
                                'aria-label': G ? G(it) : z,
                                'aria-valuenow': Y(ze),
                                'aria-labelledby': P,
                                'aria-valuetext': K ? K(Y(ze), it) : E,
                                value: ce[it],
                              },
                              vt
                            )
                          ),
                        }
                      )
                    ),
                  }
                ),
                it
              )
            )
          }),
        ],
      })
    )
  })
function PN(e) {
  return We('MuiTextField', e)
}
Qe('MuiTextField', ['root'])
const LN = [
    'autoComplete',
    'autoFocus',
    'children',
    'className',
    'color',
    'defaultValue',
    'disabled',
    'error',
    'FormHelperTextProps',
    'fullWidth',
    'helperText',
    'id',
    'InputLabelProps',
    'inputProps',
    'InputProps',
    'inputRef',
    'label',
    'maxRows',
    'minRows',
    'multiline',
    'name',
    'onBlur',
    'onChange',
    'onFocus',
    'placeholder',
    'required',
    'rows',
    'select',
    'SelectProps',
    'type',
    'value',
    'variant',
  ],
  RN = {
    standard: bd,
    filled: yd,
    outlined: xd,
  },
  TN = e => {
    const { classes: t } = e
    return Ye(
      {
        root: ['root'],
      },
      PN,
      t
    )
  },
  FN = O(Jg, {
    name: 'MuiTextField',
    slot: 'Root',
    overridesResolver: (e, t) => t.root,
  })({}),
  cm = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const o = Oe({
        props: t,
        name: 'MuiTextField',
      }),
      {
        autoComplete: r,
        autoFocus: i = !1,
        children: s,
        className: a,
        color: l = 'primary',
        defaultValue: c,
        disabled: u = !1,
        error: d = !1,
        FormHelperTextProps: f,
        fullWidth: A = !1,
        helperText: h,
        id: g,
        InputLabelProps: x,
        inputProps: m,
        InputProps: v,
        inputRef: y,
        label: b,
        maxRows: C,
        minRows: I,
        multiline: w = !1,
        name: M,
        onBlur: L,
        onChange: R,
        onFocus: T,
        placeholder: D,
        required: z = !1,
        rows: E,
        select: P = !1,
        SelectProps: B,
        type: F,
        value: S,
        variant: Q = 'outlined',
      } = o,
      j = pe(o, LN),
      U = k({}, o, {
        autoFocus: i,
        color: l,
        disabled: u,
        error: d,
        fullWidth: A,
        multiline: w,
        required: z,
        select: P,
        variant: Q,
      }),
      q = TN(U),
      ne = {}
    Q === 'outlined' && (x && typeof x.shrink < 'u' && (ne.notched = x.shrink), (ne.label = b)), P && ((!B || !B.native) && (ne.id = void 0), (ne['aria-describedby'] = void 0))
    const G = Al(g),
      K = h && G ? `${G}-helper-text` : void 0,
      $ = b && G ? `${G}-label` : void 0,
      oe = RN[Q],
      Z = /* @__PURE__ */ p.jsx(
        oe,
        k(
          {
            'aria-describedby': K,
            autoComplete: r,
            autoFocus: i,
            defaultValue: c,
            fullWidth: A,
            multiline: w,
            name: M,
            rows: E,
            maxRows: C,
            minRows: I,
            type: F,
            value: S,
            id: G,
            inputRef: y,
            onBlur: L,
            onChange: R,
            onFocus: T,
            placeholder: D,
            inputProps: m,
          },
          ne,
          v
        )
      )
    return /* @__PURE__ */ p.jsxs(
      FN,
      k(
        {
          className: de(q.root, a),
          disabled: u,
          error: d,
          fullWidth: A,
          ref: n,
          required: z,
          color: l,
          variant: Q,
          ownerState: U,
        },
        j,
        {
          children: [
            b != null &&
              b !== '' &&
              /* @__PURE__ */ p.jsx(
                em,
                k(
                  {
                    htmlFor: G,
                    id: $,
                  },
                  x,
                  {
                    children: b,
                  }
                )
              ),
            P
              ? /* @__PURE__ */ p.jsx(
                  wd,
                  k(
                    {
                      'aria-describedby': K,
                      id: G,
                      labelId: $,
                      value: S,
                      input: Z,
                    },
                    B,
                    {
                      children: s,
                    }
                  )
                )
              : Z,
            h &&
              /* @__PURE__ */ p.jsx(
                _g,
                k(
                  {
                    id: K,
                  },
                  f,
                  {
                    children: h,
                  }
                )
              ),
          ],
        }
      )
    )
  }),
  DN = {
    appEnvironment: 'local',
  },
  zN = po(DN),
  Cl = {
    appName: 'React Flow App',
    appVersion: '0.0.0',
    appEnvironment: 'local',
    apiUrl: '',
    historyDeepness: 256,
    edgeParameters: {
      minEdgeDiameterInches: 1,
      maxEdgeDiameterInches: 100,
      edgeDiameterIncrementStep: 0.5,
      edgeDiameterDecrementStep: 0.5,
      minEdgeLengthFeet: 5,
      maxEdgeLengthFeet: 500,
      edgeLengthFeetIncrementStep: 5,
      edgeLengthFeetDecrementStep: 5,
      minEdgeParallelSets: 1,
      maxEdgeParallelSets: 20,
      edgeParallelSetsIncrementStep: 1,
      edgeParallelSetsDecrementStep: 1,
      maxEdgeConductors: 4,
      minEdgeConductorAmount: 1,
      maxEdgeConductorAmount: 100,
      edgeConductorAmountIncrementStep: 1,
      edgeConductorAmountDecrementStep: 1,
    },
    subNodeParameters: {
      minAmpereRating: 0,
      maxAmpereRating: 1e3,
      defaultAmpereRating: 1,
      minPoles: 1,
      maxPoles: 10,
      defaultPoles: 3,
      polesIncrementStep: 1,
      polesDecrementStep: 1,
      minCopies: 1,
      maxCopies: 8,
    },
  },
  QN = po(Cl),
  ON = ({ config: e, children: t }) => /* @__PURE__ */ p.jsx(QN.Provider, { value: e, children: t }),
  Ed = e => ({
    x: e.clientX,
    y: e.clientY,
  }),
  Sd = (e, t) => ({
    top: e.clientY < t.height - 200 ? e.clientY : void 0,
    left: e.clientX < t.width - 200 ? e.clientX : void 0,
    right: e.clientX >= t.width - 200 ? t.width - e.clientX : void 0,
    bottom: e.clientY >= t.height - 200 ? t.height - e.clientY : void 0,
  }),
  jN = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i
function WN(e) {
  return typeof e == 'string' && jN.test(e)
}
var St = []
for (var dc = 0; dc < 256; ++dc) St.push((dc + 256).toString(16).slice(1))
function GN(e, t = 0) {
  return (St[e[t + 0]] + St[e[t + 1]] + St[e[t + 2]] + St[e[t + 3]] + '-' + St[e[t + 4]] + St[e[t + 5]] + '-' + St[e[t + 6]] + St[e[t + 7]] + '-' + St[e[t + 8]] + St[e[t + 9]] + '-' + St[e[t + 10]] + St[e[t + 11]] + St[e[t + 12]] + St[e[t + 13]] + St[e[t + 14]] + St[e[t + 15]]).toLowerCase()
}
var xs,
  VN = new Uint8Array(16)
function XN() {
  if (!xs && ((xs = typeof crypto < 'u' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)), !xs)) throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported')
  return xs(VN)
}
var YN = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto)
const mA = {
  randomUUID: YN,
}
function HN(e, t, n) {
  if (mA.randomUUID && !t && !e) return mA.randomUUID()
  e = e || {}
  var o = e.random || (e.rng || XN)()
  return (o[6] = (o[6] & 15) | 64), (o[8] = (o[8] & 63) | 128), GN(o)
}
const Ho = e => HN(e),
  nu = e => {
    if (!WN(e)) return e
    const t = e.split('-')
    return t[t.length - 1]
  },
  UN = (e, { filename: t } = {}) => {
    const n = document.createElement('a')
    ;(n.href = e), t && (n.download = t), document.body.appendChild(n), n.click(), document.body.removeChild(n)
  }
function KN(e) {
  if (!e || typeof e != 'object') throw new TypeError('Passed json is not an object')
}
function qN(e) {
  if ((KN(e), !('nodes' in e) || !('edges' in e))) throw new Error('nodes and/or edges property are missing in the save file')
  if (!Array.isArray(e.nodes) || !Array.isArray(e.edges)) throw new TypeError('nodes and/or edges are not of an array type')
}
const At = (e = {}) => ({ ...e }),
  ZN = e => Object.entries(e).reduce((t, n) => ({ ...t, [n[1]]: n[0] }), {}),
  JN = () => {
    const e = /* @__PURE__ */ new Date(),
      t = e.toDateString(),
      n = e.toTimeString().slice(0, 8)
    return `Flow ${t} ${n}.json`
  }
function _N(e, t, n = 5) {
  var l, c, u, d
  const o = {
      horizontal: void 0,
      vertical: void 0,
      snapPosition: { x: void 0, y: void 0 },
    },
    r = t.find(f => f.id === e.id)
  if (!r || !e.position) return o
  const i = {
    left: e.position.x,
    right: e.position.x + (((l = r.measured) == null ? void 0 : l.width) ?? 0),
    top: e.position.y,
    bottom: e.position.y + (((c = r.measured) == null ? void 0 : c.height) ?? 0),
    width: ((u = r.measured) == null ? void 0 : u.width) ?? 0,
    height: ((d = r.measured) == null ? void 0 : d.height) ?? 0,
  }
  let s = n,
    a = n
  return t
    .filter(f => f.id !== r.id)
    .reduce((f, A) => {
      var w, M, L, R
      const h = {
          left: A.position.x,
          right: A.position.x + (((w = A.measured) == null ? void 0 : w.width) ?? 0),
          top: A.position.y,
          bottom: A.position.y + (((M = A.measured) == null ? void 0 : M.height) ?? 0),
          width: ((L = A.measured) == null ? void 0 : L.width) ?? 0,
          height: ((R = A.measured) == null ? void 0 : R.height) ?? 0,
        },
        g = Math.abs(i.left - h.left)
      g < a && ((f.snapPosition.x = h.left), (f.vertical = h.left), (a = g))
      const x = Math.abs(i.right - h.right)
      x < a && ((f.snapPosition.x = h.right - i.width), (f.vertical = h.right), (a = x))
      const m = Math.abs(i.left - h.right)
      m < a && ((f.snapPosition.x = h.right), (f.vertical = h.right), (a = m))
      const v = Math.abs(i.right - h.left)
      v < a && ((f.snapPosition.x = h.left - i.width), (f.vertical = h.left), (a = v))
      const y = Math.abs(i.top - h.top)
      y < s && ((f.snapPosition.y = h.top), (f.horizontal = h.top), (s = y))
      const b = Math.abs(i.bottom - h.top)
      b < s && ((f.snapPosition.y = h.top - i.height), (f.horizontal = h.top), (s = b))
      const C = Math.abs(i.bottom - h.bottom)
      C < s && ((f.snapPosition.y = h.bottom - i.height), (f.horizontal = h.bottom), (s = C))
      const I = Math.abs(i.top - h.bottom)
      return I < s && ((f.snapPosition.y = h.bottom), (f.horizontal = h.bottom), (s = I)), f
    }, o)
}
const ou = (e, t) => t.filter(n => n.parentId === e.id),
  um = e => ('label' in e.data && typeof e.data.label == 'string' && e.data.label) || void 0,
  Ir = e => um(e) ?? nu(e.id) ?? e.id
function bt(e) {
  if (typeof e == 'string' || typeof e == 'number') return '' + e
  let t = ''
  if (Array.isArray(e)) for (let n = 0, o; n < e.length; n++) (o = bt(e[n])) !== '' && (t += (t && ' ') + o)
  else for (let n in e) e[n] && (t += (t && ' ') + n)
  return t
}
var $N = { value: () => {} }
function wl() {
  for (var e = 0, t = arguments.length, n = {}, o; e < t; ++e) {
    if (!(o = arguments[e] + '') || o in n || /[\s.]/.test(o)) throw new Error('illegal type: ' + o)
    n[o] = []
  }
  return new Ks(n)
}
function Ks(e) {
  this._ = e
}
function ek(e, t) {
  return e
    .trim()
    .split(/^|\s+/)
    .map(function (n) {
      var o = '',
        r = n.indexOf('.')
      if ((r >= 0 && ((o = n.slice(r + 1)), (n = n.slice(0, r))), n && !t.hasOwnProperty(n))) throw new Error('unknown type: ' + n)
      return { type: n, name: o }
    })
}
Ks.prototype = wl.prototype = {
  constructor: Ks,
  on: function (e, t) {
    var n = this._,
      o = ek(e + '', n),
      r,
      i = -1,
      s = o.length
    if (arguments.length < 2) {
      for (; ++i < s; ) if ((r = (e = o[i]).type) && (r = tk(n[r], e.name))) return r
      return
    }
    if (t != null && typeof t != 'function') throw new Error('invalid callback: ' + t)
    for (; ++i < s; )
      if ((r = (e = o[i]).type)) n[r] = yA(n[r], e.name, t)
      else if (t == null) for (r in n) n[r] = yA(n[r], e.name, null)
    return this
  },
  copy: function () {
    var e = {},
      t = this._
    for (var n in t) e[n] = t[n].slice()
    return new Ks(e)
  },
  call: function (e, t) {
    if ((r = arguments.length - 2) > 0) for (var n = new Array(r), o = 0, r, i; o < r; ++o) n[o] = arguments[o + 2]
    if (!this._.hasOwnProperty(e)) throw new Error('unknown type: ' + e)
    for (i = this._[e], o = 0, r = i.length; o < r; ++o) i[o].value.apply(t, n)
  },
  apply: function (e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error('unknown type: ' + e)
    for (var o = this._[e], r = 0, i = o.length; r < i; ++r) o[r].value.apply(t, n)
  },
}
function tk(e, t) {
  for (var n = 0, o = e.length, r; n < o; ++n) if ((r = e[n]).name === t) return r.value
}
function yA(e, t, n) {
  for (var o = 0, r = e.length; o < r; ++o)
    if (e[o].name === t) {
      ;(e[o] = $N), (e = e.slice(0, o).concat(e.slice(o + 1)))
      break
    }
  return n != null && e.push({ name: t, value: n }), e
}
var ru = 'http://www.w3.org/1999/xhtml'
const bA = {
  svg: 'http://www.w3.org/2000/svg',
  xhtml: ru,
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace',
  xmlns: 'http://www.w3.org/2000/xmlns/',
}
function El(e) {
  var t = (e += ''),
    n = t.indexOf(':')
  return n >= 0 && (t = e.slice(0, n)) !== 'xmlns' && (e = e.slice(n + 1)), bA.hasOwnProperty(t) ? { space: bA[t], local: e } : e
}
function nk(e) {
  return function () {
    var t = this.ownerDocument,
      n = this.namespaceURI
    return n === ru && t.documentElement.namespaceURI === ru ? t.createElement(e) : t.createElementNS(n, e)
  }
}
function ok(e) {
  return function () {
    return this.ownerDocument.createElementNS(e.space, e.local)
  }
}
function dm(e) {
  var t = El(e)
  return (t.local ? ok : nk)(t)
}
function rk() {}
function Bd(e) {
  return e == null
    ? rk
    : function () {
        return this.querySelector(e)
      }
}
function ik(e) {
  typeof e != 'function' && (e = Bd(e))
  for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r) for (var i = t[r], s = i.length, a = (o[r] = new Array(s)), l, c, u = 0; u < s; ++u) (l = i[u]) && (c = e.call(l, l.__data__, u, i)) && ('__data__' in l && (c.__data__ = l.__data__), (a[u] = c))
  return new Ht(o, this._parents)
}
function sk(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e)
}
function ak() {
  return []
}
function fm(e) {
  return e == null
    ? ak
    : function () {
        return this.querySelectorAll(e)
      }
}
function lk(e) {
  return function () {
    return sk(e.apply(this, arguments))
  }
}
function ck(e) {
  typeof e == 'function' ? (e = lk(e)) : (e = fm(e))
  for (var t = this._groups, n = t.length, o = [], r = [], i = 0; i < n; ++i) for (var s = t[i], a = s.length, l, c = 0; c < a; ++c) (l = s[c]) && (o.push(e.call(l, l.__data__, c, s)), r.push(l))
  return new Ht(o, r)
}
function Am(e) {
  return function () {
    return this.matches(e)
  }
}
function pm(e) {
  return function (t) {
    return t.matches(e)
  }
}
var uk = Array.prototype.find
function dk(e) {
  return function () {
    return uk.call(this.children, e)
  }
}
function fk() {
  return this.firstElementChild
}
function Ak(e) {
  return this.select(e == null ? fk : dk(typeof e == 'function' ? e : pm(e)))
}
var pk = Array.prototype.filter
function hk() {
  return Array.from(this.children)
}
function gk(e) {
  return function () {
    return pk.call(this.children, e)
  }
}
function mk(e) {
  return this.selectAll(e == null ? hk : gk(typeof e == 'function' ? e : pm(e)))
}
function yk(e) {
  typeof e != 'function' && (e = Am(e))
  for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r) for (var i = t[r], s = i.length, a = (o[r] = []), l, c = 0; c < s; ++c) (l = i[c]) && e.call(l, l.__data__, c, i) && a.push(l)
  return new Ht(o, this._parents)
}
function hm(e) {
  return new Array(e.length)
}
function bk() {
  return new Ht(this._enter || this._groups.map(hm), this._parents)
}
function da(e, t) {
  ;(this.ownerDocument = e.ownerDocument), (this.namespaceURI = e.namespaceURI), (this._next = null), (this._parent = e), (this.__data__ = t)
}
da.prototype = {
  constructor: da,
  appendChild: function (e) {
    return this._parent.insertBefore(e, this._next)
  },
  insertBefore: function (e, t) {
    return this._parent.insertBefore(e, t)
  },
  querySelector: function (e) {
    return this._parent.querySelector(e)
  },
  querySelectorAll: function (e) {
    return this._parent.querySelectorAll(e)
  },
}
function vk(e) {
  return function () {
    return e
  }
}
function xk(e, t, n, o, r, i) {
  for (var s = 0, a, l = t.length, c = i.length; s < c; ++s) (a = t[s]) ? ((a.__data__ = i[s]), (o[s] = a)) : (n[s] = new da(e, i[s]))
  for (; s < l; ++s) (a = t[s]) && (r[s] = a)
}
function Ck(e, t, n, o, r, i, s) {
  var a,
    l,
    c = /* @__PURE__ */ new Map(),
    u = t.length,
    d = i.length,
    f = new Array(u),
    A
  for (a = 0; a < u; ++a) (l = t[a]) && ((f[a] = A = s.call(l, l.__data__, a, t) + ''), c.has(A) ? (r[a] = l) : c.set(A, l))
  for (a = 0; a < d; ++a) (A = s.call(e, i[a], a, i) + ''), (l = c.get(A)) ? ((o[a] = l), (l.__data__ = i[a]), c.delete(A)) : (n[a] = new da(e, i[a]))
  for (a = 0; a < u; ++a) (l = t[a]) && c.get(f[a]) === l && (r[a] = l)
}
function wk(e) {
  return e.__data__
}
function Ek(e, t) {
  if (!arguments.length) return Array.from(this, wk)
  var n = t ? Ck : xk,
    o = this._parents,
    r = this._groups
  typeof e != 'function' && (e = vk(e))
  for (var i = r.length, s = new Array(i), a = new Array(i), l = new Array(i), c = 0; c < i; ++c) {
    var u = o[c],
      d = r[c],
      f = d.length,
      A = Sk(e.call(u, u && u.__data__, c, o)),
      h = A.length,
      g = (a[c] = new Array(h)),
      x = (s[c] = new Array(h)),
      m = (l[c] = new Array(f))
    n(u, d, g, x, m, A, t)
    for (var v = 0, y = 0, b, C; v < h; ++v)
      if ((b = g[v])) {
        for (v >= y && (y = v + 1); !(C = x[y]) && ++y < h; );
        b._next = C || null
      }
  }
  return (s = new Ht(s, o)), (s._enter = a), (s._exit = l), s
}
function Sk(e) {
  return typeof e == 'object' && 'length' in e ? e : Array.from(e)
}
function Bk() {
  return new Ht(this._exit || this._groups.map(hm), this._parents)
}
function Ik(e, t, n) {
  var o = this.enter(),
    r = this,
    i = this.exit()
  return typeof e == 'function' ? ((o = e(o)), o && (o = o.selection())) : (o = o.append(e + '')), t != null && ((r = t(r)), r && (r = r.selection())), n == null ? i.remove() : n(i), o && r ? o.merge(r).order() : r
}
function Nk(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, o = t._groups, r = n.length, i = o.length, s = Math.min(r, i), a = new Array(r), l = 0; l < s; ++l) for (var c = n[l], u = o[l], d = c.length, f = (a[l] = new Array(d)), A, h = 0; h < d; ++h) (A = c[h] || u[h]) && (f[h] = A)
  for (; l < r; ++l) a[l] = n[l]
  return new Ht(a, this._parents)
}
function kk() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; ) for (var o = e[t], r = o.length - 1, i = o[r], s; --r >= 0; ) (s = o[r]) && (i && s.compareDocumentPosition(i) ^ 4 && i.parentNode.insertBefore(s, i), (i = s))
  return this
}
function Mk(e) {
  e || (e = Pk)
  function t(d, f) {
    return d && f ? e(d.__data__, f.__data__) : !d - !f
  }
  for (var n = this._groups, o = n.length, r = new Array(o), i = 0; i < o; ++i) {
    for (var s = n[i], a = s.length, l = (r[i] = new Array(a)), c, u = 0; u < a; ++u) (c = s[u]) && (l[u] = c)
    l.sort(t)
  }
  return new Ht(r, this._parents).order()
}
function Pk(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
}
function Lk() {
  var e = arguments[0]
  return (arguments[0] = this), e.apply(null, arguments), this
}
function Rk() {
  return Array.from(this)
}
function Tk() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], r = 0, i = o.length; r < i; ++r) {
      var s = o[r]
      if (s) return s
    }
  return null
}
function Fk() {
  let e = 0
  for (const t of this) ++e
  return e
}
function Dk() {
  return !this.node()
}
function zk(e) {
  for (var t = this._groups, n = 0, o = t.length; n < o; ++n) for (var r = t[n], i = 0, s = r.length, a; i < s; ++i) (a = r[i]) && e.call(a, a.__data__, i, r)
  return this
}
function Qk(e) {
  return function () {
    this.removeAttribute(e)
  }
}
function Ok(e) {
  return function () {
    this.removeAttributeNS(e.space, e.local)
  }
}
function jk(e, t) {
  return function () {
    this.setAttribute(e, t)
  }
}
function Wk(e, t) {
  return function () {
    this.setAttributeNS(e.space, e.local, t)
  }
}
function Gk(e, t) {
  return function () {
    var n = t.apply(this, arguments)
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n)
  }
}
function Vk(e, t) {
  return function () {
    var n = t.apply(this, arguments)
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n)
  }
}
function Xk(e, t) {
  var n = El(e)
  if (arguments.length < 2) {
    var o = this.node()
    return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n)
  }
  return this.each((t == null ? (n.local ? Ok : Qk) : typeof t == 'function' ? (n.local ? Vk : Gk) : n.local ? Wk : jk)(n, t))
}
function gm(e) {
  return (e.ownerDocument && e.ownerDocument.defaultView) || (e.document && e) || e.defaultView
}
function Yk(e) {
  return function () {
    this.style.removeProperty(e)
  }
}
function Hk(e, t, n) {
  return function () {
    this.style.setProperty(e, t, n)
  }
}
function Uk(e, t, n) {
  return function () {
    var o = t.apply(this, arguments)
    o == null ? this.style.removeProperty(e) : this.style.setProperty(e, o, n)
  }
}
function Kk(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? Yk : typeof t == 'function' ? Uk : Hk)(e, t, n ?? '')) : Nr(this.node(), e)
}
function Nr(e, t) {
  return e.style.getPropertyValue(t) || gm(e).getComputedStyle(e, null).getPropertyValue(t)
}
function qk(e) {
  return function () {
    delete this[e]
  }
}
function Zk(e, t) {
  return function () {
    this[e] = t
  }
}
function Jk(e, t) {
  return function () {
    var n = t.apply(this, arguments)
    n == null ? delete this[e] : (this[e] = n)
  }
}
function _k(e, t) {
  return arguments.length > 1 ? this.each((t == null ? qk : typeof t == 'function' ? Jk : Zk)(e, t)) : this.node()[e]
}
function mm(e) {
  return e.trim().split(/^|\s+/)
}
function Id(e) {
  return e.classList || new ym(e)
}
function ym(e) {
  ;(this._node = e), (this._names = mm(e.getAttribute('class') || ''))
}
ym.prototype = {
  add: function (e) {
    var t = this._names.indexOf(e)
    t < 0 && (this._names.push(e), this._node.setAttribute('class', this._names.join(' ')))
  },
  remove: function (e) {
    var t = this._names.indexOf(e)
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute('class', this._names.join(' ')))
  },
  contains: function (e) {
    return this._names.indexOf(e) >= 0
  },
}
function bm(e, t) {
  for (var n = Id(e), o = -1, r = t.length; ++o < r; ) n.add(t[o])
}
function vm(e, t) {
  for (var n = Id(e), o = -1, r = t.length; ++o < r; ) n.remove(t[o])
}
function $k(e) {
  return function () {
    bm(this, e)
  }
}
function eM(e) {
  return function () {
    vm(this, e)
  }
}
function tM(e, t) {
  return function () {
    ;(t.apply(this, arguments) ? bm : vm)(this, e)
  }
}
function nM(e, t) {
  var n = mm(e + '')
  if (arguments.length < 2) {
    for (var o = Id(this.node()), r = -1, i = n.length; ++r < i; ) if (!o.contains(n[r])) return !1
    return !0
  }
  return this.each((typeof t == 'function' ? tM : t ? $k : eM)(n, t))
}
function oM() {
  this.textContent = ''
}
function rM(e) {
  return function () {
    this.textContent = e
  }
}
function iM(e) {
  return function () {
    var t = e.apply(this, arguments)
    this.textContent = t ?? ''
  }
}
function sM(e) {
  return arguments.length ? this.each(e == null ? oM : (typeof e == 'function' ? iM : rM)(e)) : this.node().textContent
}
function aM() {
  this.innerHTML = ''
}
function lM(e) {
  return function () {
    this.innerHTML = e
  }
}
function cM(e) {
  return function () {
    var t = e.apply(this, arguments)
    this.innerHTML = t ?? ''
  }
}
function uM(e) {
  return arguments.length ? this.each(e == null ? aM : (typeof e == 'function' ? cM : lM)(e)) : this.node().innerHTML
}
function dM() {
  this.nextSibling && this.parentNode.appendChild(this)
}
function fM() {
  return this.each(dM)
}
function AM() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
}
function pM() {
  return this.each(AM)
}
function hM(e) {
  var t = typeof e == 'function' ? e : dm(e)
  return this.select(function () {
    return this.appendChild(t.apply(this, arguments))
  })
}
function gM() {
  return null
}
function mM(e, t) {
  var n = typeof e == 'function' ? e : dm(e),
    o = t == null ? gM : typeof t == 'function' ? t : Bd(t)
  return this.select(function () {
    return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null)
  })
}
function yM() {
  var e = this.parentNode
  e && e.removeChild(this)
}
function bM() {
  return this.each(yM)
}
function vM() {
  var e = this.cloneNode(!1),
    t = this.parentNode
  return t ? t.insertBefore(e, this.nextSibling) : e
}
function xM() {
  var e = this.cloneNode(!0),
    t = this.parentNode
  return t ? t.insertBefore(e, this.nextSibling) : e
}
function CM(e) {
  return this.select(e ? xM : vM)
}
function wM(e) {
  return arguments.length ? this.property('__data__', e) : this.node().__data__
}
function EM(e) {
  return function (t) {
    e.call(this, t, this.__data__)
  }
}
function SM(e) {
  return e
    .trim()
    .split(/^|\s+/)
    .map(function (t) {
      var n = '',
        o = t.indexOf('.')
      return o >= 0 && ((n = t.slice(o + 1)), (t = t.slice(0, o))), { type: t, name: n }
    })
}
function BM(e) {
  return function () {
    var t = this.__on
    if (t) {
      for (var n = 0, o = -1, r = t.length, i; n < r; ++n) (i = t[n]), (!e.type || i.type === e.type) && i.name === e.name ? this.removeEventListener(i.type, i.listener, i.options) : (t[++o] = i)
      ++o ? (t.length = o) : delete this.__on
    }
  }
}
function IM(e, t, n) {
  return function () {
    var o = this.__on,
      r,
      i = EM(t)
    if (o) {
      for (var s = 0, a = o.length; s < a; ++s)
        if ((r = o[s]).type === e.type && r.name === e.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, (r.listener = i), (r.options = n)), (r.value = t)
          return
        }
    }
    this.addEventListener(e.type, i, n), (r = { type: e.type, name: e.name, value: t, listener: i, options: n }), o ? o.push(r) : (this.__on = [r])
  }
}
function NM(e, t, n) {
  var o = SM(e + ''),
    r,
    i = o.length,
    s
  if (arguments.length < 2) {
    var a = this.node().__on
    if (a) {
      for (var l = 0, c = a.length, u; l < c; ++l) for (r = 0, u = a[l]; r < i; ++r) if ((s = o[r]).type === u.type && s.name === u.name) return u.value
    }
    return
  }
  for (a = t ? IM : BM, r = 0; r < i; ++r) this.each(a(o[r], t, n))
  return this
}
function xm(e, t, n) {
  var o = gm(e),
    r = o.CustomEvent
  typeof r == 'function' ? (r = new r(t, n)) : ((r = o.document.createEvent('Event')), n ? (r.initEvent(t, n.bubbles, n.cancelable), (r.detail = n.detail)) : r.initEvent(t, !1, !1)), e.dispatchEvent(r)
}
function kM(e, t) {
  return function () {
    return xm(this, e, t)
  }
}
function MM(e, t) {
  return function () {
    return xm(this, e, t.apply(this, arguments))
  }
}
function PM(e, t) {
  return this.each((typeof t == 'function' ? MM : kM)(e, t))
}
function* LM() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t) for (var o = e[t], r = 0, i = o.length, s; r < i; ++r) (s = o[r]) && (yield s)
}
var Cm = [null]
function Ht(e, t) {
  ;(this._groups = e), (this._parents = t)
}
function ts() {
  return new Ht([[document.documentElement]], Cm)
}
function RM() {
  return this
}
Ht.prototype = ts.prototype = {
  constructor: Ht,
  select: ik,
  selectAll: ck,
  selectChild: Ak,
  selectChildren: mk,
  filter: yk,
  data: Ek,
  enter: bk,
  exit: Bk,
  join: Ik,
  merge: Nk,
  selection: RM,
  order: kk,
  sort: Mk,
  call: Lk,
  nodes: Rk,
  node: Tk,
  size: Fk,
  empty: Dk,
  each: zk,
  attr: Xk,
  style: Kk,
  property: _k,
  classed: nM,
  text: sM,
  html: uM,
  raise: fM,
  lower: pM,
  append: hM,
  insert: mM,
  remove: bM,
  clone: CM,
  datum: wM,
  on: NM,
  dispatch: PM,
  [Symbol.iterator]: LM,
}
function Qt(e) {
  return typeof e == 'string' ? new Ht([[document.querySelector(e)]], [document.documentElement]) : new Ht([[e]], Cm)
}
function TM(e) {
  let t
  for (; (t = e.sourceEvent); ) e = t
  return e
}
function dn(e, t) {
  if (((e = TM(e)), t === void 0 && (t = e.currentTarget), t)) {
    var n = t.ownerSVGElement || t
    if (n.createSVGPoint) {
      var o = n.createSVGPoint()
      return (o.x = e.clientX), (o.y = e.clientY), (o = o.matrixTransform(t.getScreenCTM().inverse())), [o.x, o.y]
    }
    if (t.getBoundingClientRect) {
      var r = t.getBoundingClientRect()
      return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop]
    }
  }
  return [e.pageX, e.pageY]
}
const FM = { passive: !1 },
  Ti = { capture: !0, passive: !1 }
function fc(e) {
  e.stopImmediatePropagation()
}
function mr(e) {
  e.preventDefault(), e.stopImmediatePropagation()
}
function wm(e) {
  var t = e.document.documentElement,
    n = Qt(e).on('dragstart.drag', mr, Ti)
  'onselectstart' in t ? n.on('selectstart.drag', mr, Ti) : ((t.__noselect = t.style.MozUserSelect), (t.style.MozUserSelect = 'none'))
}
function Em(e, t) {
  var n = e.document.documentElement,
    o = Qt(e).on('dragstart.drag', null)
  t &&
    (o.on('click.drag', mr, Ti),
    setTimeout(function () {
      o.on('click.drag', null)
    }, 0)),
    'onselectstart' in n ? o.on('selectstart.drag', null) : ((n.style.MozUserSelect = n.__noselect), delete n.__noselect)
}
const Cs = e => () => e
function iu(e, { sourceEvent: t, subject: n, target: o, identifier: r, active: i, x: s, y: a, dx: l, dy: c, dispatch: u }) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: o, enumerable: !0, configurable: !0 },
    identifier: { value: r, enumerable: !0, configurable: !0 },
    active: { value: i, enumerable: !0, configurable: !0 },
    x: { value: s, enumerable: !0, configurable: !0 },
    y: { value: a, enumerable: !0, configurable: !0 },
    dx: { value: l, enumerable: !0, configurable: !0 },
    dy: { value: c, enumerable: !0, configurable: !0 },
    _: { value: u },
  })
}
iu.prototype.on = function () {
  var e = this._.on.apply(this._, arguments)
  return e === this._ ? this : e
}
function DM(e) {
  return !e.ctrlKey && !e.button
}
function zM() {
  return this.parentNode
}
function QM(e, t) {
  return t ?? { x: e.x, y: e.y }
}
function OM() {
  return navigator.maxTouchPoints || 'ontouchstart' in this
}
function Nd() {
  var e = DM,
    t = zM,
    n = QM,
    o = OM,
    r = {},
    i = wl('start', 'drag', 'end'),
    s = 0,
    a,
    l,
    c,
    u,
    d = 0
  function f(b) {
    b.on('mousedown.drag', A).filter(o).on('touchstart.drag', x).on('touchmove.drag', m, FM).on('touchend.drag touchcancel.drag', v).style('touch-action', 'none').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')
  }
  function A(b, C) {
    if (!(u || !e.call(this, b, C))) {
      var I = y(this, t.call(this, b, C), b, C, 'mouse')
      I && (Qt(b.view).on('mousemove.drag', h, Ti).on('mouseup.drag', g, Ti), wm(b.view), fc(b), (c = !1), (a = b.clientX), (l = b.clientY), I('start', b))
    }
  }
  function h(b) {
    if ((mr(b), !c)) {
      var C = b.clientX - a,
        I = b.clientY - l
      c = C * C + I * I > d
    }
    r.mouse('drag', b)
  }
  function g(b) {
    Qt(b.view).on('mousemove.drag mouseup.drag', null), Em(b.view, c), mr(b), r.mouse('end', b)
  }
  function x(b, C) {
    if (e.call(this, b, C)) {
      var I = b.changedTouches,
        w = t.call(this, b, C),
        M = I.length,
        L,
        R
      for (L = 0; L < M; ++L) (R = y(this, w, b, C, I[L].identifier, I[L])) && (fc(b), R('start', b, I[L]))
    }
  }
  function m(b) {
    var C = b.changedTouches,
      I = C.length,
      w,
      M
    for (w = 0; w < I; ++w) (M = r[C[w].identifier]) && (mr(b), M('drag', b, C[w]))
  }
  function v(b) {
    var C = b.changedTouches,
      I = C.length,
      w,
      M
    for (
      u && clearTimeout(u),
        u = setTimeout(function () {
          u = null
        }, 500),
        w = 0;
      w < I;
      ++w
    )
      (M = r[C[w].identifier]) && (fc(b), M('end', b, C[w]))
  }
  function y(b, C, I, w, M, L) {
    var R = i.copy(),
      T = dn(L || I, C),
      D,
      z,
      E
    if (
      (E = n.call(
        b,
        new iu('beforestart', {
          sourceEvent: I,
          target: f,
          identifier: M,
          active: s,
          x: T[0],
          y: T[1],
          dx: 0,
          dy: 0,
          dispatch: R,
        }),
        w
      )) != null
    )
      return (
        (D = E.x - T[0] || 0),
        (z = E.y - T[1] || 0),
        function P(B, F, S) {
          var Q = T,
            j
          switch (B) {
            case 'start':
              ;(r[M] = P), (j = s++)
              break
            case 'end':
              delete r[M], --s
            case 'drag':
              ;(T = dn(S || F, C)), (j = s)
              break
          }
          R.call(
            B,
            b,
            new iu(B, {
              sourceEvent: F,
              subject: E,
              target: f,
              identifier: M,
              active: j,
              x: T[0] + D,
              y: T[1] + z,
              dx: T[0] - Q[0],
              dy: T[1] - Q[1],
              dispatch: R,
            }),
            w
          )
        }
      )
  }
  return (
    (f.filter = function (b) {
      return arguments.length ? ((e = typeof b == 'function' ? b : Cs(!!b)), f) : e
    }),
    (f.container = function (b) {
      return arguments.length ? ((t = typeof b == 'function' ? b : Cs(b)), f) : t
    }),
    (f.subject = function (b) {
      return arguments.length ? ((n = typeof b == 'function' ? b : Cs(b)), f) : n
    }),
    (f.touchable = function (b) {
      return arguments.length ? ((o = typeof b == 'function' ? b : Cs(!!b)), f) : o
    }),
    (f.on = function () {
      var b = i.on.apply(i, arguments)
      return b === i ? f : b
    }),
    (f.clickDistance = function (b) {
      return arguments.length ? ((d = (b = +b) * b), f) : Math.sqrt(d)
    }),
    f
  )
}
function kd(e, t, n) {
  ;(e.prototype = t.prototype = n), (n.constructor = e)
}
function Sm(e, t) {
  var n = Object.create(e.prototype)
  for (var o in t) n[o] = t[o]
  return n
}
function ns() {}
var Fi = 0.7,
  fa = 1 / Fi,
  yr = '\\s*([+-]?\\d+)\\s*',
  Di = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*',
  In = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
  jM = /^#([0-9a-f]{3,8})$/,
  WM = new RegExp(`^rgb\\(${yr},${yr},${yr}\\)$`),
  GM = new RegExp(`^rgb\\(${In},${In},${In}\\)$`),
  VM = new RegExp(`^rgba\\(${yr},${yr},${yr},${Di}\\)$`),
  XM = new RegExp(`^rgba\\(${In},${In},${In},${Di}\\)$`),
  YM = new RegExp(`^hsl\\(${Di},${In},${In}\\)$`),
  HM = new RegExp(`^hsla\\(${Di},${In},${In},${Di}\\)$`),
  vA = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  }
kd(ns, zi, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e)
  },
  displayable() {
    return this.rgb().displayable()
  },
  hex: xA,
  // Deprecated! Use color.formatHex.
  formatHex: xA,
  formatHex8: UM,
  formatHsl: KM,
  formatRgb: CA,
  toString: CA,
})
function xA() {
  return this.rgb().formatHex()
}
function UM() {
  return this.rgb().formatHex8()
}
function KM() {
  return Bm(this).formatHsl()
}
function CA() {
  return this.rgb().formatRgb()
}
function zi(e) {
  var t, n
  return (
    (e = (e + '').trim().toLowerCase()),
    (t = jM.exec(e))
      ? ((n = t[1].length),
        (t = parseInt(t[1], 16)),
        n === 6
          ? wA(t)
          : n === 3
          ? new Ot(((t >> 8) & 15) | ((t >> 4) & 240), ((t >> 4) & 15) | (t & 240), ((t & 15) << 4) | (t & 15), 1)
          : n === 8
          ? ws((t >> 24) & 255, (t >> 16) & 255, (t >> 8) & 255, (t & 255) / 255)
          : n === 4
          ? ws(((t >> 12) & 15) | ((t >> 8) & 240), ((t >> 8) & 15) | ((t >> 4) & 240), ((t >> 4) & 15) | (t & 240), (((t & 15) << 4) | (t & 15)) / 255)
          : null)
      : (t = WM.exec(e))
      ? new Ot(t[1], t[2], t[3], 1)
      : (t = GM.exec(e))
      ? new Ot((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, 1)
      : (t = VM.exec(e))
      ? ws(t[1], t[2], t[3], t[4])
      : (t = XM.exec(e))
      ? ws((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, t[4])
      : (t = YM.exec(e))
      ? BA(t[1], t[2] / 100, t[3] / 100, 1)
      : (t = HM.exec(e))
      ? BA(t[1], t[2] / 100, t[3] / 100, t[4])
      : vA.hasOwnProperty(e)
      ? wA(vA[e])
      : e === 'transparent'
      ? new Ot(NaN, NaN, NaN, 0)
      : null
  )
}
function wA(e) {
  return new Ot((e >> 16) & 255, (e >> 8) & 255, e & 255, 1)
}
function ws(e, t, n, o) {
  return o <= 0 && (e = t = n = NaN), new Ot(e, t, n, o)
}
function qM(e) {
  return e instanceof ns || (e = zi(e)), e ? ((e = e.rgb()), new Ot(e.r, e.g, e.b, e.opacity)) : new Ot()
}
function su(e, t, n, o) {
  return arguments.length === 1 ? qM(e) : new Ot(e, t, n, o ?? 1)
}
function Ot(e, t, n, o) {
  ;(this.r = +e), (this.g = +t), (this.b = +n), (this.opacity = +o)
}
kd(
  Ot,
  su,
  Sm(ns, {
    brighter(e) {
      return (e = e == null ? fa : Math.pow(fa, e)), new Ot(this.r * e, this.g * e, this.b * e, this.opacity)
    },
    darker(e) {
      return (e = e == null ? Fi : Math.pow(Fi, e)), new Ot(this.r * e, this.g * e, this.b * e, this.opacity)
    },
    rgb() {
      return this
    },
    clamp() {
      return new Ot(jo(this.r), jo(this.g), jo(this.b), Aa(this.opacity))
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
    },
    hex: EA,
    // Deprecated! Use color.formatHex.
    formatHex: EA,
    formatHex8: ZM,
    formatRgb: SA,
    toString: SA,
  })
)
function EA() {
  return `#${zo(this.r)}${zo(this.g)}${zo(this.b)}`
}
function ZM() {
  return `#${zo(this.r)}${zo(this.g)}${zo(this.b)}${zo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
}
function SA() {
  const e = Aa(this.opacity)
  return `${e === 1 ? 'rgb(' : 'rgba('}${jo(this.r)}, ${jo(this.g)}, ${jo(this.b)}${e === 1 ? ')' : `, ${e})`}`
}
function Aa(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
}
function jo(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0))
}
function zo(e) {
  return (e = jo(e)), (e < 16 ? '0' : '') + e.toString(16)
}
function BA(e, t, n, o) {
  return o <= 0 ? (e = t = n = NaN) : n <= 0 || n >= 1 ? (e = t = NaN) : t <= 0 && (e = NaN), new An(e, t, n, o)
}
function Bm(e) {
  if (e instanceof An) return new An(e.h, e.s, e.l, e.opacity)
  if ((e instanceof ns || (e = zi(e)), !e)) return new An()
  if (e instanceof An) return e
  e = e.rgb()
  var t = e.r / 255,
    n = e.g / 255,
    o = e.b / 255,
    r = Math.min(t, n, o),
    i = Math.max(t, n, o),
    s = NaN,
    a = i - r,
    l = (i + r) / 2
  return a ? (t === i ? (s = (n - o) / a + (n < o) * 6) : n === i ? (s = (o - t) / a + 2) : (s = (t - n) / a + 4), (a /= l < 0.5 ? i + r : 2 - i - r), (s *= 60)) : (a = l > 0 && l < 1 ? 0 : s), new An(s, a, l, e.opacity)
}
function JM(e, t, n, o) {
  return arguments.length === 1 ? Bm(e) : new An(e, t, n, o ?? 1)
}
function An(e, t, n, o) {
  ;(this.h = +e), (this.s = +t), (this.l = +n), (this.opacity = +o)
}
kd(
  An,
  JM,
  Sm(ns, {
    brighter(e) {
      return (e = e == null ? fa : Math.pow(fa, e)), new An(this.h, this.s, this.l * e, this.opacity)
    },
    darker(e) {
      return (e = e == null ? Fi : Math.pow(Fi, e)), new An(this.h, this.s, this.l * e, this.opacity)
    },
    rgb() {
      var e = (this.h % 360) + (this.h < 0) * 360,
        t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
        n = this.l,
        o = n + (n < 0.5 ? n : 1 - n) * t,
        r = 2 * n - o
      return new Ot(Ac(e >= 240 ? e - 240 : e + 120, r, o), Ac(e, r, o), Ac(e < 120 ? e + 240 : e - 120, r, o), this.opacity)
    },
    clamp() {
      return new An(IA(this.h), Es(this.s), Es(this.l), Aa(this.opacity))
    },
    displayable() {
      return ((0 <= this.s && this.s <= 1) || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
    },
    formatHsl() {
      const e = Aa(this.opacity)
      return `${e === 1 ? 'hsl(' : 'hsla('}${IA(this.h)}, ${Es(this.s) * 100}%, ${Es(this.l) * 100}%${e === 1 ? ')' : `, ${e})`}`
    },
  })
)
function IA(e) {
  return (e = (e || 0) % 360), e < 0 ? e + 360 : e
}
function Es(e) {
  return Math.max(0, Math.min(1, e || 0))
}
function Ac(e, t, n) {
  return (e < 60 ? t + ((n - t) * e) / 60 : e < 180 ? n : e < 240 ? t + ((n - t) * (240 - e)) / 60 : t) * 255
}
const Im = e => () => e
function _M(e, t) {
  return function (n) {
    return e + n * t
  }
}
function $M(e, t, n) {
  return (
    (e = Math.pow(e, n)),
    (t = Math.pow(t, n) - e),
    (n = 1 / n),
    function (o) {
      return Math.pow(e + o * t, n)
    }
  )
}
function eP(e) {
  return (e = +e) == 1
    ? Nm
    : function (t, n) {
        return n - t ? $M(t, n, e) : Im(isNaN(t) ? n : t)
      }
}
function Nm(e, t) {
  var n = t - e
  return n ? _M(e, n) : Im(isNaN(e) ? t : e)
}
const NA = (function e(t) {
  var n = eP(t)
  function o(r, i) {
    var s = n((r = su(r)).r, (i = su(i)).r),
      a = n(r.g, i.g),
      l = n(r.b, i.b),
      c = Nm(r.opacity, i.opacity)
    return function (u) {
      return (r.r = s(u)), (r.g = a(u)), (r.b = l(u)), (r.opacity = c(u)), r + ''
    }
  }
  return (o.gamma = e), o
})(1)
function io(e, t) {
  return (
    (e = +e),
    (t = +t),
    function (n) {
      return e * (1 - n) + t * n
    }
  )
}
var au = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  pc = new RegExp(au.source, 'g')
function tP(e) {
  return function () {
    return e
  }
}
function nP(e) {
  return function (t) {
    return e(t) + ''
  }
}
function oP(e, t) {
  var n = (au.lastIndex = pc.lastIndex = 0),
    o,
    r,
    i,
    s = -1,
    a = [],
    l = []
  for (e = e + '', t = t + ''; (o = au.exec(e)) && (r = pc.exec(t)); ) (i = r.index) > n && ((i = t.slice(n, i)), a[s] ? (a[s] += i) : (a[++s] = i)), (o = o[0]) === (r = r[0]) ? (a[s] ? (a[s] += r) : (a[++s] = r)) : ((a[++s] = null), l.push({ i: s, x: io(o, r) })), (n = pc.lastIndex)
  return (
    n < t.length && ((i = t.slice(n)), a[s] ? (a[s] += i) : (a[++s] = i)),
    a.length < 2
      ? l[0]
        ? nP(l[0].x)
        : tP(t)
      : ((t = l.length),
        function (c) {
          for (var u = 0, d; u < t; ++u) a[(d = l[u]).i] = d.x(c)
          return a.join('')
        })
  )
}
var kA = 180 / Math.PI,
  lu = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1,
  }
function km(e, t, n, o, r, i) {
  var s, a, l
  return (
    (s = Math.sqrt(e * e + t * t)) && ((e /= s), (t /= s)),
    (l = e * n + t * o) && ((n -= e * l), (o -= t * l)),
    (a = Math.sqrt(n * n + o * o)) && ((n /= a), (o /= a), (l /= a)),
    e * o < t * n && ((e = -e), (t = -t), (l = -l), (s = -s)),
    {
      translateX: r,
      translateY: i,
      rotate: Math.atan2(t, e) * kA,
      skewX: Math.atan(l) * kA,
      scaleX: s,
      scaleY: a,
    }
  )
}
var Ss
function rP(e) {
  const t = new (typeof DOMMatrix == 'function' ? DOMMatrix : WebKitCSSMatrix)(e + '')
  return t.isIdentity ? lu : km(t.a, t.b, t.c, t.d, t.e, t.f)
}
function iP(e) {
  return e == null || (Ss || (Ss = document.createElementNS('http://www.w3.org/2000/svg', 'g')), Ss.setAttribute('transform', e), !(e = Ss.transform.baseVal.consolidate())) ? lu : ((e = e.matrix), km(e.a, e.b, e.c, e.d, e.e, e.f))
}
function Mm(e, t, n, o) {
  function r(c) {
    return c.length ? c.pop() + ' ' : ''
  }
  function i(c, u, d, f, A, h) {
    if (c !== d || u !== f) {
      var g = A.push('translate(', null, t, null, n)
      h.push({ i: g - 4, x: io(c, d) }, { i: g - 2, x: io(u, f) })
    } else (d || f) && A.push('translate(' + d + t + f + n)
  }
  function s(c, u, d, f) {
    c !== u ? (c - u > 180 ? (u += 360) : u - c > 180 && (c += 360), f.push({ i: d.push(r(d) + 'rotate(', null, o) - 2, x: io(c, u) })) : u && d.push(r(d) + 'rotate(' + u + o)
  }
  function a(c, u, d, f) {
    c !== u ? f.push({ i: d.push(r(d) + 'skewX(', null, o) - 2, x: io(c, u) }) : u && d.push(r(d) + 'skewX(' + u + o)
  }
  function l(c, u, d, f, A, h) {
    if (c !== d || u !== f) {
      var g = A.push(r(A) + 'scale(', null, ',', null, ')')
      h.push({ i: g - 4, x: io(c, d) }, { i: g - 2, x: io(u, f) })
    } else (d !== 1 || f !== 1) && A.push(r(A) + 'scale(' + d + ',' + f + ')')
  }
  return function (c, u) {
    var d = [],
      f = []
    return (
      (c = e(c)),
      (u = e(u)),
      i(c.translateX, c.translateY, u.translateX, u.translateY, d, f),
      s(c.rotate, u.rotate, d, f),
      a(c.skewX, u.skewX, d, f),
      l(c.scaleX, c.scaleY, u.scaleX, u.scaleY, d, f),
      (c = u = null),
      function (A) {
        for (var h = -1, g = f.length, x; ++h < g; ) d[(x = f[h]).i] = x.x(A)
        return d.join('')
      }
    )
  }
}
var sP = Mm(rP, 'px, ', 'px)', 'deg)'),
  aP = Mm(iP, ', ', ')', ')'),
  lP = 1e-12
function MA(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2
}
function cP(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2
}
function uP(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1)
}
const dP = (function e(t, n, o) {
  function r(i, s) {
    var a = i[0],
      l = i[1],
      c = i[2],
      u = s[0],
      d = s[1],
      f = s[2],
      A = u - a,
      h = d - l,
      g = A * A + h * h,
      x,
      m
    if (g < lP)
      (m = Math.log(f / c) / t),
        (x = function (w) {
          return [a + w * A, l + w * h, c * Math.exp(t * w * m)]
        })
    else {
      var v = Math.sqrt(g),
        y = (f * f - c * c + o * g) / (2 * c * n * v),
        b = (f * f - c * c - o * g) / (2 * f * n * v),
        C = Math.log(Math.sqrt(y * y + 1) - y),
        I = Math.log(Math.sqrt(b * b + 1) - b)
      ;(m = (I - C) / t),
        (x = function (w) {
          var M = w * m,
            L = MA(C),
            R = (c / (n * v)) * (L * uP(t * M + C) - cP(C))
          return [a + R * A, l + R * h, (c * L) / MA(t * M + C)]
        })
    }
    return (x.duration = (m * 1e3 * t) / Math.SQRT2), x
  }
  return (
    (r.rho = function (i) {
      var s = Math.max(1e-3, +i),
        a = s * s,
        l = a * a
      return e(s, a, l)
    }),
    r
  )
})(Math.SQRT2, 2, 4)
var kr = 0,
  hi = 0,
  si = 0,
  Pm = 1e3,
  pa,
  gi,
  ha = 0,
  Uo = 0,
  Sl = 0,
  Qi = typeof performance == 'object' && performance.now ? performance : Date,
  Lm =
    typeof window == 'object' && window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : function (e) {
          setTimeout(e, 17)
        }
function Md() {
  return Uo || (Lm(fP), (Uo = Qi.now() + Sl))
}
function fP() {
  Uo = 0
}
function ga() {
  this._call = this._time = this._next = null
}
ga.prototype = Rm.prototype = {
  constructor: ga,
  restart: function (e, t, n) {
    if (typeof e != 'function') throw new TypeError('callback is not a function')
    ;(n = (n == null ? Md() : +n) + (t == null ? 0 : +t)), !this._next && gi !== this && (gi ? (gi._next = this) : (pa = this), (gi = this)), (this._call = e), (this._time = n), cu()
  },
  stop: function () {
    this._call && ((this._call = null), (this._time = 1 / 0), cu())
  },
}
function Rm(e, t, n) {
  var o = new ga()
  return o.restart(e, t, n), o
}
function AP() {
  Md(), ++kr
  for (var e = pa, t; e; ) (t = Uo - e._time) >= 0 && e._call.call(void 0, t), (e = e._next)
  --kr
}
function PA() {
  ;(Uo = (ha = Qi.now()) + Sl), (kr = hi = 0)
  try {
    AP()
  } finally {
    ;(kr = 0), hP(), (Uo = 0)
  }
}
function pP() {
  var e = Qi.now(),
    t = e - ha
  t > Pm && ((Sl -= t), (ha = e))
}
function hP() {
  for (var e, t = pa, n, o = 1 / 0; t; ) t._call ? (o > t._time && (o = t._time), (e = t), (t = t._next)) : ((n = t._next), (t._next = null), (t = e ? (e._next = n) : (pa = n)))
  ;(gi = e), cu(o)
}
function cu(e) {
  if (!kr) {
    hi && (hi = clearTimeout(hi))
    var t = e - Uo
    t > 24 ? (e < 1 / 0 && (hi = setTimeout(PA, e - Qi.now() - Sl)), si && (si = clearInterval(si))) : (si || ((ha = Qi.now()), (si = setInterval(pP, Pm))), (kr = 1), Lm(PA))
  }
}
function LA(e, t, n) {
  var o = new ga()
  return (
    (t = t == null ? 0 : +t),
    o.restart(
      r => {
        o.stop(), e(r + t)
      },
      t,
      n
    ),
    o
  )
}
var gP = wl('start', 'end', 'cancel', 'interrupt'),
  mP = [],
  Tm = 0,
  RA = 1,
  uu = 2,
  qs = 3,
  TA = 4,
  du = 5,
  Zs = 6
function Bl(e, t, n, o, r, i) {
  var s = e.__transition
  if (!s) e.__transition = {}
  else if (n in s) return
  yP(e, n, {
    name: t,
    index: o,
    // For context during callback.
    group: r,
    // For context during callback.
    on: gP,
    tween: mP,
    time: i.time,
    delay: i.delay,
    duration: i.duration,
    ease: i.ease,
    timer: null,
    state: Tm,
  })
}
function Pd(e, t) {
  var n = vn(e, t)
  if (n.state > Tm) throw new Error('too late; already scheduled')
  return n
}
function Rn(e, t) {
  var n = vn(e, t)
  if (n.state > qs) throw new Error('too late; already running')
  return n
}
function vn(e, t) {
  var n = e.__transition
  if (!n || !(n = n[t])) throw new Error('transition not found')
  return n
}
function yP(e, t, n) {
  var o = e.__transition,
    r
  ;(o[t] = n), (n.timer = Rm(i, 0, n.time))
  function i(c) {
    ;(n.state = RA), n.timer.restart(s, n.delay, n.time), n.delay <= c && s(c - n.delay)
  }
  function s(c) {
    var u, d, f, A
    if (n.state !== RA) return l()
    for (u in o)
      if (((A = o[u]), A.name === n.name)) {
        if (A.state === qs) return LA(s)
        A.state === TA ? ((A.state = Zs), A.timer.stop(), A.on.call('interrupt', e, e.__data__, A.index, A.group), delete o[u]) : +u < t && ((A.state = Zs), A.timer.stop(), A.on.call('cancel', e, e.__data__, A.index, A.group), delete o[u])
      }
    if (
      (LA(function () {
        n.state === qs && ((n.state = TA), n.timer.restart(a, n.delay, n.time), a(c))
      }),
      (n.state = uu),
      n.on.call('start', e, e.__data__, n.index, n.group),
      n.state === uu)
    ) {
      for (n.state = qs, r = new Array((f = n.tween.length)), u = 0, d = -1; u < f; ++u) (A = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (r[++d] = A)
      r.length = d + 1
    }
  }
  function a(c) {
    for (var u = c < n.duration ? n.ease.call(null, c / n.duration) : (n.timer.restart(l), (n.state = du), 1), d = -1, f = r.length; ++d < f; ) r[d].call(e, u)
    n.state === du && (n.on.call('end', e, e.__data__, n.index, n.group), l())
  }
  function l() {
    ;(n.state = Zs), n.timer.stop(), delete o[t]
    for (var c in o) return
    delete e.__transition
  }
}
function Js(e, t) {
  var n = e.__transition,
    o,
    r,
    i = !0,
    s
  if (n) {
    t = t == null ? null : t + ''
    for (s in n) {
      if ((o = n[s]).name !== t) {
        i = !1
        continue
      }
      ;(r = o.state > uu && o.state < du), (o.state = Zs), o.timer.stop(), o.on.call(r ? 'interrupt' : 'cancel', e, e.__data__, o.index, o.group), delete n[s]
    }
    i && delete e.__transition
  }
}
function bP(e) {
  return this.each(function () {
    Js(this, e)
  })
}
function vP(e, t) {
  var n, o
  return function () {
    var r = Rn(this, e),
      i = r.tween
    if (i !== n) {
      o = n = i
      for (var s = 0, a = o.length; s < a; ++s)
        if (o[s].name === t) {
          ;(o = o.slice()), o.splice(s, 1)
          break
        }
    }
    r.tween = o
  }
}
function xP(e, t, n) {
  var o, r
  if (typeof n != 'function') throw new Error()
  return function () {
    var i = Rn(this, e),
      s = i.tween
    if (s !== o) {
      r = (o = s).slice()
      for (var a = { name: t, value: n }, l = 0, c = r.length; l < c; ++l)
        if (r[l].name === t) {
          r[l] = a
          break
        }
      l === c && r.push(a)
    }
    i.tween = r
  }
}
function CP(e, t) {
  var n = this._id
  if (((e += ''), arguments.length < 2)) {
    for (var o = vn(this.node(), n).tween, r = 0, i = o.length, s; r < i; ++r) if ((s = o[r]).name === e) return s.value
    return null
  }
  return this.each((t == null ? vP : xP)(n, e, t))
}
function Ld(e, t, n) {
  var o = e._id
  return (
    e.each(function () {
      var r = Rn(this, o)
      ;(r.value || (r.value = {}))[t] = n.apply(this, arguments)
    }),
    function (r) {
      return vn(r, o).value[t]
    }
  )
}
function Fm(e, t) {
  var n
  return (typeof t == 'number' ? io : t instanceof zi ? NA : (n = zi(t)) ? ((t = n), NA) : oP)(e, t)
}
function wP(e) {
  return function () {
    this.removeAttribute(e)
  }
}
function EP(e) {
  return function () {
    this.removeAttributeNS(e.space, e.local)
  }
}
function SP(e, t, n) {
  var o,
    r = n + '',
    i
  return function () {
    var s = this.getAttribute(e)
    return s === r ? null : s === o ? i : (i = t((o = s), n))
  }
}
function BP(e, t, n) {
  var o,
    r = n + '',
    i
  return function () {
    var s = this.getAttributeNS(e.space, e.local)
    return s === r ? null : s === o ? i : (i = t((o = s), n))
  }
}
function IP(e, t, n) {
  var o, r, i
  return function () {
    var s,
      a = n(this),
      l
    return a == null ? void this.removeAttribute(e) : ((s = this.getAttribute(e)), (l = a + ''), s === l ? null : s === o && l === r ? i : ((r = l), (i = t((o = s), a))))
  }
}
function NP(e, t, n) {
  var o, r, i
  return function () {
    var s,
      a = n(this),
      l
    return a == null ? void this.removeAttributeNS(e.space, e.local) : ((s = this.getAttributeNS(e.space, e.local)), (l = a + ''), s === l ? null : s === o && l === r ? i : ((r = l), (i = t((o = s), a))))
  }
}
function kP(e, t) {
  var n = El(e),
    o = n === 'transform' ? aP : Fm
  return this.attrTween(e, typeof t == 'function' ? (n.local ? NP : IP)(n, o, Ld(this, 'attr.' + e, t)) : t == null ? (n.local ? EP : wP)(n) : (n.local ? BP : SP)(n, o, t))
}
function MP(e, t) {
  return function (n) {
    this.setAttribute(e, t.call(this, n))
  }
}
function PP(e, t) {
  return function (n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n))
  }
}
function LP(e, t) {
  var n, o
  function r() {
    var i = t.apply(this, arguments)
    return i !== o && (n = (o = i) && PP(e, i)), n
  }
  return (r._value = t), r
}
function RP(e, t) {
  var n, o
  function r() {
    var i = t.apply(this, arguments)
    return i !== o && (n = (o = i) && MP(e, i)), n
  }
  return (r._value = t), r
}
function TP(e, t) {
  var n = 'attr.' + e
  if (arguments.length < 2) return (n = this.tween(n)) && n._value
  if (t == null) return this.tween(n, null)
  if (typeof t != 'function') throw new Error()
  var o = El(e)
  return this.tween(n, (o.local ? LP : RP)(o, t))
}
function FP(e, t) {
  return function () {
    Pd(this, e).delay = +t.apply(this, arguments)
  }
}
function DP(e, t) {
  return (
    (t = +t),
    function () {
      Pd(this, e).delay = t
    }
  )
}
function zP(e) {
  var t = this._id
  return arguments.length ? this.each((typeof e == 'function' ? FP : DP)(t, e)) : vn(this.node(), t).delay
}
function QP(e, t) {
  return function () {
    Rn(this, e).duration = +t.apply(this, arguments)
  }
}
function OP(e, t) {
  return (
    (t = +t),
    function () {
      Rn(this, e).duration = t
    }
  )
}
function jP(e) {
  var t = this._id
  return arguments.length ? this.each((typeof e == 'function' ? QP : OP)(t, e)) : vn(this.node(), t).duration
}
function WP(e, t) {
  if (typeof t != 'function') throw new Error()
  return function () {
    Rn(this, e).ease = t
  }
}
function GP(e) {
  var t = this._id
  return arguments.length ? this.each(WP(t, e)) : vn(this.node(), t).ease
}
function VP(e, t) {
  return function () {
    var n = t.apply(this, arguments)
    if (typeof n != 'function') throw new Error()
    Rn(this, e).ease = n
  }
}
function XP(e) {
  if (typeof e != 'function') throw new Error()
  return this.each(VP(this._id, e))
}
function YP(e) {
  typeof e != 'function' && (e = Am(e))
  for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r) for (var i = t[r], s = i.length, a = (o[r] = []), l, c = 0; c < s; ++c) (l = i[c]) && e.call(l, l.__data__, c, i) && a.push(l)
  return new Un(o, this._parents, this._name, this._id)
}
function HP(e) {
  if (e._id !== this._id) throw new Error()
  for (var t = this._groups, n = e._groups, o = t.length, r = n.length, i = Math.min(o, r), s = new Array(o), a = 0; a < i; ++a) for (var l = t[a], c = n[a], u = l.length, d = (s[a] = new Array(u)), f, A = 0; A < u; ++A) (f = l[A] || c[A]) && (d[A] = f)
  for (; a < o; ++a) s[a] = t[a]
  return new Un(s, this._parents, this._name, this._id)
}
function UP(e) {
  return (e + '')
    .trim()
    .split(/^|\s+/)
    .every(function (t) {
      var n = t.indexOf('.')
      return n >= 0 && (t = t.slice(0, n)), !t || t === 'start'
    })
}
function KP(e, t, n) {
  var o,
    r,
    i = UP(t) ? Pd : Rn
  return function () {
    var s = i(this, e),
      a = s.on
    a !== o && (r = (o = a).copy()).on(t, n), (s.on = r)
  }
}
function qP(e, t) {
  var n = this._id
  return arguments.length < 2 ? vn(this.node(), n).on.on(e) : this.each(KP(n, e, t))
}
function ZP(e) {
  return function () {
    var t = this.parentNode
    for (var n in this.__transition) if (+n !== e) return
    t && t.removeChild(this)
  }
}
function JP() {
  return this.on('end.remove', ZP(this._id))
}
function _P(e) {
  var t = this._name,
    n = this._id
  typeof e != 'function' && (e = Bd(e))
  for (var o = this._groups, r = o.length, i = new Array(r), s = 0; s < r; ++s) for (var a = o[s], l = a.length, c = (i[s] = new Array(l)), u, d, f = 0; f < l; ++f) (u = a[f]) && (d = e.call(u, u.__data__, f, a)) && ('__data__' in u && (d.__data__ = u.__data__), (c[f] = d), Bl(c[f], t, n, f, c, vn(u, n)))
  return new Un(i, this._parents, t, n)
}
function $P(e) {
  var t = this._name,
    n = this._id
  typeof e != 'function' && (e = fm(e))
  for (var o = this._groups, r = o.length, i = [], s = [], a = 0; a < r; ++a)
    for (var l = o[a], c = l.length, u, d = 0; d < c; ++d)
      if ((u = l[d])) {
        for (var f = e.call(u, u.__data__, d, l), A, h = vn(u, n), g = 0, x = f.length; g < x; ++g) (A = f[g]) && Bl(A, t, n, g, f, h)
        i.push(f), s.push(u)
      }
  return new Un(i, s, t, n)
}
var e2 = ts.prototype.constructor
function t2() {
  return new e2(this._groups, this._parents)
}
function n2(e, t) {
  var n, o, r
  return function () {
    var i = Nr(this, e),
      s = (this.style.removeProperty(e), Nr(this, e))
    return i === s ? null : i === n && s === o ? r : (r = t((n = i), (o = s)))
  }
}
function Dm(e) {
  return function () {
    this.style.removeProperty(e)
  }
}
function o2(e, t, n) {
  var o,
    r = n + '',
    i
  return function () {
    var s = Nr(this, e)
    return s === r ? null : s === o ? i : (i = t((o = s), n))
  }
}
function r2(e, t, n) {
  var o, r, i
  return function () {
    var s = Nr(this, e),
      a = n(this),
      l = a + ''
    return a == null && (l = a = (this.style.removeProperty(e), Nr(this, e))), s === l ? null : s === o && l === r ? i : ((r = l), (i = t((o = s), a)))
  }
}
function i2(e, t) {
  var n,
    o,
    r,
    i = 'style.' + t,
    s = 'end.' + i,
    a
  return function () {
    var l = Rn(this, e),
      c = l.on,
      u = l.value[i] == null ? a || (a = Dm(t)) : void 0
    ;(c !== n || r !== u) && (o = (n = c).copy()).on(s, (r = u)), (l.on = o)
  }
}
function s2(e, t, n) {
  var o = (e += '') == 'transform' ? sP : Fm
  return t == null ? this.styleTween(e, n2(e, o)).on('end.style.' + e, Dm(e)) : typeof t == 'function' ? this.styleTween(e, r2(e, o, Ld(this, 'style.' + e, t))).each(i2(this._id, e)) : this.styleTween(e, o2(e, o, t), n).on('end.style.' + e, null)
}
function a2(e, t, n) {
  return function (o) {
    this.style.setProperty(e, t.call(this, o), n)
  }
}
function l2(e, t, n) {
  var o, r
  function i() {
    var s = t.apply(this, arguments)
    return s !== r && (o = (r = s) && a2(e, s, n)), o
  }
  return (i._value = t), i
}
function c2(e, t, n) {
  var o = 'style.' + (e += '')
  if (arguments.length < 2) return (o = this.tween(o)) && o._value
  if (t == null) return this.tween(o, null)
  if (typeof t != 'function') throw new Error()
  return this.tween(o, l2(e, t, n ?? ''))
}
function u2(e) {
  return function () {
    this.textContent = e
  }
}
function d2(e) {
  return function () {
    var t = e(this)
    this.textContent = t ?? ''
  }
}
function f2(e) {
  return this.tween('text', typeof e == 'function' ? d2(Ld(this, 'text', e)) : u2(e == null ? '' : e + ''))
}
function A2(e) {
  return function (t) {
    this.textContent = e.call(this, t)
  }
}
function p2(e) {
  var t, n
  function o() {
    var r = e.apply(this, arguments)
    return r !== n && (t = (n = r) && A2(r)), t
  }
  return (o._value = e), o
}
function h2(e) {
  var t = 'text'
  if (arguments.length < 1) return (t = this.tween(t)) && t._value
  if (e == null) return this.tween(t, null)
  if (typeof e != 'function') throw new Error()
  return this.tween(t, p2(e))
}
function g2() {
  for (var e = this._name, t = this._id, n = zm(), o = this._groups, r = o.length, i = 0; i < r; ++i)
    for (var s = o[i], a = s.length, l, c = 0; c < a; ++c)
      if ((l = s[c])) {
        var u = vn(l, t)
        Bl(l, e, n, c, s, {
          time: u.time + u.delay + u.duration,
          delay: 0,
          duration: u.duration,
          ease: u.ease,
        })
      }
  return new Un(o, this._parents, e, n)
}
function m2() {
  var e,
    t,
    n = this,
    o = n._id,
    r = n.size()
  return new Promise(function (i, s) {
    var a = { value: s },
      l = {
        value: function () {
          --r === 0 && i()
        },
      }
    n.each(function () {
      var c = Rn(this, o),
        u = c.on
      u !== e && ((t = (e = u).copy()), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(l)), (c.on = t)
    }),
      r === 0 && i()
  })
}
var y2 = 0
function Un(e, t, n, o) {
  ;(this._groups = e), (this._parents = t), (this._name = n), (this._id = o)
}
function zm() {
  return ++y2
}
var zn = ts.prototype
Un.prototype = {
  constructor: Un,
  select: _P,
  selectAll: $P,
  selectChild: zn.selectChild,
  selectChildren: zn.selectChildren,
  filter: YP,
  merge: HP,
  selection: t2,
  transition: g2,
  call: zn.call,
  nodes: zn.nodes,
  node: zn.node,
  size: zn.size,
  empty: zn.empty,
  each: zn.each,
  on: qP,
  attr: kP,
  attrTween: TP,
  style: s2,
  styleTween: c2,
  text: f2,
  textTween: h2,
  remove: JP,
  tween: CP,
  delay: zP,
  duration: jP,
  ease: GP,
  easeVarying: XP,
  end: m2,
  [Symbol.iterator]: zn[Symbol.iterator],
}
function b2(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2
}
var v2 = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: b2,
}
function x2(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); ) if (!(e = e.parentNode)) throw new Error(`transition ${t} not found`)
  return n
}
function C2(e) {
  var t, n
  e instanceof Un ? ((t = e._id), (e = e._name)) : ((t = zm()), ((n = v2).time = Md()), (e = e == null ? null : e + ''))
  for (var o = this._groups, r = o.length, i = 0; i < r; ++i) for (var s = o[i], a = s.length, l, c = 0; c < a; ++c) (l = s[c]) && Bl(l, e, t, c, s, n || x2(l, t))
  return new Un(o, this._parents, e, t)
}
ts.prototype.interrupt = bP
ts.prototype.transition = C2
const Bs = e => () => e
function w2(e, { sourceEvent: t, target: n, transform: o, dispatch: r }) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: o, enumerable: !0, configurable: !0 },
    _: { value: r },
  })
}
function Gn(e, t, n) {
  ;(this.k = e), (this.x = t), (this.y = n)
}
Gn.prototype = {
  constructor: Gn,
  scale: function (e) {
    return e === 1 ? this : new Gn(this.k * e, this.x, this.y)
  },
  translate: function (e, t) {
    return (e === 0) & (t === 0) ? this : new Gn(this.k, this.x + this.k * e, this.y + this.k * t)
  },
  apply: function (e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y]
  },
  applyX: function (e) {
    return e * this.k + this.x
  },
  applyY: function (e) {
    return e * this.k + this.y
  },
  invert: function (e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k]
  },
  invertX: function (e) {
    return (e - this.x) / this.k
  },
  invertY: function (e) {
    return (e - this.y) / this.k
  },
  rescaleX: function (e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e))
  },
  rescaleY: function (e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e))
  },
  toString: function () {
    return 'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')'
  },
}
var Il = new Gn(1, 0, 0)
Qm.prototype = Gn.prototype
function Qm(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return Il
  return e.__zoom
}
function hc(e) {
  e.stopImmediatePropagation()
}
function ai(e) {
  e.preventDefault(), e.stopImmediatePropagation()
}
function E2(e) {
  return (!e.ctrlKey || e.type === 'wheel') && !e.button
}
function S2() {
  var e = this
  return e instanceof SVGElement
    ? ((e = e.ownerSVGElement || e),
      e.hasAttribute('viewBox')
        ? ((e = e.viewBox.baseVal),
          [
            [e.x, e.y],
            [e.x + e.width, e.y + e.height],
          ])
        : [
            [0, 0],
            [e.width.baseVal.value, e.height.baseVal.value],
          ])
    : [
        [0, 0],
        [e.clientWidth, e.clientHeight],
      ]
}
function FA() {
  return this.__zoom || Il
}
function B2(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1)
}
function I2() {
  return navigator.maxTouchPoints || 'ontouchstart' in this
}
function N2(e, t, n) {
  var o = e.invertX(t[0][0]) - n[0][0],
    r = e.invertX(t[1][0]) - n[1][0],
    i = e.invertY(t[0][1]) - n[0][1],
    s = e.invertY(t[1][1]) - n[1][1]
  return e.translate(r > o ? (o + r) / 2 : Math.min(0, o) || Math.max(0, r), s > i ? (i + s) / 2 : Math.min(0, i) || Math.max(0, s))
}
function Om() {
  var e = E2,
    t = S2,
    n = N2,
    o = B2,
    r = I2,
    i = [0, 1 / 0],
    s = [
      [-1 / 0, -1 / 0],
      [1 / 0, 1 / 0],
    ],
    a = 250,
    l = dP,
    c = wl('start', 'zoom', 'end'),
    u,
    d,
    f,
    A = 500,
    h = 150,
    g = 0,
    x = 10
  function m(E) {
    E.property('__zoom', FA).on('wheel.zoom', M, { passive: !1 }).on('mousedown.zoom', L).on('dblclick.zoom', R).filter(r).on('touchstart.zoom', T).on('touchmove.zoom', D).on('touchend.zoom touchcancel.zoom', z).style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')
  }
  ;(m.transform = function (E, P, B, F) {
    var S = E.selection ? E.selection() : E
    S.property('__zoom', FA),
      E !== S
        ? C(E, P, B, F)
        : S.interrupt().each(function () {
            I(this, arguments)
              .event(F)
              .start()
              .zoom(null, typeof P == 'function' ? P.apply(this, arguments) : P)
              .end()
          })
  }),
    (m.scaleBy = function (E, P, B, F) {
      m.scaleTo(
        E,
        function () {
          var S = this.__zoom.k,
            Q = typeof P == 'function' ? P.apply(this, arguments) : P
          return S * Q
        },
        B,
        F
      )
    }),
    (m.scaleTo = function (E, P, B, F) {
      m.transform(
        E,
        function () {
          var S = t.apply(this, arguments),
            Q = this.__zoom,
            j = B == null ? b(S) : typeof B == 'function' ? B.apply(this, arguments) : B,
            U = Q.invert(j),
            q = typeof P == 'function' ? P.apply(this, arguments) : P
          return n(y(v(Q, q), j, U), S, s)
        },
        B,
        F
      )
    }),
    (m.translateBy = function (E, P, B, F) {
      m.transform(
        E,
        function () {
          return n(this.__zoom.translate(typeof P == 'function' ? P.apply(this, arguments) : P, typeof B == 'function' ? B.apply(this, arguments) : B), t.apply(this, arguments), s)
        },
        null,
        F
      )
    }),
    (m.translateTo = function (E, P, B, F, S) {
      m.transform(
        E,
        function () {
          var Q = t.apply(this, arguments),
            j = this.__zoom,
            U = F == null ? b(Q) : typeof F == 'function' ? F.apply(this, arguments) : F
          return n(
            Il.translate(U[0], U[1])
              .scale(j.k)
              .translate(typeof P == 'function' ? -P.apply(this, arguments) : -P, typeof B == 'function' ? -B.apply(this, arguments) : -B),
            Q,
            s
          )
        },
        F,
        S
      )
    })
  function v(E, P) {
    return (P = Math.max(i[0], Math.min(i[1], P))), P === E.k ? E : new Gn(P, E.x, E.y)
  }
  function y(E, P, B) {
    var F = P[0] - B[0] * E.k,
      S = P[1] - B[1] * E.k
    return F === E.x && S === E.y ? E : new Gn(E.k, F, S)
  }
  function b(E) {
    return [(+E[0][0] + +E[1][0]) / 2, (+E[0][1] + +E[1][1]) / 2]
  }
  function C(E, P, B, F) {
    E.on('start.zoom', function () {
      I(this, arguments).event(F).start()
    })
      .on('interrupt.zoom end.zoom', function () {
        I(this, arguments).event(F).end()
      })
      .tween('zoom', function () {
        var S = this,
          Q = arguments,
          j = I(S, Q).event(F),
          U = t.apply(S, Q),
          q = B == null ? b(U) : typeof B == 'function' ? B.apply(S, Q) : B,
          ne = Math.max(U[1][0] - U[0][0], U[1][1] - U[0][1]),
          G = S.__zoom,
          K = typeof P == 'function' ? P.apply(S, Q) : P,
          $ = l(G.invert(q).concat(ne / G.k), K.invert(q).concat(ne / K.k))
        return function (oe) {
          if (oe === 1) oe = K
          else {
            var Z = $(oe),
              ie = ne / Z[2]
            oe = new Gn(ie, q[0] - Z[0] * ie, q[1] - Z[1] * ie)
          }
          j.zoom(null, oe)
        }
      })
  }
  function I(E, P, B) {
    return (!B && E.__zooming) || new w(E, P)
  }
  function w(E, P) {
    ;(this.that = E), (this.args = P), (this.active = 0), (this.sourceEvent = null), (this.extent = t.apply(E, P)), (this.taps = 0)
  }
  w.prototype = {
    event: function (E) {
      return E && (this.sourceEvent = E), this
    },
    start: function () {
      return ++this.active === 1 && ((this.that.__zooming = this), this.emit('start')), this
    },
    zoom: function (E, P) {
      return this.mouse && E !== 'mouse' && (this.mouse[1] = P.invert(this.mouse[0])), this.touch0 && E !== 'touch' && (this.touch0[1] = P.invert(this.touch0[0])), this.touch1 && E !== 'touch' && (this.touch1[1] = P.invert(this.touch1[0])), (this.that.__zoom = P), this.emit('zoom'), this
    },
    end: function () {
      return --this.active === 0 && (delete this.that.__zooming, this.emit('end')), this
    },
    emit: function (E) {
      var P = Qt(this.that).datum()
      c.call(
        E,
        this.that,
        new w2(E, {
          sourceEvent: this.sourceEvent,
          target: m,
          type: E,
          transform: this.that.__zoom,
          dispatch: c,
        }),
        P
      )
    },
  }
  function M(E, ...P) {
    if (!e.apply(this, arguments)) return
    var B = I(this, P).event(E),
      F = this.__zoom,
      S = Math.max(i[0], Math.min(i[1], F.k * Math.pow(2, o.apply(this, arguments)))),
      Q = dn(E)
    if (B.wheel) (B.mouse[0][0] !== Q[0] || B.mouse[0][1] !== Q[1]) && (B.mouse[1] = F.invert((B.mouse[0] = Q))), clearTimeout(B.wheel)
    else {
      if (F.k === S) return
      ;(B.mouse = [Q, F.invert(Q)]), Js(this), B.start()
    }
    ai(E), (B.wheel = setTimeout(j, h)), B.zoom('mouse', n(y(v(F, S), B.mouse[0], B.mouse[1]), B.extent, s))
    function j() {
      ;(B.wheel = null), B.end()
    }
  }
  function L(E, ...P) {
    if (f || !e.apply(this, arguments)) return
    var B = E.currentTarget,
      F = I(this, P, !0).event(E),
      S = Qt(E.view).on('mousemove.zoom', q, !0).on('mouseup.zoom', ne, !0),
      Q = dn(E, B),
      j = E.clientX,
      U = E.clientY
    wm(E.view), hc(E), (F.mouse = [Q, this.__zoom.invert(Q)]), Js(this), F.start()
    function q(G) {
      if ((ai(G), !F.moved)) {
        var K = G.clientX - j,
          $ = G.clientY - U
        F.moved = K * K + $ * $ > g
      }
      F.event(G).zoom('mouse', n(y(F.that.__zoom, (F.mouse[0] = dn(G, B)), F.mouse[1]), F.extent, s))
    }
    function ne(G) {
      S.on('mousemove.zoom mouseup.zoom', null), Em(G.view, F.moved), ai(G), F.event(G).end()
    }
  }
  function R(E, ...P) {
    if (e.apply(this, arguments)) {
      var B = this.__zoom,
        F = dn(E.changedTouches ? E.changedTouches[0] : E, this),
        S = B.invert(F),
        Q = B.k * (E.shiftKey ? 0.5 : 2),
        j = n(y(v(B, Q), F, S), t.apply(this, P), s)
      ai(E), a > 0 ? Qt(this).transition().duration(a).call(C, j, F, E) : Qt(this).call(m.transform, j, F, E)
    }
  }
  function T(E, ...P) {
    if (e.apply(this, arguments)) {
      var B = E.touches,
        F = B.length,
        S = I(this, P, E.changedTouches.length === F).event(E),
        Q,
        j,
        U,
        q
      for (hc(E), j = 0; j < F; ++j) (U = B[j]), (q = dn(U, this)), (q = [q, this.__zoom.invert(q), U.identifier]), S.touch0 ? !S.touch1 && S.touch0[2] !== q[2] && ((S.touch1 = q), (S.taps = 0)) : ((S.touch0 = q), (Q = !0), (S.taps = 1 + !!u))
      u && (u = clearTimeout(u)),
        Q &&
          (S.taps < 2 &&
            ((d = q[0]),
            (u = setTimeout(function () {
              u = null
            }, A))),
          Js(this),
          S.start())
    }
  }
  function D(E, ...P) {
    if (this.__zooming) {
      var B = I(this, P).event(E),
        F = E.changedTouches,
        S = F.length,
        Q,
        j,
        U,
        q
      for (ai(E), Q = 0; Q < S; ++Q) (j = F[Q]), (U = dn(j, this)), B.touch0 && B.touch0[2] === j.identifier ? (B.touch0[0] = U) : B.touch1 && B.touch1[2] === j.identifier && (B.touch1[0] = U)
      if (((j = B.that.__zoom), B.touch1)) {
        var ne = B.touch0[0],
          G = B.touch0[1],
          K = B.touch1[0],
          $ = B.touch1[1],
          oe = (oe = K[0] - ne[0]) * oe + (oe = K[1] - ne[1]) * oe,
          Z = (Z = $[0] - G[0]) * Z + (Z = $[1] - G[1]) * Z
        ;(j = v(j, Math.sqrt(oe / Z))), (U = [(ne[0] + K[0]) / 2, (ne[1] + K[1]) / 2]), (q = [(G[0] + $[0]) / 2, (G[1] + $[1]) / 2])
      } else if (B.touch0) (U = B.touch0[0]), (q = B.touch0[1])
      else return
      B.zoom('touch', n(y(j, U, q), B.extent, s))
    }
  }
  function z(E, ...P) {
    if (this.__zooming) {
      var B = I(this, P).event(E),
        F = E.changedTouches,
        S = F.length,
        Q,
        j
      for (
        hc(E),
          f && clearTimeout(f),
          f = setTimeout(function () {
            f = null
          }, A),
          Q = 0;
        Q < S;
        ++Q
      )
        (j = F[Q]), B.touch0 && B.touch0[2] === j.identifier ? delete B.touch0 : B.touch1 && B.touch1[2] === j.identifier && delete B.touch1
      if ((B.touch1 && !B.touch0 && ((B.touch0 = B.touch1), delete B.touch1), B.touch0)) B.touch0[1] = this.__zoom.invert(B.touch0[0])
      else if ((B.end(), B.taps === 2 && ((j = dn(j, this)), Math.hypot(d[0] - j[0], d[1] - j[1]) < x))) {
        var U = Qt(this).on('dblclick.zoom')
        U && U.apply(this, arguments)
      }
    }
  }
  return (
    (m.wheelDelta = function (E) {
      return arguments.length ? ((o = typeof E == 'function' ? E : Bs(+E)), m) : o
    }),
    (m.filter = function (E) {
      return arguments.length ? ((e = typeof E == 'function' ? E : Bs(!!E)), m) : e
    }),
    (m.touchable = function (E) {
      return arguments.length ? ((r = typeof E == 'function' ? E : Bs(!!E)), m) : r
    }),
    (m.extent = function (E) {
      return arguments.length
        ? ((t =
            typeof E == 'function'
              ? E
              : Bs([
                  [+E[0][0], +E[0][1]],
                  [+E[1][0], +E[1][1]],
                ])),
          m)
        : t
    }),
    (m.scaleExtent = function (E) {
      return arguments.length ? ((i[0] = +E[0]), (i[1] = +E[1]), m) : [i[0], i[1]]
    }),
    (m.translateExtent = function (E) {
      return arguments.length
        ? ((s[0][0] = +E[0][0]), (s[1][0] = +E[1][0]), (s[0][1] = +E[0][1]), (s[1][1] = +E[1][1]), m)
        : [
            [s[0][0], s[0][1]],
            [s[1][0], s[1][1]],
          ]
    }),
    (m.constrain = function (E) {
      return arguments.length ? ((n = E), m) : n
    }),
    (m.duration = function (E) {
      return arguments.length ? ((a = +E), m) : a
    }),
    (m.interpolate = function (E) {
      return arguments.length ? ((l = E), m) : l
    }),
    (m.on = function () {
      var E = c.on.apply(c, arguments)
      return E === c ? m : E
    }),
    (m.clickDistance = function (E) {
      return arguments.length ? ((g = (E = +E) * E), m) : Math.sqrt(g)
    }),
    (m.tapDistance = function (E) {
      return arguments.length ? ((x = +E), m) : x
    }),
    m
  )
}
const Jn = {
    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',
    error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
    error003: e => `Node type "${e}" not found. Using fallback type "default".`,
    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',
    error005: () => 'Only child nodes can use a parent extent.',
    error006: () => "Can't create edge. An edge needs a source and a target.",
    error007: e => `The old edge with id=${e} does not exist.`,
    error009: e => `Marker type "${e}" doesn't exist.`,
    error008: (e, { id: t, sourceHandle: n, targetHandle: o }) => `Couldn't create edge for ${e} handle id: "${e === 'source' ? n : o}", edge id: ${t}.`,
    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',
    error011: e => `Edge type "${e}" not found. Using fallback type "default".`,
    error012: e => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
    error013: (e = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  },
  Oi = [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],
  ],
  jm = ['Enter', ' ', 'Escape']
var Mr
;(function (e) {
  ;(e.Strict = 'strict'), (e.Loose = 'loose')
})(Mr || (Mr = {}))
var Wo
;(function (e) {
  ;(e.Free = 'free'), (e.Vertical = 'vertical'), (e.Horizontal = 'horizontal')
})(Wo || (Wo = {}))
var ji
;(function (e) {
  ;(e.Partial = 'partial'), (e.Full = 'full')
})(ji || (ji = {}))
const Wm = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null,
}
var En
;(function (e) {
  ;(e.Bezier = 'default'), (e.Straight = 'straight'), (e.Step = 'step'), (e.SmoothStep = 'smoothstep'), (e.SimpleBezier = 'simplebezier')
})(En || (En = {}))
var ma
;(function (e) {
  ;(e.Arrow = 'arrow'), (e.ArrowClosed = 'arrowclosed')
})(ma || (ma = {}))
var ye
;(function (e) {
  ;(e.Left = 'left'), (e.Top = 'top'), (e.Right = 'right'), (e.Bottom = 'bottom')
})(ye || (ye = {}))
const DA = {
  [ye.Left]: ye.Right,
  [ye.Right]: ye.Left,
  [ye.Top]: ye.Bottom,
  [ye.Bottom]: ye.Top,
}
function Gm(e) {
  return e === null ? null : e ? 'valid' : 'invalid'
}
const Vm = e => 'id' in e && 'source' in e && 'target' in e,
  k2 = e => 'id' in e && 'position' in e && !('source' in e) && !('target' in e),
  Rd = e => 'id' in e && 'internals' in e && !('source' in e) && !('target' in e),
  os = (e, t = [0, 0]) => {
    const { width: n, height: o } = _n(e),
      r = e.origin ?? t,
      i = n * r[0],
      s = o * r[1]
    return {
      x: e.position.x - i,
      y: e.position.y - s,
    }
  },
  M2 = (e, t = { nodeOrigin: [0, 0], nodeLookup: void 0 }) => {
    if (e.length === 0) return { x: 0, y: 0, width: 0, height: 0 }
    const n = e.reduce(
      (o, r) => {
        const i = typeof r == 'string'
        let s = !t.nodeLookup && !i ? r : void 0
        t.nodeLookup && (s = i ? t.nodeLookup.get(r) : Rd(r) ? r : t.nodeLookup.get(r.id))
        const a = s ? ya(s, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 }
        return Nl(o, a)
      },
      { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }
    )
    return kl(n)
  },
  rs = (e, t = {}) => {
    if (e.size === 0) return { x: 0, y: 0, width: 0, height: 0 }
    let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }
    return (
      e.forEach(o => {
        if (t.filter === void 0 || t.filter(o)) {
          const r = ya(o)
          n = Nl(n, r)
        }
      }),
      kl(n)
    )
  },
  Xm = (e, t, [n, o, r] = [0, 0, 1], i = !1, s = !1) => {
    const a = {
        ...is(t, [n, o, r]),
        width: t.width / r,
        height: t.height / r,
      },
      l = []
    for (const c of e.values()) {
      const { measured: u, selectable: d = !0, hidden: f = !1 } = c
      if ((s && !d) || f) continue
      const A = u.width ?? c.width ?? c.initialWidth ?? null,
        h = u.height ?? c.height ?? c.initialHeight ?? null,
        g = Wi(a, Lr(c)),
        x = (A ?? 0) * (h ?? 0),
        m = i && g > 0
      ;(!c.internals.handleBounds || m || g >= x || c.dragging) && l.push(c)
    }
    return l
  },
  fu = (e, t) => {
    const n = /* @__PURE__ */ new Set()
    return (
      e.forEach(o => {
        n.add(o.id)
      }),
      t.filter(o => n.has(o.source) || n.has(o.target))
    )
  }
function Au(e, t) {
  const n = /* @__PURE__ */ new Map(),
    o = t != null && t.nodes ? new Set(t.nodes.map(r => r.id)) : null
  return (
    e.forEach(r => {
      r.measured.width && r.measured.height && ((t == null ? void 0 : t.includeHiddenNodes) || !r.hidden) && (!o || o.has(r.id)) && n.set(r.id, r)
    }),
    n
  )
}
async function pu({ nodes: e, width: t, height: n, panZoom: o, minZoom: r, maxZoom: i }, s) {
  if (e.size === 0) return Promise.resolve(!1)
  const a = rs(e),
    l = Td(a, t, n, (s == null ? void 0 : s.minZoom) ?? r, (s == null ? void 0 : s.maxZoom) ?? i, (s == null ? void 0 : s.padding) ?? 0.1)
  return await o.setViewport(l, { duration: s == null ? void 0 : s.duration }), Promise.resolve(!0)
}
function Ym({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: o = [0, 0], nodeExtent: r, onError: i }) {
  const s = n.get(e),
    a = s.parentId ? n.get(s.parentId) : void 0,
    { x: l, y: c } = a ? a.internals.positionAbsolute : { x: 0, y: 0 },
    u = s.origin ?? o
  let d = r
  if (s.extent === 'parent' && !s.expandParent)
    if (!a) i == null || i('005', Jn.error005())
    else {
      const A = a.measured.width,
        h = a.measured.height
      A &&
        h &&
        (d = [
          [l, c],
          [l + A, c + h],
        ])
    }
  else
    a &&
      Rr(s.extent) &&
      (d = [
        [s.extent[0][0] + l, s.extent[0][1] + c],
        [s.extent[1][0] + l, s.extent[1][1] + c],
      ])
  const f = Rr(d) ? Ko(t, d, s.measured) : t
  return {
    position: {
      x: f.x - l + s.measured.width * u[0],
      y: f.y - c + s.measured.height * u[1],
    },
    positionAbsolute: f,
  }
}
async function P2({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: o, onBeforeDelete: r }) {
  const i = new Set(e.map(f => f.id)),
    s = []
  for (const f of n) {
    if (f.deletable === !1) continue
    const A = i.has(f.id),
      h = !A && f.parentId && s.find(g => g.id === f.parentId)
    ;(A || h) && s.push(f)
  }
  const a = new Set(t.map(f => f.id)),
    l = o.filter(f => f.deletable !== !1),
    u = fu(s, l)
  for (const f of l) a.has(f.id) && !u.find(h => h.id === f.id) && u.push(f)
  if (!r)
    return {
      edges: u,
      nodes: s,
    }
  const d = await r({
    nodes: s,
    edges: u,
  })
  return typeof d == 'boolean' ? (d ? { edges: u, nodes: s } : { edges: [], nodes: [] }) : d
}
const Pr = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n),
  Ko = (e = { x: 0, y: 0 }, t, n) => ({
    x: Pr(e.x, t[0][0], t[1][0] - ((n == null ? void 0 : n.width) ?? 0)),
    y: Pr(e.y, t[0][1], t[1][1] - ((n == null ? void 0 : n.height) ?? 0)),
  })
function Hm(e, t, n) {
  const { width: o, height: r } = _n(n),
    { x: i, y: s } = n.internals.positionAbsolute
  return Ko(
    e,
    [
      [i, s],
      [i + o, s + r],
    ],
    t
  )
}
const zA = (e, t, n) => (e < t ? Pr(Math.abs(e - t), 1, t) / t : e > n ? -Pr(Math.abs(e - n), 1, t) / t : 0),
  Um = (e, t, n = 15, o = 40) => {
    const r = zA(e.x, o, t.width - o) * n,
      i = zA(e.y, o, t.height - o) * n
    return [r, i]
  },
  Nl = (e, t) => ({
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x2, t.x2),
    y2: Math.max(e.y2, t.y2),
  }),
  hu = ({ x: e, y: t, width: n, height: o }) => ({
    x: e,
    y: t,
    x2: e + n,
    y2: t + o,
  }),
  kl = ({ x: e, y: t, x2: n, y2: o }) => ({
    x: e,
    y: t,
    width: n - e,
    height: o - t,
  }),
  Lr = (e, t = [0, 0]) => {
    var r, i
    const { x: n, y: o } = Rd(e) ? e.internals.positionAbsolute : os(e, t)
    return {
      x: n,
      y: o,
      width: ((r = e.measured) == null ? void 0 : r.width) ?? e.width ?? e.initialWidth ?? 0,
      height: ((i = e.measured) == null ? void 0 : i.height) ?? e.height ?? e.initialHeight ?? 0,
    }
  },
  ya = (e, t = [0, 0]) => {
    var r, i
    const { x: n, y: o } = Rd(e) ? e.internals.positionAbsolute : os(e, t)
    return {
      x: n,
      y: o,
      x2: n + (((r = e.measured) == null ? void 0 : r.width) ?? e.width ?? e.initialWidth ?? 0),
      y2: o + (((i = e.measured) == null ? void 0 : i.height) ?? e.height ?? e.initialHeight ?? 0),
    }
  },
  Km = (e, t) => kl(Nl(hu(e), hu(t))),
  Wi = (e, t) => {
    const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)),
      o = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y))
    return Math.ceil(n * o)
  },
  QA = e => pn(e.width) && pn(e.height) && pn(e.x) && pn(e.y),
  pn = e => !isNaN(e) && isFinite(e),
  L2 = (e, t) => {},
  Ml = (e, t = [1, 1]) => ({
    x: t[0] * Math.round(e.x / t[0]),
    y: t[1] * Math.round(e.y / t[1]),
  }),
  is = ({ x: e, y: t }, [n, o, r], i = !1, s = [1, 1]) => {
    const a = {
      x: (e - n) / r,
      y: (t - o) / r,
    }
    return i ? Ml(a, s) : a
  },
  qm = ({ x: e, y: t }, [n, o, r]) => ({
    x: e * r + n,
    y: t * r + o,
  }),
  Td = (e, t, n, o, r, i) => {
    const s = t / (e.width * (1 + i)),
      a = n / (e.height * (1 + i)),
      l = Math.min(s, a),
      c = Pr(l, o, r),
      u = e.x + e.width / 2,
      d = e.y + e.height / 2,
      f = t / 2 - u * c,
      A = n / 2 - d * c
    return { x: f, y: A, zoom: c }
  },
  ba = () => {
    var e
    return typeof navigator < 'u' && ((e = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : e.indexOf('Mac')) >= 0
  }
function Rr(e) {
  return e !== void 0 && e !== 'parent'
}
function _n(e) {
  var t, n
  return {
    width: ((t = e.measured) == null ? void 0 : t.width) ?? e.width ?? e.initialWidth ?? 0,
    height: ((n = e.measured) == null ? void 0 : n.height) ?? e.height ?? e.initialHeight ?? 0,
  }
}
function Zm(e) {
  var t, n
  return (((t = e.measured) == null ? void 0 : t.width) ?? e.width ?? e.initialWidth) !== void 0 && (((n = e.measured) == null ? void 0 : n.height) ?? e.height ?? e.initialHeight) !== void 0
}
function Jm(e, t = { width: 0, height: 0 }, n, o, r) {
  const i = { ...e },
    s = o.get(n)
  if (s) {
    const a = s.origin || r
    ;(i.x += s.internals.positionAbsolute.x - (t.width ?? 0) * a[0]), (i.y += s.internals.positionAbsolute.y - (t.height ?? 0) * a[1])
  }
  return i
}
function Si(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: o, containerBounds: r }) {
  const { x: i, y: s } = Xn(e),
    a = is({ x: i - ((r == null ? void 0 : r.left) ?? 0), y: s - ((r == null ? void 0 : r.top) ?? 0) }, o),
    { x: l, y: c } = n ? Ml(a, t) : a
  return {
    xSnapped: l,
    ySnapped: c,
    ...a,
  }
}
const Pl = e => ({
    width: e.offsetWidth,
    height: e.offsetHeight,
  }),
  _m = e => {
    var t
    return ((t = e.getRootNode) == null ? void 0 : t.call(e)) || (window == null ? void 0 : window.document)
  },
  R2 = ['INPUT', 'SELECT', 'TEXTAREA']
function gu(e) {
  var o, r, i
  const t = ((r = (o = e.composedPath) == null ? void 0 : o.call(e)) == null ? void 0 : r[0]) || e.target
  return R2.includes(t == null ? void 0 : t.nodeName) || ((i = t == null ? void 0 : t.hasAttribute) == null ? void 0 : i.call(t, 'contenteditable')) || !!(t != null && t.closest('.nokey'))
}
const $m = e => 'clientX' in e,
  Xn = (e, t) => {
    var i, s
    const n = $m(e),
      o = n ? e.clientX : (i = e.touches) == null ? void 0 : i[0].clientX,
      r = n ? e.clientY : (s = e.touches) == null ? void 0 : s[0].clientY
    return {
      x: o - ((t == null ? void 0 : t.left) ?? 0),
      y: r - ((t == null ? void 0 : t.top) ?? 0),
    }
  },
  OA = (e, t, n, o, r) => {
    const i = t.querySelectorAll(`.${e}`)
    return !i || !i.length
      ? null
      : Array.from(i).map(s => {
          const a = s.getBoundingClientRect()
          return {
            id: s.getAttribute('data-handleid'),
            type: e,
            nodeId: r,
            position: s.getAttribute('data-handlepos'),
            x: (a.left - n.left) / o,
            y: (a.top - n.top) / o,
            ...Pl(s),
          }
        })
  }
function e0({ sourceX: e, sourceY: t, targetX: n, targetY: o, sourceControlX: r, sourceControlY: i, targetControlX: s, targetControlY: a }) {
  const l = e * 0.125 + r * 0.375 + s * 0.375 + n * 0.125,
    c = t * 0.125 + i * 0.375 + a * 0.375 + o * 0.125,
    u = Math.abs(l - e),
    d = Math.abs(c - t)
  return [l, c, u, d]
}
function Is(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e)
}
function jA({ pos: e, x1: t, y1: n, x2: o, y2: r, c: i }) {
  switch (e) {
    case ye.Left:
      return [t - Is(t - o, i), n]
    case ye.Right:
      return [t + Is(o - t, i), n]
    case ye.Top:
      return [t, n - Is(n - r, i)]
    case ye.Bottom:
      return [t, n + Is(r - n, i)]
  }
}
function t0({ sourceX: e, sourceY: t, sourcePosition: n = ye.Bottom, targetX: o, targetY: r, targetPosition: i = ye.Top, curvature: s = 0.25 }) {
  const [a, l] = jA({
      pos: n,
      x1: e,
      y1: t,
      x2: o,
      y2: r,
      c: s,
    }),
    [c, u] = jA({
      pos: i,
      x1: o,
      y1: r,
      x2: e,
      y2: t,
      c: s,
    }),
    [d, f, A, h] = e0({
      sourceX: e,
      sourceY: t,
      targetX: o,
      targetY: r,
      sourceControlX: a,
      sourceControlY: l,
      targetControlX: c,
      targetControlY: u,
    })
  return [`M${e},${t} C${a},${l} ${c},${u} ${o},${r}`, d, f, A, h]
}
function n0({ sourceX: e, sourceY: t, targetX: n, targetY: o }) {
  const r = Math.abs(n - e) / 2,
    i = n < e ? n + r : n - r,
    s = Math.abs(o - t) / 2,
    a = o < t ? o + s : o - s
  return [i, a, r, s]
}
function T2({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: o = 0, elevateOnSelect: r = !1 }) {
  if (!r) return o
  const i = n || t.selected || e.selected,
    s = Math.max(e.internals.z || 0, t.internals.z || 0, 1e3)
  return o + (i ? s : 0)
}
function F2({ sourceNode: e, targetNode: t, width: n, height: o, transform: r }) {
  const i = Nl(ya(e), ya(t))
  i.x === i.x2 && (i.x2 += 1), i.y === i.y2 && (i.y2 += 1)
  const s = {
    x: -r[0] / r[2],
    y: -r[1] / r[2],
    width: n / r[2],
    height: o / r[2],
  }
  return Wi(s, kl(i)) > 0
}
const D2 = ({ source: e, sourceHandle: t, target: n, targetHandle: o }) => `xy-edge__${e}${t || ''}-${n}${o || ''}`,
  z2 = (e, t) => t.some(n => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || (!n.sourceHandle && !e.sourceHandle)) && (n.targetHandle === e.targetHandle || (!n.targetHandle && !e.targetHandle))),
  mu = (e, t) => {
    if (!e.source || !e.target) return t
    let n
    return (
      Vm(e)
        ? (n = { ...e })
        : (n = {
            ...e,
            id: D2(e),
          }),
      z2(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n))
    )
  }
function o0({ sourceX: e, sourceY: t, targetX: n, targetY: o }) {
  const [r, i, s, a] = n0({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: o,
  })
  return [`M ${e},${t}L ${n},${o}`, r, i, s, a]
}
const WA = {
    [ye.Left]: { x: -1, y: 0 },
    [ye.Right]: { x: 1, y: 0 },
    [ye.Top]: { x: 0, y: -1 },
    [ye.Bottom]: { x: 0, y: 1 },
  },
  Q2 = ({ source: e, sourcePosition: t = ye.Bottom, target: n }) => (t === ye.Left || t === ye.Right ? (e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 }) : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }),
  GA = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
function O2({ source: e, sourcePosition: t = ye.Bottom, target: n, targetPosition: o = ye.Top, center: r, offset: i }) {
  const s = WA[t],
    a = WA[o],
    l = { x: e.x + s.x * i, y: e.y + s.y * i },
    c = { x: n.x + a.x * i, y: n.y + a.y * i },
    u = Q2({
      source: l,
      sourcePosition: t,
      target: c,
    }),
    d = u.x !== 0 ? 'x' : 'y',
    f = u[d]
  let A = [],
    h,
    g
  const x = { x: 0, y: 0 },
    m = { x: 0, y: 0 },
    [v, y, b, C] = n0({
      sourceX: e.x,
      sourceY: e.y,
      targetX: n.x,
      targetY: n.y,
    })
  if (s[d] * a[d] === -1) {
    ;(h = r.x ?? v), (g = r.y ?? y)
    const w = [
        { x: h, y: l.y },
        { x: h, y: c.y },
      ],
      M = [
        { x: l.x, y: g },
        { x: c.x, y: g },
      ]
    s[d] === f ? (A = d === 'x' ? w : M) : (A = d === 'x' ? M : w)
  } else {
    const w = [{ x: l.x, y: c.y }],
      M = [{ x: c.x, y: l.y }]
    if ((d === 'x' ? (A = s.x === f ? M : w) : (A = s.y === f ? w : M), t === o)) {
      const z = Math.abs(e[d] - n[d])
      if (z <= i) {
        const E = Math.min(i - 1, i - z)
        s[d] === f ? (x[d] = (l[d] > e[d] ? -1 : 1) * E) : (m[d] = (c[d] > n[d] ? -1 : 1) * E)
      }
    }
    if (t !== o) {
      const z = d === 'x' ? 'y' : 'x',
        E = s[d] === a[z],
        P = l[z] > c[z],
        B = l[z] < c[z]
      ;((s[d] === 1 && ((!E && P) || (E && B))) || (s[d] !== 1 && ((!E && B) || (E && P)))) && (A = d === 'x' ? w : M)
    }
    const L = { x: l.x + x.x, y: l.y + x.y },
      R = { x: c.x + m.x, y: c.y + m.y },
      T = Math.max(Math.abs(L.x - A[0].x), Math.abs(R.x - A[0].x)),
      D = Math.max(Math.abs(L.y - A[0].y), Math.abs(R.y - A[0].y))
    T >= D ? ((h = (L.x + R.x) / 2), (g = A[0].y)) : ((h = A[0].x), (g = (L.y + R.y) / 2))
  }
  return [[e, { x: l.x + x.x, y: l.y + x.y }, ...A, { x: c.x + m.x, y: c.y + m.y }, n], h, g, b, C]
}
function j2(e, t, n, o) {
  const r = Math.min(GA(e, t) / 2, GA(t, n) / 2, o),
    { x: i, y: s } = t
  if ((e.x === i && i === n.x) || (e.y === s && s === n.y)) return `L${i} ${s}`
  if (e.y === s) {
    const c = e.x < n.x ? -1 : 1,
      u = e.y < n.y ? 1 : -1
    return `L ${i + r * c},${s}Q ${i},${s} ${i},${s + r * u}`
  }
  const a = e.x < n.x ? 1 : -1,
    l = e.y < n.y ? -1 : 1
  return `L ${i},${s + r * l}Q ${i},${s} ${i + r * a},${s}`
}
function va({ sourceX: e, sourceY: t, sourcePosition: n = ye.Bottom, targetX: o, targetY: r, targetPosition: i = ye.Top, borderRadius: s = 5, centerX: a, centerY: l, offset: c = 20 }) {
  const [u, d, f, A, h] = O2({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: o, y: r },
    targetPosition: i,
    center: { x: a, y: l },
    offset: c,
  })
  return [
    u.reduce((x, m, v) => {
      let y = ''
      return v > 0 && v < u.length - 1 ? (y = j2(u[v - 1], m, u[v + 1], s)) : (y = `${v === 0 ? 'M' : 'L'}${m.x} ${m.y}`), (x += y), x
    }, ''),
    d,
    f,
    A,
    h,
  ]
}
function VA(e) {
  var t
  return e && !!(e.internals.handleBounds || ((t = e.handles) != null && t.length)) && !!(e.measured.width || e.width || e.initialWidth)
}
function W2(e) {
  var d
  const { sourceNode: t, targetNode: n } = e
  if (!VA(t) || !VA(n)) return null
  const o = t.internals.handleBounds || XA(t.handles),
    r = n.internals.handleBounds || XA(n.handles),
    i = YA((o == null ? void 0 : o.source) ?? [], e.sourceHandle),
    s = YA(
      // when connection type is loose we can define all handles as sources and connect source -> source
      e.connectionMode === Mr.Strict ? (r == null ? void 0 : r.target) ?? [] : ((r == null ? void 0 : r.target) ?? []).concat((r == null ? void 0 : r.source) ?? []),
      e.targetHandle
    )
  if (!i || !s)
    return (
      (d = e.onError) == null ||
        d.call(
          e,
          '008',
          Jn.error008(i ? 'target' : 'source', {
            id: e.id,
            sourceHandle: e.sourceHandle,
            targetHandle: e.targetHandle,
          })
        ),
      null
    )
  const a = (i == null ? void 0 : i.position) || ye.Bottom,
    l = (s == null ? void 0 : s.position) || ye.Top,
    c = Gi(t, i, a),
    u = Gi(n, s, l)
  return {
    sourceX: c.x,
    sourceY: c.y,
    targetX: u.x,
    targetY: u.y,
    sourcePosition: a,
    targetPosition: l,
  }
}
function XA(e) {
  if (!e) return null
  const t = [],
    n = []
  for (const o of e) (o.width = o.width ?? 1), (o.height = o.height ?? 1), o.type === 'source' ? t.push(o) : o.type === 'target' && n.push(o)
  return {
    source: t,
    target: n,
  }
}
function Gi(e, t, n = ye.Left, o = !1) {
  const r = ((t == null ? void 0 : t.x) ?? 0) + e.internals.positionAbsolute.x,
    i = ((t == null ? void 0 : t.y) ?? 0) + e.internals.positionAbsolute.y,
    { width: s, height: a } = t ?? _n(e)
  if (o) return { x: r + s / 2, y: i + a / 2 }
  switch ((t == null ? void 0 : t.position) ?? n) {
    case ye.Top:
      return { x: r + s / 2, y: i }
    case ye.Right:
      return { x: r + s, y: i + a / 2 }
    case ye.Bottom:
      return { x: r + s / 2, y: i + a }
    case ye.Left:
      return { x: r, y: i + a / 2 }
  }
}
function YA(e, t) {
  return (e && (t ? e.find(n => n.id === t) : e[0])) || null
}
function yu(e, t) {
  return e
    ? typeof e == 'string'
      ? e
      : `${t ? `${t}__` : ''}${Object.keys(e)
          .sort()
          .map(o => `${o}=${e[o]}`)
          .join('&')}`
    : ''
}
function G2(e, { id: t, defaultColor: n, defaultMarkerStart: o, defaultMarkerEnd: r }) {
  const i = /* @__PURE__ */ new Set()
  return e
    .reduce(
      (s, a) => (
        [a.markerStart || o, a.markerEnd || r].forEach(l => {
          if (l && typeof l == 'object') {
            const c = yu(l, t)
            i.has(c) || (s.push({ id: c, color: l.color || n, ...l }), i.add(c))
          }
        }),
        s
      ),
      []
    )
    .sort((s, a) => s.id.localeCompare(a.id))
}
const Fd = {
    nodeOrigin: [0, 0],
    nodeExtent: Oi,
    elevateNodesOnSelect: !0,
    defaults: {},
  },
  V2 = {
    ...Fd,
    checkEquality: !0,
  }
function Dd(e, t) {
  const n = { ...e }
  for (const o in t) t[o] !== void 0 && (n[o] = t[o])
  return n
}
function X2(e, t, n) {
  const o = Dd(Fd, n)
  for (const r of e.values())
    if (r.parentId) zd(r, e, t, o)
    else {
      const i = os(r, o.nodeOrigin),
        s = Rr(r.extent) ? r.extent : o.nodeExtent,
        a = Ko(i, s, _n(r))
      r.internals.positionAbsolute = a
    }
}
function bu(e, t, n, o) {
  var a, l
  const r = Dd(V2, o),
    i = new Map(t),
    s = r != null && r.elevateNodesOnSelect ? 1e3 : 0
  t.clear(), n.clear()
  for (const c of e) {
    let u = i.get(c.id)
    if (r.checkEquality && c === (u == null ? void 0 : u.internals.userNode)) t.set(c.id, u)
    else {
      const d = os(c, r.nodeOrigin),
        f = Rr(c.extent) ? c.extent : r.nodeExtent,
        A = Ko(d, f, _n(c))
      ;(u = {
        ...r.defaults,
        ...c,
        measured: {
          width: (a = c.measured) == null ? void 0 : a.width,
          height: (l = c.measured) == null ? void 0 : l.height,
        },
        internals: {
          positionAbsolute: A,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: c.measured ? (u == null ? void 0 : u.internals.handleBounds) : void 0,
          z: r0(c, s),
          userNode: c,
        },
      }),
        t.set(c.id, u)
    }
    c.parentId && zd(u, t, n, o)
  }
}
function Y2(e, t) {
  if (!e.parentId) return
  const n = t.get(e.parentId)
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]))
}
function zd(e, t, n, o) {
  const { elevateNodesOnSelect: r, nodeOrigin: i, nodeExtent: s } = Dd(Fd, o),
    a = e.parentId,
    l = t.get(a)
  if (!l) {
    console.warn(`Parent node ${a} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`)
    return
  }
  Y2(e, n)
  const c = r ? 1e3 : 0,
    { x: u, y: d, z: f } = H2(e, l, i, s, c),
    { positionAbsolute: A } = e.internals,
    h = u !== A.x || d !== A.y
  ;(h || f !== e.internals.z) &&
    (e.internals = {
      ...e.internals,
      positionAbsolute: h ? { x: u, y: d } : A,
      z: f,
    })
}
function r0(e, t) {
  return (pn(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0)
}
function H2(e, t, n, o, r) {
  const { x: i, y: s } = t.internals.positionAbsolute,
    a = _n(e),
    l = os(e, n),
    c = Rr(e.extent) ? Ko(l, e.extent, a) : l
  let u = Ko({ x: i + c.x, y: s + c.y }, o, a)
  e.extent === 'parent' && (u = Hm(u, a, t))
  const d = r0(e, r),
    f = t.internals.z ?? 0
  return {
    x: u.x,
    y: u.y,
    z: f > d ? f : d,
  }
}
function Qd(e, t, n, o = [0, 0]) {
  var s
  const r = [],
    i = /* @__PURE__ */ new Map()
  for (const a of e) {
    const l = t.get(a.parentId)
    if (!l) continue
    const c = ((s = i.get(a.parentId)) == null ? void 0 : s.expandedRect) ?? Lr(l),
      u = Km(c, a.rect)
    i.set(a.parentId, { expandedRect: u, parent: l })
  }
  return (
    i.size > 0 &&
      i.forEach(({ expandedRect: a, parent: l }, c) => {
        var y
        const u = l.internals.positionAbsolute,
          d = _n(l),
          f = l.origin ?? o,
          A = a.x < u.x ? Math.round(Math.abs(u.x - a.x)) : 0,
          h = a.y < u.y ? Math.round(Math.abs(u.y - a.y)) : 0,
          g = Math.max(d.width, Math.round(a.width)),
          x = Math.max(d.height, Math.round(a.height)),
          m = (g - d.width) * f[0],
          v = (x - d.height) * f[1]
        ;(A > 0 || h > 0 || m || v) &&
          (r.push({
            id: c,
            type: 'position',
            position: {
              x: l.position.x - A + m,
              y: l.position.y - h + v,
            },
          }),
          (y = n.get(c)) == null ||
            y.forEach(b => {
              e.some(C => C.id === b.id) ||
                r.push({
                  id: b.id,
                  type: 'position',
                  position: {
                    x: b.position.x + A,
                    y: b.position.y + h,
                  },
                })
            })),
          (d.width < a.width || d.height < a.height || A || h) &&
            r.push({
              id: c,
              type: 'dimensions',
              setAttributes: !0,
              dimensions: {
                width: g + (A ? f[0] * A - m : 0),
                height: x + (h ? f[1] * h - v : 0),
              },
            })
      }),
    r
  )
}
function U2(e, t, n, o, r, i) {
  const s = o == null ? void 0 : o.querySelector('.xyflow__viewport')
  let a = !1
  if (!s) return { changes: [], updatedInternals: a }
  const l = [],
    c = window.getComputedStyle(s),
    { m22: u } = new window.DOMMatrixReadOnly(c.transform),
    d = []
  for (const f of e.values()) {
    const A = t.get(f.id)
    if (A)
      if (A.hidden)
        (A.internals = {
          ...A.internals,
          handleBounds: void 0,
        }),
          (a = !0)
      else {
        const h = Pl(f.nodeElement),
          g = A.measured.width !== h.width || A.measured.height !== h.height
        if (!!(h.width && h.height && (g || !A.internals.handleBounds || f.force))) {
          const m = f.nodeElement.getBoundingClientRect(),
            v = Rr(A.extent) ? A.extent : i
          let { positionAbsolute: y } = A.internals
          A.parentId && A.extent === 'parent' ? (y = Hm(y, h, t.get(A.parentId))) : v && (y = Ko(y, v, h)),
            (A.measured = h),
            (A.internals = {
              ...A.internals,
              positionAbsolute: y,
              handleBounds: {
                source: OA('source', f.nodeElement, m, u, A.id),
                target: OA('target', f.nodeElement, m, u, A.id),
              },
            }),
            A.parentId && zd(A, t, n, { nodeOrigin: r }),
            (a = !0),
            g &&
              (l.push({
                id: A.id,
                type: 'dimensions',
                dimensions: h,
              }),
              A.expandParent &&
                A.parentId &&
                d.push({
                  id: A.id,
                  parentId: A.parentId,
                  rect: Lr(A, r),
                }))
        }
      }
  }
  if (d.length > 0) {
    const f = Qd(d, t, n, r)
    l.push(...f)
  }
  return { changes: l, updatedInternals: a }
}
async function K2({ delta: e, panZoom: t, transform: n, translateExtent: o, width: r, height: i }) {
  if (!t || (!e.x && !e.y)) return Promise.resolve(!1)
  const s = await t.setViewportConstrained(
      {
        x: n[0] + e.x,
        y: n[1] + e.y,
        zoom: n[2],
      },
      [
        [0, 0],
        [r, i],
      ],
      o
    ),
    a = !!s && (s.x !== n[0] || s.y !== n[1] || s.k !== n[2])
  return Promise.resolve(a)
}
function i0(e, t, n) {
  e.clear(), t.clear()
  for (const o of n) {
    const { source: r, target: i, sourceHandle: s = null, targetHandle: a = null } = o,
      l = `${r}-source-${s}`,
      c = `${i}-target-${a}`,
      u = e.get(l) || /* @__PURE__ */ new Map(),
      d = e.get(c) || /* @__PURE__ */ new Map(),
      f = { edgeId: o.id, source: r, target: i, sourceHandle: s, targetHandle: a }
    t.set(o.id, o), e.set(l, u.set(`${i}-${a}`, f)), e.set(c, d.set(`${r}-${s}`, f))
  }
}
function s0(e, t) {
  if (!e.parentId) return !1
  const n = t.get(e.parentId)
  return n ? (n.selected ? !0 : s0(n, t)) : !1
}
function HA(e, t, n) {
  let o = e
  do {
    if (o != null && o.matches(t)) return !0
    if (o === n) return !1
    o = o.parentElement
  } while (o)
  return !1
}
function q2(e, t, n, o) {
  const r = /* @__PURE__ */ new Map()
  for (const [i, s] of e)
    if ((s.selected || s.id === o) && (!s.parentId || !s0(s, e)) && (s.draggable || (t && typeof s.draggable > 'u'))) {
      const a = e.get(i)
      a &&
        r.set(i, {
          id: i,
          position: a.position || { x: 0, y: 0 },
          distance: {
            x: n.x - a.internals.positionAbsolute.x,
            y: n.y - a.internals.positionAbsolute.y,
          },
          extent: a.extent,
          parentId: a.parentId,
          origin: a.origin,
          expandParent: a.expandParent,
          internals: {
            positionAbsolute: a.internals.positionAbsolute || { x: 0, y: 0 },
          },
          measured: {
            width: a.measured.width ?? 0,
            height: a.measured.height ?? 0,
          },
        })
    }
  return r
}
function gc({ nodeId: e, dragItems: t, nodeLookup: n, dragging: o = !0 }) {
  var s, a, l
  const r = []
  for (const [c, u] of t) {
    const d = (s = n.get(c)) == null ? void 0 : s.internals.userNode
    d &&
      r.push({
        ...d,
        position: u.position,
        dragging: o,
      })
  }
  if (!e) return [r[0], r]
  const i = (a = n.get(e)) == null ? void 0 : a.internals.userNode
  return [
    i
      ? {
          ...i,
          position: ((l = t.get(e)) == null ? void 0 : l.position) || i.position,
          dragging: o,
        }
      : r[0],
    r,
  ]
}
function Z2({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: o, onDragStop: r }) {
  let i = { x: null, y: null },
    s = 0,
    a = /* @__PURE__ */ new Map(),
    l = !1,
    c = { x: 0, y: 0 },
    u = null,
    d = !1,
    f = null,
    A = !1
  function h({ noDragClassName: x, handleSelector: m, domNode: v, isSelectable: y, nodeId: b, nodeClickDistance: C = 0 }) {
    f = Qt(v)
    function I({ x: R, y: T }, D) {
      const { nodeLookup: z, nodeExtent: E, snapGrid: P, snapToGrid: B, nodeOrigin: F, onNodeDrag: S, onSelectionDrag: Q, onError: j, updateNodePositions: U } = t()
      i = { x: R, y: T }
      let q = !1,
        ne = { x: 0, y: 0, x2: 0, y2: 0 }
      if (a.size > 1 && E) {
        const G = rs(a)
        ne = hu(G)
      }
      for (const [G, K] of a) {
        if (!z.has(G)) continue
        let $ = { x: R - K.distance.x, y: T - K.distance.y }
        B && ($ = Ml($, P))
        let oe = [
          [E[0][0], E[0][1]],
          [E[1][0], E[1][1]],
        ]
        if (a.size > 1 && E && !K.extent) {
          const { positionAbsolute: fe } = K.internals,
            se = fe.x - ne.x + E[0][0],
            re = fe.x + K.measured.width - ne.x2 + E[1][0],
            Y = fe.y - ne.y + E[0][1],
            H = fe.y + K.measured.height - ne.y2 + E[1][1]
          oe = [
            [se, Y],
            [re, H],
          ]
        }
        const { position: Z, positionAbsolute: ie } = Ym({
          nodeId: G,
          nextPosition: $,
          nodeLookup: z,
          nodeExtent: oe,
          nodeOrigin: F,
          onError: j,
        })
        ;(q = q || K.position.x !== Z.x || K.position.y !== Z.y), (K.position = Z), (K.internals.positionAbsolute = ie)
      }
      if (q && (U(a, !0), D && (o || S || (!b && Q)))) {
        const [G, K] = gc({
          nodeId: b,
          dragItems: a,
          nodeLookup: z,
        })
        o == null || o(D, a, G, K), S == null || S(D, G, K), b || Q == null || Q(D, K)
      }
    }
    async function w() {
      if (!u) return
      const { transform: R, panBy: T, autoPanSpeed: D } = t(),
        [z, E] = Um(c, u, D)
      ;(z !== 0 || E !== 0) && ((i.x = (i.x ?? 0) - z / R[2]), (i.y = (i.y ?? 0) - E / R[2]), (await T({ x: z, y: E })) && I(i, null)), (s = requestAnimationFrame(w))
    }
    function M(R) {
      var q
      const { nodeLookup: T, multiSelectionActive: D, nodesDraggable: z, transform: E, snapGrid: P, snapToGrid: B, selectNodesOnDrag: F, onNodeDragStart: S, onSelectionDragStart: Q, unselectNodesAndEdges: j } = t()
      ;(d = !0), (!F || !y) && !D && b && (((q = T.get(b)) != null && q.selected) || j()), y && F && b && (e == null || e(b))
      const U = Si(R.sourceEvent, { transform: E, snapGrid: P, snapToGrid: B, containerBounds: u })
      if (((i = U), (a = q2(T, z, U, b)), a.size > 0 && (n || S || (!b && Q)))) {
        const [ne, G] = gc({
          nodeId: b,
          dragItems: a,
          nodeLookup: T,
        })
        n == null || n(R.sourceEvent, a, ne, G), S == null || S(R.sourceEvent, ne, G), b || Q == null || Q(R.sourceEvent, G)
      }
    }
    const L = Nd()
      .clickDistance(C)
      .on('start', R => {
        const { domNode: T, nodeDragThreshold: D, transform: z, snapGrid: E, snapToGrid: P } = t()
        ;(u = (T == null ? void 0 : T.getBoundingClientRect()) || null), (A = !1), D === 0 && M(R), (i = Si(R.sourceEvent, { transform: z, snapGrid: E, snapToGrid: P, containerBounds: u })), (c = Xn(R.sourceEvent, u))
      })
      .on('drag', R => {
        const { autoPanOnNodeDrag: T, transform: D, snapGrid: z, snapToGrid: E, nodeDragThreshold: P, nodeLookup: B } = t(),
          F = Si(R.sourceEvent, { transform: D, snapGrid: z, snapToGrid: E, containerBounds: u })
        if (
          (((R.sourceEvent.type === 'touchmove' && R.sourceEvent.touches.length > 1) || // if user deletes a node while dragging, we need to abort the drag to prevent errors
            (b && !B.has(b))) &&
            (A = !0),
          !A)
        ) {
          if ((!l && T && d && ((l = !0), w()), !d)) {
            const S = F.xSnapped - (i.x ?? 0),
              Q = F.ySnapped - (i.y ?? 0)
            Math.sqrt(S * S + Q * Q) > P && M(R)
          }
          ;(i.x !== F.xSnapped || i.y !== F.ySnapped) && a && d && ((c = Xn(R.sourceEvent, u)), I(F, R.sourceEvent))
        }
      })
      .on('end', R => {
        if (!(!d || A) && ((l = !1), (d = !1), cancelAnimationFrame(s), a.size > 0)) {
          const { nodeLookup: T, updateNodePositions: D, onNodeDragStop: z, onSelectionDragStop: E } = t()
          if ((D(a, !1), r || z || (!b && E))) {
            const [P, B] = gc({
              nodeId: b,
              dragItems: a,
              nodeLookup: T,
              dragging: !1,
            })
            r == null || r(R.sourceEvent, a, P, B), z == null || z(R.sourceEvent, P, B), b || E == null || E(R.sourceEvent, B)
          }
        }
      })
      .filter(R => {
        const T = R.target
        return !R.button && (!x || !HA(T, `.${x}`, v)) && (!m || HA(T, m, v))
      })
    f.call(L)
  }
  function g() {
    f == null || f.on('.drag', null)
  }
  return {
    update: h,
    destroy: g,
  }
}
function J2(e, t, n) {
  const o = [],
    r = {
      x: e.x - n,
      y: e.y - n,
      width: n * 2,
      height: n * 2,
    }
  for (const i of t.values()) Wi(r, Lr(i)) > 0 && o.push(i)
  return o
}
const _2 = 250
function $2(e, t, n, o) {
  var a, l
  let r = [],
    i = 1 / 0
  const s = J2(e, n, t + _2)
  for (const c of s) {
    const u = [...(((a = c.internals.handleBounds) == null ? void 0 : a.source) ?? []), ...(((l = c.internals.handleBounds) == null ? void 0 : l.target) ?? [])]
    for (const d of u) {
      if (o.nodeId === d.nodeId && o.type === d.type && o.id === d.id) continue
      const { x: f, y: A } = Gi(c, d, d.position, !0),
        h = Math.sqrt(Math.pow(f - e.x, 2) + Math.pow(A - e.y, 2))
      h > t || (h < i ? ((r = [{ ...d, x: f, y: A }]), (i = h)) : h === i && r.push({ ...d, x: f, y: A }))
    }
  }
  if (!r.length) return null
  if (r.length > 1) {
    const c = o.type === 'source' ? 'target' : 'source'
    return r.find(u => u.type === c) ?? r[0]
  }
  return r[0]
}
function a0(e, t, n, o, r, i = !1) {
  var c, u, d
  const s = o.get(e)
  if (!s) return null
  const a = r === 'strict' ? ((c = s.internals.handleBounds) == null ? void 0 : c[t]) : [...(((u = s.internals.handleBounds) == null ? void 0 : u.source) ?? []), ...(((d = s.internals.handleBounds) == null ? void 0 : d.target) ?? [])],
    l = (n ? (a == null ? void 0 : a.find(f => f.id === n)) : a == null ? void 0 : a[0]) ?? null
  return l && i ? { ...l, ...Gi(s, l, l.position, !0) } : l
}
function l0(e, t) {
  return e || (t != null && t.classList.contains('target') ? 'target' : t != null && t.classList.contains('source') ? 'source' : null)
}
function eL(e, t) {
  let n = null
  return t ? (n = !0) : e && !t && (n = !1), n
}
const c0 = () => !0
function tL(
  e,
  {
    connectionMode: t,
    connectionRadius: n,
    handleId: o,
    nodeId: r,
    edgeUpdaterType: i,
    isTarget: s,
    domNode: a,
    nodeLookup: l,
    lib: c,
    autoPanOnConnect: u,
    flowId: d,
    panBy: f,
    cancelConnection: A,
    onConnectStart: h,
    onConnect: g,
    onConnectEnd: x,
    isValidConnection: m = c0,
    onReconnectEnd: v,
    updateConnection: y,
    getTransform: b,
    getFromHandle: C,
    autoPanSpeed: I,
  }
) {
  const w = _m(e.target)
  let M = 0,
    L
  const { x: R, y: T } = Xn(e),
    D = w == null ? void 0 : w.elementFromPoint(R, T),
    z = l0(i, D),
    E = a == null ? void 0 : a.getBoundingClientRect()
  if (!E || !z) return
  const P = a0(r, z, o, l, t)
  if (!P) return
  let B = Xn(e, E),
    F = !1,
    S = null,
    Q = !1,
    j = null
  function U() {
    if (!u || !E) return
    const [ie, fe] = Um(B, E, I)
    f({ x: ie, y: fe }), (M = requestAnimationFrame(U))
  }
  const q = {
      ...P,
      nodeId: r,
      type: z,
      position: P.position,
    },
    ne = l.get(r),
    K = {
      inProgress: !0,
      isValid: null,
      from: Gi(ne, q, ye.Left, !0),
      fromHandle: q,
      fromPosition: q.position,
      fromNode: ne,
      to: B,
      toHandle: null,
      toPosition: DA[q.position],
      toNode: null,
    }
  y(K)
  let $ = K
  h == null || h(e, { nodeId: r, handleId: o, handleType: z })
  function oe(ie) {
    if (!C() || !q) {
      Z(ie)
      return
    }
    const fe = b()
    ;(B = Xn(ie, E)), (L = $2(is(B, fe, !1, [1, 1]), n, l, q)), F || (U(), (F = !0))
    const se = u0(ie, {
      handle: L,
      connectionMode: t,
      fromNodeId: r,
      fromHandleId: o,
      fromType: s ? 'target' : 'source',
      isValidConnection: m,
      doc: w,
      lib: c,
      flowId: d,
      nodeLookup: l,
    })
    ;(j = se.handleDomNode), (S = se.connection), (Q = eL(!!L, se.isValid))
    const re = {
      // from stays the same
      ...$,
      isValid: Q,
      to: L && Q ? qm({ x: L.x, y: L.y }, fe) : B,
      toHandle: se.toHandle,
      toPosition: Q && se.toHandle ? se.toHandle.position : DA[q.position],
      toNode: se.toHandle ? l.get(se.toHandle.nodeId) : null,
    }
    ;(Q && L && $.toHandle && re.toHandle && $.toHandle.type === re.toHandle.type && $.toHandle.nodeId === re.toHandle.nodeId && $.toHandle.id === re.toHandle.id && $.to.x === re.to.x && $.to.y === re.to.y) || (y(re), ($ = re))
  }
  function Z(ie) {
    ;(L || j) && S && Q && (g == null || g(S))
    const { inProgress: fe, ...se } = $,
      re = {
        ...se,
        toPosition: $.toHandle ? $.toPosition : null,
      }
    x == null || x(ie, re), i && (v == null || v(ie, re)), A(), cancelAnimationFrame(M), (F = !1), (Q = !1), (S = null), (j = null), w.removeEventListener('mousemove', oe), w.removeEventListener('mouseup', Z), w.removeEventListener('touchmove', oe), w.removeEventListener('touchend', Z)
  }
  w.addEventListener('mousemove', oe), w.addEventListener('mouseup', Z), w.addEventListener('touchmove', oe), w.addEventListener('touchend', Z)
}
function u0(e, { handle: t, connectionMode: n, fromNodeId: o, fromHandleId: r, fromType: i, doc: s, lib: a, flowId: l, isValidConnection: c = c0, nodeLookup: u }) {
  const d = i === 'target',
    f = t ? s.querySelector(`.${a}-flow__handle[data-id="${l}-${t == null ? void 0 : t.nodeId}-${t == null ? void 0 : t.id}-${t == null ? void 0 : t.type}"]`) : null,
    { x: A, y: h } = Xn(e),
    g = s.elementFromPoint(A, h),
    x = g != null && g.classList.contains(`${a}-flow__handle`) ? g : f,
    m = {
      handleDomNode: x,
      isValid: !1,
      connection: null,
      toHandle: null,
    }
  if (x) {
    const v = l0(void 0, x),
      y = x.getAttribute('data-nodeid'),
      b = x.getAttribute('data-handleid'),
      C = x.classList.contains('connectable'),
      I = x.classList.contains('connectableend')
    if (!y || !v) return m
    const w = {
      source: d ? y : o,
      sourceHandle: d ? b : r,
      target: d ? o : y,
      targetHandle: d ? r : b,
    }
    m.connection = w
    const L = C && I && (n === Mr.Strict ? (d && v === 'source') || (!d && v === 'target') : y !== o || b !== r)
    ;(m.isValid = L && c(w)), (m.toHandle = a0(y, v, b, u, n, !1))
  }
  return m
}
const vu = {
  onPointerDown: tL,
  isValid: u0,
}
function nL({ domNode: e, panZoom: t, getTransform: n, getViewScale: o }) {
  const r = Qt(e)
  function i({ translateExtent: a, width: l, height: c, zoomStep: u = 10, pannable: d = !0, zoomable: f = !0, inversePan: A = !1 }) {
    const h = y => {
      const b = n()
      if (y.sourceEvent.type !== 'wheel' || !t) return
      const C = -y.sourceEvent.deltaY * (y.sourceEvent.deltaMode === 1 ? 0.05 : y.sourceEvent.deltaMode ? 1 : 2e-3) * u,
        I = b[2] * Math.pow(2, C)
      t.scaleTo(I)
    }
    let g = [0, 0]
    const x = y => {
        ;(y.sourceEvent.type === 'mousedown' || y.sourceEvent.type === 'touchstart') && (g = [y.sourceEvent.clientX ?? y.sourceEvent.touches[0].clientX, y.sourceEvent.clientY ?? y.sourceEvent.touches[0].clientY])
      },
      m = y => {
        const b = n()
        if ((y.sourceEvent.type !== 'mousemove' && y.sourceEvent.type !== 'touchmove') || !t) return
        const C = [y.sourceEvent.clientX ?? y.sourceEvent.touches[0].clientX, y.sourceEvent.clientY ?? y.sourceEvent.touches[0].clientY],
          I = [C[0] - g[0], C[1] - g[1]]
        g = C
        const w = o() * Math.max(b[2], Math.log(b[2])) * (A ? -1 : 1),
          M = {
            x: b[0] - I[0] * w,
            y: b[1] - I[1] * w,
          },
          L = [
            [0, 0],
            [l, c],
          ]
        t.setViewportConstrained(
          {
            x: M.x,
            y: M.y,
            zoom: b[2],
          },
          L,
          a
        )
      },
      v = Om()
        .on('start', x)
        .on('zoom', d ? m : null)
        .on('zoom.wheel', f ? h : null)
    r.call(v, {})
  }
  function s() {
    r.on('zoom', null)
  }
  return {
    update: i,
    destroy: s,
    pointer: dn,
  }
}
const oL = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k,
  Ll = e => ({
    x: e.x,
    y: e.y,
    zoom: e.k,
  }),
  mc = ({ x: e, y: t, zoom: n }) => Il.translate(e, t).scale(n),
  Ar = (e, t) => e.target.closest(`.${t}`),
  d0 = (e, t) => t === 2 && Array.isArray(e) && e.includes(2),
  yc = (e, t = 0, n = () => {}) => {
    const o = typeof t == 'number' && t > 0
    return o || n(), o ? e.transition().duration(t).on('end', n) : e
  },
  f0 = e => {
    const t = e.ctrlKey && ba() ? 10 : 1
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t
  }
function rL({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: o, panOnScrollMode: r, panOnScrollSpeed: i, zoomOnPinch: s, onPanZoomStart: a, onPanZoom: l, onPanZoomEnd: c }) {
  return u => {
    if (Ar(u, t)) return !1
    u.preventDefault(), u.stopImmediatePropagation()
    const d = n.property('__zoom').k || 1
    if (u.ctrlKey && s) {
      const x = dn(u),
        m = f0(u),
        v = d * Math.pow(2, m)
      o.scaleTo(n, v, x, u)
      return
    }
    const f = u.deltaMode === 1 ? 20 : 1
    let A = r === Wo.Vertical ? 0 : u.deltaX * f,
      h = r === Wo.Horizontal ? 0 : u.deltaY * f
    !ba() && u.shiftKey && r !== Wo.Vertical && ((A = u.deltaY * f), (h = 0)),
      o.translateBy(
        n,
        -(A / d) * i,
        -(h / d) * i,
        // @ts-ignore
        { internal: !0 }
      )
    const g = Ll(n.property('__zoom'))
    clearTimeout(e.panScrollTimeout),
      e.isPanScrolling || ((e.isPanScrolling = !0), a == null || a(u, g)),
      e.isPanScrolling &&
        (l == null || l(u, g),
        (e.panScrollTimeout = setTimeout(() => {
          c == null || c(u, g), (e.isPanScrolling = !1)
        }, 150)))
  }
}
function iL({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function (o, r) {
    if ((!t && o.type === 'wheel' && !o.ctrlKey) || Ar(o, e)) return null
    o.preventDefault(), n.call(this, o, r)
  }
}
function sL({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return o => {
    var i, s, a
    if ((i = o.sourceEvent) != null && i.internal) return
    const r = Ll(o.transform)
    ;(e.mouseButton = ((s = o.sourceEvent) == null ? void 0 : s.button) || 0), (e.isZoomingOrPanning = !0), (e.prevViewport = r), ((a = o.sourceEvent) == null ? void 0 : a.type) === 'mousedown' && t(!0), n && (n == null || n(o.sourceEvent, r))
  }
}
function aL({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: o, onPanZoom: r }) {
  return i => {
    var s, a
    ;(e.usedRightMouseButton = !!(n && d0(t, e.mouseButton ?? 0))), ((s = i.sourceEvent) != null && s.sync) || o([i.transform.x, i.transform.y, i.transform.k]), r && !((a = i.sourceEvent) != null && a.internal) && (r == null || r(i.sourceEvent, Ll(i.transform)))
  }
}
function lL({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: o, onPanZoomEnd: r, onPaneContextMenu: i }) {
  return s => {
    var a
    if (!((a = s.sourceEvent) != null && a.internal) && ((e.isZoomingOrPanning = !1), i && d0(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && s.sourceEvent && i(s.sourceEvent), (e.usedRightMouseButton = !1), o(!1), r && oL(e.prevViewport, s.transform))) {
      const l = Ll(s.transform)
      ;(e.prevViewport = l),
        clearTimeout(e.timerId),
        (e.timerId = setTimeout(
          () => {
            r == null || r(s.sourceEvent, l)
          },
          // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
          n ? 150 : 0
        ))
    }
  }
}
function cL({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: o, panOnScroll: r, zoomOnDoubleClick: i, userSelectionActive: s, noWheelClassName: a, noPanClassName: l, lib: c }) {
  return u => {
    var h
    const d = e || t,
      f = n && u.ctrlKey
    if (u.button === 1 && u.type === 'mousedown' && (Ar(u, `${c}-flow__node`) || Ar(u, `${c}-flow__edge`))) return !0
    if ((!o && !d && !r && !i && !n) || s || (Ar(u, a) && u.type === 'wheel') || (Ar(u, l) && (u.type !== 'wheel' || (r && u.type === 'wheel' && !e))) || (!n && u.ctrlKey && u.type === 'wheel')) return !1
    if (!n && u.type === 'touchstart' && ((h = u.touches) == null ? void 0 : h.length) > 1) return u.preventDefault(), !1
    if ((!d && !r && !f && u.type === 'wheel') || (!o && (u.type === 'mousedown' || u.type === 'touchstart')) || (Array.isArray(o) && !o.includes(u.button) && u.type === 'mousedown')) return !1
    const A = (Array.isArray(o) && o.includes(u.button)) || !u.button || u.button <= 1
    return (!u.ctrlKey || u.type === 'wheel') && A
  }
}
function uL({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: o, translateExtent: r, viewport: i, onPanZoom: s, onPanZoomStart: a, onPanZoomEnd: l, onDraggingChange: c }) {
  const u = {
      isZoomingOrPanning: !1,
      usedRightMouseButton: !1,
      prevViewport: { x: 0, y: 0, zoom: 0 },
      mouseButton: 0,
      timerId: void 0,
      panScrollTimeout: void 0,
      isPanScrolling: !1,
    },
    d = e.getBoundingClientRect(),
    f = Om()
      .clickDistance(!pn(o) || o < 0 ? 0 : o)
      .scaleExtent([t, n])
      .translateExtent(r),
    A = Qt(e).call(f)
  y(
    {
      x: i.x,
      y: i.y,
      zoom: Pr(i.zoom, t, n),
    },
    [
      [0, 0],
      [d.width, d.height],
    ],
    r
  )
  const h = A.on('wheel.zoom'),
    g = A.on('dblclick.zoom')
  f.wheelDelta(f0)
  function x(D, z) {
    return A
      ? new Promise(E => {
          f == null ||
            f.transform(
              yc(A, z == null ? void 0 : z.duration, () => E(!0)),
              D
            )
        })
      : Promise.resolve(!1)
  }
  function m({ noWheelClassName: D, noPanClassName: z, onPaneContextMenu: E, userSelectionActive: P, panOnScroll: B, panOnDrag: F, panOnScrollMode: S, panOnScrollSpeed: Q, preventScrolling: j, zoomOnPinch: U, zoomOnScroll: q, zoomOnDoubleClick: ne, zoomActivationKeyPressed: G, lib: K, onTransformChange: $ }) {
    P && !u.isZoomingOrPanning && v()
    const Z =
      B && !G && !P
        ? rL({
            zoomPanValues: u,
            noWheelClassName: D,
            d3Selection: A,
            d3Zoom: f,
            panOnScrollMode: S,
            panOnScrollSpeed: Q,
            zoomOnPinch: U,
            onPanZoomStart: a,
            onPanZoom: s,
            onPanZoomEnd: l,
          })
        : iL({
            noWheelClassName: D,
            preventScrolling: j,
            d3ZoomHandler: h,
          })
    if ((A.on('wheel.zoom', Z, { passive: !1 }), !P)) {
      const fe = sL({
        zoomPanValues: u,
        onDraggingChange: c,
        onPanZoomStart: a,
      })
      f.on('start', fe)
      const se = aL({
        zoomPanValues: u,
        panOnDrag: F,
        onPaneContextMenu: !!E,
        onPanZoom: s,
        onTransformChange: $,
      })
      f.on('zoom', se)
      const re = lL({
        zoomPanValues: u,
        panOnDrag: F,
        panOnScroll: B,
        onPaneContextMenu: E,
        onPanZoomEnd: l,
        onDraggingChange: c,
      })
      f.on('end', re)
    }
    const ie = cL({
      zoomActivationKeyPressed: G,
      panOnDrag: F,
      zoomOnScroll: q,
      panOnScroll: B,
      zoomOnDoubleClick: ne,
      zoomOnPinch: U,
      userSelectionActive: P,
      noPanClassName: z,
      noWheelClassName: D,
      lib: K,
    })
    f.filter(ie), ne ? A.on('dblclick.zoom', g) : A.on('dblclick.zoom', null)
  }
  function v() {
    f.on('zoom', null)
  }
  async function y(D, z, E) {
    const P = mc(D),
      B = f == null ? void 0 : f.constrain()(P, z, E)
    return B && (await x(B)), new Promise(F => F(B))
  }
  async function b(D, z) {
    const E = mc(D)
    return await x(E, z), new Promise(P => P(E))
  }
  function C(D) {
    if (A) {
      const z = mc(D),
        E = A.property('__zoom')
      ;(E.k !== D.zoom || E.x !== D.x || E.y !== D.y) && (f == null || f.transform(A, z, null, { sync: !0 }))
    }
  }
  function I() {
    const D = A ? Qm(A.node()) : { x: 0, y: 0, k: 1 }
    return { x: D.x, y: D.y, zoom: D.k }
  }
  function w(D, z) {
    return A
      ? new Promise(E => {
          f == null ||
            f.scaleTo(
              yc(A, z == null ? void 0 : z.duration, () => E(!0)),
              D
            )
        })
      : Promise.resolve(!1)
  }
  function M(D, z) {
    return A
      ? new Promise(E => {
          f == null ||
            f.scaleBy(
              yc(A, z == null ? void 0 : z.duration, () => E(!0)),
              D
            )
        })
      : Promise.resolve(!1)
  }
  function L(D) {
    f == null || f.scaleExtent(D)
  }
  function R(D) {
    f == null || f.translateExtent(D)
  }
  function T(D) {
    const z = !pn(D) || D < 0 ? 0 : D
    f == null || f.clickDistance(z)
  }
  return {
    update: m,
    destroy: v,
    setViewport: b,
    setViewportConstrained: y,
    getViewport: I,
    scaleTo: w,
    scaleBy: M,
    setScaleExtent: L,
    setTranslateExtent: R,
    syncViewport: C,
    setClickDistance: T,
  }
}
var Bi
;(function (e) {
  ;(e.Line = 'line'), (e.Handle = 'handle')
})(Bi || (Bi = {}))
function dL({ width: e, prevWidth: t, height: n, prevHeight: o, affectsX: r, affectsY: i }) {
  const s = e - t,
    a = n - o,
    l = [s > 0 ? 1 : s < 0 ? -1 : 0, a > 0 ? 1 : a < 0 ? -1 : 0]
  return s && r && (l[0] = l[0] * -1), a && i && (l[1] = l[1] * -1), l
}
function fL(e) {
  const t = e.includes('right') || e.includes('left'),
    n = e.includes('bottom') || e.includes('top'),
    o = e.includes('left'),
    r = e.includes('top')
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: o,
    affectsY: r,
  }
}
function no(e, t) {
  return Math.max(0, t - e)
}
function oo(e, t) {
  return Math.max(0, e - t)
}
function Ns(e, t, n) {
  return Math.max(0, t - e, e - n)
}
function UA(e, t) {
  return e ? !t : t
}
function AL(e, t, n, o, r, i, s, a) {
  let { affectsX: l, affectsY: c } = t
  const { isHorizontal: u, isVertical: d } = t,
    f = u && d,
    { xSnapped: A, ySnapped: h } = n,
    { minWidth: g, maxWidth: x, minHeight: m, maxHeight: v } = o,
    { x: y, y: b, width: C, height: I, aspectRatio: w } = e
  let M = Math.floor(u ? A - e.pointerX : 0),
    L = Math.floor(d ? h - e.pointerY : 0)
  const R = C + (l ? -M : M),
    T = I + (c ? -L : L),
    D = -i[0] * C,
    z = -i[1] * I
  let E = Ns(R, g, x),
    P = Ns(T, m, v)
  if (s) {
    let S = 0,
      Q = 0
    l && M < 0 ? (S = no(y + M + D, s[0][0])) : !l && M > 0 && (S = oo(y + R + D, s[1][0])), c && L < 0 ? (Q = no(b + L + z, s[0][1])) : !c && L > 0 && (Q = oo(b + T + z, s[1][1])), (E = Math.max(E, S)), (P = Math.max(P, Q))
  }
  if (a) {
    let S = 0,
      Q = 0
    l && M > 0 ? (S = oo(y + M, a[0][0])) : !l && M < 0 && (S = no(y + R, a[1][0])), c && L > 0 ? (Q = oo(b + L, a[0][1])) : !c && L < 0 && (Q = no(b + T, a[1][1])), (E = Math.max(E, S)), (P = Math.max(P, Q))
  }
  if (r) {
    if (u) {
      const S = Ns(R / w, m, v) * w
      if (((E = Math.max(E, S)), s)) {
        let Q = 0
        ;(!l && !c) || (l && !c && f) ? (Q = oo(b + z + R / w, s[1][1]) * w) : (Q = no(b + z + (l ? M : -M) / w, s[0][1]) * w), (E = Math.max(E, Q))
      }
      if (a) {
        let Q = 0
        ;(!l && !c) || (l && !c && f) ? (Q = no(b + R / w, a[1][1]) * w) : (Q = oo(b + (l ? M : -M) / w, a[0][1]) * w), (E = Math.max(E, Q))
      }
    }
    if (d) {
      const S = Ns(T * w, g, x) / w
      if (((P = Math.max(P, S)), s)) {
        let Q = 0
        ;(!l && !c) || (c && !l && f) ? (Q = oo(y + T * w + D, s[1][0]) / w) : (Q = no(y + (c ? L : -L) * w + D, s[0][0]) / w), (P = Math.max(P, Q))
      }
      if (a) {
        let Q = 0
        ;(!l && !c) || (c && !l && f) ? (Q = no(y + T * w, a[1][0]) / w) : (Q = oo(y + (c ? L : -L) * w, a[0][0]) / w), (P = Math.max(P, Q))
      }
    }
  }
  ;(L = L + (L < 0 ? P : -P)), (M = M + (M < 0 ? E : -E)), r && (f ? (R > T * w ? (L = (UA(l, c) ? -M : M) / w) : (M = (UA(l, c) ? -L : L) * w)) : u ? ((L = M / w), (c = l)) : ((M = L * w), (l = c)))
  const B = l ? y + M : y,
    F = c ? b + L : b
  return {
    width: C + (l ? -M : M),
    height: I + (c ? -L : L),
    x: i[0] * M * (l ? -1 : 1) + B,
    y: i[1] * L * (c ? -1 : 1) + F,
  }
}
const A0 = { width: 0, height: 0, x: 0, y: 0 },
  pL = {
    ...A0,
    pointerX: 0,
    pointerY: 0,
    aspectRatio: 1,
  }
function hL(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height],
  ]
}
function gL(e, t, n) {
  const o = t.position.x + e.position.x,
    r = t.position.y + e.position.y,
    i = e.measured.width ?? 0,
    s = e.measured.height ?? 0,
    a = n[0] * i,
    l = n[1] * s
  return [
    [o - a, r - l],
    [o + i - a, r + s - l],
  ]
}
function mL({ domNode: e, nodeId: t, getStoreItems: n, onChange: o, onEnd: r }) {
  const i = Qt(e)
  function s({ controlPosition: l, boundaries: c, keepAspectRatio: u, onResizeStart: d, onResize: f, onResizeEnd: A, shouldResize: h }) {
    let g = { ...A0 },
      x = { ...pL }
    const m = fL(l)
    let v,
      y = null,
      b = [],
      C,
      I,
      w
    const M = Nd()
      .on('start', L => {
        const { nodeLookup: R, transform: T, snapGrid: D, snapToGrid: z, nodeOrigin: E, paneDomNode: P } = n()
        if (((v = R.get(t)), !v)) return
        y = (P == null ? void 0 : P.getBoundingClientRect()) ?? null
        const { xSnapped: B, ySnapped: F } = Si(L.sourceEvent, {
          transform: T,
          snapGrid: D,
          snapToGrid: z,
          containerBounds: y,
        })
        ;(g = {
          width: v.measured.width ?? 0,
          height: v.measured.height ?? 0,
          x: v.position.x ?? 0,
          y: v.position.y ?? 0,
        }),
          (x = {
            ...g,
            pointerX: B,
            pointerY: F,
            aspectRatio: g.width / g.height,
          }),
          (C = void 0),
          v.parentId && (v.extent === 'parent' || v.expandParent) && ((C = R.get(v.parentId)), (I = C && v.extent === 'parent' ? hL(C) : void 0)),
          (b = []),
          (w = void 0)
        for (const [S, Q] of R)
          if (
            Q.parentId === t &&
            (b.push({
              id: S,
              position: { ...Q.position },
              extent: Q.extent,
            }),
            Q.extent === 'parent' || Q.expandParent)
          ) {
            const j = gL(Q, v, Q.origin ?? E)
            w
              ? (w = [
                  [Math.min(j[0][0], w[0][0]), Math.min(j[0][1], w[0][1])],
                  [Math.max(j[1][0], w[1][0]), Math.max(j[1][1], w[1][1])],
                ])
              : (w = j)
          }
        d == null || d(L, { ...g })
      })
      .on('drag', L => {
        const { transform: R, snapGrid: T, snapToGrid: D, nodeOrigin: z } = n(),
          E = Si(L.sourceEvent, {
            transform: R,
            snapGrid: T,
            snapToGrid: D,
            containerBounds: y,
          }),
          P = []
        if (!v) return
        const { x: B, y: F, width: S, height: Q } = g,
          j = {},
          U = v.origin ?? z,
          { width: q, height: ne, x: G, y: K } = AL(x, m, E, c, u, U, I, w),
          $ = q !== S,
          oe = ne !== Q,
          Z = G !== B && $,
          ie = K !== F && oe
        if (!Z && !ie && !$ && !oe) return
        if ((Z || ie || U[0] === 1 || U[1] === 1) && ((j.x = Z ? G : g.x), (j.y = ie ? K : g.y), (g.x = j.x), (g.y = j.y), b.length > 0)) {
          const Y = G - B,
            H = K - F
          for (const ee of b)
            (ee.position = {
              x: ee.position.x - Y + U[0] * (q - S),
              y: ee.position.y - H + U[1] * (ne - Q),
            }),
              P.push(ee)
        }
        if ((($ || oe) && ((j.width = $ ? q : g.width), (j.height = oe ? ne : g.height), (g.width = j.width), (g.height = j.height)), C && v.expandParent)) {
          const Y = U[0] * (j.width ?? 0)
          j.x && j.x < Y && ((g.x = Y), (x.x = x.x - (j.x - Y)))
          const H = U[1] * (j.height ?? 0)
          j.y && j.y < H && ((g.y = H), (x.y = x.y - (j.y - H)))
        }
        const fe = dL({
            width: g.width,
            prevWidth: S,
            height: g.height,
            prevHeight: Q,
            affectsX: m.affectsX,
            affectsY: m.affectsY,
          }),
          se = { ...g, direction: fe }
        ;(h == null ? void 0 : h(L, se)) !== !1 && (f == null || f(L, se), o(j, P))
      })
      .on('end', L => {
        A == null || A(L, { ...g }), r == null || r()
      })
    i.call(M)
  }
  function a() {
    i.on('.drag', null)
  }
  return {
    update: s,
    destroy: a,
  }
}
var p0 = { exports: {} },
  h0 = {},
  g0 = { exports: {} },
  m0 = {}
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tr = ve
function yL(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var bL = typeof Object.is == 'function' ? Object.is : yL,
  vL = Tr.useState,
  xL = Tr.useEffect,
  CL = Tr.useLayoutEffect,
  wL = Tr.useDebugValue
function EL(e, t) {
  var n = t(),
    o = vL({ inst: { value: n, getSnapshot: t } }),
    r = o[0].inst,
    i = o[1]
  return (
    CL(
      function () {
        ;(r.value = n), (r.getSnapshot = t), bc(r) && i({ inst: r })
      },
      [e, n, t]
    ),
    xL(
      function () {
        return (
          bc(r) && i({ inst: r }),
          e(function () {
            bc(r) && i({ inst: r })
          })
        )
      },
      [e]
    ),
    wL(n),
    n
  )
}
function bc(e) {
  var t = e.getSnapshot
  e = e.value
  try {
    var n = t()
    return !bL(e, n)
  } catch {
    return !0
  }
}
function SL(e, t) {
  return t()
}
var BL = typeof window > 'u' || typeof window.document > 'u' || typeof window.document.createElement > 'u' ? SL : EL
m0.useSyncExternalStore = Tr.useSyncExternalStore !== void 0 ? Tr.useSyncExternalStore : BL
g0.exports = m0
var IL = g0.exports
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rl = ve,
  NL = IL
function kL(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var ML = typeof Object.is == 'function' ? Object.is : kL,
  PL = NL.useSyncExternalStore,
  LL = Rl.useRef,
  RL = Rl.useEffect,
  TL = Rl.useMemo,
  FL = Rl.useDebugValue
h0.useSyncExternalStoreWithSelector = function (e, t, n, o, r) {
  var i = LL(null)
  if (i.current === null) {
    var s = { hasValue: !1, value: null }
    i.current = s
  } else s = i.current
  i = TL(
    function () {
      function l(A) {
        if (!c) {
          if (((c = !0), (u = A), (A = o(A)), r !== void 0 && s.hasValue)) {
            var h = s.value
            if (r(h, A)) return (d = h)
          }
          return (d = A)
        }
        if (((h = d), ML(u, A))) return h
        var g = o(A)
        return r !== void 0 && r(h, g) ? h : ((u = A), (d = g))
      }
      var c = !1,
        u,
        d,
        f = n === void 0 ? null : n
      return [
        function () {
          return l(t())
        },
        f === null
          ? void 0
          : function () {
              return l(f())
            },
      ]
    },
    [t, n, o, r]
  )
  var a = PL(e, i[0], i[1])
  return (
    RL(
      function () {
        ;(s.hasValue = !0), (s.value = a)
      },
      [a]
    ),
    FL(a),
    a
  )
}
p0.exports = h0
var DL = p0.exports
const zL = /* @__PURE__ */ Oh(DL),
  KA = e => {
    let t
    const n = /* @__PURE__ */ new Set(),
      o = (u, d) => {
        const f = typeof u == 'function' ? u(t) : u
        if (!Object.is(f, t)) {
          const A = t
          ;(t = d ?? (typeof f != 'object' || f === null) ? f : Object.assign({}, t, f)), n.forEach(h => h(t, A))
        }
      },
      r = () => t,
      l = {
        setState: o,
        getState: r,
        getInitialState: () => c,
        subscribe: u => (n.add(u), () => n.delete(u)),
        destroy: () => {
          n.clear()
        },
      },
      c = (t = e(o, r, l))
    return l
  },
  QL = e => (e ? KA(e) : KA),
  { useDebugValue: OL } = ve,
  { useSyncExternalStoreWithSelector: jL } = zL,
  WL = e => e
function y0(e, t = WL, n) {
  const o = jL(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n)
  return OL(o), o
}
const qA = (e, t) => {
    const n = QL(e),
      o = (r, i = t) => y0(n, r, i)
    return Object.assign(o, n), o
  },
  GL = (e, t) => (e ? qA(e, t) : qA)
function ft(e, t) {
  if (Object.is(e, t)) return !0
  if (typeof e != 'object' || e === null || typeof t != 'object' || t === null) return !1
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1
    for (const [o, r] of e) if (!Object.is(r, t.get(o))) return !1
    return !0
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1
    for (const o of e) if (!t.has(o)) return !1
    return !0
  }
  const n = Object.keys(e)
  if (n.length !== Object.keys(t).length) return !1
  for (const o of n) if (!Object.prototype.hasOwnProperty.call(t, o) || !Object.is(e[o], t[o])) return !1
  return !0
}
const Tl = po(null),
  VL = Tl.Provider,
  b0 = Jn.error001()
function Re(e, t) {
  const n = qn(Tl)
  if (n === null) throw new Error(b0)
  return y0(n, e, t)
}
function ot() {
  const e = qn(Tl)
  if (e === null) throw new Error(b0)
  return Pe(
    () => ({
      getState: e.getState,
      setState: e.setState,
      subscribe: e.subscribe,
    }),
    [e]
  )
}
const ZA = { display: 'none' },
  XL = {
    position: 'absolute',
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: 'hidden',
    clip: 'rect(0px, 0px, 0px, 0px)',
    clipPath: 'inset(100%)',
  },
  v0 = 'react-flow__node-desc',
  x0 = 'react-flow__edge-desc',
  YL = 'react-flow__aria-live',
  HL = e => e.ariaLiveMessage
function UL({ rfId: e }) {
  const t = Re(HL)
  return p.jsx('div', { id: `${YL}-${e}`, 'aria-live': 'assertive', 'aria-atomic': 'true', style: XL, children: t })
}
function KL({ rfId: e, disableKeyboardA11y: t }) {
  return p.jsxs(p.Fragment, {
    children: [
      p.jsxs('div', { id: `${v0}-${e}`, style: ZA, children: ['Press enter or space to select a node.', !t && 'You can then use the arrow keys to move the node around.', ' Press delete to remove it and escape to cancel.', ' '] }),
      p.jsx('div', { id: `${x0}-${e}`, style: ZA, children: 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.' }),
      !t && p.jsx(UL, { rfId: e }),
    ],
  })
}
const qL = e => (e.userSelectionActive ? 'none' : 'all'),
  Fl = jr(({ position: e = 'top-left', children: t, className: n, style: o, ...r }, i) => {
    const s = Re(qL),
      a = `${e}`.split('-')
    return p.jsx('div', { className: bt(['react-flow__panel', n, ...a]), style: { ...o, pointerEvents: s }, ref: i, ...r, children: t })
  })
function ZL({ proOptions: e, position: t = 'bottom-right' }) {
  return e != null && e.hideAttribution
    ? null
    : p.jsx(Fl, {
        position: t,
        className: 'react-flow__attribution',
        'data-message': 'Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev',
        children: p.jsx('a', { href: 'https://reactflow.dev', target: '_blank', rel: 'noopener noreferrer', 'aria-label': 'React Flow attribution', children: 'React Flow' }),
      })
}
const JL = e => {
    const t = [],
      n = []
    for (const [, o] of e.nodeLookup) o.selected && t.push(o.internals.userNode)
    for (const [, o] of e.edgeLookup) o.selected && n.push(o)
    return { selectedNodes: t, selectedEdges: n }
  },
  ks = e => e.id
function _L(e, t) {
  return ft(e.selectedNodes.map(ks), t.selectedNodes.map(ks)) && ft(e.selectedEdges.map(ks), t.selectedEdges.map(ks))
}
function $L({ onSelectionChange: e }) {
  const t = ot(),
    { selectedNodes: n, selectedEdges: o } = Re(JL, _L)
  return (
    Ce(() => {
      const r = { nodes: n, edges: o }
      e == null || e(r), t.getState().onSelectionChangeHandlers.forEach(i => i(r))
    }, [n, o, e]),
    null
  )
}
const e5 = e => !!e.onSelectionChangeHandlers
function t5({ onSelectionChange: e }) {
  const t = Re(e5)
  return e || t ? p.jsx($L, { onSelectionChange: e }) : null
}
const C0 = [0, 0],
  n5 = { x: 0, y: 0, zoom: 1 },
  o5 = [
    'nodes',
    'edges',
    'defaultNodes',
    'defaultEdges',
    'onConnect',
    'onConnectStart',
    'onConnectEnd',
    'onClickConnectStart',
    'onClickConnectEnd',
    'nodesDraggable',
    'nodesConnectable',
    'nodesFocusable',
    'edgesFocusable',
    'edgesReconnectable',
    'elevateNodesOnSelect',
    'elevateEdgesOnSelect',
    'minZoom',
    'maxZoom',
    'nodeExtent',
    'onNodesChange',
    'onEdgesChange',
    'elementsSelectable',
    'connectionMode',
    'snapGrid',
    'snapToGrid',
    'translateExtent',
    'connectOnClick',
    'defaultEdgeOptions',
    'fitView',
    'fitViewOptions',
    'onNodesDelete',
    'onEdgesDelete',
    'onDelete',
    'onNodeDrag',
    'onNodeDragStart',
    'onNodeDragStop',
    'onSelectionDrag',
    'onSelectionDragStart',
    'onSelectionDragStop',
    'onMoveStart',
    'onMove',
    'onMoveEnd',
    'noPanClassName',
    'nodeOrigin',
    'autoPanOnConnect',
    'autoPanOnNodeDrag',
    'onError',
    'connectionRadius',
    'isValidConnection',
    'selectNodesOnDrag',
    'nodeDragThreshold',
    'onBeforeDelete',
    'debug',
    'autoPanSpeed',
    'paneClickDistance',
  ],
  JA = [...o5, 'rfId'],
  r5 = e => ({
    setNodes: e.setNodes,
    setEdges: e.setEdges,
    setMinZoom: e.setMinZoom,
    setMaxZoom: e.setMaxZoom,
    setTranslateExtent: e.setTranslateExtent,
    setNodeExtent: e.setNodeExtent,
    reset: e.reset,
    setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
    setPaneClickDistance: e.setPaneClickDistance,
  }),
  _A = {
    // these are values that are also passed directly to other components
    // than the StoreUpdater. We can reduce the number of setStore calls
    // by setting the same values here as prev fields.
    translateExtent: Oi,
    nodeOrigin: C0,
    minZoom: 0.5,
    maxZoom: 2,
    elementsSelectable: !0,
    noPanClassName: 'nopan',
    rfId: '1',
    paneClickDistance: 0,
  }
function i5(e) {
  const { setNodes: t, setEdges: n, setMinZoom: o, setMaxZoom: r, setTranslateExtent: i, setNodeExtent: s, reset: a, setDefaultNodesAndEdges: l, setPaneClickDistance: c } = Re(r5, ft),
    u = ot()
  Ce(
    () => (
      l(e.defaultNodes, e.defaultEdges),
      () => {
        ;(d.current = _A), a()
      }
    ),
    []
  )
  const d = Ne(_A)
  return (
    Ce(
      () => {
        for (const f of JA) {
          const A = e[f],
            h = d.current[f]
          A !== h &&
            (typeof e[f] > 'u' ||
              (f === 'nodes'
                ? t(A)
                : f === 'edges'
                ? n(A)
                : f === 'minZoom'
                ? o(A)
                : f === 'maxZoom'
                ? r(A)
                : f === 'translateExtent'
                ? i(A)
                : f === 'nodeExtent'
                ? s(A)
                : f === 'paneClickDistance'
                ? c(A)
                : f === 'fitView'
                ? u.setState({ fitViewOnInit: A })
                : f === 'fitViewOptions'
                ? u.setState({ fitViewOnInitOptions: A })
                : u.setState({ [f]: A })))
        }
        d.current = e
      },
      // Only re-run the effect if one of the fields we track changes
      JA.map(f => e[f])
    ),
    null
  )
}
function $A() {
  return typeof window > 'u' || !window.matchMedia ? null : window.matchMedia('(prefers-color-scheme: dark)')
}
function s5(e) {
  var o
  const [t, n] = be(e === 'system' ? null : e)
  return (
    Ce(() => {
      if (e !== 'system') {
        n(e)
        return
      }
      const r = $A(),
        i = () => n(r != null && r.matches ? 'dark' : 'light')
      return (
        i(),
        r == null || r.addEventListener('change', i),
        () => {
          r == null || r.removeEventListener('change', i)
        }
      )
    }, [e]),
    t !== null ? t : (o = $A()) != null && o.matches ? 'dark' : 'light'
  )
}
const ep = typeof document < 'u' ? document : null
function Fr(e = null, t = { target: ep, actInsideInputWithModifier: !0 }) {
  const [n, o] = be(!1),
    r = Ne(!1),
    i = Ne(/* @__PURE__ */ new Set([])),
    [s, a] = Pe(() => {
      if (e !== null) {
        const c = (Array.isArray(e) ? e : [e])
            .filter(d => typeof d == 'string')
            .map(d =>
              d
                .replace(
                  '+',
                  `
`
                )
                .replace(
                  `

`,
                  `
+`
                ).split(`
`)
            ),
          u = c.reduce((d, f) => d.concat(...f), [])
        return [c, u]
      }
      return [[], []]
    }, [e])
  return (
    Ce(() => {
      const l = (t == null ? void 0 : t.target) || ep
      if (e !== null) {
        const c = f => {
            if (((r.current = f.ctrlKey || f.metaKey || f.shiftKey), (!r.current || (r.current && !t.actInsideInputWithModifier)) && gu(f))) return !1
            const h = np(f.code, a)
            i.current.add(f[h]), tp(s, i.current, !1) && (f.preventDefault(), o(!0))
          },
          u = f => {
            if ((!r.current || (r.current && !t.actInsideInputWithModifier)) && gu(f)) return !1
            const h = np(f.code, a)
            tp(s, i.current, !0) ? (o(!1), i.current.clear()) : i.current.delete(f[h]), f.key === 'Meta' && i.current.clear(), (r.current = !1)
          },
          d = () => {
            i.current.clear(), o(!1)
          }
        return (
          l == null || l.addEventListener('keydown', c),
          l == null || l.addEventListener('keyup', u),
          window.addEventListener('blur', d),
          window.addEventListener('contextmenu', d),
          () => {
            l == null || l.removeEventListener('keydown', c), l == null || l.removeEventListener('keyup', u), window.removeEventListener('blur', d), window.removeEventListener('contextmenu', d)
          }
        )
      }
    }, [e, o]),
    n
  )
}
function tp(e, t, n) {
  return e.filter(o => n || o.length === t.size).some(o => o.every(r => t.has(r)))
}
function np(e, t) {
  return t.includes(e) ? 'code' : 'key'
}
const a5 = () => {
  const e = ot()
  return Pe(
    () => ({
      zoomIn: t => {
        const { panZoom: n } = e.getState()
        return n ? n.scaleBy(1.2, { duration: t == null ? void 0 : t.duration }) : Promise.resolve(!1)
      },
      zoomOut: t => {
        const { panZoom: n } = e.getState()
        return n ? n.scaleBy(1 / 1.2, { duration: t == null ? void 0 : t.duration }) : Promise.resolve(!1)
      },
      zoomTo: (t, n) => {
        const { panZoom: o } = e.getState()
        return o ? o.scaleTo(t, { duration: n == null ? void 0 : n.duration }) : Promise.resolve(!1)
      },
      getZoom: () => e.getState().transform[2],
      setViewport: async (t, n) => {
        const {
          transform: [o, r, i],
          panZoom: s,
        } = e.getState()
        return s
          ? (await s.setViewport(
              {
                x: t.x ?? o,
                y: t.y ?? r,
                zoom: t.zoom ?? i,
              },
              { duration: n == null ? void 0 : n.duration }
            ),
            Promise.resolve(!0))
          : Promise.resolve(!1)
      },
      getViewport: () => {
        const [t, n, o] = e.getState().transform
        return { x: t, y: n, zoom: o }
      },
      fitView: t => {
        const { nodeLookup: n, minZoom: o, maxZoom: r, panZoom: i, domNode: s } = e.getState()
        if (!i || !s) return Promise.resolve(!1)
        const a = Au(n, t),
          { width: l, height: c } = Pl(s)
        return pu(
          {
            nodes: a,
            width: l,
            height: c,
            minZoom: o,
            maxZoom: r,
            panZoom: i,
          },
          t
        )
      },
      setCenter: async (t, n, o) => {
        const { width: r, height: i, maxZoom: s, panZoom: a } = e.getState(),
          l = typeof (o == null ? void 0 : o.zoom) < 'u' ? o.zoom : s,
          c = r / 2 - t * l,
          u = i / 2 - n * l
        return a
          ? (await a.setViewport(
              {
                x: c,
                y: u,
                zoom: l,
              },
              { duration: o == null ? void 0 : o.duration }
            ),
            Promise.resolve(!0))
          : Promise.resolve(!1)
      },
      fitBounds: async (t, n) => {
        const { width: o, height: r, minZoom: i, maxZoom: s, panZoom: a } = e.getState(),
          l = Td(t, o, r, i, s, (n == null ? void 0 : n.padding) ?? 0.1)
        return a ? (await a.setViewport(l, { duration: n == null ? void 0 : n.duration }), Promise.resolve(!0)) : Promise.resolve(!1)
      },
      screenToFlowPosition: (t, n = { snapToGrid: !0 }) => {
        const { transform: o, snapGrid: r, domNode: i } = e.getState()
        if (!i) return t
        const { x: s, y: a } = i.getBoundingClientRect(),
          l = {
            x: t.x - s,
            y: t.y - a,
          }
        return is(l, o, n.snapToGrid, r)
      },
      flowToScreenPosition: t => {
        const { transform: n, domNode: o } = e.getState()
        if (!o) return t
        const { x: r, y: i } = o.getBoundingClientRect(),
          s = qm(t, n)
        return {
          x: s.x + r,
          y: s.y + i,
        }
      },
    }),
    []
  )
}
function w0(e, t) {
  const n = [],
    o = /* @__PURE__ */ new Map(),
    r = []
  for (const i of e)
    if (i.type === 'add') {
      r.push(i)
      continue
    } else if (i.type === 'remove' || i.type === 'replace') o.set(i.id, [i])
    else {
      const s = o.get(i.id)
      s ? s.push(i) : o.set(i.id, [i])
    }
  for (const i of t) {
    const s = o.get(i.id)
    if (!s) {
      n.push(i)
      continue
    }
    if (s[0].type === 'remove') continue
    if (s[0].type === 'replace') {
      n.push({ ...s[0].item })
      continue
    }
    const a = { ...i }
    for (const l of s) l5(l, a)
    n.push(a)
  }
  return (
    r.length &&
      r.forEach(i => {
        i.index !== void 0 ? n.splice(i.index, 0, { ...i.item }) : n.push({ ...i.item })
      }),
    n
  )
}
function l5(e, t) {
  switch (e.type) {
    case 'select': {
      t.selected = e.selected
      break
    }
    case 'position': {
      typeof e.position < 'u' && (t.position = e.position), typeof e.dragging < 'u' && (t.dragging = e.dragging)
      break
    }
    case 'dimensions': {
      typeof e.dimensions < 'u' && (t.measured ?? (t.measured = {}), (t.measured.width = e.dimensions.width), (t.measured.height = e.dimensions.height), e.setAttributes && ((t.width = e.dimensions.width), (t.height = e.dimensions.height))), typeof e.resizing == 'boolean' && (t.resizing = e.resizing)
      break
    }
  }
}
function E0(e, t) {
  return w0(e, t)
}
function S0(e, t) {
  return w0(e, t)
}
function Ro(e, t) {
  return {
    id: e,
    type: 'select',
    selected: t,
  }
}
function pr(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const o = []
  for (const [r, i] of e) {
    const s = t.has(r)
    !(i.selected === void 0 && !s) && i.selected !== s && (n && (i.selected = s), o.push(Ro(i.id, s)))
  }
  return o
}
function op({ items: e = [], lookup: t }) {
  var r
  const n = [],
    o = new Map(e.map(i => [i.id, i]))
  for (const [i, s] of e.entries()) {
    const a = t.get(s.id),
      l = ((r = a == null ? void 0 : a.internals) == null ? void 0 : r.userNode) ?? a
    l !== void 0 && l !== s && n.push({ id: s.id, item: s, type: 'replace' }), l === void 0 && n.push({ item: s, type: 'add', index: i })
  }
  for (const [i] of t) o.get(i) === void 0 && n.push({ id: i, type: 'remove' })
  return n
}
function rp(e) {
  return {
    id: e.id,
    type: 'remove',
  }
}
const ip = e => k2(e),
  c5 = e => Vm(e)
function B0(e) {
  return jr(e)
}
const u5 = typeof window < 'u' ? Ma : Ce
function sp(e) {
  const [t, n] = be(BigInt(0)),
    [o] = be(() => d5(() => n(r => r + BigInt(1))))
  return (
    u5(() => {
      const r = o.get()
      r.length && (e(r), o.reset())
    }, [t]),
    o
  )
}
function d5(e) {
  let t = []
  return {
    get: () => t,
    reset: () => {
      t = []
    },
    push: n => {
      t.push(n), e()
    },
  }
}
const I0 = po(null)
function f5({ children: e }) {
  const t = ot(),
    n = ge(a => {
      const { nodes: l = [], setNodes: c, hasDefaultNodes: u, onNodesChange: d, nodeLookup: f } = t.getState()
      let A = l
      for (const h of a) A = typeof h == 'function' ? h(A) : h
      u
        ? c(A)
        : d &&
          d(
            op({
              items: A,
              lookup: f,
            })
          )
    }, []),
    o = sp(n),
    r = ge(a => {
      const { edges: l = [], setEdges: c, hasDefaultEdges: u, onEdgesChange: d, edgeLookup: f } = t.getState()
      let A = l
      for (const h of a) A = typeof h == 'function' ? h(A) : h
      u
        ? c(A)
        : d &&
          d(
            op({
              items: A,
              lookup: f,
            })
          )
    }, []),
    i = sp(r),
    s = Pe(() => ({ nodeQueue: o, edgeQueue: i }), [])
  return p.jsx(I0.Provider, { value: s, children: e })
}
function A5() {
  const e = qn(I0)
  if (!e) throw new Error('useBatchContext must be used within a BatchProvider')
  return e
}
const p5 = e => !!e.panZoom
function qo() {
  const e = a5(),
    t = ot(),
    n = A5(),
    o = Re(p5),
    r = Pe(() => {
      const i = d => t.getState().nodeLookup.get(d),
        s = d => {
          n.nodeQueue.push(d)
        },
        a = d => {
          n.edgeQueue.push(d)
        },
        l = d => {
          var m, v
          const { nodeLookup: f, nodeOrigin: A } = t.getState(),
            h = ip(d) ? d : f.get(d.id),
            g = h.parentId ? Jm(h.position, h.measured, h.parentId, f, A) : h.position,
            x = {
              ...h,
              position: g,
              width: ((m = h.measured) == null ? void 0 : m.width) ?? h.width,
              height: ((v = h.measured) == null ? void 0 : v.height) ?? h.height,
            }
          return Lr(x)
        },
        c = (d, f, A = { replace: !1 }) => {
          s(h =>
            h.map(g => {
              if (g.id === d) {
                const x = typeof f == 'function' ? f(g) : f
                return A.replace && ip(x) ? x : { ...g, ...x }
              }
              return g
            })
          )
        },
        u = (d, f, A = { replace: !1 }) => {
          a(h =>
            h.map(g => {
              if (g.id === d) {
                const x = typeof f == 'function' ? f(g) : f
                return A.replace && c5(x) ? x : { ...g, ...x }
              }
              return g
            })
          )
        }
      return {
        getNodes: () => t.getState().nodes.map(d => ({ ...d })),
        getNode: d => {
          var f
          return (f = i(d)) == null ? void 0 : f.internals.userNode
        },
        getInternalNode: i,
        getEdges: () => {
          const { edges: d = [] } = t.getState()
          return d.map(f => ({ ...f }))
        },
        getEdge: d => t.getState().edgeLookup.get(d),
        setNodes: s,
        setEdges: a,
        addNodes: d => {
          const f = Array.isArray(d) ? d : [d]
          n.nodeQueue.push(A => [...A, ...f])
        },
        addEdges: d => {
          const f = Array.isArray(d) ? d : [d]
          n.edgeQueue.push(A => [...A, ...f])
        },
        toObject: () => {
          const { nodes: d = [], edges: f = [], transform: A } = t.getState(),
            [h, g, x] = A
          return {
            nodes: d.map(m => ({ ...m })),
            edges: f.map(m => ({ ...m })),
            viewport: {
              x: h,
              y: g,
              zoom: x,
            },
          }
        },
        deleteElements: async ({ nodes: d = [], edges: f = [] }) => {
          const { nodes: A, edges: h, onNodesDelete: g, onEdgesDelete: x, triggerNodeChanges: m, triggerEdgeChanges: v, onDelete: y, onBeforeDelete: b } = t.getState(),
            { nodes: C, edges: I } = await P2({
              nodesToRemove: d,
              edgesToRemove: f,
              nodes: A,
              edges: h,
              onBeforeDelete: b,
            }),
            w = I.length > 0,
            M = C.length > 0
          if (w) {
            const L = I.map(rp)
            x == null || x(I), v(L)
          }
          if (M) {
            const L = C.map(rp)
            g == null || g(C), m(L)
          }
          return (M || w) && (y == null || y({ nodes: C, edges: I })), { deletedNodes: C, deletedEdges: I }
        },
        getIntersectingNodes: (d, f = !0, A) => {
          const h = QA(d),
            g = h ? d : l(d),
            x = A !== void 0
          return g
            ? (A || t.getState().nodes).filter(m => {
                const v = t.getState().nodeLookup.get(m.id)
                if (v && !h && (m.id === d.id || !v.internals.positionAbsolute)) return !1
                const y = Lr(x ? m : v),
                  b = Wi(y, g)
                return (f && b > 0) || b >= g.width * g.height
              })
            : []
        },
        isNodeIntersecting: (d, f, A = !0) => {
          const g = QA(d) ? d : l(d)
          if (!g) return !1
          const x = Wi(g, f)
          return (A && x > 0) || x >= g.width * g.height
        },
        updateNode: c,
        updateNodeData: (d, f, A = { replace: !1 }) => {
          c(
            d,
            h => {
              const g = typeof f == 'function' ? f(h) : f
              return A.replace ? { ...h, data: g } : { ...h, data: { ...h.data, ...g } }
            },
            A
          )
        },
        updateEdge: u,
        updateEdgeData: (d, f, A = { replace: !1 }) => {
          u(
            d,
            h => {
              const g = typeof f == 'function' ? f(h) : f
              return A.replace ? { ...h, data: g } : { ...h, data: { ...h.data, ...g } }
            },
            A
          )
        },
        getNodesBounds: d => {
          const { nodeLookup: f, nodeOrigin: A } = t.getState()
          return M2(d, { nodeLookup: f, nodeOrigin: A })
        },
        getHandleConnections: ({ type: d, id: f, nodeId: A }) => {
          var h
          return Array.from(((h = t.getState().connectionLookup.get(`${A}-${d}-${f ?? null}`)) == null ? void 0 : h.values()) ?? [])
        },
      }
    }, [])
  return Pe(
    () => ({
      ...r,
      ...e,
      viewportInitialized: o,
    }),
    [o]
  )
}
const ap = e => e.selected,
  h5 = { actInsideInputWithModifier: !1 },
  g5 = typeof window < 'u' ? window : void 0
function m5({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = ot(),
    { deleteElements: o } = qo(),
    r = Fr(e, h5),
    i = Fr(t, { target: g5 })
  Ce(() => {
    if (r) {
      const { edges: s, nodes: a } = n.getState()
      o({ nodes: a.filter(ap), edges: s.filter(ap) }), n.setState({ nodesSelectionActive: !1 })
    }
  }, [r]),
    Ce(() => {
      n.setState({ multiSelectionActive: i })
    }, [i])
}
function y5(e) {
  const t = ot()
  Ce(() => {
    const n = () => {
      var r, i
      if (!e.current) return !1
      const o = Pl(e.current)
      ;(o.height === 0 || o.width === 0) && ((i = (r = t.getState()).onError) == null || i.call(r, '004', Jn.error004())), t.setState({ width: o.width || 500, height: o.height || 500 })
    }
    if (e.current) {
      n(), window.addEventListener('resize', n)
      const o = new ResizeObserver(() => n())
      return (
        o.observe(e.current),
        () => {
          window.removeEventListener('resize', n), o && e.current && o.unobserve(e.current)
        }
      )
    }
  }, [])
}
const Dl = {
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: 0,
    left: 0,
  },
  b5 = e => ({
    userSelectionActive: e.userSelectionActive,
    lib: e.lib,
  })
function v5({
  onPaneContextMenu: e,
  zoomOnScroll: t = !0,
  zoomOnPinch: n = !0,
  panOnScroll: o = !1,
  panOnScrollSpeed: r = 0.5,
  panOnScrollMode: i = Wo.Free,
  zoomOnDoubleClick: s = !0,
  panOnDrag: a = !0,
  defaultViewport: l,
  translateExtent: c,
  minZoom: u,
  maxZoom: d,
  zoomActivationKeyCode: f,
  preventScrolling: A = !0,
  children: h,
  noWheelClassName: g,
  noPanClassName: x,
  onViewportChange: m,
  isControlledViewport: v,
  paneClickDistance: y,
}) {
  const b = ot(),
    C = Ne(null),
    { userSelectionActive: I, lib: w } = Re(b5, ft),
    M = Fr(f),
    L = Ne()
  y5(C)
  const R = ge(
    T => {
      m == null || m({ x: T[0], y: T[1], zoom: T[2] }), v || b.setState({ transform: T })
    },
    [m, v]
  )
  return (
    Ce(() => {
      if (C.current) {
        L.current = uL({
          domNode: C.current,
          minZoom: u,
          maxZoom: d,
          translateExtent: c,
          viewport: l,
          paneClickDistance: y,
          onDraggingChange: E => b.setState({ paneDragging: E }),
          onPanZoomStart: (E, P) => {
            const { onViewportChangeStart: B, onMoveStart: F } = b.getState()
            F == null || F(E, P), B == null || B(P)
          },
          onPanZoom: (E, P) => {
            const { onViewportChange: B, onMove: F } = b.getState()
            F == null || F(E, P), B == null || B(P)
          },
          onPanZoomEnd: (E, P) => {
            const { onViewportChangeEnd: B, onMoveEnd: F } = b.getState()
            F == null || F(E, P), B == null || B(P)
          },
        })
        const { x: T, y: D, zoom: z } = L.current.getViewport()
        return (
          b.setState({
            panZoom: L.current,
            transform: [T, D, z],
            domNode: C.current.closest('.react-flow'),
          }),
          () => {
            var E
            ;(E = L.current) == null || E.destroy()
          }
        )
      }
    }, []),
    Ce(() => {
      var T
      ;(T = L.current) == null ||
        T.update({
          onPaneContextMenu: e,
          zoomOnScroll: t,
          zoomOnPinch: n,
          panOnScroll: o,
          panOnScrollSpeed: r,
          panOnScrollMode: i,
          zoomOnDoubleClick: s,
          panOnDrag: a,
          zoomActivationKeyPressed: M,
          preventScrolling: A,
          noPanClassName: x,
          userSelectionActive: I,
          noWheelClassName: g,
          lib: w,
          onTransformChange: R,
        })
    }, [e, t, n, o, r, i, s, a, M, A, x, I, g, w, R]),
    p.jsx('div', { className: 'react-flow__renderer', ref: C, style: Dl, children: h })
  )
}
const x5 = e => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect,
})
function C5() {
  const { userSelectionActive: e, userSelectionRect: t } = Re(x5, ft)
  return e && t
    ? p.jsx('div', {
        className: 'react-flow__selection react-flow__container',
        style: {
          width: t.width,
          height: t.height,
          transform: `translate(${t.x}px, ${t.y}px)`,
        },
      })
    : null
}
const vc = (e, t) => n => {
    n.target === t.current && (e == null || e(n))
  },
  w5 = e => ({
    userSelectionActive: e.userSelectionActive,
    elementsSelectable: e.elementsSelectable,
    dragging: e.paneDragging,
  })
function E5({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = ji.Full, panOnDrag: o, selectionOnDrag: r, onSelectionStart: i, onSelectionEnd: s, onPaneClick: a, onPaneContextMenu: l, onPaneScroll: c, onPaneMouseEnter: u, onPaneMouseMove: d, onPaneMouseLeave: f, children: A }) {
  const h = Ne(null),
    g = ot(),
    x = Ne(0),
    m = Ne(0),
    v = Ne(),
    y = Ne(/* @__PURE__ */ new Map()),
    { userSelectionActive: b, elementsSelectable: C, dragging: I } = Re(w5, ft),
    w = C && (e || b),
    M = Ne(!1),
    L = Ne(!1),
    R = () => {
      g.setState({ userSelectionActive: !1, userSelectionRect: null }), (x.current = 0), (m.current = 0)
    },
    T = S => {
      if (M.current) {
        M.current = !1
        return
      }
      a == null || a(S), g.getState().resetSelectedElements(), g.setState({ nodesSelectionActive: !1 })
    },
    D = S => {
      if (Array.isArray(o) && o != null && o.includes(2)) {
        S.preventDefault()
        return
      }
      l == null || l(S)
    },
    z = c ? S => c(S) : void 0,
    E = S => {
      var G, K, $, oe
      const { resetSelectedElements: Q, domNode: j, edgeLookup: U } = g.getState()
      if (((v.current = j == null ? void 0 : j.getBoundingClientRect()), !C || !e || S.button !== 0 || S.target !== h.current || !v.current)) return
      ;(K = (G = S.target) == null ? void 0 : G.setPointerCapture) == null || K.call(G, S.pointerId), (L.current = !0), (M.current = !1), (y.current = /* @__PURE__ */ new Map())
      for (const [Z, ie] of U) y.current.set(ie.source, (($ = y.current.get(ie.source)) == null ? void 0 : $.add(Z)) || /* @__PURE__ */ new Set([Z])), y.current.set(ie.target, ((oe = y.current.get(ie.target)) == null ? void 0 : oe.add(Z)) || /* @__PURE__ */ new Set([Z]))
      const { x: q, y: ne } = Xn(S.nativeEvent, v.current)
      Q(),
        g.setState({
          userSelectionRect: {
            width: 0,
            height: 0,
            startX: q,
            startY: ne,
            x: q,
            y: ne,
          },
        }),
        i == null || i(S)
    },
    P = S => {
      const { userSelectionRect: Q, edgeLookup: j, transform: U, nodeLookup: q, triggerNodeChanges: ne, triggerEdgeChanges: G } = g.getState()
      if (!v.current || !Q) return
      M.current = !0
      const { x: K, y: $ } = Xn(S.nativeEvent, v.current),
        { startX: oe, startY: Z } = Q,
        ie = {
          startX: oe,
          startY: Z,
          x: K < oe ? K : oe,
          y: $ < Z ? $ : Z,
          width: Math.abs(K - oe),
          height: Math.abs($ - Z),
        },
        fe = Xm(q, ie, U, n === ji.Partial, !0),
        se = /* @__PURE__ */ new Set(),
        re = /* @__PURE__ */ new Set()
      for (const Y of fe) {
        re.add(Y.id)
        const H = y.current.get(Y.id)
        if (H) for (const ee of H) se.add(ee)
      }
      if (x.current !== re.size) {
        x.current = re.size
        const Y = pr(q, re, !0)
        ne(Y)
      }
      if (m.current !== se.size) {
        m.current = se.size
        const Y = pr(j, se)
        G(Y)
      }
      g.setState({
        userSelectionRect: ie,
        userSelectionActive: !0,
        nodesSelectionActive: !1,
      })
    },
    B = S => {
      var j, U
      if (S.button !== 0 || !L.current) return
      ;(U = (j = S.target) == null ? void 0 : j.releasePointerCapture) == null || U.call(j, S.pointerId)
      const { userSelectionRect: Q } = g.getState()
      !b && Q && S.target === h.current && (T == null || T(S)), x.current > 0 && g.setState({ nodesSelectionActive: !0 }), R(), s == null || s(S), (t || r) && (M.current = !1), (L.current = !1)
    },
    F = o === !0 || (Array.isArray(o) && o.includes(0))
  return p.jsxs('div', {
    className: bt(['react-flow__pane', { draggable: F, dragging: I, selection: e }]),
    onClick: w ? void 0 : vc(T, h),
    onContextMenu: vc(D, h),
    onWheel: vc(z, h),
    onPointerEnter: w ? void 0 : u,
    onPointerDown: w ? E : d,
    onPointerMove: w ? P : d,
    onPointerUp: w ? B : void 0,
    onPointerLeave: f,
    ref: h,
    style: Dl,
    children: [A, p.jsx(C5, {})],
  })
}
function xu({ id: e, store: t, unselect: n = !1, nodeRef: o }) {
  const { addSelectedNodes: r, unselectNodesAndEdges: i, multiSelectionActive: s, nodeLookup: a, onError: l } = t.getState(),
    c = a.get(e)
  if (!c) {
    l == null || l('012', Jn.error012(e))
    return
  }
  t.setState({ nodesSelectionActive: !1 }),
    c.selected
      ? (n || (c.selected && s)) &&
        (i({ nodes: [c], edges: [] }),
        requestAnimationFrame(() => {
          var u
          return (u = o == null ? void 0 : o.current) == null ? void 0 : u.blur()
        }))
      : r([e])
}
function N0({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: o, nodeId: r, isSelectable: i, nodeClickDistance: s }) {
  const a = ot(),
    [l, c] = be(!1),
    u = Ne()
  return (
    Ce(() => {
      u.current = Z2({
        getStoreItems: () => a.getState(),
        onNodeMouseDown: d => {
          xu({
            id: d,
            store: a,
            nodeRef: e,
          })
        },
        onDragStart: () => {
          c(!0)
        },
        onDragStop: () => {
          c(!1)
        },
      })
    }, []),
    Ce(() => {
      var d, f
      if (t) (d = u.current) == null || d.destroy()
      else if (e.current)
        return (
          (f = u.current) == null ||
            f.update({
              noDragClassName: n,
              handleSelector: o,
              domNode: e.current,
              isSelectable: i,
              nodeId: r,
              nodeClickDistance: s,
            }),
          () => {
            var A
            ;(A = u.current) == null || A.destroy()
          }
        )
    }, [n, o, t, i, e, r]),
    l
  )
}
const S5 = e => t => t.selected && (t.draggable || (e && typeof t.draggable > 'u'))
function k0() {
  const e = ot()
  return ge(n => {
    const { nodeExtent: o, snapToGrid: r, snapGrid: i, nodesDraggable: s, onError: a, updateNodePositions: l, nodeLookup: c, nodeOrigin: u } = e.getState(),
      d = /* @__PURE__ */ new Map(),
      f = S5(s),
      A = r ? i[0] : 5,
      h = r ? i[1] : 5,
      g = n.direction.x * A * n.factor,
      x = n.direction.y * h * n.factor
    for (const [, m] of c) {
      if (!f(m)) continue
      let v = {
        x: m.internals.positionAbsolute.x + g,
        y: m.internals.positionAbsolute.y + x,
      }
      r && (v = Ml(v, i))
      const { position: y, positionAbsolute: b } = Ym({
        nodeId: m.id,
        nextPosition: v,
        nodeLookup: c,
        nodeExtent: o,
        nodeOrigin: u,
        onError: a,
      })
      ;(m.position = y), (m.internals.positionAbsolute = b), d.set(m.id, m)
    }
    l(d)
  }, [])
}
const Od = po(null),
  B5 = Od.Provider
Od.Consumer
const M0 = () => qn(Od),
  I5 = e => ({
    connectOnClick: e.connectOnClick,
    noPanClassName: e.noPanClassName,
    rfId: e.rfId,
  }),
  N5 = (e, t, n) => o => {
    const { connectionClickStartHandle: r, connectionMode: i, connection: s } = o,
      { fromHandle: a, toHandle: l, isValid: c } = s,
      u = (l == null ? void 0 : l.nodeId) === e && (l == null ? void 0 : l.id) === t && (l == null ? void 0 : l.type) === n
    return {
      connectingFrom: (a == null ? void 0 : a.nodeId) === e && (a == null ? void 0 : a.id) === t && (a == null ? void 0 : a.type) === n,
      connectingTo: u,
      clickConnecting: (r == null ? void 0 : r.nodeId) === e && (r == null ? void 0 : r.id) === t && (r == null ? void 0 : r.type) === n,
      isPossibleEndHandle: i === Mr.Strict ? (a == null ? void 0 : a.type) !== n : e !== (a == null ? void 0 : a.nodeId) || t !== (a == null ? void 0 : a.id),
      connectionInProcess: !!a,
      valid: u && c,
    }
  }
function k5({ type: e = 'source', position: t = ye.Top, isValidConnection: n, isConnectable: o = !0, isConnectableStart: r = !0, isConnectableEnd: i = !0, id: s, onConnect: a, children: l, className: c, onMouseDown: u, onTouchStart: d, ...f }, A) {
  var E, P
  const h = s || null,
    g = e === 'target',
    x = ot(),
    m = M0(),
    { connectOnClick: v, noPanClassName: y, rfId: b } = Re(I5, ft),
    { connectingFrom: C, connectingTo: I, clickConnecting: w, isPossibleEndHandle: M, connectionInProcess: L, valid: R } = Re(N5(m, h, e), ft)
  m || (P = (E = x.getState()).onError) == null || P.call(E, '010', Jn.error010())
  const T = B => {
      const { defaultEdgeOptions: F, onConnect: S, hasDefaultEdges: Q } = x.getState(),
        j = {
          ...F,
          ...B,
        }
      if (Q) {
        const { edges: U, setEdges: q } = x.getState()
        q(mu(j, U))
      }
      S == null || S(j), a == null || a(j)
    },
    D = B => {
      if (!m) return
      const F = $m(B.nativeEvent)
      if (r && ((F && B.button === 0) || !F)) {
        const S = x.getState()
        vu.onPointerDown(B.nativeEvent, {
          autoPanOnConnect: S.autoPanOnConnect,
          connectionMode: S.connectionMode,
          connectionRadius: S.connectionRadius,
          domNode: S.domNode,
          nodeLookup: S.nodeLookup,
          lib: S.lib,
          isTarget: g,
          handleId: h,
          nodeId: m,
          flowId: S.rfId,
          panBy: S.panBy,
          cancelConnection: S.cancelConnection,
          onConnectStart: S.onConnectStart,
          onConnectEnd: S.onConnectEnd,
          updateConnection: S.updateConnection,
          onConnect: T,
          isValidConnection: n || S.isValidConnection,
          getTransform: () => x.getState().transform,
          getFromHandle: () => x.getState().connection.fromHandle,
          autoPanSpeed: S.autoPanSpeed,
        })
      }
      F ? u == null || u(B) : d == null || d(B)
    },
    z = B => {
      const { onClickConnectStart: F, onClickConnectEnd: S, connectionClickStartHandle: Q, connectionMode: j, isValidConnection: U, lib: q, rfId: ne, nodeLookup: G, connection: K } = x.getState()
      if (!m || (!Q && !r)) return
      if (!Q) {
        F == null || F(B.nativeEvent, { nodeId: m, handleId: h, handleType: e }), x.setState({ connectionClickStartHandle: { nodeId: m, type: e, id: h } })
        return
      }
      const $ = _m(B.target),
        oe = n || U,
        { connection: Z, isValid: ie } = vu.isValid(B.nativeEvent, {
          handle: {
            nodeId: m,
            id: h,
            type: e,
          },
          connectionMode: j,
          fromNodeId: Q.nodeId,
          fromHandleId: Q.id || null,
          fromType: Q.type,
          isValidConnection: oe,
          flowId: ne,
          doc: $,
          lib: q,
          nodeLookup: G,
        })
      ie && Z && T(Z)
      const fe = structuredClone(K)
      delete fe.inProgress, (fe.toPosition = fe.toHandle ? fe.toHandle.position : null), S == null || S(B, fe), x.setState({ connectionClickStartHandle: null })
    }
  return p.jsx('div', {
    'data-handleid': h,
    'data-nodeid': m,
    'data-handlepos': t,
    'data-id': `${b}-${m}-${h}-${e}`,
    className: bt([
      'react-flow__handle',
      `react-flow__handle-${t}`,
      'nodrag',
      y,
      c,
      {
        source: !g,
        target: g,
        connectable: o,
        connectablestart: r,
        connectableend: i,
        clickconnecting: w,
        connectingfrom: C,
        connectingto: I,
        valid: R,
        // shows where you can start a connection from
        // and where you can end it while connecting
        connectionindicator: o && (!L || M) && (L ? i : r),
      },
    ]),
    onMouseDown: D,
    onTouchStart: D,
    onClick: v ? z : void 0,
    ref: A,
    ...f,
    children: l,
  })
}
const Vi = Te(B0(k5))
function M5({ data: e, isConnectable: t, sourcePosition: n = ye.Bottom }) {
  return p.jsxs(p.Fragment, { children: [e == null ? void 0 : e.label, p.jsx(Vi, { type: 'source', position: n, isConnectable: t })] })
}
function P5({ data: e, isConnectable: t, targetPosition: n = ye.Top, sourcePosition: o = ye.Bottom }) {
  return p.jsxs(p.Fragment, { children: [p.jsx(Vi, { type: 'target', position: n, isConnectable: t }), e == null ? void 0 : e.label, p.jsx(Vi, { type: 'source', position: o, isConnectable: t })] })
}
function L5() {
  return null
}
function R5({ data: e, isConnectable: t, targetPosition: n = ye.Top }) {
  return p.jsxs(p.Fragment, { children: [p.jsx(Vi, { type: 'target', position: n, isConnectable: t }), e == null ? void 0 : e.label] })
}
const xa = {
    ArrowUp: { x: 0, y: -1 },
    ArrowDown: { x: 0, y: 1 },
    ArrowLeft: { x: -1, y: 0 },
    ArrowRight: { x: 1, y: 0 },
  },
  lp = {
    input: M5,
    default: P5,
    output: R5,
    group: L5,
  }
function T5(e) {
  var t, n, o, r
  return e.internals.handleBounds === void 0
    ? {
        width: e.width ?? e.initialWidth ?? ((t = e.style) == null ? void 0 : t.width),
        height: e.height ?? e.initialHeight ?? ((n = e.style) == null ? void 0 : n.height),
      }
    : {
        width: e.width ?? ((o = e.style) == null ? void 0 : o.width),
        height: e.height ?? ((r = e.style) == null ? void 0 : r.height),
      }
}
const F5 = e => {
  const {
    width: t,
    height: n,
    x: o,
    y: r,
  } = rs(e.nodeLookup, {
    filter: i => !!i.selected,
  })
  return {
    width: pn(t) ? t : null,
    height: pn(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${o}px,${r}px)`,
  }
}
function D5({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const o = ot(),
    { width: r, height: i, transformString: s, userSelectionActive: a } = Re(F5, ft),
    l = k0(),
    c = Ne(null)
  if (
    (Ce(() => {
      var f
      n ||
        (f = c.current) == null ||
        f.focus({
          preventScroll: !0,
        })
    }, [n]),
    N0({
      nodeRef: c,
    }),
    a || !r || !i)
  )
    return null
  const u = e
      ? f => {
          const A = o.getState().nodes.filter(h => h.selected)
          e(f, A)
        }
      : void 0,
    d = f => {
      Object.prototype.hasOwnProperty.call(xa, f.key) &&
        (f.preventDefault(),
        l({
          direction: xa[f.key],
          factor: f.shiftKey ? 4 : 1,
        }))
    }
  return p.jsx('div', {
    className: bt(['react-flow__nodesselection', 'react-flow__container', t]),
    style: {
      transform: s,
    },
    children: p.jsx('div', {
      ref: c,
      className: 'react-flow__nodesselection-rect',
      onContextMenu: u,
      tabIndex: n ? void 0 : -1,
      onKeyDown: n ? void 0 : d,
      style: {
        width: r,
        height: i,
      },
    }),
  })
}
const cp = typeof window < 'u' ? window : void 0,
  z5 = e => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive })
function P0({
  children: e,
  onPaneClick: t,
  onPaneMouseEnter: n,
  onPaneMouseMove: o,
  onPaneMouseLeave: r,
  onPaneContextMenu: i,
  onPaneScroll: s,
  paneClickDistance: a,
  deleteKeyCode: l,
  selectionKeyCode: c,
  selectionOnDrag: u,
  selectionMode: d,
  onSelectionStart: f,
  onSelectionEnd: A,
  multiSelectionKeyCode: h,
  panActivationKeyCode: g,
  zoomActivationKeyCode: x,
  elementsSelectable: m,
  zoomOnScroll: v,
  zoomOnPinch: y,
  panOnScroll: b,
  panOnScrollSpeed: C,
  panOnScrollMode: I,
  zoomOnDoubleClick: w,
  panOnDrag: M,
  defaultViewport: L,
  translateExtent: R,
  minZoom: T,
  maxZoom: D,
  preventScrolling: z,
  onSelectionContextMenu: E,
  noWheelClassName: P,
  noPanClassName: B,
  disableKeyboardA11y: F,
  onViewportChange: S,
  isControlledViewport: Q,
}) {
  const { nodesSelectionActive: j, userSelectionActive: U } = Re(z5),
    q = Fr(c, { target: cp }),
    ne = Fr(g, { target: cp }),
    G = ne || M,
    K = ne || b,
    $ = u && G !== !0,
    oe = q || U || $
  return (
    m5({ deleteKeyCode: l, multiSelectionKeyCode: h }),
    p.jsx(v5, {
      onPaneContextMenu: i,
      elementsSelectable: m,
      zoomOnScroll: v,
      zoomOnPinch: y,
      panOnScroll: K,
      panOnScrollSpeed: C,
      panOnScrollMode: I,
      zoomOnDoubleClick: w,
      panOnDrag: !q && G,
      defaultViewport: L,
      translateExtent: R,
      minZoom: T,
      maxZoom: D,
      zoomActivationKeyCode: x,
      preventScrolling: z,
      noWheelClassName: P,
      noPanClassName: B,
      onViewportChange: S,
      isControlledViewport: Q,
      paneClickDistance: a,
      children: p.jsxs(E5, {
        onSelectionStart: f,
        onSelectionEnd: A,
        onPaneClick: t,
        onPaneMouseEnter: n,
        onPaneMouseMove: o,
        onPaneMouseLeave: r,
        onPaneContextMenu: i,
        onPaneScroll: s,
        panOnDrag: G,
        isSelecting: !!oe,
        selectionMode: d,
        selectionKeyPressed: q,
        selectionOnDrag: $,
        children: [e, j && p.jsx(D5, { onSelectionContextMenu: E, noPanClassName: B, disableKeyboardA11y: F })],
      }),
    })
  )
}
P0.displayName = 'FlowRenderer'
const Q5 = Te(P0),
  O5 = e => t => e ? Xm(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map(n => n.id) : Array.from(t.nodeLookup.keys())
function j5(e) {
  return Re(ge(O5(e), [e]), ft)
}
const W5 = e => e.updateNodeInternals
function G5() {
  const e = Re(W5),
    [t] = be(() =>
      typeof ResizeObserver > 'u'
        ? null
        : new ResizeObserver(n => {
            const o = /* @__PURE__ */ new Map()
            n.forEach(r => {
              const i = r.target.getAttribute('data-id')
              o.set(i, {
                id: i,
                nodeElement: r.target,
                force: !0,
              })
            }),
              e(o)
          })
    )
  return (
    Ce(
      () => () => {
        t == null || t.disconnect()
      },
      [t]
    ),
    t
  )
}
function V5({ node: e, nodeType: t, hasDimensions: n, resizeObserver: o }) {
  const r = ot(),
    i = Ne(null),
    s = Ne(null),
    a = Ne(e.sourcePosition),
    l = Ne(e.targetPosition),
    c = Ne(t),
    u = n && !!e.internals.handleBounds
  return (
    Ce(() => {
      i.current && !e.hidden && (!u || s.current !== i.current) && (s.current && (o == null || o.unobserve(s.current)), o == null || o.observe(i.current), (s.current = i.current))
    }, [u, e.hidden]),
    Ce(
      () => () => {
        s.current && (o == null || o.unobserve(s.current), (s.current = null))
      },
      []
    ),
    Ce(() => {
      if (i.current) {
        const d = c.current !== t,
          f = a.current !== e.sourcePosition,
          A = l.current !== e.targetPosition
        ;(d || f || A) && ((c.current = t), (a.current = e.sourcePosition), (l.current = e.targetPosition), r.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: i.current, force: !0 }]])))
      }
    }, [e.id, t, e.sourcePosition, e.targetPosition]),
    i
  )
}
function X5({
  id: e,
  onClick: t,
  onMouseEnter: n,
  onMouseMove: o,
  onMouseLeave: r,
  onContextMenu: i,
  onDoubleClick: s,
  nodesDraggable: a,
  elementsSelectable: l,
  nodesConnectable: c,
  nodesFocusable: u,
  resizeObserver: d,
  noDragClassName: f,
  noPanClassName: A,
  disableKeyboardA11y: h,
  rfId: g,
  nodeTypes: x,
  nodeExtent: m,
  nodeClickDistance: v,
  onError: y,
}) {
  const {
    node: b,
    internals: C,
    isParent: I,
  } = Re(Z => {
    const ie = Z.nodeLookup.get(e),
      fe = Z.parentLookup.has(e)
    return {
      node: ie,
      internals: ie.internals,
      isParent: fe,
    }
  }, ft)
  let w = b.type || 'default',
    M = (x == null ? void 0 : x[w]) || lp[w]
  M === void 0 && (y == null || y('003', Jn.error003(w)), (w = 'default'), (M = lp.default))
  const L = !!(b.draggable || (a && typeof b.draggable > 'u')),
    R = !!(b.selectable || (l && typeof b.selectable > 'u')),
    T = !!(b.connectable || (c && typeof b.connectable > 'u')),
    D = !!(b.focusable || (u && typeof b.focusable > 'u')),
    z = ot(),
    E = Zm(b),
    P = V5({ node: b, nodeType: w, hasDimensions: E, resizeObserver: d }),
    B = N0({
      nodeRef: P,
      disabled: b.hidden || !L,
      noDragClassName: f,
      handleSelector: b.dragHandle,
      nodeId: e,
      isSelectable: R,
      nodeClickDistance: v,
    }),
    F = k0()
  if (b.hidden) return null
  const S = _n(b),
    Q = T5(b),
    j = R || L || t || n || o || r,
    U = n ? Z => n(Z, { ...C.userNode }) : void 0,
    q = o ? Z => o(Z, { ...C.userNode }) : void 0,
    ne = r ? Z => r(Z, { ...C.userNode }) : void 0,
    G = i ? Z => i(Z, { ...C.userNode }) : void 0,
    K = s ? Z => s(Z, { ...C.userNode }) : void 0,
    $ = Z => {
      const { selectNodesOnDrag: ie, nodeDragThreshold: fe } = z.getState()
      R &&
        (!ie || !L || fe > 0) &&
        xu({
          id: e,
          store: z,
          nodeRef: P,
        }),
        t && t(Z, { ...C.userNode })
    },
    oe = Z => {
      if (!(gu(Z.nativeEvent) || h))
        if (jm.includes(Z.key) && R) {
          const ie = Z.key === 'Escape'
          xu({
            id: e,
            store: z,
            unselect: ie,
            nodeRef: P,
          })
        } else
          L &&
            b.selected &&
            Object.prototype.hasOwnProperty.call(xa, Z.key) &&
            (Z.preventDefault(),
            z.setState({
              ariaLiveMessage: `Moved selected node ${Z.key.replace('Arrow', '').toLowerCase()}. New position, x: ${~~C.positionAbsolute.x}, y: ${~~C.positionAbsolute.y}`,
            }),
            F({
              direction: xa[Z.key],
              factor: Z.shiftKey ? 4 : 1,
            }))
    }
  return p.jsx('div', {
    className: bt([
      'react-flow__node',
      `react-flow__node-${w}`,
      {
        // this is overwritable by passing `nopan` as a class name
        [A]: L,
      },
      b.className,
      {
        selected: b.selected,
        selectable: R,
        parent: I,
        draggable: L,
        dragging: B,
      },
    ]),
    ref: P,
    style: {
      zIndex: C.z,
      transform: `translate(${C.positionAbsolute.x}px,${C.positionAbsolute.y}px)`,
      pointerEvents: j ? 'all' : 'none',
      visibility: E ? 'visible' : 'hidden',
      ...b.style,
      ...Q,
    },
    'data-id': e,
    'data-testid': `rf__node-${e}`,
    onMouseEnter: U,
    onMouseMove: q,
    onMouseLeave: ne,
    onContextMenu: G,
    onClick: $,
    onDoubleClick: K,
    onKeyDown: D ? oe : void 0,
    tabIndex: D ? 0 : void 0,
    role: D ? 'button' : void 0,
    'aria-describedby': h ? void 0 : `${v0}-${g}`,
    'aria-label': b.ariaLabel,
    children: p.jsx(B5, {
      value: e,
      children: p.jsx(M, {
        id: e,
        data: b.data,
        type: w,
        positionAbsoluteX: C.positionAbsolute.x,
        positionAbsoluteY: C.positionAbsolute.y,
        selected: b.selected,
        selectable: R,
        draggable: L,
        deletable: b.deletable ?? !0,
        isConnectable: T,
        sourcePosition: b.sourcePosition,
        targetPosition: b.targetPosition,
        dragging: B,
        dragHandle: b.dragHandle,
        zIndex: C.z,
        parentId: b.parentId,
        ...S,
      }),
    }),
  })
}
const Y5 = e => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError,
})
function L0(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: o, elementsSelectable: r, onError: i } = Re(Y5, ft),
    s = j5(e.onlyRenderVisibleElements),
    a = G5()
  return p.jsx('div', {
    className: 'react-flow__nodes',
    style: Dl,
    children: s.map(l =>
      // The split of responsibilities between NodeRenderer and
      // NodeComponentWrapper may appear weird. However, it’s designed to
      // minimize the cost of updates when individual nodes change.
      //
      // For example, when you’re dragging a single node, that node gets
      // updated multiple times per second. If `NodeRenderer` were to update
      // every time, it would have to re-run the `nodes.map()` loop every
      // time. This gets pricey with hundreds of nodes, especially if every
      // loop cycle does more than just rendering a JSX element!
      //
      // As a result of this choice, we took the following implementation
      // decisions:
      // - NodeRenderer subscribes *only* to node IDs – and therefore
      //   rerender *only* when visible nodes are added or removed.
      // - NodeRenderer performs all operations the result of which can be
      //   shared between nodes (such as creating the `ResizeObserver`
      //   instance, or subscribing to `selector`). This means extra prop
      //   drilling into `NodeComponentWrapper`, but it means we need to run
      //   these operations only once – instead of once per node.
      // - Any operations that you’d normally write inside `nodes.map` are
      //   moved into `NodeComponentWrapper`. This ensures they are
      //   memorized – so if `NodeRenderer` *has* to rerender, it only
      //   needs to regenerate the list of nodes, nothing else.
      p.jsx(
        X5,
        {
          id: l,
          nodeTypes: e.nodeTypes,
          nodeExtent: e.nodeExtent,
          onClick: e.onNodeClick,
          onMouseEnter: e.onNodeMouseEnter,
          onMouseMove: e.onNodeMouseMove,
          onMouseLeave: e.onNodeMouseLeave,
          onContextMenu: e.onNodeContextMenu,
          onDoubleClick: e.onNodeDoubleClick,
          noDragClassName: e.noDragClassName,
          noPanClassName: e.noPanClassName,
          rfId: e.rfId,
          disableKeyboardA11y: e.disableKeyboardA11y,
          resizeObserver: a,
          nodesDraggable: t,
          nodesConnectable: n,
          nodesFocusable: o,
          elementsSelectable: r,
          nodeClickDistance: e.nodeClickDistance,
          onError: i,
        },
        l
      )
    ),
  })
}
L0.displayName = 'NodeRenderer'
const H5 = Te(L0)
function U5(e) {
  return Re(
    ge(
      n => {
        if (!e) return n.edges.map(r => r.id)
        const o = []
        if (n.width && n.height)
          for (const r of n.edges) {
            const i = n.nodeLookup.get(r.source),
              s = n.nodeLookup.get(r.target)
            i &&
              s &&
              F2({
                sourceNode: i,
                targetNode: s,
                width: n.width,
                height: n.height,
                transform: n.transform,
              }) &&
              o.push(r.id)
          }
        return o
      },
      [e]
    ),
    ft
  )
}
const K5 = ({ color: e = 'none', strokeWidth: t = 1 }) =>
    p.jsx('polyline', {
      style: {
        stroke: e,
        strokeWidth: t,
      },
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      fill: 'none',
      points: '-5,-4 0,0 -5,4',
    }),
  q5 = ({ color: e = 'none', strokeWidth: t = 1 }) =>
    p.jsx('polyline', {
      style: {
        stroke: e,
        fill: e,
        strokeWidth: t,
      },
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      points: '-5,-4 0,0 -5,4 -5,-4',
    }),
  up = {
    [ma.Arrow]: K5,
    [ma.ArrowClosed]: q5,
  }
function Z5(e) {
  const t = ot()
  return Pe(() => {
    var r, i
    return Object.prototype.hasOwnProperty.call(up, e) ? up[e] : ((i = (r = t.getState()).onError) == null || i.call(r, '009', Jn.error009(e)), null)
  }, [e])
}
const J5 = ({ id: e, type: t, color: n, width: o = 12.5, height: r = 12.5, markerUnits: i = 'strokeWidth', strokeWidth: s, orient: a = 'auto-start-reverse' }) => {
    const l = Z5(t)
    return l ? p.jsx('marker', { className: 'react-flow__arrowhead', id: e, markerWidth: `${o}`, markerHeight: `${r}`, viewBox: '-10 -10 20 20', markerUnits: i, orient: a, refX: '0', refY: '0', children: p.jsx(l, { color: n, strokeWidth: s }) }) : null
  },
  R0 = ({ defaultColor: e, rfId: t }) => {
    const n = Re(i => i.edges),
      o = Re(i => i.defaultEdgeOptions),
      r = Pe(
        () =>
          G2(n, {
            id: t,
            defaultColor: e,
            defaultMarkerStart: o == null ? void 0 : o.markerStart,
            defaultMarkerEnd: o == null ? void 0 : o.markerEnd,
          }),
        [n, o, t, e]
      )
    return r.length ? p.jsx('svg', { className: 'react-flow__marker', children: p.jsx('defs', { children: r.map(i => p.jsx(J5, { id: i.id, type: i.type, color: i.color, width: i.width, height: i.height, markerUnits: i.markerUnits, strokeWidth: i.strokeWidth, orient: i.orient }, i.id)) }) }) : null
  }
R0.displayName = 'MarkerDefinitions'
var _5 = Te(R0)
function T0({ x: e, y: t, label: n, labelStyle: o = {}, labelShowBg: r = !0, labelBgStyle: i = {}, labelBgPadding: s = [2, 4], labelBgBorderRadius: a = 2, children: l, className: c, ...u }) {
  const [d, f] = be({ x: 1, y: 0, width: 0, height: 0 }),
    A = bt(['react-flow__edge-textwrapper', c]),
    h = Ne(null)
  return (
    Ce(() => {
      if (h.current) {
        const g = h.current.getBBox()
        f({
          x: g.x,
          y: g.y,
          width: g.width,
          height: g.height,
        })
      }
    }, [n]),
    typeof n > 'u' || !n
      ? null
      : p.jsxs('g', {
          transform: `translate(${e - d.width / 2} ${t - d.height / 2})`,
          className: A,
          visibility: d.width ? 'visible' : 'hidden',
          ...u,
          children: [r && p.jsx('rect', { width: d.width + 2 * s[0], x: -s[0], y: -s[1], height: d.height + 2 * s[1], className: 'react-flow__edge-textbg', style: i, rx: a, ry: a }), p.jsx('text', { className: 'react-flow__edge-text', y: d.height / 2, dy: '0.3em', ref: h, style: o, children: n }), l],
        })
  )
}
T0.displayName = 'EdgeText'
const $5 = Te(T0)
function ss({ path: e, labelX: t, labelY: n, label: o, labelStyle: r, labelShowBg: i, labelBgStyle: s, labelBgPadding: a, labelBgBorderRadius: l, interactionWidth: c = 20, ...u }) {
  return p.jsxs(p.Fragment, {
    children: [
      p.jsx('path', { ...u, d: e, fill: 'none', className: bt(['react-flow__edge-path', u.className]) }),
      c && p.jsx('path', { d: e, fill: 'none', strokeOpacity: 0, strokeWidth: c, className: 'react-flow__edge-interaction' }),
      o && pn(t) && pn(n) ? p.jsx($5, { x: t, y: n, label: o, labelStyle: r, labelShowBg: i, labelBgStyle: s, labelBgPadding: a, labelBgBorderRadius: l }) : null,
    ],
  })
}
function dp({ pos: e, x1: t, y1: n, x2: o, y2: r }) {
  return e === ye.Left || e === ye.Right ? [0.5 * (t + o), n] : [t, 0.5 * (n + r)]
}
function F0({ sourceX: e, sourceY: t, sourcePosition: n = ye.Bottom, targetX: o, targetY: r, targetPosition: i = ye.Top }) {
  const [s, a] = dp({
      pos: n,
      x1: e,
      y1: t,
      x2: o,
      y2: r,
    }),
    [l, c] = dp({
      pos: i,
      x1: o,
      y1: r,
      x2: e,
      y2: t,
    }),
    [u, d, f, A] = e0({
      sourceX: e,
      sourceY: t,
      targetX: o,
      targetY: r,
      sourceControlX: s,
      sourceControlY: a,
      targetControlX: l,
      targetControlY: c,
    })
  return [`M${e},${t} C${s},${a} ${l},${c} ${o},${r}`, u, d, f, A]
}
function D0(e) {
  return Te(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, sourcePosition: s = ye.Bottom, targetPosition: a = ye.Top, label: l, labelStyle: c, labelShowBg: u, labelBgStyle: d, labelBgPadding: f, labelBgBorderRadius: A, style: h, markerEnd: g, markerStart: x, interactionWidth: m }) => {
    const [v, y, b] = F0({
        sourceX: n,
        sourceY: o,
        sourcePosition: s,
        targetX: r,
        targetY: i,
        targetPosition: a,
      }),
      C = e.isInternal ? void 0 : t
    return p.jsx(ss, { id: C, path: v, labelX: y, labelY: b, label: l, labelStyle: c, labelShowBg: u, labelBgStyle: d, labelBgPadding: f, labelBgBorderRadius: A, style: h, markerEnd: g, markerStart: x, interactionWidth: m })
  })
}
const eR = D0({ isInternal: !1 }),
  z0 = D0({ isInternal: !0 })
eR.displayName = 'SimpleBezierEdge'
z0.displayName = 'SimpleBezierEdgeInternal'
function Q0(e) {
  return Te(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, label: s, labelStyle: a, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: d, style: f, sourcePosition: A = ye.Bottom, targetPosition: h = ye.Top, markerEnd: g, markerStart: x, pathOptions: m, interactionWidth: v }) => {
    const [y, b, C] = va({
        sourceX: n,
        sourceY: o,
        sourcePosition: A,
        targetX: r,
        targetY: i,
        targetPosition: h,
        borderRadius: m == null ? void 0 : m.borderRadius,
        offset: m == null ? void 0 : m.offset,
      }),
      I = e.isInternal ? void 0 : t
    return p.jsx(ss, { id: I, path: y, labelX: b, labelY: C, label: s, labelStyle: a, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: d, style: f, markerEnd: g, markerStart: x, interactionWidth: v })
  })
}
const O0 = Q0({ isInternal: !1 }),
  j0 = Q0({ isInternal: !0 })
O0.displayName = 'SmoothStepEdge'
j0.displayName = 'SmoothStepEdgeInternal'
function W0(e) {
  return Te(({ id: t, ...n }) => {
    var r
    const o = e.isInternal ? void 0 : t
    return p.jsx(O0, {
      ...n,
      id: o,
      pathOptions: Pe(() => {
        var i
        return { borderRadius: 0, offset: (i = n.pathOptions) == null ? void 0 : i.offset }
      }, [(r = n.pathOptions) == null ? void 0 : r.offset]),
    })
  })
}
const tR = W0({ isInternal: !1 }),
  G0 = W0({ isInternal: !0 })
tR.displayName = 'StepEdge'
G0.displayName = 'StepEdgeInternal'
function V0(e) {
  return Te(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, label: s, labelStyle: a, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: d, style: f, markerEnd: A, markerStart: h, interactionWidth: g }) => {
    const [x, m, v] = o0({ sourceX: n, sourceY: o, targetX: r, targetY: i }),
      y = e.isInternal ? void 0 : t
    return p.jsx(ss, { id: y, path: x, labelX: m, labelY: v, label: s, labelStyle: a, labelShowBg: l, labelBgStyle: c, labelBgPadding: u, labelBgBorderRadius: d, style: f, markerEnd: A, markerStart: h, interactionWidth: g })
  })
}
const nR = V0({ isInternal: !1 }),
  X0 = V0({ isInternal: !0 })
nR.displayName = 'StraightEdge'
X0.displayName = 'StraightEdgeInternal'
function Y0(e) {
  return Te(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, sourcePosition: s = ye.Bottom, targetPosition: a = ye.Top, label: l, labelStyle: c, labelShowBg: u, labelBgStyle: d, labelBgPadding: f, labelBgBorderRadius: A, style: h, markerEnd: g, markerStart: x, pathOptions: m, interactionWidth: v }) => {
    const [y, b, C] = t0({
        sourceX: n,
        sourceY: o,
        sourcePosition: s,
        targetX: r,
        targetY: i,
        targetPosition: a,
        curvature: m == null ? void 0 : m.curvature,
      }),
      I = e.isInternal ? void 0 : t
    return p.jsx(ss, { id: I, path: y, labelX: b, labelY: C, label: l, labelStyle: c, labelShowBg: u, labelBgStyle: d, labelBgPadding: f, labelBgBorderRadius: A, style: h, markerEnd: g, markerStart: x, interactionWidth: v })
  })
}
const oR = Y0({ isInternal: !1 }),
  H0 = Y0({ isInternal: !0 })
oR.displayName = 'BezierEdge'
H0.displayName = 'BezierEdgeInternal'
const fp = {
    default: H0,
    straight: X0,
    step: G0,
    smoothstep: j0,
    simplebezier: z0,
  },
  Ap = {
    sourceX: null,
    sourceY: null,
    targetX: null,
    targetY: null,
    sourcePosition: null,
    targetPosition: null,
  },
  rR = (e, t, n) => (n === ye.Left ? e - t : n === ye.Right ? e + t : e),
  iR = (e, t, n) => (n === ye.Top ? e - t : n === ye.Bottom ? e + t : e),
  pp = 'react-flow__edgeupdater'
function hp({ position: e, centerX: t, centerY: n, radius: o = 10, onMouseDown: r, onMouseEnter: i, onMouseOut: s, type: a }) {
  return p.jsx('circle', { onMouseDown: r, onMouseEnter: i, onMouseOut: s, className: bt([pp, `${pp}-${a}`]), cx: rR(t, o, e), cy: iR(n, o, e), r: o, stroke: 'transparent', fill: 'transparent' })
}
function sR({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: o, sourceY: r, targetX: i, targetY: s, sourcePosition: a, targetPosition: l, onReconnect: c, onReconnectStart: u, onReconnectEnd: d, setReconnecting: f, setUpdateHover: A }) {
  const h = ot(),
    g = (b, C) => {
      if (b.button !== 0) return
      const { autoPanOnConnect: I, domNode: w, isValidConnection: M, connectionMode: L, connectionRadius: R, lib: T, onConnectStart: D, onConnectEnd: z, cancelConnection: E, nodeLookup: P, rfId: B, panBy: F, updateConnection: S } = h.getState(),
        Q = C.type === 'target'
      f(!0), u == null || u(b, n, C.type)
      const j = (q, ne) => {
          f(!1), d == null || d(q, n, C.type, ne)
        },
        U = q => (c == null ? void 0 : c(n, q))
      vu.onPointerDown(b.nativeEvent, {
        autoPanOnConnect: I,
        connectionMode: L,
        connectionRadius: R,
        domNode: w,
        handleId: C.id,
        nodeId: C.nodeId,
        nodeLookup: P,
        isTarget: Q,
        edgeUpdaterType: C.type,
        lib: T,
        flowId: B,
        cancelConnection: E,
        panBy: F,
        isValidConnection: M,
        onConnect: U,
        onConnectStart: D,
        onConnectEnd: z,
        onReconnectEnd: j,
        updateConnection: S,
        getTransform: () => h.getState().transform,
        getFromHandle: () => h.getState().connection.fromHandle,
      })
    },
    x = b => g(b, { nodeId: n.target, id: n.targetHandle ?? null, type: 'target' }),
    m = b => g(b, { nodeId: n.source, id: n.sourceHandle ?? null, type: 'source' }),
    v = () => A(!0),
    y = () => A(!1)
  return p.jsxs(p.Fragment, {
    children: [(e === !0 || e === 'source') && p.jsx(hp, { position: a, centerX: o, centerY: r, radius: t, onMouseDown: x, onMouseEnter: v, onMouseOut: y, type: 'source' }), (e === !0 || e === 'target') && p.jsx(hp, { position: l, centerX: i, centerY: s, radius: t, onMouseDown: m, onMouseEnter: v, onMouseOut: y, type: 'target' })],
  })
}
function aR({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: o, onClick: r, onDoubleClick: i, onContextMenu: s, onMouseEnter: a, onMouseMove: l, onMouseLeave: c, reconnectRadius: u, onReconnect: d, onReconnectStart: f, onReconnectEnd: A, rfId: h, edgeTypes: g, noPanClassName: x, onError: m, disableKeyboardA11y: v }) {
  let y = Re(re => re.edgeLookup.get(e))
  const b = Re(re => re.defaultEdgeOptions)
  y = b ? { ...b, ...y } : y
  let C = y.type || 'default',
    I = (g == null ? void 0 : g[C]) || fp[C]
  I === void 0 && (m == null || m('011', Jn.error011(C)), (C = 'default'), (I = fp.default))
  const w = !!(y.focusable || (t && typeof y.focusable > 'u')),
    M = typeof d < 'u' && (y.reconnectable || (n && typeof y.reconnectable > 'u')),
    L = !!(y.selectable || (o && typeof y.selectable > 'u')),
    R = Ne(null),
    [T, D] = be(!1),
    [z, E] = be(!1),
    P = ot(),
    {
      zIndex: B,
      sourceX: F,
      sourceY: S,
      targetX: Q,
      targetY: j,
      sourcePosition: U,
      targetPosition: q,
    } = Re(
      ge(
        re => {
          const Y = re.nodeLookup.get(y.source),
            H = re.nodeLookup.get(y.target)
          if (!Y || !H)
            return {
              zIndex: y.zIndex,
              ...Ap,
            }
          const ee = W2({
            id: e,
            sourceNode: Y,
            targetNode: H,
            sourceHandle: y.sourceHandle || null,
            targetHandle: y.targetHandle || null,
            connectionMode: re.connectionMode,
            onError: m,
          })
          return {
            zIndex: T2({
              selected: y.selected,
              zIndex: y.zIndex,
              sourceNode: Y,
              targetNode: H,
              elevateOnSelect: re.elevateEdgesOnSelect,
            }),
            ...(ee || Ap),
          }
        },
        [y.source, y.target, y.sourceHandle, y.targetHandle, y.selected, y.zIndex]
      ),
      ft
    ),
    ne = Pe(() => (y.markerStart ? `url('#${yu(y.markerStart, h)}')` : void 0), [y.markerStart, h]),
    G = Pe(() => (y.markerEnd ? `url('#${yu(y.markerEnd, h)}')` : void 0), [y.markerEnd, h])
  if (y.hidden || F === null || S === null || Q === null || j === null) return null
  const K = re => {
      var xe
      const { addSelectedEdges: Y, unselectNodesAndEdges: H, multiSelectionActive: ee } = P.getState()
      L && (P.setState({ nodesSelectionActive: !1 }), y.selected && ee ? (H({ nodes: [], edges: [y] }), (xe = R.current) == null || xe.blur()) : Y([e])), r && r(re, y)
    },
    $ = i
      ? re => {
          i(re, { ...y })
        }
      : void 0,
    oe = s
      ? re => {
          s(re, { ...y })
        }
      : void 0,
    Z = a
      ? re => {
          a(re, { ...y })
        }
      : void 0,
    ie = l
      ? re => {
          l(re, { ...y })
        }
      : void 0,
    fe = c
      ? re => {
          c(re, { ...y })
        }
      : void 0,
    se = re => {
      var Y
      if (!v && jm.includes(re.key) && L) {
        const { unselectNodesAndEdges: H, addSelectedEdges: ee } = P.getState()
        re.key === 'Escape' ? ((Y = R.current) == null || Y.blur(), H({ edges: [y] })) : ee([e])
      }
    }
  return p.jsx('svg', {
    style: { zIndex: B },
    children: p.jsxs('g', {
      className: bt([
        'react-flow__edge',
        `react-flow__edge-${C}`,
        y.className,
        x,
        {
          selected: y.selected,
          animated: y.animated,
          inactive: !L && !r,
          updating: T,
          selectable: L,
        },
      ]),
      onClick: K,
      onDoubleClick: $,
      onContextMenu: oe,
      onMouseEnter: Z,
      onMouseMove: ie,
      onMouseLeave: fe,
      onKeyDown: w ? se : void 0,
      tabIndex: w ? 0 : void 0,
      role: w ? 'button' : 'img',
      'data-id': e,
      'data-testid': `rf__edge-${e}`,
      'aria-label': y.ariaLabel === null ? void 0 : y.ariaLabel || `Edge from ${y.source} to ${y.target}`,
      'aria-describedby': w ? `${x0}-${h}` : void 0,
      ref: R,
      children: [
        !z &&
          p.jsx(I, {
            id: e,
            source: y.source,
            target: y.target,
            type: y.type,
            selected: y.selected,
            animated: y.animated,
            selectable: L,
            deletable: y.deletable ?? !0,
            label: y.label,
            labelStyle: y.labelStyle,
            labelShowBg: y.labelShowBg,
            labelBgStyle: y.labelBgStyle,
            labelBgPadding: y.labelBgPadding,
            labelBgBorderRadius: y.labelBgBorderRadius,
            sourceX: F,
            sourceY: S,
            targetX: Q,
            targetY: j,
            sourcePosition: U,
            targetPosition: q,
            data: y.data,
            style: y.style,
            sourceHandleId: y.sourceHandle,
            targetHandleId: y.targetHandle,
            markerStart: ne,
            markerEnd: G,
            pathOptions: 'pathOptions' in y ? y.pathOptions : void 0,
            interactionWidth: y.interactionWidth,
          }),
        M && p.jsx(sR, { edge: y, isReconnectable: M, reconnectRadius: u, onReconnect: d, onReconnectStart: f, onReconnectEnd: A, sourceX: F, sourceY: S, targetX: Q, targetY: j, sourcePosition: U, targetPosition: q, setUpdateHover: D, setReconnecting: E }),
      ],
    }),
  })
}
const lR = e => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError,
})
function U0({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: o, noPanClassName: r, onReconnect: i, onEdgeContextMenu: s, onEdgeMouseEnter: a, onEdgeMouseMove: l, onEdgeMouseLeave: c, onEdgeClick: u, reconnectRadius: d, onEdgeDoubleClick: f, onReconnectStart: A, onReconnectEnd: h, disableKeyboardA11y: g }) {
  const { edgesFocusable: x, edgesReconnectable: m, elementsSelectable: v, onError: y } = Re(lR, ft),
    b = U5(t)
  return p.jsxs('div', {
    className: 'react-flow__edges',
    children: [
      p.jsx(_5, { defaultColor: e, rfId: n }),
      b.map(C =>
        p.jsx(aR, { id: C, edgesFocusable: x, edgesReconnectable: m, elementsSelectable: v, noPanClassName: r, onReconnect: i, onContextMenu: s, onMouseEnter: a, onMouseMove: l, onMouseLeave: c, onClick: u, reconnectRadius: d, onDoubleClick: f, onReconnectStart: A, onReconnectEnd: h, rfId: n, onError: y, edgeTypes: o, disableKeyboardA11y: g }, C)
      ),
    ],
  })
}
U0.displayName = 'EdgeRenderer'
const cR = Te(U0),
  uR = e => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`
function dR({ children: e }) {
  const t = Re(uR)
  return p.jsx('div', { className: 'react-flow__viewport xyflow__viewport react-flow__container', style: { transform: t }, children: e })
}
function fR(e) {
  const t = qo(),
    n = Ne(!1)
  Ce(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), (n.current = !0))
  }, [e, t.viewportInitialized])
}
const AR = e => {
  var t
  return (t = e.panZoom) == null ? void 0 : t.syncViewport
}
function pR(e) {
  const t = Re(AR),
    n = ot()
  return (
    Ce(() => {
      e && (t == null || t(e), n.setState({ transform: [e.x, e.y, e.zoom] }))
    }, [e, t]),
    null
  )
}
function hR(e) {
  return e.connection.inProgress ? { ...e.connection, to: is(e.connection.to, e.transform) } : { ...e.connection }
}
function gR(e) {
  return hR
}
function mR(e) {
  const t = gR()
  return Re(t, ft)
}
const yR = e => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height,
})
function bR({ containerStyle: e, style: t, type: n, component: o }) {
  const { nodesConnectable: r, width: i, height: s, isValid: a, inProgress: l } = Re(yR, ft)
  return !(i && r && l) ? null : p.jsx('svg', { style: e, width: i, height: s, className: 'react-flow__connectionline react-flow__container', children: p.jsx('g', { className: bt(['react-flow__connection', Gm(a)]), children: p.jsx(K0, { style: t, type: n, CustomComponent: o, isValid: a }) }) })
}
const K0 = ({ style: e, type: t = En.Bezier, CustomComponent: n, isValid: o }) => {
  const { inProgress: r, from: i, fromNode: s, fromHandle: a, fromPosition: l, to: c, toNode: u, toHandle: d, toPosition: f } = mR()
  if (!r) return
  if (n) return p.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: s, fromHandle: a, fromX: i.x, fromY: i.y, toX: c.x, toY: c.y, fromPosition: l, toPosition: f, connectionStatus: Gm(o), toNode: u, toHandle: d })
  let A = ''
  const h = {
    sourceX: i.x,
    sourceY: i.y,
    sourcePosition: l,
    targetX: c.x,
    targetY: c.y,
    targetPosition: f,
  }
  switch (t) {
    case En.Bezier:
      ;[A] = t0(h)
      break
    case En.SimpleBezier:
      ;[A] = F0(h)
      break
    case En.Step:
      ;[A] = va({
        ...h,
        borderRadius: 0,
      })
      break
    case En.SmoothStep:
      ;[A] = va(h)
      break
    default:
      ;[A] = o0(h)
  }
  return p.jsx('path', { d: A, fill: 'none', className: 'react-flow__connection-path', style: e })
}
K0.displayName = 'ConnectionLine'
const vR = {}
function gp(e = vR) {
  Ne(e), ot(), Ce(() => {}, [e])
}
function xR() {
  ot(), Ne(!1), Ce(() => {}, [])
}
function q0({
  nodeTypes: e,
  edgeTypes: t,
  onInit: n,
  onNodeClick: o,
  onEdgeClick: r,
  onNodeDoubleClick: i,
  onEdgeDoubleClick: s,
  onNodeMouseEnter: a,
  onNodeMouseMove: l,
  onNodeMouseLeave: c,
  onNodeContextMenu: u,
  onSelectionContextMenu: d,
  onSelectionStart: f,
  onSelectionEnd: A,
  connectionLineType: h,
  connectionLineStyle: g,
  connectionLineComponent: x,
  connectionLineContainerStyle: m,
  selectionKeyCode: v,
  selectionOnDrag: y,
  selectionMode: b,
  multiSelectionKeyCode: C,
  panActivationKeyCode: I,
  zoomActivationKeyCode: w,
  deleteKeyCode: M,
  onlyRenderVisibleElements: L,
  elementsSelectable: R,
  defaultViewport: T,
  translateExtent: D,
  minZoom: z,
  maxZoom: E,
  preventScrolling: P,
  defaultMarkerColor: B,
  zoomOnScroll: F,
  zoomOnPinch: S,
  panOnScroll: Q,
  panOnScrollSpeed: j,
  panOnScrollMode: U,
  zoomOnDoubleClick: q,
  panOnDrag: ne,
  onPaneClick: G,
  onPaneMouseEnter: K,
  onPaneMouseMove: $,
  onPaneMouseLeave: oe,
  onPaneScroll: Z,
  onPaneContextMenu: ie,
  paneClickDistance: fe,
  nodeClickDistance: se,
  onEdgeContextMenu: re,
  onEdgeMouseEnter: Y,
  onEdgeMouseMove: H,
  onEdgeMouseLeave: ee,
  reconnectRadius: xe,
  onReconnect: Fe,
  onReconnectStart: De,
  onReconnectEnd: _e,
  noDragClassName: Be,
  noWheelClassName: ke,
  noPanClassName: rt,
  disableKeyboardA11y: He,
  nodeExtent: Le,
  rfId: tt,
  viewport: $e,
  onViewportChange: Ke,
}) {
  return (
    gp(e),
    gp(t),
    xR(),
    fR(n),
    pR($e),
    p.jsx(Q5, {
      onPaneClick: G,
      onPaneMouseEnter: K,
      onPaneMouseMove: $,
      onPaneMouseLeave: oe,
      onPaneContextMenu: ie,
      onPaneScroll: Z,
      paneClickDistance: fe,
      deleteKeyCode: M,
      selectionKeyCode: v,
      selectionOnDrag: y,
      selectionMode: b,
      onSelectionStart: f,
      onSelectionEnd: A,
      multiSelectionKeyCode: C,
      panActivationKeyCode: I,
      zoomActivationKeyCode: w,
      elementsSelectable: R,
      zoomOnScroll: F,
      zoomOnPinch: S,
      zoomOnDoubleClick: q,
      panOnScroll: Q,
      panOnScrollSpeed: j,
      panOnScrollMode: U,
      panOnDrag: ne,
      defaultViewport: T,
      translateExtent: D,
      minZoom: z,
      maxZoom: E,
      onSelectionContextMenu: d,
      preventScrolling: P,
      noDragClassName: Be,
      noWheelClassName: ke,
      noPanClassName: rt,
      disableKeyboardA11y: He,
      onViewportChange: Ke,
      isControlledViewport: !!$e,
      children: p.jsxs(dR, {
        children: [
          p.jsx(cR, { edgeTypes: t, onEdgeClick: r, onEdgeDoubleClick: s, onReconnect: Fe, onReconnectStart: De, onReconnectEnd: _e, onlyRenderVisibleElements: L, onEdgeContextMenu: re, onEdgeMouseEnter: Y, onEdgeMouseMove: H, onEdgeMouseLeave: ee, reconnectRadius: xe, defaultMarkerColor: B, noPanClassName: rt, disableKeyboardA11y: He, rfId: tt }),
          p.jsx(bR, { style: g, type: h, component: x, containerStyle: m }),
          p.jsx('div', { className: 'react-flow__edgelabel-renderer' }),
          p.jsx(H5, { nodeTypes: e, onNodeClick: o, onNodeDoubleClick: i, onNodeMouseEnter: a, onNodeMouseMove: l, onNodeMouseLeave: c, onNodeContextMenu: u, nodeClickDistance: se, onlyRenderVisibleElements: L, noPanClassName: rt, noDragClassName: Be, disableKeyboardA11y: He, nodeExtent: Le, rfId: tt }),
          p.jsx('div', { className: 'react-flow__viewport-portal' }),
        ],
      }),
    })
  )
}
q0.displayName = 'GraphView'
const CR = Te(q0),
  mp = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: i, fitView: s, nodeOrigin: a, nodeExtent: l } = {}) => {
    const c = /* @__PURE__ */ new Map(),
      u = /* @__PURE__ */ new Map(),
      d = /* @__PURE__ */ new Map(),
      f = /* @__PURE__ */ new Map(),
      A = o ?? t ?? [],
      h = n ?? e ?? [],
      g = a ?? [0, 0],
      x = l ?? Oi
    i0(d, f, A),
      bu(h, c, u, {
        nodeOrigin: g,
        nodeExtent: x,
        elevateNodesOnSelect: !1,
      })
    let m = [0, 0, 1]
    if (s && r && i) {
      const v = rs(c, {
          filter: I => !!((I.width || I.initialWidth) && (I.height || I.initialHeight)),
        }),
        { x: y, y: b, zoom: C } = Td(v, r, i, 0.5, 2, 0.1)
      m = [y, b, C]
    }
    return {
      rfId: '1',
      width: 0,
      height: 0,
      transform: m,
      nodes: h,
      nodeLookup: c,
      parentLookup: u,
      edges: A,
      edgeLookup: f,
      connectionLookup: d,
      onNodesChange: null,
      onEdgesChange: null,
      hasDefaultNodes: n !== void 0,
      hasDefaultEdges: o !== void 0,
      panZoom: null,
      minZoom: 0.5,
      maxZoom: 2,
      translateExtent: Oi,
      nodeExtent: x,
      nodesSelectionActive: !1,
      userSelectionActive: !1,
      userSelectionRect: null,
      connectionMode: Mr.Strict,
      domNode: null,
      paneDragging: !1,
      noPanClassName: 'nopan',
      nodeOrigin: g,
      nodeDragThreshold: 1,
      snapGrid: [15, 15],
      snapToGrid: !1,
      nodesDraggable: !0,
      nodesConnectable: !0,
      nodesFocusable: !0,
      edgesFocusable: !0,
      edgesReconnectable: !0,
      elementsSelectable: !0,
      elevateNodesOnSelect: !0,
      elevateEdgesOnSelect: !1,
      fitViewOnInit: !1,
      fitViewDone: !1,
      fitViewOnInitOptions: void 0,
      selectNodesOnDrag: !0,
      multiSelectionActive: !1,
      connection: { ...Wm },
      connectionClickStartHandle: null,
      connectOnClick: !0,
      ariaLiveMessage: '',
      autoPanOnConnect: !0,
      autoPanOnNodeDrag: !0,
      autoPanSpeed: 15,
      connectionRadius: 20,
      onError: L2,
      isValidConnection: void 0,
      onSelectionChangeHandlers: [],
      lib: 'react',
      debug: !1,
    }
  },
  wR = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: i, fitView: s, nodeOrigin: a, nodeExtent: l }) =>
    GL(
      (c, u) => ({
        ...mp({ nodes: e, edges: t, width: r, height: i, fitView: s, nodeOrigin: a, nodeExtent: l, defaultNodes: n, defaultEdges: o }),
        setNodes: d => {
          const { nodeLookup: f, parentLookup: A, nodeOrigin: h, elevateNodesOnSelect: g } = u()
          bu(d, f, A, {
            nodeOrigin: h,
            nodeExtent: l,
            elevateNodesOnSelect: g,
            checkEquality: !0,
          }),
            c({ nodes: d })
        },
        setEdges: d => {
          const { connectionLookup: f, edgeLookup: A } = u()
          i0(f, A, d), c({ edges: d })
        },
        setDefaultNodesAndEdges: (d, f) => {
          if (d) {
            const { setNodes: A } = u()
            A(d), c({ hasDefaultNodes: !0 })
          }
          if (f) {
            const { setEdges: A } = u()
            A(f), c({ hasDefaultEdges: !0 })
          }
        },
        // Every node gets registerd at a ResizeObserver. Whenever a node
        // changes its dimensions, this function is called to measure the
        // new dimensions and update the nodes.
        updateNodeInternals: (d, f = { triggerFitView: !0 }) => {
          const { triggerNodeChanges: A, nodeLookup: h, parentLookup: g, fitViewOnInit: x, fitViewDone: m, fitViewOnInitOptions: v, domNode: y, nodeOrigin: b, nodeExtent: C, debug: I, fitViewSync: w } = u(),
            { changes: M, updatedInternals: L } = U2(d, h, g, y, b, C)
          if (L) {
            if ((X2(h, g, { nodeOrigin: b, nodeExtent: C }), f.triggerFitView)) {
              let R = m
              !m &&
                x &&
                (R = w({
                  ...v,
                  nodes: v == null ? void 0 : v.nodes,
                })),
                c({ fitViewDone: R })
            } else c({})
            ;(M == null ? void 0 : M.length) > 0 && (I && console.log('React Flow: trigger node changes', M), A == null || A(M))
          }
        },
        updateNodePositions: (d, f = !1) => {
          const A = [],
            h = []
          for (const [g, x] of d) {
            const m = !!(x != null && x.expandParent && x != null && x.parentId && x != null && x.position),
              v = {
                id: g,
                type: 'position',
                position: m
                  ? {
                      x: Math.max(0, x.position.x),
                      y: Math.max(0, x.position.y),
                    }
                  : x.position,
                dragging: f,
              }
            m &&
              A.push({
                id: g,
                parentId: x.parentId,
                rect: {
                  ...x.internals.positionAbsolute,
                  width: x.measured.width,
                  height: x.measured.height,
                },
              }),
              h.push(v)
          }
          if (A.length > 0) {
            const { nodeLookup: g, parentLookup: x, nodeOrigin: m } = u(),
              v = Qd(A, g, x, m)
            h.push(...v)
          }
          u().triggerNodeChanges(h)
        },
        triggerNodeChanges: d => {
          const { onNodesChange: f, setNodes: A, nodes: h, hasDefaultNodes: g, debug: x } = u()
          if (d != null && d.length) {
            if (g) {
              const m = E0(d, h)
              A(m)
            }
            x && console.log('React Flow: trigger node changes', d), f == null || f(d)
          }
        },
        triggerEdgeChanges: d => {
          const { onEdgesChange: f, setEdges: A, edges: h, hasDefaultEdges: g, debug: x } = u()
          if (d != null && d.length) {
            if (g) {
              const m = S0(d, h)
              A(m)
            }
            x && console.log('React Flow: trigger edge changes', d), f == null || f(d)
          }
        },
        addSelectedNodes: d => {
          const { multiSelectionActive: f, edgeLookup: A, nodeLookup: h, triggerNodeChanges: g, triggerEdgeChanges: x } = u()
          if (f) {
            const m = d.map(v => Ro(v, !0))
            g(m)
            return
          }
          g(pr(h, /* @__PURE__ */ new Set([...d]), !0)), x(pr(A))
        },
        addSelectedEdges: d => {
          const { multiSelectionActive: f, edgeLookup: A, nodeLookup: h, triggerNodeChanges: g, triggerEdgeChanges: x } = u()
          if (f) {
            const m = d.map(v => Ro(v, !0))
            x(m)
            return
          }
          x(pr(A, /* @__PURE__ */ new Set([...d]))), g(pr(h, /* @__PURE__ */ new Set(), !0))
        },
        unselectNodesAndEdges: ({ nodes: d, edges: f } = {}) => {
          const { edges: A, nodes: h, nodeLookup: g, triggerNodeChanges: x, triggerEdgeChanges: m } = u(),
            v = d || h,
            y = f || A,
            b = v.map(I => {
              const w = g.get(I.id)
              return w && (w.selected = !1), Ro(I.id, !1)
            }),
            C = y.map(I => Ro(I.id, !1))
          x(b), m(C)
        },
        setMinZoom: d => {
          const { panZoom: f, maxZoom: A } = u()
          f == null || f.setScaleExtent([d, A]), c({ minZoom: d })
        },
        setMaxZoom: d => {
          const { panZoom: f, minZoom: A } = u()
          f == null || f.setScaleExtent([A, d]), c({ maxZoom: d })
        },
        setTranslateExtent: d => {
          var f
          ;(f = u().panZoom) == null || f.setTranslateExtent(d), c({ translateExtent: d })
        },
        setPaneClickDistance: d => {
          var f
          ;(f = u().panZoom) == null || f.setClickDistance(d)
        },
        resetSelectedElements: () => {
          const { edges: d, nodes: f, triggerNodeChanges: A, triggerEdgeChanges: h } = u(),
            g = f.reduce((m, v) => (v.selected ? [...m, Ro(v.id, !1)] : m), []),
            x = d.reduce((m, v) => (v.selected ? [...m, Ro(v.id, !1)] : m), [])
          A(g), h(x)
        },
        setNodeExtent: d => {
          const { nodes: f, nodeLookup: A, parentLookup: h, nodeOrigin: g, elevateNodesOnSelect: x, nodeExtent: m } = u()
          ;(d[0][0] === m[0][0] && d[0][1] === m[0][1] && d[1][0] === m[1][0] && d[1][1] === m[1][1]) ||
            (bu(f, A, h, {
              nodeOrigin: g,
              nodeExtent: d,
              elevateNodesOnSelect: x,
              checkEquality: !1,
            }),
            c({ nodeExtent: d }))
        },
        panBy: d => {
          const { transform: f, width: A, height: h, panZoom: g, translateExtent: x } = u()
          return K2({ delta: d, panZoom: g, transform: f, translateExtent: x, width: A, height: h })
        },
        fitView: d => {
          const { panZoom: f, width: A, height: h, minZoom: g, maxZoom: x, nodeLookup: m } = u()
          if (!f) return Promise.resolve(!1)
          const v = Au(m, d)
          return pu(
            {
              nodes: v,
              width: A,
              height: h,
              panZoom: f,
              minZoom: g,
              maxZoom: x,
            },
            d
          )
        },
        // we can't call an asnychronous function in updateNodeInternals
        // for that we created this sync version of fitView
        fitViewSync: d => {
          const { panZoom: f, width: A, height: h, minZoom: g, maxZoom: x, nodeLookup: m } = u()
          if (!f) return !1
          const v = Au(m, d)
          return (
            pu(
              {
                nodes: v,
                width: A,
                height: h,
                panZoom: f,
                minZoom: g,
                maxZoom: x,
              },
              d
            ),
            v.size > 0
          )
        },
        cancelConnection: () => {
          c({
            connection: { ...Wm },
          })
        },
        updateConnection: d => {
          c({ connection: d })
        },
        reset: () => c({ ...mp() }),
      }),
      Object.is
    )
function Z0({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: o, initialWidth: r, initialHeight: i, fitView: s, nodeOrigin: a, nodeExtent: l, children: c }) {
  const [u] = be(() =>
    wR({
      nodes: e,
      edges: t,
      defaultNodes: n,
      defaultEdges: o,
      width: r,
      height: i,
      fitView: s,
      nodeOrigin: a,
      nodeExtent: l,
    })
  )
  return p.jsx(VL, { value: u, children: p.jsx(f5, { children: c }) })
}
function ER({ children: e, nodes: t, edges: n, defaultNodes: o, defaultEdges: r, width: i, height: s, fitView: a, nodeOrigin: l, nodeExtent: c }) {
  return qn(Tl) ? p.jsx(p.Fragment, { children: e }) : p.jsx(Z0, { initialNodes: t, initialEdges: n, defaultNodes: o, defaultEdges: r, initialWidth: i, initialHeight: s, fitView: a, nodeOrigin: l, nodeExtent: c, children: e })
}
const SR = {
  width: '100%',
  height: '100%',
  overflow: 'hidden',
  position: 'relative',
  zIndex: 0,
}
function BR(
  {
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: o,
    className: r,
    nodeTypes: i,
    edgeTypes: s,
    onNodeClick: a,
    onEdgeClick: l,
    onInit: c,
    onMove: u,
    onMoveStart: d,
    onMoveEnd: f,
    onConnect: A,
    onConnectStart: h,
    onConnectEnd: g,
    onClickConnectStart: x,
    onClickConnectEnd: m,
    onNodeMouseEnter: v,
    onNodeMouseMove: y,
    onNodeMouseLeave: b,
    onNodeContextMenu: C,
    onNodeDoubleClick: I,
    onNodeDragStart: w,
    onNodeDrag: M,
    onNodeDragStop: L,
    onNodesDelete: R,
    onEdgesDelete: T,
    onDelete: D,
    onSelectionChange: z,
    onSelectionDragStart: E,
    onSelectionDrag: P,
    onSelectionDragStop: B,
    onSelectionContextMenu: F,
    onSelectionStart: S,
    onSelectionEnd: Q,
    onBeforeDelete: j,
    connectionMode: U,
    connectionLineType: q = En.Bezier,
    connectionLineStyle: ne,
    connectionLineComponent: G,
    connectionLineContainerStyle: K,
    deleteKeyCode: $ = 'Backspace',
    selectionKeyCode: oe = 'Shift',
    selectionOnDrag: Z = !1,
    selectionMode: ie = ji.Full,
    panActivationKeyCode: fe = 'Space',
    multiSelectionKeyCode: se = ba() ? 'Meta' : 'Control',
    zoomActivationKeyCode: re = ba() ? 'Meta' : 'Control',
    snapToGrid: Y,
    snapGrid: H,
    onlyRenderVisibleElements: ee = !1,
    selectNodesOnDrag: xe,
    nodesDraggable: Fe,
    nodesConnectable: De,
    nodesFocusable: _e,
    nodeOrigin: Be = C0,
    edgesFocusable: ke,
    edgesReconnectable: rt,
    elementsSelectable: He = !0,
    defaultViewport: Le = n5,
    minZoom: tt = 0.5,
    maxZoom: $e = 2,
    translateExtent: Ke = Oi,
    preventScrolling: V = !0,
    nodeExtent: W,
    defaultMarkerColor: le = '#b1b1b7',
    zoomOnScroll: te = !0,
    zoomOnPinch: ce = !0,
    panOnScroll: J = !1,
    panOnScrollSpeed: Ae = 0.5,
    panOnScrollMode: we = Wo.Free,
    zoomOnDoubleClick: Ie = !0,
    panOnDrag: lt = !0,
    onPaneClick: Zt,
    onPaneMouseEnter: Fn,
    onPaneMouseMove: nr,
    onPaneMouseLeave: or,
    onPaneScroll: go,
    onPaneContextMenu: mo,
    paneClickDistance: yo = 0,
    nodeClickDistance: bo = 0,
    children: qr,
    onReconnect: vo,
    onReconnectStart: xo,
    onReconnectEnd: Co,
    onEdgeContextMenu: Zr,
    onEdgeDoubleClick: Jr,
    onEdgeMouseEnter: _r,
    onEdgeMouseMove: $r,
    onEdgeMouseLeave: ae,
    reconnectRadius: ue = 10,
    onNodesChange: Me,
    onEdgesChange: he,
    noDragClassName: Ee = 'nodrag',
    noWheelClassName: nt = 'nowheel',
    noPanClassName: vt = 'nopan',
    fitView: ze,
    fitViewOptions: it,
    connectOnClick: eo,
    attributionPosition: Dn,
    proOptions: Dt,
    defaultEdgeOptions: Rb,
    elevateNodesOnSelect: Tb,
    elevateEdgesOnSelect: Fb,
    disableKeyboardA11y: df = !1,
    autoPanOnConnect: Db,
    autoPanOnNodeDrag: zb,
    autoPanSpeed: Qb,
    connectionRadius: Ob,
    isValidConnection: jb,
    onError: Wb,
    style: Gb,
    id: ff,
    nodeDragThreshold: Vb,
    viewport: Xb,
    onViewportChange: Yb,
    width: Hb,
    height: Ub,
    colorMode: Kb = 'light',
    debug: qb,
    ...Zb
  },
  Jb
) {
  const Jl = ff || '1',
    _b = s5(Kb)
  return p.jsx('div', {
    'data-testid': 'rf__wrapper',
    ...Zb,
    style: { ...Gb, ...SR },
    ref: Jb,
    className: bt(['react-flow', r, _b]),
    id: ff,
    children: p.jsxs(ER, {
      nodes: e,
      edges: t,
      width: Hb,
      height: Ub,
      fitView: ze,
      nodeOrigin: Be,
      nodeExtent: W,
      children: [
        p.jsx(CR, {
          onInit: c,
          onNodeClick: a,
          onEdgeClick: l,
          onNodeMouseEnter: v,
          onNodeMouseMove: y,
          onNodeMouseLeave: b,
          onNodeContextMenu: C,
          onNodeDoubleClick: I,
          nodeTypes: i,
          edgeTypes: s,
          connectionLineType: q,
          connectionLineStyle: ne,
          connectionLineComponent: G,
          connectionLineContainerStyle: K,
          selectionKeyCode: oe,
          selectionOnDrag: Z,
          selectionMode: ie,
          deleteKeyCode: $,
          multiSelectionKeyCode: se,
          panActivationKeyCode: fe,
          zoomActivationKeyCode: re,
          onlyRenderVisibleElements: ee,
          defaultViewport: Le,
          translateExtent: Ke,
          minZoom: tt,
          maxZoom: $e,
          preventScrolling: V,
          zoomOnScroll: te,
          zoomOnPinch: ce,
          zoomOnDoubleClick: Ie,
          panOnScroll: J,
          panOnScrollSpeed: Ae,
          panOnScrollMode: we,
          panOnDrag: lt,
          onPaneClick: Zt,
          onPaneMouseEnter: Fn,
          onPaneMouseMove: nr,
          onPaneMouseLeave: or,
          onPaneScroll: go,
          onPaneContextMenu: mo,
          paneClickDistance: yo,
          nodeClickDistance: bo,
          onSelectionContextMenu: F,
          onSelectionStart: S,
          onSelectionEnd: Q,
          onReconnect: vo,
          onReconnectStart: xo,
          onReconnectEnd: Co,
          onEdgeContextMenu: Zr,
          onEdgeDoubleClick: Jr,
          onEdgeMouseEnter: _r,
          onEdgeMouseMove: $r,
          onEdgeMouseLeave: ae,
          reconnectRadius: ue,
          defaultMarkerColor: le,
          noDragClassName: Ee,
          noWheelClassName: nt,
          noPanClassName: vt,
          rfId: Jl,
          disableKeyboardA11y: df,
          nodeExtent: W,
          viewport: Xb,
          onViewportChange: Yb,
        }),
        p.jsx(i5, {
          nodes: e,
          edges: t,
          defaultNodes: n,
          defaultEdges: o,
          onConnect: A,
          onConnectStart: h,
          onConnectEnd: g,
          onClickConnectStart: x,
          onClickConnectEnd: m,
          nodesDraggable: Fe,
          nodesConnectable: De,
          nodesFocusable: _e,
          edgesFocusable: ke,
          edgesReconnectable: rt,
          elementsSelectable: He,
          elevateNodesOnSelect: Tb,
          elevateEdgesOnSelect: Fb,
          minZoom: tt,
          maxZoom: $e,
          nodeExtent: W,
          onNodesChange: Me,
          onEdgesChange: he,
          snapToGrid: Y,
          snapGrid: H,
          connectionMode: U,
          translateExtent: Ke,
          connectOnClick: eo,
          defaultEdgeOptions: Rb,
          fitView: ze,
          fitViewOptions: it,
          onNodesDelete: R,
          onEdgesDelete: T,
          onDelete: D,
          onNodeDragStart: w,
          onNodeDrag: M,
          onNodeDragStop: L,
          onSelectionDrag: P,
          onSelectionDragStart: E,
          onSelectionDragStop: B,
          onMove: u,
          onMoveStart: d,
          onMoveEnd: f,
          noPanClassName: vt,
          nodeOrigin: Be,
          rfId: Jl,
          autoPanOnConnect: Db,
          autoPanOnNodeDrag: zb,
          autoPanSpeed: Qb,
          onError: Wb,
          connectionRadius: Ob,
          isValidConnection: jb,
          selectNodesOnDrag: xe,
          nodeDragThreshold: Vb,
          onBeforeDelete: j,
          paneClickDistance: yo,
          debug: qb,
        }),
        p.jsx(t5, { onSelectionChange: z }),
        qr,
        p.jsx(ZL, { proOptions: Dt, position: Dn }),
        p.jsx(KL, { rfId: Jl, disableKeyboardA11y: df }),
      ],
    }),
  })
}
var IR = B0(BR)
const NR = e => {
  var t
  return (t = e.domNode) == null ? void 0 : t.querySelector('.react-flow__edgelabel-renderer')
}
function kR({ children: e }) {
  const t = Re(NR)
  return t ? ov(e, t) : null
}
function MR() {
  const e = ot()
  return ge(t => {
    const { domNode: n, updateNodeInternals: o } = e.getState(),
      r = Array.isArray(t) ? t : [t],
      i = /* @__PURE__ */ new Map()
    r.forEach(s => {
      const a = n == null ? void 0 : n.querySelector(`.react-flow__node[data-id="${s}"]`)
      a && i.set(s, { id: s, nodeElement: a, force: !0 })
    }),
      requestAnimationFrame(() => o(i, { triggerFitView: !1 }))
  }, [])
}
function PR({ dimensions: e, lineWidth: t, variant: n, className: o }) {
  return p.jsx('path', { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: bt(['react-flow__background-pattern', n, o]) })
}
function LR({ radius: e, className: t }) {
  return p.jsx('circle', { cx: e, cy: e, r: e, className: bt(['react-flow__background-pattern', 'dots', t]) })
}
var co
;(function (e) {
  ;(e.Lines = 'lines'), (e.Dots = 'dots'), (e.Cross = 'cross')
})(co || (co = {}))
const RR = {
    [co.Dots]: 1,
    [co.Lines]: 1,
    [co.Cross]: 6,
  },
  TR = e => ({ transform: e.transform, patternId: `pattern-${e.rfId}` })
function J0({
  id: e,
  variant: t = co.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: o,
  lineWidth: r = 1,
  offset: i = 0,
  color: s,
  bgColor: a,
  style: l,
  className: c,
  patternClassName: u,
}) {
  const d = Ne(null),
    { transform: f, patternId: A } = Re(TR, ft),
    h = o || RR[t],
    g = t === co.Dots,
    x = t === co.Cross,
    m = Array.isArray(n) ? n : [n, n],
    v = [m[0] * f[2] || 1, m[1] * f[2] || 1],
    y = h * f[2],
    b = Array.isArray(i) ? i : [i, i],
    C = x ? [y, y] : v,
    I = [b[0] * f[2] || 1 + C[0] / 2, b[1] * f[2] || 1 + C[1] / 2],
    w = `${A}${e || ''}`
  return p.jsxs('svg', {
    className: bt(['react-flow__background', c]),
    style: {
      ...l,
      ...Dl,
      '--xy-background-color-props': a,
      '--xy-background-pattern-color-props': s,
    },
    ref: d,
    'data-testid': 'rf__background',
    children: [
      p.jsx('pattern', { id: w, x: f[0] % v[0], y: f[1] % v[1], width: v[0], height: v[1], patternUnits: 'userSpaceOnUse', patternTransform: `translate(-${I[0]},-${I[1]})`, children: g ? p.jsx(LR, { radius: y / 2, className: u }) : p.jsx(PR, { dimensions: C, lineWidth: r, variant: t, className: u }) }),
      p.jsx('rect', { x: '0', y: '0', width: '100%', height: '100%', fill: `url(#${w})` }),
    ],
  })
}
J0.displayName = 'Background'
const FR = Te(J0)
function DR() {
  return p.jsx('svg', { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 32 32', children: p.jsx('path', { d: 'M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z' }) })
}
function zR() {
  return p.jsx('svg', { xmlns: 'http://www.w3.org/2000/svg', viewBox: '0 0 32 5', children: p.jsx('path', { d: 'M0 0h32v4.2H0z' }) })
}
function QR() {
  return p.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    viewBox: '0 0 32 30',
    children: p.jsx('path', {
      d: 'M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z',
    }),
  })
}
function OR() {
  return p.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    viewBox: '0 0 25 32',
    children: p.jsx('path', {
      d: 'M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z',
    }),
  })
}
function jR() {
  return p.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    viewBox: '0 0 25 32',
    children: p.jsx('path', {
      d: 'M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z',
    }),
  })
}
function Ms({ children: e, className: t, ...n }) {
  return p.jsx('button', { type: 'button', className: bt(['react-flow__controls-button', t]), ...n, children: e })
}
const WR = e => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom,
})
function _0({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: o = !0, fitViewOptions: r, onZoomIn: i, onZoomOut: s, onFitView: a, onInteractiveChange: l, className: c, children: u, position: d = 'bottom-left', orientation: f = 'vertical', 'aria-label': A = 'React Flow controls' }) {
  const h = ot(),
    { isInteractive: g, minZoomReached: x, maxZoomReached: m } = Re(WR, ft),
    { zoomIn: v, zoomOut: y, fitView: b } = qo(),
    C = () => {
      v(), i == null || i()
    },
    I = () => {
      y(), s == null || s()
    },
    w = () => {
      b(r), a == null || a()
    },
    M = () => {
      h.setState({
        nodesDraggable: !g,
        nodesConnectable: !g,
        elementsSelectable: !g,
      }),
        l == null || l(!g)
    },
    L = f === 'horizontal' ? 'horizontal' : 'vertical'
  return p.jsxs(Fl, {
    className: bt(['react-flow__controls', L, c]),
    position: d,
    style: e,
    'data-testid': 'rf__controls',
    'aria-label': A,
    children: [
      t && p.jsxs(p.Fragment, { children: [p.jsx(Ms, { onClick: C, className: 'react-flow__controls-zoomin', title: 'zoom in', 'aria-label': 'zoom in', disabled: m, children: p.jsx(DR, {}) }), p.jsx(Ms, { onClick: I, className: 'react-flow__controls-zoomout', title: 'zoom out', 'aria-label': 'zoom out', disabled: x, children: p.jsx(zR, {}) })] }),
      n && p.jsx(Ms, { className: 'react-flow__controls-fitview', onClick: w, title: 'fit view', 'aria-label': 'fit view', children: p.jsx(QR, {}) }),
      o && p.jsx(Ms, { className: 'react-flow__controls-interactive', onClick: M, title: 'toggle interactivity', 'aria-label': 'toggle interactivity', children: g ? p.jsx(jR, {}) : p.jsx(OR, {}) }),
      u,
    ],
  })
}
_0.displayName = 'Controls'
Te(_0)
function GR({ id: e, x: t, y: n, width: o, height: r, style: i, color: s, strokeColor: a, strokeWidth: l, className: c, borderRadius: u, shapeRendering: d, selected: f, onClick: A }) {
  const { background: h, backgroundColor: g } = i || {},
    x = s || h || g
  return p.jsx('rect', {
    className: bt(['react-flow__minimap-node', { selected: f }, c]),
    x: t,
    y: n,
    rx: u,
    ry: u,
    width: o,
    height: r,
    style: {
      fill: x,
      stroke: a,
      strokeWidth: l,
    },
    shapeRendering: d,
    onClick: A ? m => A(m, e) : void 0,
  })
}
const VR = Te(GR),
  XR = e => e.nodes.map(t => t.id),
  xc = e => (e instanceof Function ? e : () => e)
function YR({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = '',
  nodeBorderRadius: o = 5,
  nodeStrokeWidth: r,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent: i = VR,
  onClick: s,
}) {
  const a = Re(XR, ft),
    l = xc(t),
    c = xc(e),
    u = xc(n),
    d = typeof window > 'u' || window.chrome ? 'crispEdges' : 'geometricPrecision'
  return p.jsx(p.Fragment, {
    children: a.map(f =>
      // The split of responsibilities between MiniMapNodes and
      // NodeComponentWrapper may appear weird. However, it’s designed to
      // minimize the cost of updates when individual nodes change.
      //
      // For more details, see a similar commit in `NodeRenderer/index.tsx`.
      p.jsx(UR, { id: f, nodeColorFunc: l, nodeStrokeColorFunc: c, nodeClassNameFunc: u, nodeBorderRadius: o, nodeStrokeWidth: r, NodeComponent: i, onClick: s, shapeRendering: d }, f)
    ),
  })
}
function HR({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: o, nodeBorderRadius: r, nodeStrokeWidth: i, shapeRendering: s, NodeComponent: a, onClick: l }) {
  const {
    node: c,
    x: u,
    y: d,
    width: f,
    height: A,
  } = Re(h => {
    const g = h.nodeLookup.get(e),
      { x, y: m } = g.internals.positionAbsolute,
      { width: v, height: y } = _n(g)
    return {
      node: g,
      x,
      y: m,
      width: v,
      height: y,
    }
  }, ft)
  return !c || c.hidden || !Zm(c) ? null : p.jsx(a, { x: u, y: d, width: f, height: A, style: c.style, selected: !!c.selected, className: o(c), color: t(c), borderRadius: r, strokeColor: n(c), strokeWidth: i, shapeRendering: s, onClick: l, id: c.id })
}
const UR = Te(HR)
var KR = Te(YR)
const qR = 200,
  ZR = 150,
  JR = e => {
    const t = {
      x: -e.transform[0] / e.transform[2],
      y: -e.transform[1] / e.transform[2],
      width: e.width / e.transform[2],
      height: e.height / e.transform[2],
    }
    return {
      viewBB: t,
      boundingRect: e.nodeLookup.size > 0 ? Km(rs(e.nodeLookup), t) : t,
      rfId: e.rfId,
      panZoom: e.panZoom,
      translateExtent: e.translateExtent,
      flowWidth: e.width,
      flowHeight: e.height,
    }
  },
  _R = 'react-flow__minimap-desc'
function $0({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: o,
  nodeClassName: r = '',
  nodeBorderRadius: i = 5,
  nodeStrokeWidth: s,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent: a,
  bgColor: l,
  maskColor: c,
  maskStrokeColor: u,
  maskStrokeWidth: d,
  position: f = 'bottom-right',
  onClick: A,
  onNodeClick: h,
  pannable: g = !1,
  zoomable: x = !1,
  ariaLabel: m = 'React Flow mini map',
  inversePan: v,
  zoomStep: y = 10,
  offsetScale: b = 5,
}) {
  const C = ot(),
    I = Ne(null),
    { boundingRect: w, viewBB: M, rfId: L, panZoom: R, translateExtent: T, flowWidth: D, flowHeight: z } = Re(JR, ft),
    E = (e == null ? void 0 : e.width) ?? qR,
    P = (e == null ? void 0 : e.height) ?? ZR,
    B = w.width / E,
    F = w.height / P,
    S = Math.max(B, F),
    Q = S * E,
    j = S * P,
    U = b * S,
    q = w.x - (Q - w.width) / 2 - U,
    ne = w.y - (j - w.height) / 2 - U,
    G = Q + U * 2,
    K = j + U * 2,
    $ = `${_R}-${L}`,
    oe = Ne(0),
    Z = Ne()
  ;(oe.current = S),
    Ce(() => {
      if (I.current && R)
        return (
          (Z.current = nL({
            domNode: I.current,
            panZoom: R,
            getTransform: () => C.getState().transform,
            getViewScale: () => oe.current,
          })),
          () => {
            var se
            ;(se = Z.current) == null || se.destroy()
          }
        )
    }, [R]),
    Ce(() => {
      var se
      ;(se = Z.current) == null ||
        se.update({
          translateExtent: T,
          width: D,
          height: z,
          inversePan: v,
          pannable: g,
          zoomStep: y,
          zoomable: x,
        })
    }, [g, x, v, y, T, D, z])
  const ie = A
      ? se => {
          var H
          const [re, Y] = ((H = Z.current) == null ? void 0 : H.pointer(se)) || [0, 0]
          A(se, { x: re, y: Y })
        }
      : void 0,
    fe = h
      ? ge((se, re) => {
          const Y = C.getState().nodeLookup.get(re)
          h(se, Y)
        }, [])
      : void 0
  return p.jsx(Fl, {
    position: f,
    style: {
      ...e,
      '--xy-minimap-background-color-props': typeof l == 'string' ? l : void 0,
      '--xy-minimap-mask-background-color-props': typeof c == 'string' ? c : void 0,
      '--xy-minimap-mask-stroke-color-props': typeof u == 'string' ? u : void 0,
      '--xy-minimap-mask-stroke-width-props': typeof d == 'number' ? d * S : void 0,
      '--xy-minimap-node-background-color-props': typeof o == 'string' ? o : void 0,
      '--xy-minimap-node-stroke-color-props': typeof n == 'string' ? n : void 0,
      '--xy-minimap-node-stroke-width-props': typeof s == 'string' ? s : void 0,
    },
    className: bt(['react-flow__minimap', t]),
    'data-testid': 'rf__minimap',
    children: p.jsxs('svg', {
      width: E,
      height: P,
      viewBox: `${q} ${ne} ${G} ${K}`,
      className: 'react-flow__minimap-svg',
      role: 'img',
      'aria-labelledby': $,
      ref: I,
      onClick: ie,
      children: [
        m && p.jsx('title', { id: $, children: m }),
        p.jsx(KR, { onClick: fe, nodeColor: o, nodeStrokeColor: n, nodeBorderRadius: i, nodeClassName: r, nodeStrokeWidth: s, nodeComponent: a }),
        p.jsx('path', {
          className: 'react-flow__minimap-mask',
          d: `M${q - U},${ne - U}h${G + U * 2}v${K + U * 2}h${-G - U * 2}z
        M${M.x},${M.y}h${M.width}v${M.height}h${-M.width}z`,
          fillRule: 'evenodd',
          pointerEvents: 'none',
        }),
      ],
    }),
  })
}
$0.displayName = 'MiniMap'
const $R = Te($0)
function eT({ nodeId: e, position: t, variant: n = Bi.Handle, className: o, style: r = {}, children: i, color: s, minWidth: a = 10, minHeight: l = 10, maxWidth: c = Number.MAX_VALUE, maxHeight: u = Number.MAX_VALUE, keepAspectRatio: d = !1, shouldResize: f, onResizeStart: A, onResize: h, onResizeEnd: g }) {
  const x = M0(),
    m = typeof e == 'string' ? e : x,
    v = ot(),
    y = Ne(null),
    b = n === Bi.Line ? 'right' : 'bottom-right',
    C = t ?? b,
    I = Ne(null)
  Ce(() => {
    if (!(!y.current || !m))
      return (
        I.current ||
          (I.current = mL({
            domNode: y.current,
            nodeId: m,
            getStoreItems: () => {
              const { nodeLookup: R, transform: T, snapGrid: D, snapToGrid: z, nodeOrigin: E, domNode: P } = v.getState()
              return {
                nodeLookup: R,
                transform: T,
                snapGrid: D,
                snapToGrid: z,
                nodeOrigin: E,
                paneDomNode: P,
              }
            },
            onChange: (R, T) => {
              const { triggerNodeChanges: D, nodeLookup: z, parentLookup: E, nodeOrigin: P } = v.getState(),
                B = [],
                F = { x: R.x, y: R.y },
                S = z.get(m)
              if (S && S.expandParent && S.parentId) {
                const Q = S.origin ?? P,
                  j = R.width ?? S.measured.width,
                  U = R.height ?? S.measured.height,
                  q = {
                    id: S.id,
                    parentId: S.parentId,
                    rect: {
                      width: j,
                      height: U,
                      ...Jm(
                        {
                          x: R.x ?? S.position.x,
                          y: R.y ?? S.position.y,
                        },
                        { width: j, height: U },
                        S.parentId,
                        z,
                        Q
                      ),
                    },
                  },
                  ne = Qd([q], z, E, P)
                B.push(...ne), (F.x = R.x ? Math.max(Q[0] * j, R.x) : void 0), (F.y = R.y ? Math.max(Q[1] * U, R.y) : void 0)
              }
              if (F.x !== void 0 && F.y !== void 0) {
                const Q = {
                  id: m,
                  type: 'position',
                  position: { ...F },
                }
                B.push(Q)
              }
              if (R.width !== void 0 && R.height !== void 0) {
                const Q = {
                  id: m,
                  type: 'dimensions',
                  resizing: !0,
                  setAttributes: !0,
                  dimensions: {
                    width: R.width,
                    height: R.height,
                  },
                }
                B.push(Q)
              }
              for (const Q of T) {
                const j = {
                  ...Q,
                  type: 'position',
                }
                B.push(j)
              }
              D(B)
            },
            onEnd: () => {
              const R = {
                id: m,
                type: 'dimensions',
                resizing: !1,
              }
              v.getState().triggerNodeChanges([R])
            },
          })),
        I.current.update({
          controlPosition: C,
          boundaries: {
            minWidth: a,
            minHeight: l,
            maxWidth: c,
            maxHeight: u,
          },
          keepAspectRatio: d,
          onResizeStart: A,
          onResize: h,
          onResizeEnd: g,
          shouldResize: f,
        }),
        () => {
          var R
          ;(R = I.current) == null || R.destroy()
        }
      )
  }, [C, a, l, c, u, d, A, h, g, f])
  const w = C.split('-'),
    M = n === Bi.Line ? 'borderColor' : 'backgroundColor',
    L = s ? { ...r, [M]: s } : r
  return p.jsx('div', { className: bt(['react-flow__resize-control', 'nodrag', ...w, n, o]), ref: y, style: L, children: i })
}
Te(eT)
const ey = At({
    opacity: 0,
    pointerEvents: 'none',
    cursor: 'auto',
  }),
  tT = ({ id: e, sourceX: t, sourceY: n, targetX: o, targetY: r, sourcePosition: i, targetPosition: s, data: a }) => {
    const [l, c, u] = va({
        sourceX: t,
        sourceY: n,
        sourcePosition: i,
        targetX: o,
        targetY: r,
        targetPosition: s,
      }),
      d = a == null ? void 0 : a.isInvisibleEdge
    return /* @__PURE__ */ p.jsxs(p.Fragment, {
      children: [
        /* @__PURE__ */ p.jsx(ss, {
          id: e,
          path: l,
          style: { ...(d ? ey : {}) },
        }),
        /* @__PURE__ */ p.jsx(kR, {
          children: /* @__PURE__ */ p.jsx('div', {
            style: At({
              transform: `translate(${c - 28}px,${u - 28}px)`,
              fontSize: 12,
            }),
            className: 'edge-label-renderer__custom-edge nodrag nopan',
            dangerouslySetInnerHTML: { __html: a == null ? void 0 : a.label },
          }),
        }),
      ],
    })
  },
  ty = {
    DefaultEdge: 'step',
  },
  nT = {
    [ty.DefaultEdge]: tT,
  },
  fo = e => ({
    ...e,
    id: e.id ?? Ho(),
    type: e.type ?? ty.DefaultEdge,
  }),
  oT = e => {
    var t
    return (t = e.style) == null ? void 0 : t.stroke
  },
  rT = e => 'class' in e.data && typeof e.data.class == 'string',
  Xe = e => /* @__PURE__ */ p.jsx(Vi, { ...e }),
  iT = O('div')`
  padding: 16px 64px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
`,
  sT = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: 100%;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const aT = e => {
    const t = Ne(!1)
    Ce(() => {
      t.current || ((t.current = !0), e())
    }, [e])
  },
  zl = (e = !1) => {
    const [t, n] = be(e),
      o = ge(() => n(!0), []),
      r = ge(() => n(!1), []),
      i = ge(() => n(s => !s), [])
    return [t, n, o, r, i]
  },
  yp = (e, t) => {
    Ce(() => {
      const n = o => {
        const r = /* @__PURE__ */ new Set()
        o.metaKey && r.add('Meta'), o.ctrlKey && r.add('Ctrl'), o.altKey && r.add('Alt'), o.shiftKey && r.add('Shift'), o.key.length === 1 && r.add(o.key.toUpperCase()), e.every(s => r.has(s)) && (o.preventDefault(), t())
      }
      return (
        window.addEventListener('keydown', n),
        () => {
          window.removeEventListener('keydown', n)
        }
      )
    }, [e, t])
  },
  Mt = e => {
    const t = Ne(null)
    return (
      Ce(() => {
        t.current && e(t.current)
      }, [e]),
      t
    )
  }
function lT(e) {
  if (typeof document > 'u') return
  let t = document.head || document.getElementsByTagName('head')[0],
    n = document.createElement('style')
  ;(n.type = 'text/css'), t.firstChild ? t.insertBefore(n, t.firstChild) : t.appendChild(n), n.styleSheet ? (n.styleSheet.cssText = e) : n.appendChild(document.createTextNode(e))
}
lT(`:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}
`)
var as = e => typeof e == 'number' && !isNaN(e),
  Zo = e => typeof e == 'string',
  Kn = e => typeof e == 'function',
  cT = e => Zo(e) || as(e),
  Cu = e => (Zo(e) || Kn(e) ? e : null),
  uT = (e, t) => (e === !1 || (as(e) && e > 0) ? e : t),
  wu = e => ao(e) || Zo(e) || Kn(e) || as(e)
function dT(e, t, n = 300) {
  let { scrollHeight: o, style: r } = e
  requestAnimationFrame(() => {
    ;(r.minHeight = 'initial'),
      (r.height = o + 'px'),
      (r.transition = `all ${n}ms`),
      requestAnimationFrame(() => {
        ;(r.height = '0'), (r.padding = '0'), (r.margin = '0'), setTimeout(t, n)
      })
  })
}
function fT({ enter: e, exit: t, appendPosition: n = !1, collapse: o = !0, collapseDuration: r = 300 }) {
  return function ({ children: i, position: s, preventExitTransition: a, done: l, nodeRef: c, isIn: u, playToast: d }) {
    let f = n ? `${e}--${s}` : e,
      A = n ? `${t}--${s}` : t,
      h = Ne(0)
    return (
      Ma(() => {
        let g = c.current,
          x = f.split(' '),
          m = v => {
            v.target === c.current && (d(), g.removeEventListener('animationend', m), g.removeEventListener('animationcancel', m), h.current === 0 && v.type !== 'animationcancel' && g.classList.remove(...x))
          }
        g.classList.add(...x), g.addEventListener('animationend', m), g.addEventListener('animationcancel', m)
      }, []),
      Ce(() => {
        let g = c.current,
          x = () => {
            g.removeEventListener('animationend', x), o ? dT(g, l, r) : l()
          }
        u || (a ? x() : ((h.current = 1), (g.className += ` ${A}`), g.addEventListener('animationend', x)))
      }, [u]),
      ve.createElement(ve.Fragment, null, i)
    )
  }
}
function bp(e, t) {
  return { content: ny(e.content, e.props), containerId: e.props.containerId, id: e.props.toastId, theme: e.props.theme, type: e.props.type, data: e.props.data || {}, isLoading: e.props.isLoading, icon: e.props.icon, reason: e.removalReason, status: t }
}
function ny(e, t, n = !1) {
  return ao(e) && !Zo(e.type) ? Oo(e, { closeToast: t.closeToast, toastProps: t, data: t.data, isPaused: n }) : Kn(e) ? e({ closeToast: t.closeToast, toastProps: t, data: t.data, isPaused: n }) : e
}
function AT({ closeToast: e, theme: t, ariaLabel: n = 'close' }) {
  return ve.createElement(
    'button',
    {
      className: `Toastify__close-button Toastify__close-button--${t}`,
      type: 'button',
      onClick: o => {
        o.stopPropagation(), e(!0)
      },
      'aria-label': n,
    },
    ve.createElement('svg', { 'aria-hidden': 'true', viewBox: '0 0 14 16' }, ve.createElement('path', { fillRule: 'evenodd', d: 'M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z' }))
  )
}
function pT({ delay: e, isRunning: t, closeToast: n, type: o = 'default', hide: r, className: i, controlledProgress: s, progress: a, rtl: l, isIn: c, theme: u }) {
  let d = r || (s && a === 0),
    f = { animationDuration: `${e}ms`, animationPlayState: t ? 'running' : 'paused' }
  s && (f.transform = `scaleX(${a})`)
  let A = de('Toastify__progress-bar', s ? 'Toastify__progress-bar--controlled' : 'Toastify__progress-bar--animated', `Toastify__progress-bar-theme--${u}`, `Toastify__progress-bar--${o}`, { 'Toastify__progress-bar--rtl': l }),
    h = Kn(i) ? i({ rtl: l, type: o, defaultClassName: A }) : de(A, i),
    g = {
      [s && a >= 1 ? 'onTransitionEnd' : 'onAnimationEnd']:
        s && a < 1
          ? null
          : () => {
              c && n()
            },
    }
  return ve.createElement(
    'div',
    { className: 'Toastify__progress-bar--wrp', 'data-hidden': d },
    ve.createElement('div', { className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${u} Toastify__progress-bar--${o}` }),
    ve.createElement('div', { role: 'progressbar', 'aria-hidden': d ? 'true' : 'false', 'aria-label': 'notification timer', className: h, style: f, ...g })
  )
}
var hT = 1,
  oy = () => `${hT++}`
function gT(e, t, n) {
  let o = 1,
    r = 0,
    i = [],
    s = [],
    a = t,
    l = /* @__PURE__ */ new Map(),
    c = /* @__PURE__ */ new Set(),
    u = v => (c.add(v), () => c.delete(v)),
    d = () => {
      ;(s = Array.from(l.values())), c.forEach(v => v())
    },
    f = ({ containerId: v, toastId: y, updateId: b }) => {
      let C = v ? v !== e : e !== 1,
        I = l.has(y) && b == null
      return C || I
    },
    A = (v, y) => {
      l.forEach(b => {
        var C
        ;(y == null || y === b.props.toastId) && ((C = b.toggle) == null || C.call(b, v))
      })
    },
    h = v => {
      var y, b
      ;(b = (y = v.props) == null ? void 0 : y.onClose) == null || b.call(y, v.removalReason), (v.isActive = !1)
    },
    g = v => {
      if (v == null) l.forEach(h)
      else {
        let y = l.get(v)
        y && h(y)
      }
      d()
    },
    x = () => {
      ;(r -= i.length), (i = [])
    },
    m = v => {
      var y, b
      let { toastId: C, updateId: I } = v.props,
        w = I == null
      v.staleId && l.delete(v.staleId), (v.isActive = !0), l.set(C, v), d(), n(bp(v, w ? 'added' : 'updated')), w && ((b = (y = v.props).onOpen) == null || b.call(y))
    }
  return {
    id: e,
    props: a,
    observe: u,
    toggle: A,
    removeToast: g,
    toasts: l,
    clearQueue: x,
    buildToast: (v, y) => {
      if (f(y)) return
      let { toastId: b, updateId: C, data: I, staleId: w, delay: M } = y,
        L = C == null
      L && r++
      let R = {
        ...a,
        style: a.toastStyle,
        key: o++,
        ...Object.fromEntries(Object.entries(y).filter(([D, z]) => z != null)),
        toastId: b,
        updateId: C,
        data: I,
        isIn: !1,
        className: Cu(y.className || a.toastClassName),
        progressClassName: Cu(y.progressClassName || a.progressClassName),
        autoClose: y.isLoading ? !1 : uT(y.autoClose, a.autoClose),
        closeToast(D) {
          ;(l.get(b).removalReason = D), g(b)
        },
        deleteToast() {
          let D = l.get(b)
          if (D != null) {
            if ((n(bp(D, 'removed')), l.delete(b), r--, r < 0 && (r = 0), i.length > 0)) {
              m(i.shift())
              return
            }
            d()
          }
        },
      }
      ;(R.closeButton = a.closeButton), y.closeButton === !1 || wu(y.closeButton) ? (R.closeButton = y.closeButton) : y.closeButton === !0 && (R.closeButton = wu(a.closeButton) ? a.closeButton : !0)
      let T = { content: v, props: R, staleId: w }
      a.limit && a.limit > 0 && r > a.limit && L
        ? i.push(T)
        : as(M)
        ? setTimeout(() => {
            m(T)
          }, M)
        : m(T)
    },
    setProps(v) {
      a = v
    },
    setToggle: (v, y) => {
      let b = l.get(v)
      b && (b.toggle = y)
    },
    isToastActive: v => {
      var y
      return (y = l.get(v)) == null ? void 0 : y.isActive
    },
    getSnapshot: () => s,
  }
}
var Rt = /* @__PURE__ */ new Map(),
  Xi = [],
  Eu = /* @__PURE__ */ new Set(),
  mT = e => Eu.forEach(t => t(e)),
  ry = () => Rt.size > 0
function yT() {
  Xi.forEach(e => sy(e.content, e.options)), (Xi = [])
}
var bT = (e, { containerId: t }) => {
  var n
  return (n = Rt.get(t || 1)) == null ? void 0 : n.toasts.get(e)
}
function iy(e, t) {
  var n
  if (t) return !!((n = Rt.get(t)) != null && n.isToastActive(e))
  let o = !1
  return (
    Rt.forEach(r => {
      r.isToastActive(e) && (o = !0)
    }),
    o
  )
}
function vT(e) {
  if (!ry()) {
    Xi = Xi.filter(t => e != null && t.options.toastId !== e)
    return
  }
  if (e == null || cT(e))
    Rt.forEach(t => {
      t.removeToast(e)
    })
  else if (e && ('containerId' in e || 'id' in e)) {
    let t = Rt.get(e.containerId)
    t
      ? t.removeToast(e.id)
      : Rt.forEach(n => {
          n.removeToast(e.id)
        })
  }
}
var xT = (e = {}) => {
  Rt.forEach(t => {
    t.props.limit && (!e.containerId || t.id === e.containerId) && t.clearQueue()
  })
}
function sy(e, t) {
  wu(e) &&
    (ry() || Xi.push({ content: e, options: t }),
    Rt.forEach(n => {
      n.buildToast(e, t)
    }))
}
function CT(e) {
  var t
  ;(t = Rt.get(e.containerId || 1)) == null || t.setToggle(e.id, e.fn)
}
function ay(e, t) {
  Rt.forEach(n => {
    ;(t == null || !(t != null && t.containerId) || (t == null ? void 0 : t.containerId) === n.id) && n.toggle(e, t == null ? void 0 : t.id)
  })
}
function wT(e) {
  let t = e.containerId || 1
  return {
    subscribe(n) {
      let o = gT(t, e, mT)
      Rt.set(t, o)
      let r = o.observe(n)
      return (
        yT(),
        () => {
          r(), Rt.delete(t)
        }
      )
    },
    setProps(n) {
      var o
      ;(o = Rt.get(t)) == null || o.setProps(n)
    },
    getSnapshot() {
      var n
      return (n = Rt.get(t)) == null ? void 0 : n.getSnapshot()
    },
  }
}
function ET(e) {
  return (
    Eu.add(e),
    () => {
      Eu.delete(e)
    }
  )
}
function ST(e) {
  return e && (Zo(e.toastId) || as(e.toastId)) ? e.toastId : oy()
}
function ls(e, t) {
  return sy(e, t), t.toastId
}
function Ql(e, t) {
  return { ...t, type: (t && t.type) || e, toastId: ST(t) }
}
function Ol(e) {
  return (t, n) => ls(t, Ql(e, n))
}
function je(e, t) {
  return ls(e, Ql('default', t))
}
je.loading = (e, t) => ls(e, Ql('default', { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...t }))
function BT(e, { pending: t, error: n, success: o }, r) {
  let i
  t && (i = Zo(t) ? je.loading(t, r) : je.loading(t.render, { ...r, ...t }))
  let s = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null },
    a = (c, u, d) => {
      if (u == null) {
        je.dismiss(i)
        return
      }
      let f = { type: c, ...s, ...r, data: d },
        A = Zo(u) ? { render: u } : u
      return i ? je.update(i, { ...f, ...A }) : je(A.render, { ...f, ...A }), d
    },
    l = Kn(e) ? e() : e
  return l.then(c => a('success', o, c)).catch(c => a('error', n, c)), l
}
je.promise = BT
je.success = Ol('success')
je.info = Ol('info')
je.error = Ol('error')
je.warning = Ol('warning')
je.warn = je.warning
je.dark = (e, t) => ls(e, Ql('default', { theme: 'dark', ...t }))
function IT(e) {
  vT(e)
}
je.dismiss = IT
je.clearWaitingQueue = xT
je.isActive = iy
je.update = (e, t = {}) => {
  let n = bT(e, t)
  if (n) {
    let { props: o, content: r } = n,
      i = { delay: 100, ...o, ...t, toastId: t.toastId || e, updateId: oy() }
    i.toastId !== e && (i.staleId = e)
    let s = i.render || r
    delete i.render, ls(s, i)
  }
}
je.done = e => {
  je.update(e, { progress: 1 })
}
je.onChange = ET
je.play = e => ay(!0, e)
je.pause = e => ay(!1, e)
function NT(e) {
  var t
  let { subscribe: n, getSnapshot: o, setProps: r } = Ne(wT(e)).current
  r(e)
  let i = (t = nv(n, o, o)) == null ? void 0 : t.slice()
  function s(a) {
    if (!i) return []
    let l = /* @__PURE__ */ new Map()
    return (
      e.newestOnTop && i.reverse(),
      i.forEach(c => {
        let { position: u } = c.props
        l.has(u) || l.set(u, []), l.get(u).push(c)
      }),
      Array.from(l, c => a(c[0], c[1]))
    )
  }
  return { getToastToRender: s, isToastActive: iy, count: i == null ? void 0 : i.length }
}
function kT(e) {
  let [t, n] = be(!1),
    [o, r] = be(!1),
    i = Ne(null),
    s = Ne({ start: 0, delta: 0, removalDistance: 0, canCloseOnClick: !0, canDrag: !1, didMove: !1 }).current,
    { autoClose: a, pauseOnHover: l, closeToast: c, onClick: u, closeOnClick: d } = e
  CT({ id: e.toastId, containerId: e.containerId, fn: n }),
    Ce(() => {
      if (e.pauseOnFocusLoss)
        return (
          f(),
          () => {
            A()
          }
        )
    }, [e.pauseOnFocusLoss])
  function f() {
    document.hasFocus() || m(), window.addEventListener('focus', x), window.addEventListener('blur', m)
  }
  function A() {
    window.removeEventListener('focus', x), window.removeEventListener('blur', m)
  }
  function h(w) {
    if (e.draggable === !0 || e.draggable === w.pointerType) {
      v()
      let M = i.current
      ;(s.canCloseOnClick = !0),
        (s.canDrag = !0),
        (M.style.transition = 'none'),
        e.draggableDirection === 'x' ? ((s.start = w.clientX), (s.removalDistance = M.offsetWidth * (e.draggablePercent / 100))) : ((s.start = w.clientY), (s.removalDistance = (M.offsetHeight * (e.draggablePercent === 80 ? e.draggablePercent * 1.5 : e.draggablePercent)) / 100))
    }
  }
  function g(w) {
    let { top: M, bottom: L, left: R, right: T } = i.current.getBoundingClientRect()
    w.nativeEvent.type !== 'touchend' && e.pauseOnHover && w.clientX >= R && w.clientX <= T && w.clientY >= M && w.clientY <= L ? m() : x()
  }
  function x() {
    n(!0)
  }
  function m() {
    n(!1)
  }
  function v() {
    ;(s.didMove = !1), document.addEventListener('pointermove', b), document.addEventListener('pointerup', C)
  }
  function y() {
    document.removeEventListener('pointermove', b), document.removeEventListener('pointerup', C)
  }
  function b(w) {
    let M = i.current
    if (s.canDrag && M) {
      ;(s.didMove = !0), t && m(), e.draggableDirection === 'x' ? (s.delta = w.clientX - s.start) : (s.delta = w.clientY - s.start), s.start !== w.clientX && (s.canCloseOnClick = !1)
      let L = e.draggableDirection === 'x' ? `${s.delta}px, var(--y)` : `0, calc(${s.delta}px + var(--y))`
      ;(M.style.transform = `translate3d(${L},0)`), (M.style.opacity = `${1 - Math.abs(s.delta / s.removalDistance)}`)
    }
  }
  function C() {
    y()
    let w = i.current
    if (s.canDrag && s.didMove && w) {
      if (((s.canDrag = !1), Math.abs(s.delta) > s.removalDistance)) {
        r(!0), e.closeToast(!0), e.collapseAll()
        return
      }
      ;(w.style.transition = 'transform 0.2s, opacity 0.2s'), w.style.removeProperty('transform'), w.style.removeProperty('opacity')
    }
  }
  let I = { onPointerDown: h, onPointerUp: g }
  return (
    a && l && ((I.onMouseEnter = m), e.stacked || (I.onMouseLeave = x)),
    d &&
      (I.onClick = w => {
        u && u(w), s.canCloseOnClick && c(!0)
      }),
    { playToast: x, pauseToast: m, isRunning: t, preventExitTransition: o, toastRef: i, eventHandlers: I }
  )
}
var MT = typeof window < 'u' ? Ma : Ce,
  jl = ({ theme: e, type: t, isLoading: n, ...o }) => ve.createElement('svg', { viewBox: '0 0 24 24', width: '100%', height: '100%', fill: e === 'colored' ? 'currentColor' : `var(--toastify-icon-color-${t})`, ...o })
function PT(e) {
  return ve.createElement(
    jl,
    { ...e },
    ve.createElement('path', {
      d: 'M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z',
    })
  )
}
function LT(e) {
  return ve.createElement(jl, { ...e }, ve.createElement('path', { d: 'M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z' }))
}
function RT(e) {
  return ve.createElement(jl, { ...e }, ve.createElement('path', { d: 'M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z' }))
}
function TT(e) {
  return ve.createElement(
    jl,
    { ...e },
    ve.createElement('path', {
      d: 'M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z',
    })
  )
}
function FT() {
  return ve.createElement('div', { className: 'Toastify__spinner' })
}
var Su = { info: LT, warning: PT, success: RT, error: TT, spinner: FT },
  DT = e => e in Su
function zT({ theme: e, type: t, isLoading: n, icon: o }) {
  let r = null,
    i = { theme: e, type: t }
  return o === !1 || (Kn(o) ? (r = o({ ...i, isLoading: n })) : ao(o) ? (r = Oo(o, i)) : n ? (r = Su.spinner()) : DT(t) && (r = Su[t](i))), r
}
var QT = e => {
    let { isRunning: t, preventExitTransition: n, toastRef: o, eventHandlers: r, playToast: i } = kT(e),
      { closeButton: s, children: a, autoClose: l, onClick: c, type: u, hideProgressBar: d, closeToast: f, transition: A, position: h, className: g, style: x, progressClassName: m, updateId: v, role: y, progress: b, rtl: C, toastId: I, deleteToast: w, isIn: M, isLoading: L, closeOnClick: R, theme: T, ariaLabel: D } = e,
      z = de('Toastify__toast', `Toastify__toast-theme--${T}`, `Toastify__toast--${u}`, { 'Toastify__toast--rtl': C }, { 'Toastify__toast--close-on-click': R }),
      E = Kn(g) ? g({ rtl: C, position: h, type: u, defaultClassName: z }) : de(z, g),
      P = zT(e),
      B = !!b || !l,
      F = { closeToast: f, type: u, theme: T },
      S = null
    return (
      s === !1 || (Kn(s) ? (S = s(F)) : ao(s) ? (S = Oo(s, F)) : (S = AT(F))),
      ve.createElement(
        A,
        { isIn: M, done: w, position: h, preventExitTransition: n, nodeRef: o, playToast: i },
        ve.createElement(
          'div',
          { id: I, tabIndex: 0, onClick: c, 'data-in': M, className: E, ...r, style: x, ref: o, ...(M && { role: y, 'aria-label': D }) },
          P != null && ve.createElement('div', { className: de('Toastify__toast-icon', { 'Toastify--animate-icon Toastify__zoom-enter': !L }) }, P),
          ny(a, e, !t),
          S,
          !e.customProgressBar && ve.createElement(pT, { ...(v && !B ? { key: `p-${v}` } : {}), rtl: C, theme: T, delay: l, isRunning: t, isIn: M, closeToast: f, hide: d, type: u, className: m, controlledProgress: B, progress: b || 0 })
        )
      )
    )
  },
  OT = (e, t = !1) => ({ enter: `Toastify--animate Toastify__${e}-enter`, exit: `Toastify--animate Toastify__${e}-exit`, appendPosition: t }),
  jT = fT(OT('bounce', !0)),
  WT = { position: 'top-right', transition: jT, autoClose: 5e3, closeButton: !0, pauseOnHover: !0, pauseOnFocusLoss: !0, draggable: 'touch', draggablePercent: 80, draggableDirection: 'x', role: 'alert', theme: 'light', 'aria-label': 'Notifications Alt+T', hotKeys: e => e.altKey && e.code === 'KeyT' }
function GT(e) {
  let t = { ...WT, ...e },
    n = e.stacked,
    [o, r] = be(!0),
    i = Ne(null),
    { getToastToRender: s, isToastActive: a, count: l } = NT(t),
    { className: c, style: u, rtl: d, containerId: f, hotKeys: A } = t
  function h(x) {
    let m = de('Toastify__toast-container', `Toastify__toast-container--${x}`, { 'Toastify__toast-container--rtl': d })
    return Kn(c) ? c({ position: x, rtl: d, defaultClassName: m }) : de(m, Cu(c))
  }
  function g() {
    n && (r(!0), je.play())
  }
  return (
    MT(() => {
      var x
      if (n) {
        let m = i.current.querySelectorAll('[data-in="true"]'),
          v = 12,
          y = (x = t.position) == null ? void 0 : x.includes('top'),
          b = 0,
          C = 0
        Array.from(m)
          .reverse()
          .forEach((I, w) => {
            let M = I
            M.classList.add('Toastify__toast--stacked'), w > 0 && (M.dataset.collapsed = `${o}`), M.dataset.pos || (M.dataset.pos = y ? 'top' : 'bot')
            let L = b * (o ? 0.2 : 1) + (o ? 0 : v * w)
            M.style.setProperty('--y', `${y ? L : L * -1}px`), M.style.setProperty('--g', `${v}`), M.style.setProperty('--s', `${1 - (o ? C : 0)}`), (b += M.offsetHeight), (C += 0.025)
          })
      }
    }, [o, l, n]),
    Ce(() => {
      function x(m) {
        var v
        let y = i.current
        A(m) && ((v = y.querySelector('[tabIndex="0"]')) == null || v.focus(), r(!1), je.pause()), m.key === 'Escape' && (document.activeElement === y || (y != null && y.contains(document.activeElement))) && (r(!0), je.play())
      }
      return (
        document.addEventListener('keydown', x),
        () => {
          document.removeEventListener('keydown', x)
        }
      )
    }, [A]),
    ve.createElement(
      'section',
      {
        ref: i,
        className: 'Toastify',
        id: f,
        onMouseEnter: () => {
          n && (r(!1), je.pause())
        },
        onMouseLeave: g,
        'aria-live': 'polite',
        'aria-atomic': 'false',
        'aria-relevant': 'additions text',
        'aria-label': t['aria-label'],
      },
      s((x, m) => {
        let v = m.length ? { ...u } : { ...u, pointerEvents: 'none' }
        return ve.createElement(
          'div',
          { tabIndex: -1, className: h(x), 'data-stacked': n, style: v, key: `c-${x}` },
          m.map(({ content: y, props: b }) => ve.createElement(QT, { ...b, stacked: n, collapseAll: g, isIn: a(b.toastId, b.containerId), key: `t-${b.key}` }, y))
        )
      })
    )
  )
}
const VT = () => {
    const e = ge((i, s) => {
        je(i, { type: 'default', ...s })
      }, []),
      t = ge((i, s) => {
        je(i, { type: 'info', theme: 'colored', ...s })
      }, []),
      n = ge((i, s) => {
        je(i, { type: 'error', theme: 'colored', ...s })
      }, []),
      o = ge((i, s) => {
        je(i, { type: 'warning', theme: 'colored', ...s })
      }, []),
      r = ge((i, s) => {
        je(i, { type: 'success', theme: 'colored', ...s })
      }, [])
    return Pe(
      () => ({
        general: e,
        info: t,
        warning: o,
        error: n,
        success: r,
      }),
      [e, t, o, n, r]
    )
  },
  ir = e => {
    const [t, n] = be(e)
    return (
      Ce(() => {
        n(e)
      }, [e]),
      [t, n]
    )
  },
  XT = (e = {}) => ({
    ...e,
  }),
  jd = 2e3,
  YT = [12.5, 12.5],
  HT = 'none',
  UT = '#ededed',
  KT = (e = {}) => ({
    background: e.background ?? HT,
    border: UT,
  }),
  ly = 1 / 3,
  cy = 1 / 6,
  uy = 180,
  Tt = uy * ly,
  Pn = uy * cy,
  Ze = 132,
  $n = 32,
  an = 160,
  qT = 'CapacitorNode',
  ZT = 'PCAP',
  JT = 'SubSwitchNode',
  _T = 'SUB_LISW',
  $T = 'line-side',
  eF = e =>
    ge(
      (t, n = {}) => {
        const o = fn({
          position: t,
          ...n,
        })
        return (
          e(r => {
            const { data: i, type: s } = n
            return (o.type = s ?? qT), (o.data.label = (i == null ? void 0 : i.label) ?? `NEW ASSET ${r.length + 1}`), (o.data.code = (i == null ? void 0 : i.code) ?? ZT), [...r, o]
          }),
          o
        )
      },
      [e]
    ),
  tF = (e, t) => {
    const n = ge(
        r => {
          r.preventDefault()
          const i = e.current.getBoundingClientRect()
          t({
            ...Sd(r, i),
            position: Ed(r),
          })
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [t]
      ),
      o = ge(() => t(null), [t])
    return { openMenu: n, closeMenu: o }
  },
  nF = (e, t, n = {}) => {
    const { onSet: o } = n,
      r = ge(
        (s, a) => {
          s.preventDefault(), s.stopPropagation()
          const l = e.current.getBoundingClientRect(),
            c = {
              id: a.id,
              ...Sd(s, l),
              position: Ed(s),
              targetNode: a,
            }
          t(c), o(c)
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [t]
      ),
      i = ge(() => t(null), [t])
    return { openMenu: r, closeMenu: i }
  },
  oF = (e, t) => {
    const n = ge(
        (r, i) => {
          r.preventDefault(), r.stopPropagation()
          const s = e.current.getBoundingClientRect()
          t({
            id: i.id,
            ...Sd(r, s),
            position: Ed(r),
            targetEdge: i,
          })
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [t]
      ),
      o = ge(() => t(null), [t])
    return { openMenu: n, closeMenu: o }
  },
  rF = e =>
    ge(
      n => {
        e(o => o.filter(r => r.id !== n))
      },
      [e]
    ),
  iF = e =>
    ge(
      n => {
        e(o => o.filter(r => r.id !== n))
      },
      [e]
    ),
  sF = {
    open: !1,
    openDrawer: () => {},
    closeDrawer: () => {},
    toggleDrawer: () => {},
    setOpen: () => {},
  },
  dy = po(sF),
  aF = ({ children: e }) => {
    const [t, n, o, r, i] = zl(),
      s = Pe(
        () => ({
          open: t,
          setOpen: n,
          openDrawer: o,
          closeDrawer: r,
          toggleDrawer: i,
        }),
        [r, t, o, n, i]
      )
    return /* @__PURE__ */ p.jsx(dy.Provider, { value: s, children: e })
  },
  lF = () => qn(dy),
  cF = e => {
    const [t, n] = be(e),
      { openDrawer: o, ...r } = lF(),
      i = ge(
        s => {
          n(s), o()
        },
        [o]
      )
    return (
      Ce(() => {
        const s = a => {
          const l = a.target
          l && l.classList.contains('MuiBackdrop-root') && r.closeDrawer()
        }
        return (
          window.addEventListener('click', s),
          () => {
            window.removeEventListener('click', s)
          }
        )
      }, [r]),
      {
        nodeToEdit: t,
        setNodeToEdit: n,
        openDrawer: i,
        ...r,
      }
    )
  },
  uF = e =>
    ge(
      t => {
        e(n => n.map(o => (o.id !== t.id ? o : t)))
      },
      [e]
    ),
  dF = e =>
    ge(
      t => {
        e(n => n.map(o => (o.id !== t.id ? o : t)))
      },
      [e]
    ),
  vp = {
    maxHistorySize: Cl.historyDeepness,
  },
  fF = ({ maxHistorySize: e = vp.maxHistorySize } = vp) => {
    const [t, n] = be([]),
      [o, r] = be([]),
      { setNodes: i, setEdges: s, getNodes: a, getEdges: l } = qo(),
      c = ge(() => {
        n(f => [...f.slice(f.length - e + 1, f.length), { nodes: a(), edges: l() }]), r([])
      }, [a, l, e]),
      u = ge(() => {
        const f = t[t.length - 1]
        f && (n(A => A.slice(0, A.length - 1)), r(A => [...A, { nodes: a(), edges: l() }]), i(f.nodes), s(f.edges))
      }, [i, s, a, l, t]),
      d = ge(() => {
        const f = o[o.length - 1]
        f && (r(A => A.slice(0, A.length - 1)), n(A => [...A, { nodes: a(), edges: l() }]), i(f.nodes), s(f.edges))
      }, [i, s, a, l, o])
    return {
      undo: u,
      redo: d,
      takeSnapshot: c,
      canUndo: !t.length,
      canRedo: !o.length,
    }
  },
  AF = e => {
    const [t, n] = be(e),
      [o, r] = be(void 0),
      [i, s] = be(void 0),
      a = fF(),
      l = ge(
        m => {
          n(v =>
            typeof m != 'function'
              ? {
                  ...m,
                  stateId: Ho(),
                }
              : {
                  ...m(v),
                  stateId: Ho(),
                }
          )
        },
        [n]
      ),
      c = ge(
        m => {
          l(v =>
            typeof m != 'function'
              ? {
                  ...v,
                  nodes: m,
                }
              : {
                  ...v,
                  nodes: m(v.nodes),
                }
          )
        },
        [l]
      ),
      u = ge(
        m => {
          l(v =>
            typeof m != 'function'
              ? {
                  ...v,
                  edges: m,
                }
              : {
                  ...v,
                  edges: m(v.edges),
                }
          )
        },
        [l]
      ),
      d = ge(
        m => {
          l(v =>
            typeof m != 'function'
              ? {
                  ...v,
                  viewMode: m,
                }
              : {
                  ...v,
                  viewMode: m(v.viewMode),
                }
          )
        },
        [l]
      ),
      f = ge(
        m => {
          l(v =>
            typeof m != 'function'
              ? {
                  ...v,
                  editMode: m,
                }
              : {
                  ...v,
                  editMode: m(v.editMode),
                }
          )
        },
        [l]
      ),
      A = ge((m, v) => {
        if ((r(void 0), s(void 0), m.length === 1 && m[0] && m[0].type === 'position' && m[0].dragging && m[0].position)) {
          const y = _N(m[0], v)
          ;(m[0].position.x = y.snapPosition.x ?? m[0].position.x), (m[0].position.y = y.snapPosition.y ?? m[0].position.y), r(y.horizontal), s(y.vertical)
        }
        return E0(m, v)
      }, []),
      h = ge(
        m => {
          l(v => ({
            ...v,
            nodes: A(m, v.nodes),
          }))
        },
        [A, l]
      ),
      g = ge(
        m => {
          l(v => ({
            ...v,
            edges: S0(m, v.edges).map(fo),
          }))
        },
        [l]
      )
    return {
      nodeState: [Pe(() => (t.viewMode === uo.enhanced ? t.nodes : t.nodes.filter(m => !Ul(m))), [t]), c, h],
      edgeState: [t.edges, u, g],
      viewModeState: [t.viewMode, d],
      editModeState: [t.editMode, f],
      horizontalHelperLineState: [o, r],
      verticalHelperLineState: [i, s],
      history: a,
    }
  },
  pF = e =>
    ge(
      (t, n) => {
        const o = fo({
          source: t.id,
          target: n.id,
        })
        return e(r => [...r, o]), o
      },
      [e]
    ),
  hF = e =>
    ge(
      (t, n, { type: o, ...r } = {}) => {
        const i = fn({
          parentId: t.id,
          extent: 'parent',
          type: o ?? JT,
          position: n,
          ...r,
        })
        return (
          e(s => {
            const { data: a } = r
            return (i.data.label = (a == null ? void 0 : a.label) ?? ''), (i.data.code = _T), (i.data.archetype = (a == null ? void 0 : a.archetype) ?? $T), [...s, i]
          }),
          i
        )
      },
      [e]
    ),
  gF = () => {
    const { flowDirection: e } = ho(),
      t = ye
    return {
      sourceHandlePosition: e === yn.vertical ? t.Bottom : t.Right,
      targetHandlePosition: e === yn.vertical ? t.Top : t.Left,
    }
  },
  mF = (...e) => Fr(...e),
  Cc = (e, t) => {
    const [n, o] = zl(),
      r = mF(e)
    Ce(() => {
      r && !n ? (t(), o(!0)) : o(r)
    }, [r, n, t, o])
  },
  yF = () => {
    const e = Ne({ x: 0, y: 0 }),
      t = Re(h => h.domNode),
      { getNodes: n, setNodes: o, getEdges: r, setEdges: i, screenToFlowPosition: s } = qo(),
      [a, l] = be([]),
      [c, u] = be([])
    Ce(() => {
      const h = ['cut', 'copy', 'paste']
      if (t) {
        const g = m => m.preventDefault(),
          x = m => {
            e.current = {
              x: m.clientX,
              y: m.clientY,
            }
          }
        for (const m of h) t.addEventListener(m, g)
        return (
          t.addEventListener('mousemove', x),
          () => {
            for (const m of h) t.removeEventListener(m, g)
            t.removeEventListener('mousemove', x)
          }
        )
      }
    }, [t])
    const d = ge(() => {
        const h = n().filter(x => x.selected),
          g = fu(h, r()).filter(x => {
            const m = h.every(y => y.id !== x.source),
              v = h.every(y => y.id !== x.target)
            return !(m || v)
          })
        l(h), u(g)
      }, [n, r]),
      f = ge(() => {
        const h = n().filter(x => x.selected),
          g = fu(h, r()).filter(x => {
            const m = h.every(y => y.id !== x.source),
              v = h.every(y => y.id !== x.target)
            return !(m || v)
          })
        l(h), u(g), o(x => x.filter(m => !m.selected)), i(x => x.filter(m => !g.includes(m)))
      }, [n, o, r, i]),
      A = ge(
        (
          { x: h, y: g } = s({
            x: e.current.x,
            y: e.current.y,
          })
        ) => {
          const x = Math.min(...a.map(C => C.position.x)),
            m = Math.min(...a.map(C => C.position.y)),
            v = Ho(),
            y = a.map(C => {
              const I = `${C.id}-${v}`,
                w = h + (C.position.x - x),
                M = g + (C.position.y - m)
              return { ...C, id: I, position: { x: w, y: M } }
            }),
            b = c.map(C => {
              const I = `${C.id}-${v}`,
                w = `${C.source}-${v}`,
                M = `${C.target}-${v}`
              return { ...C, id: I, source: w, target: M }
            })
          o(C => [...C.map(I => ({ ...I, selected: !1 })), ...y]), i(C => [...C.map(I => ({ ...I, selected: !1 })), ...b])
        },
        [a, c, s, o, i]
      )
    return { cut: f, copy: d, paste: A, bufferedNodes: a, bufferedEdges: c }
  },
  bF = () => MR(),
  fy = e => {
    const { nodes: t, setNodes: n } = ho(),
      o = Pe(() => t.find(i => i.id === e), [e, t]),
      r = ge(
        i => {
          n(s => s.map(a => (a.id === (o == null ? void 0 : o.id) ? i : a)))
        },
        [n, o]
      )
    return o
      ? {
          node: o,
          updateNode: r,
        }
      : {
          node: void 0,
          updateNode: null,
        }
  },
  vF = (
    e,
    t = {
      resizable: !0,
      rotatable: !0,
    }
  ) => {
    const n = Ne(null),
      o = bF(),
      { node: r, updateNode: i } = fy(e),
      s = Pe(() => (r ? d6(r) ?? 0 : 0), [r]),
      [a, l] = be(s),
      [c, u] = be(!!t.resizable),
      [d, f] = be(!!t.rotatable)
    return (
      Ce(() => {
        f(!!t.rotatable)
      }, [t]),
      Ce(() => {
        u(!!t.resizable)
      }, [t]),
      Ce(() => {
        l(s)
      }, [s]),
      Ce(() => {
        if (!n.current) return
        const A = Qt(n.current),
          h = Nd().on('drag', g => {
            const x = g.x - 100,
              m = g.y - 100,
              b = 180 - Math.atan2(x, m) * (180 / Math.PI)
            l(b),
              o(e),
              i == null ||
                i({
                  ...r,
                  data: {
                    ...r.data,
                    rotation: b,
                  },
                  style: {
                    ...r.style,
                  },
                })
          })
        A.call(h)
      }, [r, e, i, o]),
      {
        rotation: a,
        setRotation: l,
        resizable: c,
        setResizable: u,
        rotatable: d,
        setRotatable: f,
        rotateControlRef: n,
        updateNodeInternals: o,
      }
    )
  },
  xF = e => {
    const { nodes: t, setNodes: n } = ho(),
      { node: o } = fy(e),
      r = Pe(() => (o ? Jd(o, t) : void 0), [o, t]),
      i = ge(s => n(a => a.map(l => (r && r.id === l.id ? s : l))), [r, n])
    return r
      ? {
          node: r,
          updateNode: i,
        }
      : {
          node: void 0,
          updateNode: null,
        }
  },
  CF = e => {
    const { node: t } = xF(e)
    return t == null ? void 0 : t.data.rotation
  },
  wF = e =>
    ge(
      (t, n, o) => {
        const r = t,
          i = Jd(r, n),
          s = t.data.archetype,
          a = s === et.lineSide,
          l = s === et.loadSide
        if (!i) return
        const c = a,
          u = l,
          d = nu(r.id),
          f = nu(i.id),
          A = c ? `${d}-${f}` : `${f}-${d}`
        if (o.some(x => x.id === A)) return
        const g = fo({
          source: c ? r.id : i.id,
          target: u ? r.id : i.id,
          id: A,
          style: ey,
          data: {
            isInvisibleEdge: !0,
          },
        })
        e(x => [...x, g])
      },
      [e]
    ),
  EF =
    'data:image/png;base64,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',
  SF =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHwAAAIICAYAAACsMopAAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAViSURBVHgB7dwxqhNRFIDhG0kh2tqI8CoFO1tLV+AOrF2FhbyduAR716C9/evF4pUxgQs24ULKmf/7YHICt8vPKSYwcxj7dxq3OYwdezJIETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPETxG8BjBYwSPOZ6vT/P768HF17FPPy8fNjzmcL5OgwwbHiN4jOAxgscIHnNcnH2e889gS97MeX/t0IbHrO7DX835MNiSd3P+unZow2MEjxE8RvAYwWMEjxE8RvAYwWMEjxE8RvAYwWMEjxE8RvAYwWMEjxE8RvAYwWMEjxE8RvAYwWMEjxE8ZvX06N2czwdbcrc6tOEx3uIUY8NjBI8RPEbwGMFjVvfhP+Z8HGzJiznfXzu04THe4rQ/3uLEf4LHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB4jeIzgMYLHCB5zXJx9m/NxsCVPV4c2POZwvk6DDBseI3iM4DGCxwges7oP/zDnw2BL3s75/dqhDY9ZbfjvOW34tjxbHdrwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI8RPEbwGMFjBI9ZPVv2cc6/gy15uTq04THe4hRjw2MEjxE8RvAYwWMu9+H3Y9++jNvs+vew4TGHsX+3/s+w69/EhscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgscIHiN4jOAxgsf8A9M1HnYFS8jzAAAAAElFTkSuQmCC',
  Bu =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdAAAALgCAYAAAAkzyYwAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACfJSURBVHgB7d3hdRPZljbg4lv3/9ARtIgAEwEmAiACRAS2I8BEAESAiQCIABEBJgJEBM1E0N9YOrsb1TWizlZJqpKeZ61ht4zEbeBM73p9Tu260wBD9ndT504D7MT/awCAahooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQcKcBupiUerfUk9brqH/+4uuTZv2v25frUn+0vj4v9Xvr5+e/eD1vgLUkUABIkEA5Nu1EGEny/i++3k6SxyYS7bxVP7deXzdwZCRQAEiQQDk0kRxPS73f+vpJwzZdt+rXUmetr8PoSaAAkCCBMjanpUaSfNx6fax7lWMRp30jiX5svZ41MBISKAAkSKAMTSTIaakP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AkCCBHo4JqW+L/Wk2QL3kXIIYkLQhw8fFvXdu3eLusXEOSv1Zes1IyaBAkCCBHq4pqVu5bRuiET65MmTRT07O1v5OgxBJM6YVRtPR+lxVm3bvNR4asqHhoMjgQJAggR6PKalbjWRhkiksUcar2EXdniaNkSUbZ+u5YBJoACQIIEer3jay1mpk2aLYk807iONvdKYxQsZkSw/fvy4qFdXV4u6xb3N0E6cr1tf5whIoACQIIESzxmNTcqd7JGG9ine2DOVTPlZJM3Pnz8vaiTNHp+/+TsSJ/9FAgWABAmUX5mWutNEGtp7ppFMzeI9TLFneX19vah72NNsm5caifOqVImTf0igAJAggdLVtNQYfnva7FEk0dg7vX///srXGabYy/z69euixizaSJ57SJphVqpZtXQmgQJAggRK1qTUy1Iftr6+F3fvLg8VxyneSKSRUOPrZvX2K07DRpKM07LxegAJM8S/wLtSr0q9bqCSBAoACRIofZuWOoi90l9pJ9WokVQjocbX4/3HIpJiO1nG3mV8PfY0B5Asf2VW6pvWa6dp2ZgECgAJEijbNin1tNSYvTuqUUORQCOZthNsvP7zzz9XXv+qhuxebCS+dvJrf709qef79+8rX2+/r/31EZmV+rlUk4LYOgkUABIkUPZlUuqTUh+XetrAr81KjaR5Veq8gR2TQAEgQQJlaCalnpbaTqbHdRz2+MSe5azUdtK0p8lgSKAAkCCBMjanpcYp3set1xLqsEWCjMk/H1uvZw2MhAQKAAkSKIcmkuhp6/X91mu247pVv5Y6a30dRk8CBYAECZRjFUl0UuppqX+2vn6sifVHq0Zy/N56HXXeej8cPAkUABIkUOhm0qp3f/G6nWCb1s/f/cWv25d5q7aT5PdffP269XreAGtJoACQIIHCsP3d1PH/07AjEigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAggYKAAkaKAAkaKAAkKCBAkCCBgoACRooACRooACQoIECQIIGCgAJGigAJGigAJCggQJAwv8H2bzP/InUqH8AAAAASUVORK5CYII=',
  BF =
    'data:image/png;base64,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',
  IF =
    'data:image/png;base64,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c13mOtGdXTPPjvF5QWb5xlo6ulAahI9//OPB4Nx8881Nlmb79ttvjy6VJumAmAAaBACgMpENQnFo5n9GCyed1HkLe9999w367zOf+UyTBx98cLT09sxPBQyPDTJ/Hd15MHPlzIejO9/L7OrymaWX7hQPl112WZMbbrhh0H9vfetbmyy7SbpQdnOVxXU/iwmgQQAAKsPQICybeX3mjOjCWmut1eR5553XpPvQ++Omm25q8iUv6Vxud+ONN0aXbsksE/LvA4ZH2V11bHTn1MxXRzs7Zp4bLbz0pZ3Lc8tdNvRH2dW1666dpScLFnR9rEs592DPmEAaBACgMgwNQvGvmUdFCzvttFOTZZKjN8ptjW9+85ub/OpXvxotvTPz6IDh0+q9///rzZn/Hb1xXuZLooWjj+58ux122GFB79xyS6cQ3XrrrZssdwa1UE7wbH3ATBsaBACgMkwNQjnrvOyLf0608LGPfazJd77znUF773rXu5r8j//4j2ipnHuxeebcgOGxfOY1mavG+DyWWb6+fx69sUnmldHC4ot3Lqc8/fTTm9x5552D7v3xj39scu+9927yhz/8YbR0SubeMQQ0CABAZZgahOJvMr8WPfD1r3+9yf322y8Yv699rfNpeP3rXx89cmDmiQHDp7xy+0Z0p9zauHH0x2cy/59oYcaMzmaxcgLq2muP69JIUlnLccwxx0RLpUl9YebNMQQ0CABAZRgbhKJcoP3KaGG55TpLG8rJf6973euCZ9aH5mCo3luDp/DFzG7Pvv9E5qHRHytmlrUNrdZqrbbaak1efPHFTTo/ZuG84x2dYzKOO+646JF3Z340hogGAQCoDHODsFpmWbW7erRQmoR///d/b/Itb3lLUCtnhx9yyCFNzp8/P1q6M3PTzFsDhs9imb/KfF50p2wLaHXy4UIoJ+x9K7PVi73SJJx//vlNPu953f7vT20HHXRQk5/73OeiRy7K3Cmz9RNuL2kQAIDKMDcIxT6Z5ei+xaMHjjjiiCbf//73N7nIIpPhr6J/ynkR//mfnUs1W5whXpR/wW6ZpwcMr3InyCXRnXK3SHnp/ccYjE9mvj16YKmllmqynJS61157xSi79957myy3BJ911lnRI/dllvMyroshpEEAACqT6WXzezI/HD20ww47NHnCCSc0ud5668UouPrqq5v8+7//+yYvuuii6JHS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',
  NF =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtAAAALoCAYAAABRfsJcAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACYFSURBVHgB7d15uGVldSbwhZQGCSg4IAEN5YRRwRhxnlJ2cIiJQ0eTSBITNZMazUS3JrHTjR3tqIkkGmfiPMUxUTHOWo5oK84zKoWIqDiBoiACeXxYC/CUNay997n3nnN+v3/eh6Iope7i1HvW/c639wgA1suFMc4eAcCau0wAAAC7TYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgQYEGAIAGBRoAABoUaAAAaFCgAQCgYVPwi5k3jZ4TM7cGAMBiuV3m1aPnU5kfjhVmAw0AAA020BF3yzw6eo7N3BoAAIvlQZlHRU/1HxtoAABg9yjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAECDAg0AAA0KNAAANCjQAADQoEADAEDDpmConwkAAFaODTQAADQo0AAA0KBAAwBAgwINAAANCjQAADQo0AAA0KBAAwBAgwINAAANCjQAADQo0AAA0KBAAwBAgwINAAANCjQAADQo0AAA0KBAAwBAgwINAAANCjQAADRsCs6PYfYIiPjrzKOi5wWZjwuAYR6duSV6XpL5xGCV7RnDDO1NS8UGGgAAGmygI74Tw+wVEHHDzMOj57CAiBdm/nb0/EdAxI0ybx09JwVE7B3DfDewgQYAgA4b6OHvpPYPiDgohjkkYPj8XDkgYr8YxusPPzJ0fs4ObKABAKDDBjri2zHM1QKGv4O/XsDw+Tk0YPgm+cCA4fPz9cAGGgAAOmygI86MYeoM9BUyzwpWyeUzh76Dr+9gmJ/VZH4Yo+bn6jFM/fm1T6ZbFVbL2Pk5ObCBBgCADhvo4fdhXiXzmpkfCVZJbQ7H3sZiflaT+WGM+roPfSJu/fl1QKYN9GoZOz+fDmygAQCgwwY64pOZda/hT+/mP1fP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',
  kF =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlwAAALgCAYAAABBFKm+AAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAEvvSURBVHgB7d15lJTVnf/xy77KvomIBS4sUWmMEIwammg0UX8K0Riz0piJmTh/gJOcyeSMCc0sZyYzZyLmjJPJSnOSOMkkETBqolFpXGLcoIkoGrdCECUgssvO7/it+1G6pLuf56m6VU9VvV9/5JNuqhoVuvvWp+/93k4OANLriIunkwOAFOrsAAAAEBQLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYCy4AAAAAmPBBQAAEBgLLgAAgMBYcAEAAATGggsAACAwFlwAAACBseACAAAIjAUXAABAYJ0cAESX8Tmgg7f7571/QBuPy5f/uKS25WVH78/mvX97G+/flvf+rAOACGi4AAAAAqPhAmpLfsNUl/f+SXm/np84tmwbuc5nS977WxyAmkLDBQAAEBgNF1AdMj7r8nJS3tsZhzTJb75W570//9cBVCgaLgAAgMBouIB0096q/OZqus/6vMehOul0pBqvFT6b896/zQFIJRouAACAwGi4gPJSM1XvM7+5qnNAdGq6mn3mN2E0YECZ0HABAAAERsMFlEa9z/wGq94BpdPsM7/5anYAgqLhAgAACIyGCygO7cWa6XN63ttVcYpwwIDcv0Ymk2mV+e/v379/q/d3lPn0cZLatm1bq+zo/dlsttX7t2/f3ur9+b+e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',
  MF =
    'data:image/png;base64,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S6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsq4HzPVowIFsUECWDYrZrgYcyAYFZAkUkCVQQJb3oFjrxYBJbFBAlg2Ktf4dMIkNCsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggCyBArIECsgSKCBLoIAsgQKyBArIEiggS6CALIECsgQKyBIoIEuggKzrAXM9HnAgGxSQJVBAlkABWQIFZAkUkOVP8Vjr2YBJbFBAlg2KtZ4OmMQGBWQJFJAlUECWQAFZAgVkCRSQJVBAlkABWQIFZAkUkCVQQJZAAVkCBWQJFJAlUECWQAFZAgVkCRSQJVBAlkABWQIFZAkUkCVQQJZAAVkCBWQJFJAlUECWQAFZAgVkCRSQJVBAlkABWQIFZAkUkCVQQJZAAVkCBWQJFJAlUECWQAFZAgVkCRSQJVBAlkABWQIFZAkUkCVQQJZAAVkCBWQJFJAlUEDW9YB1/ljml+M4TwYcyAYFAADwyvgPnbB96DKjgGMAAAAASUVORK5CYII=',
  PF =
    'data:image/png;base64,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',
  LF =
    'data:image/png;base64,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',
  RF =
    'data:image/png;base64,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',
  TF =
    'data:image/png;base64,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',
  FF = 180,
  DF = 30,
  cn = e => (e ? e * ly : FF),
  wc = e => (e ? e * cy : DF),
  un = Tt,
  Ec = Pn,
  Ps = {
    src: Bu,
    alt: 'generic',
    width: cn(),
    height: un,
  },
  qt = {
    CIRCUIT_BREAKER: {
      src: EF,
      alt: 'circuit breaker',
      width: wc(104),
      height: Ec,
    },
    ELECTRICAL_PANEL: {
      src: Bu,
      alt: 'electrical panel',
      width: cn(0),
      height: un,
    },
    FUSE: {
      src: SF,
      alt: 'fuse',
      width: wc(45),
      height: Ec,
    },
    MISC: {
      src: Bu,
      alt: 'other',
      width: cn(116),
      height: un,
    },
    SWITCH: {
      src: BF,
      alt: 'switch',
      width: cn(77),
      height: un,
    },
    TRANSFER_SWITCH: {
      src: IF,
      alt: 'transfer switch',
      width: cn(130),
      height: un,
    },
    TRANSFORMER: {
      src: NF,
      alt: 'transformer',
      width: cn(180),
      height: un,
    },
    UPS_SYSTEM: {
      src: kF,
      alt: 'ups system',
      width: cn(151),
      height: un,
    },
    CAPACITOR: {
      src: MF,
      alt: 'capacitor',
      width: cn(74),
      height: un,
    },
    SUB_SWITCH: {
      src: PF,
      alt: 'switch',
      width: wc(72),
      height: Ec,
    },
    MOTOR: {
      src: LF,
      alt: 'motor',
      width: cn(151),
      height: un,
    },
    GENERATOR: {
      src: RF,
      alt: 'generator',
      width: cn(151),
      height: un,
    },
    RELAY: {
      src: TF,
      alt: 'relay',
      width: cn(151),
      height: un,
    },
    GROUND_FAULT_SYSTEM: Ps,
    GROUNDING_OR_BONDING: Ps,
    INSTRUMENT_TRANSFORMER: Ps,
    METER: Ps,
  },
  zF = async () => ({
    services: {
      appEnvironment: Cl.appEnvironment,
    },
  }),
  QF = ld({
    palette: {
      ...Cv,
    },
    typography: {
      fontFamily: ['Manrope-Regular', 'Manrope-Medium', 'Manrope-Bold', 'BlinkMacSystemFont', '"Segoe UI"', 'Roboto', '"Helvetica Neue"', 'Arial', 'sans-serif', '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"'].join(','),
      fontSize: 14,
      // Set the base font size
      body1: {
        fontSize: '14px',
        // Ensure body text is 14px
      },
      body2: {
        fontSize: '13px',
        // Optionally set other variants
      },
      // button: {
      //   fontSize: "14px",
      //   textTransform: "none", // Prevent automatic uppercase on buttons
      // },
      h1: {
        fontSize: '2rem',
      },
      h2: {
        fontSize: '1.5rem',
      },
      h3: {
        fontSize: '1.25rem',
      },
    },
  }),
  cs = () => {
    const [e, t] = be(),
      [n, o] = zl(),
      r = ge(async () => {
        const i = await zF()
        t(i.services), o(!0)
      }, [o])
    return (
      aT(() => {
        r()
      }),
      {
        services: e,
        config: Cl,
        bootstrapped: n,
        theme: QF,
      }
    )
  },
  Wd = ({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: i, onNodeArchetypeChange: s, onDeleteClick: a, onCopyClick: l }) => {
    var $e, Ke
    const { config: c } = cs(),
      { minAmpereRating: u = 0.01, maxAmpereRating: d = 1e3, defaultAmpereRating: f = 1, minPoles: A = 1, maxPoles: h = 10, defaultPoles: g = 3 } = c.subNodeParameters,
      x = VT(),
      { nodes: m, setNodes: v, edges: y, setEdges: b } = ho(),
      [C, I] = be(() => um(e) ?? ''),
      [w, M] = be(() => jy(e).background ?? ''),
      [L, R] = be(() => Oy(e)),
      [T, D] = be(() => ou(e, m)),
      [z, E] = be(() => e.data.electricalPanelType ?? Vo.MCB),
      P = Pe(() => Ul(e), [e]),
      B = Pe(() => !P, [P]),
      F = B && Ni[Ru[L]] === To.ElectricalPanelNode,
      S = Qy(e),
      Q = zy(e),
      j = f6(e),
      U = Jd(e, m),
      q = l6(e, m),
      ne = j ? 'Parent name' : 'Parent id',
      [G, K] = be((($e = e == null ? void 0 : e.data) == null ? void 0 : $e.archetype) ?? et.lineSide),
      [$, oe] = be(((Ke = e == null ? void 0 : e.data) == null ? void 0 : Ke.amperes) ?? f),
      [Z, ie] = be((e == null ? void 0 : e.data.poles) ?? g),
      fe = V => ie(W => Math.min(W + V, h)),
      se = V => ie(W => Math.max(W - V, A)),
      re = ge(
        V => {
          K(V),
            s == null ||
              s(
                fn({
                  ...e,
                  data: {
                    ...e.data,
                    archetype: V,
                  },
                })
              )
        },
        [s]
      )
    Ce(() => {
      D(ou(e, m))
    }, [m, e])
    const Y = V => W => {
        D(le => le.map(te => (te.id !== V.id ? te : A6(V, W.target.value))))
      },
      H = Pe(
        () =>
          m.some(V => {
            var W
            return ((W = Ir(V)) == null ? void 0 : W.trim()) === C.trim() && V.id !== e.id
          }),
        [m, C, e]
      ),
      ee = V => {
        I(V.target.value),
          n == null ||
            n(
              fn({
                ...e,
                data: { ...e.data, label: V.target.value.trim() },
              })
            )
      },
      xe = ge(
        ({ classCode: V = L, nodeColor: W = w, epType: le = z } = {}) => {
          const te = c6(S),
            ce = Ru[V],
            J = Fy[V],
            Ae = te ? null : B ? ce : J,
            we = te ? (B ? To.ResizableNode : To.ResizableSubNode) : B ? (Kp(ce) ? Ni[ce] : To.ImageNode) : Kp(J) ? Ni[J] : To.ImageSubNode,
            Ie = Ae ?? S,
            lt = P ? `${Ly[Ie]}-${Dy[G]}-${m.length + 1}-${Z}P/${$}A` : null,
            Zt = C.trim(),
            Fn = lt ? null : Zt
          return fn({
            ...e,
            type: we,
            data: te
              ? {
                  ...e.data,
                  label: Fn,
                  defaultLabel: lt,
                  background: W,
                }
              : {
                  ...e.data,
                  class: Ie,
                  image: qt[Ie],
                  code: V,
                  background: W,
                  electricalPanelType: le,
                  defaultLabel: lt,
                  ...(Q ? { label: Fn } : {}),
                  ...(B
                    ? {}
                    : {
                        archetype: G,
                        amperes: $,
                        poles: Z,
                      }),
                },
          })
        },
        [S, B, Q, w, C, e, L, z, G, $, Z]
      ),
      Fe = V => {
        const W = V.target.value
        R(W), r == null || r(fn(xe({ classCode: W })))
      },
      De = V => {
        M(V), o == null || o(xe({ nodeColor: V }))
      },
      _e = () => {
        const V = y.filter(W => W.target === e.id)
        b(W => W.filter(te => V.every(ce => ce.id !== te.id)))
      },
      Be = () => {
        const V = m.filter(te => te.parentId === e.id && te.data.archetype === et.lineSide)
        V.length > 0 && x.warning('Switching to MLO results in deleting all of the line-side components')
        const le = y
          .filter(te => V.some(ce => ce.id === te.target))
          .map(te =>
            fo({
              ...te,
              target: e.id,
            })
          )
        b(te => te.map(J => (le.some(Ae => Ae.id === J.id) ? le.find(Ae => Ae.id === J.id) : J))), v(te => te.filter(J => V.every(Ae => Ae.id !== J.id)))
      }
    return {
      node: e,
      existingNodes: m,
      setNodes: v,
      existingEdges: y,
      setEdges: b,
      name: C,
      setName: I,
      color: w,
      setColor: M,
      code: L,
      setCode: R,
      archetype: G,
      setArchetype: K,
      ampereRating: $,
      setAmpereRating: oe,
      poles: Z,
      setPoles: ie,
      nodeChildren: T,
      setNodeChildren: D,
      electricalPanelType: z,
      setElectricalPanelType: E,
      hasParent: P,
      isTopLevelNode: B,
      isElectricalPanel: F,
      heterogenousClass: S,
      isWithImplicitClass: Q,
      hasName: j,
      nodeParent: U,
      hasChildren: q,
      parentNodeInputLabel: ne,
      handleChildNameChange: Y,
      nameExistsAlready: H,
      handleNameChange: ee,
      evaluateNextNode: xe,
      handleNodeClassCodeChange: Fe,
      handleColorChange: De,
      handleSwitchToMCB: _e,
      handleSwitchToMLO: Be,
      handleElectricalPanelTypeChange: V => {
        const W = V.target.value,
          le = W === Vo.MCB,
          te = W === Vo.MLO
        le && _e(), te && Be(), E(W), i == null || i(xe({ epType: W }))
      },
      handleSave: () => {
        t == null || t(fn(xe({ classCode: L }))), q && v(V => V.map(W => T.find(te => te.id === W.id) ?? W))
      },
      handleArchetypeChange: re,
      handleAmpereRatingChange: (V, W) => {
        V.preventDefault(), oe(W > d ? d : W < u ? u : W)
      },
      handlePolesIncrement: fe,
      handlePolesDecrement: se,
      handleDeleteClick: () => {
        a == null || a(fn(xe({ classCode: L })))
      },
      handleCopyClick: () => {
        l == null || l(fn(xe({ classCode: L })), U)
      },
    }
  },
  Gd = e => {
    const t = e.label,
      n = e.defaultLabel
    return n ? /* @__PURE__ */ p.jsxs(p.Fragment, { children: [Ly[e.class], '-', Dy[e.archetype], '-', n.split('-')[2], /* @__PURE__ */ p.jsx('br', {}), e.poles, 'P/', e.amperes, 'A'] }) : t ? /* @__PURE__ */ p.jsxs(p.Fragment, { children: [t, /* @__PURE__ */ p.jsx('br', {}), e.poles, 'P/', e.amperes, 'A'] }) : ''
  }
function OF(e) {
  return typeof e == 'string'
}
function jF(e, t, n) {
  return e === void 0 || OF(e)
    ? t
    : {
        ...t,
        ownerState: {
          ...t.ownerState,
          ...n,
        },
      }
}
const WF = {
    disableDefaultClasses: !1,
  },
  GF = /* @__PURE__ */ N.createContext(WF)
function Ay(e) {
  const { disableDefaultClasses: t } = N.useContext(GF)
  return n => (t ? '' : e(n))
}
function _s(e, t = []) {
  if (e === void 0) return {}
  const n = {}
  return (
    Object.keys(e)
      .filter(o => o.match(/^on[A-Z]/) && typeof e[o] == 'function' && !t.includes(o))
      .forEach(o => {
        n[o] = e[o]
      }),
    n
  )
}
function Iu(e, t) {
  typeof e == 'function' ? e(t) : e && (e.current = t)
}
function Wl(...e) {
  return N.useMemo(
    () =>
      e.every(t => t == null)
        ? null
        : t => {
            e.forEach(n => {
              Iu(n, t)
            })
          },
    e
  )
}
function xp(e) {
  if (e === void 0) return {}
  const t = {}
  return (
    Object.keys(e)
      .filter(n => !(n.match(/^on[A-Z]/) && typeof e[n] == 'function'))
      .forEach(n => {
        t[n] = e[n]
      }),
    t
  )
}
function VF(e) {
  const { getSlotProps: t, additionalProps: n, externalSlotProps: o, externalForwardedProps: r, className: i } = e
  if (!t) {
    const A = de(n == null ? void 0 : n.className, i, r == null ? void 0 : r.className, o == null ? void 0 : o.className),
      h = {
        ...(n == null ? void 0 : n.style),
        ...(r == null ? void 0 : r.style),
        ...(o == null ? void 0 : o.style),
      },
      g = {
        ...n,
        ...r,
        ...o,
      }
    return (
      A.length > 0 && (g.className = A),
      Object.keys(h).length > 0 && (g.style = h),
      {
        props: g,
        internalRef: void 0,
      }
    )
  }
  const s = _s({
      ...r,
      ...o,
    }),
    a = xp(o),
    l = xp(r),
    c = t(s),
    u = de(c == null ? void 0 : c.className, n == null ? void 0 : n.className, i, r == null ? void 0 : r.className, o == null ? void 0 : o.className),
    d = {
      ...(c == null ? void 0 : c.style),
      ...(n == null ? void 0 : n.style),
      ...(r == null ? void 0 : r.style),
      ...(o == null ? void 0 : o.style),
    },
    f = {
      ...c,
      ...n,
      ...l,
      ...a,
    }
  return (
    u.length > 0 && (f.className = u),
    Object.keys(d).length > 0 && (f.style = d),
    {
      props: f,
      internalRef: c.ref,
    }
  )
}
function XF(e, t, n) {
  return typeof e == 'function' ? e(t, n) : e
}
function mi(e) {
  var d
  const { elementType: t, externalSlotProps: n, ownerState: o, skipResolvingSlotProps: r = !1, ...i } = e,
    s = r ? {} : XF(n, o),
    { props: a, internalRef: l } = VF({
      ...i,
      externalSlotProps: s,
    }),
    c = Wl(l, s == null ? void 0 : s.ref, (d = e.additionalProps) == null ? void 0 : d.ref)
  return jF(
    t,
    {
      ...a,
      ref: c,
    },
    o
  )
}
function YF(e) {
  let t = 'https://mui.com/production-error/?code=' + e
  for (let n = 1; n < arguments.length; n += 1) t += '&args[]=' + encodeURIComponent(arguments[n])
  return 'Minified MUI error #' + e + '; visit ' + t + ' for the full message.'
}
const Nu = typeof window < 'u' ? N.useLayoutEffect : N.useEffect
let Cp = 0
function HF(e) {
  const [t, n] = N.useState(e),
    o = e || t
  return (
    N.useEffect(() => {
      t == null && ((Cp += 1), n(`mui-${Cp}`))
    }, [t]),
    o
  )
}
const wp = N.useId
function UF(e) {
  if (wp !== void 0) {
    const t = wp()
    return e ?? t
  }
  return HF(e)
}
function py(e, t, n = void 0) {
  const o = {}
  for (const r in e) {
    const i = e[r]
    let s = ''
    for (let a = 0; a < i.length; a += 1) {
      const l = i[a]
      l && ((s += t(l) + ' '), n && n[l] && (s += n[l] + ' '))
    }
    o[r] = s
  }
  return o
}
const KF = {
  active: 'active',
  checked: 'checked',
  completed: 'completed',
  disabled: 'disabled',
  error: 'error',
  expanded: 'expanded',
  focused: 'focused',
  focusVisible: 'focusVisible',
  open: 'open',
  readOnly: 'readOnly',
  required: 'required',
  selected: 'selected',
}
function Sc(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n))
}
function qF(e) {
  return !e || !(/* @__PURE__ */ N.isValidElement(e))
    ? null
    : e.props.propertyIsEnumerable('ref')
    ? e.props.ref
    : // @ts-expect-error element.ref is not included in the ReactElement type
      // We cannot check for it, but isValidElement is true at this point
      // https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/70189
      e.ref
}
const hy = 'base'
function ZF(e) {
  return `${hy}--${e}`
}
function JF(e, t) {
  return `${hy}-${e}-${t}`
}
function Vd(e, t) {
  const n = KF[t]
  return n ? ZF(n) : JF(e, t)
}
function gy(e, t) {
  const n = {}
  return (
    t.forEach(o => {
      n[o] = Vd(e, o)
    }),
    n
  )
}
function _F(e, t) {
  return e === t
}
const Bc = {},
  Ep = () => {}
function ku(e, t) {
  const n = {
    ...e,
  }
  return (
    Object.keys(t).forEach(o => {
      t[o] !== void 0 && (n[o] = t[o])
    }),
    n
  )
}
function $F(e) {
  const { nextState: t, initialState: n, stateComparers: o, onStateChange: r, controlledProps: i, lastActionRef: s } = e,
    a = N.useRef(n)
  N.useEffect(() => {
    if (s.current === null) return
    const l = ku(a.current, i)
    Object.keys(t).forEach(c => {
      const u = o[c] ?? _F,
        d = t[c],
        f = l[c]
      ;((f == null && d != null) || (f != null && d == null) || (f != null && d != null && !u(d, f))) && (r == null || r(s.current.event ?? null, c, d, s.current.type ?? '', t))
    }),
      (a.current = t),
      (s.current = null)
  }, [a, t, s, r, o, i])
}
function e3(e) {
  const t = N.useRef(null),
    { reducer: n, initialState: o, controlledProps: r = Bc, stateComparers: i = Bc, onStateChange: s = Ep, actionContext: a, componentName: l = '' } = e
  N.useRef(r)
  const c = N.useCallback(
      (A, h) => {
        t.current = h
        const g = ku(A, r)
        return n(g, h)
      },
      [r, n]
    ),
    [u, d] = N.useReducer(c, o),
    f = N.useCallback(
      A => {
        d({
          ...A,
          context: a,
        })
      },
      [a]
    )
  return (
    $F({
      nextState: u,
      initialState: o,
      stateComparers: i ?? Bc,
      onStateChange: s ?? Ep,
      controlledProps: r,
      lastActionRef: t,
    }),
    [ku(u, r), f]
  )
}
const t3 = /* @__PURE__ */ N.createContext(void 0)
function n3() {
  return N.useContext(t3)
}
const Ca = Math.min,
  Go = Math.max,
  wa = Math.round,
  Ls = Math.floor,
  Nn = e => ({
    x: e,
    y: e,
  }),
  o3 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom',
  },
  r3 = {
    start: 'end',
    end: 'start',
  }
function Sp(e, t, n) {
  return Go(e, Ca(t, n))
}
function Gl(e, t) {
  return typeof e == 'function' ? e(t) : e
}
function Jo(e) {
  return e.split('-')[0]
}
function Vl(e) {
  return e.split('-')[1]
}
function my(e) {
  return e === 'x' ? 'y' : 'x'
}
function yy(e) {
  return e === 'y' ? 'height' : 'width'
}
function Dr(e) {
  return ['top', 'bottom'].includes(Jo(e)) ? 'y' : 'x'
}
function by(e) {
  return my(Dr(e))
}
function i3(e, t, n) {
  n === void 0 && (n = !1)
  const o = Vl(e),
    r = by(e),
    i = yy(r)
  let s = r === 'x' ? (o === (n ? 'end' : 'start') ? 'right' : 'left') : o === 'start' ? 'bottom' : 'top'
  return t.reference[i] > t.floating[i] && (s = Ea(s)), [s, Ea(s)]
}
function s3(e) {
  const t = Ea(e)
  return [Mu(e), t, Mu(t)]
}
function Mu(e) {
  return e.replace(/start|end/g, t => r3[t])
}
function a3(e, t, n) {
  const o = ['left', 'right'],
    r = ['right', 'left'],
    i = ['top', 'bottom'],
    s = ['bottom', 'top']
  switch (e) {
    case 'top':
    case 'bottom':
      return n ? (t ? r : o) : t ? o : r
    case 'left':
    case 'right':
      return t ? i : s
    default:
      return []
  }
}
function l3(e, t, n, o) {
  const r = Vl(e)
  let i = a3(Jo(e), n === 'start', o)
  return r && ((i = i.map(s => s + '-' + r)), t && (i = i.concat(i.map(Mu)))), i
}
function Ea(e) {
  return e.replace(/left|right|bottom|top/g, t => o3[t])
}
function c3(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e,
  }
}
function u3(e) {
  return typeof e != 'number'
    ? c3(e)
    : {
        top: e,
        right: e,
        bottom: e,
        left: e,
      }
}
function Sa(e) {
  const { x: t, y: n, width: o, height: r } = e
  return {
    width: o,
    height: r,
    top: n,
    left: t,
    right: t + o,
    bottom: n + r,
    x: t,
    y: n,
  }
}
function Bp(e, t, n) {
  let { reference: o, floating: r } = e
  const i = Dr(t),
    s = by(t),
    a = yy(s),
    l = Jo(t),
    c = i === 'y',
    u = o.x + o.width / 2 - r.width / 2,
    d = o.y + o.height / 2 - r.height / 2,
    f = o[a] / 2 - r[a] / 2
  let A
  switch (l) {
    case 'top':
      A = {
        x: u,
        y: o.y - r.height,
      }
      break
    case 'bottom':
      A = {
        x: u,
        y: o.y + o.height,
      }
      break
    case 'right':
      A = {
        x: o.x + o.width,
        y: d,
      }
      break
    case 'left':
      A = {
        x: o.x - r.width,
        y: d,
      }
      break
    default:
      A = {
        x: o.x,
        y: o.y,
      }
  }
  switch (Vl(t)) {
    case 'start':
      A[s] -= f * (n && c ? -1 : 1)
      break
    case 'end':
      A[s] += f * (n && c ? -1 : 1)
      break
  }
  return A
}
const d3 = async (e, t, n) => {
  const { placement: o = 'bottom', strategy: r = 'absolute', middleware: i = [], platform: s } = n,
    a = i.filter(Boolean),
    l = await (s.isRTL == null ? void 0 : s.isRTL(t))
  let c = await s.getElementRects({
      reference: e,
      floating: t,
      strategy: r,
    }),
    { x: u, y: d } = Bp(c, o, l),
    f = o,
    A = {},
    h = 0
  for (let g = 0; g < a.length; g++) {
    const { name: x, fn: m } = a[g],
      {
        x: v,
        y,
        data: b,
        reset: C,
      } = await m({
        x: u,
        y: d,
        initialPlacement: o,
        placement: f,
        strategy: r,
        middlewareData: A,
        rects: c,
        platform: s,
        elements: {
          reference: e,
          floating: t,
        },
      })
    ;(u = v ?? u),
      (d = y ?? d),
      (A = {
        ...A,
        [x]: {
          ...A[x],
          ...b,
        },
      }),
      C &&
        h <= 50 &&
        (h++,
        typeof C == 'object' &&
          (C.placement && (f = C.placement),
          C.rects &&
            (c =
              C.rects === !0
                ? await s.getElementRects({
                    reference: e,
                    floating: t,
                    strategy: r,
                  })
                : C.rects),
          ({ x: u, y: d } = Bp(c, f, l))),
        (g = -1))
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: r,
    middlewareData: A,
  }
}
async function vy(e, t) {
  var n
  t === void 0 && (t = {})
  const { x: o, y: r, platform: i, rects: s, elements: a, strategy: l } = e,
    { boundary: c = 'clippingAncestors', rootBoundary: u = 'viewport', elementContext: d = 'floating', altBoundary: f = !1, padding: A = 0 } = Gl(t, e),
    h = u3(A),
    x = a[f ? (d === 'floating' ? 'reference' : 'floating') : d],
    m = Sa(
      await i.getClippingRect({
        element: (n = await (i.isElement == null ? void 0 : i.isElement(x))) == null || n ? x : x.contextElement || (await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating))),
        boundary: c,
        rootBoundary: u,
        strategy: l,
      })
    ),
    v =
      d === 'floating'
        ? {
            x: o,
            y: r,
            width: s.floating.width,
            height: s.floating.height,
          }
        : s.reference,
    y = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)),
    b = (await (i.isElement == null ? void 0 : i.isElement(y)))
      ? (await (i.getScale == null ? void 0 : i.getScale(y))) || {
          x: 1,
          y: 1,
        }
      : {
          x: 1,
          y: 1,
        },
    C = Sa(
      i.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: a,
            rect: v,
            offsetParent: y,
            strategy: l,
          })
        : v
    )
  return {
    top: (m.top - C.top + h.top) / b.y,
    bottom: (C.bottom - m.bottom + h.bottom) / b.y,
    left: (m.left - C.left + h.left) / b.x,
    right: (C.right - m.right + h.right) / b.x,
  }
}
const f3 = function (e) {
  return (
    e === void 0 && (e = {}),
    {
      name: 'flip',
      options: e,
      async fn(t) {
        var n, o
        const { placement: r, middlewareData: i, rects: s, initialPlacement: a, platform: l, elements: c } = t,
          { mainAxis: u = !0, crossAxis: d = !0, fallbackPlacements: f, fallbackStrategy: A = 'bestFit', fallbackAxisSideDirection: h = 'none', flipAlignment: g = !0, ...x } = Gl(e, t)
        if ((n = i.arrow) != null && n.alignmentOffset) return {}
        const m = Jo(r),
          v = Dr(a),
          y = Jo(a) === a,
          b = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
          C = f || (y || !g ? [Ea(a)] : s3(a)),
          I = h !== 'none'
        !f && I && C.push(...l3(a, g, h, b))
        const w = [a, ...C],
          M = await vy(t, x),
          L = []
        let R = ((o = i.flip) == null ? void 0 : o.overflows) || []
        if ((u && L.push(M[m]), d)) {
          const E = i3(r, s, b)
          L.push(M[E[0]], M[E[1]])
        }
        if (
          ((R = [
            ...R,
            {
              placement: r,
              overflows: L,
            },
          ]),
          !L.every(E => E <= 0))
        ) {
          var T, D
          const E = (((T = i.flip) == null ? void 0 : T.index) || 0) + 1,
            P = w[E]
          if (P)
            return {
              data: {
                index: E,
                overflows: R,
              },
              reset: {
                placement: P,
              },
            }
          let B = (D = R.filter(F => F.overflows[0] <= 0).sort((F, S) => F.overflows[1] - S.overflows[1])[0]) == null ? void 0 : D.placement
          if (!B)
            switch (A) {
              case 'bestFit': {
                var z
                const F =
                  (z = R.filter(S => {
                    if (I) {
                      const Q = Dr(S.placement)
                      return (
                        Q === v || // Create a bias to the `y` side axis due to horizontal
                        // reading directions favoring greater width.
                        Q === 'y'
                      )
                    }
                    return !0
                  })
                    .map(S => [S.placement, S.overflows.filter(Q => Q > 0).reduce((Q, j) => Q + j, 0)])
                    .sort((S, Q) => S[1] - Q[1])[0]) == null
                    ? void 0
                    : z[0]
                F && (B = F)
                break
              }
              case 'initialPlacement':
                B = a
                break
            }
          if (r !== B)
            return {
              reset: {
                placement: B,
              },
            }
        }
        return {}
      },
    }
  )
}
async function A3(e, t) {
  const { placement: n, platform: o, elements: r } = e,
    i = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)),
    s = Jo(n),
    a = Vl(n),
    l = Dr(n) === 'y',
    c = ['left', 'top'].includes(s) ? -1 : 1,
    u = i && l ? -1 : 1,
    d = Gl(t, e)
  let {
    mainAxis: f,
    crossAxis: A,
    alignmentAxis: h,
  } = typeof d == 'number'
    ? {
        mainAxis: d,
        crossAxis: 0,
        alignmentAxis: null,
      }
    : {
        mainAxis: d.mainAxis || 0,
        crossAxis: d.crossAxis || 0,
        alignmentAxis: d.alignmentAxis,
      }
  return (
    a && typeof h == 'number' && (A = a === 'end' ? h * -1 : h),
    l
      ? {
          x: A * u,
          y: f * c,
        }
      : {
          x: f * c,
          y: A * u,
        }
  )
}
const p3 = function (e) {
    return (
      e === void 0 && (e = 0),
      {
        name: 'offset',
        options: e,
        async fn(t) {
          var n, o
          const { x: r, y: i, placement: s, middlewareData: a } = t,
            l = await A3(t, e)
          return s === ((n = a.offset) == null ? void 0 : n.placement) && (o = a.arrow) != null && o.alignmentOffset
            ? {}
            : {
                x: r + l.x,
                y: i + l.y,
                data: {
                  ...l,
                  placement: s,
                },
              }
        },
      }
    )
  },
  h3 = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'shift',
        options: e,
        async fn(t) {
          const { x: n, y: o, placement: r } = t,
            {
              mainAxis: i = !0,
              crossAxis: s = !1,
              limiter: a = {
                fn: x => {
                  let { x: m, y: v } = x
                  return {
                    x: m,
                    y: v,
                  }
                },
              },
              ...l
            } = Gl(e, t),
            c = {
              x: n,
              y: o,
            },
            u = await vy(t, l),
            d = Dr(Jo(r)),
            f = my(d)
          let A = c[f],
            h = c[d]
          if (i) {
            const x = f === 'y' ? 'top' : 'left',
              m = f === 'y' ? 'bottom' : 'right',
              v = A + u[x],
              y = A - u[m]
            A = Sp(v, A, y)
          }
          if (s) {
            const x = d === 'y' ? 'top' : 'left',
              m = d === 'y' ? 'bottom' : 'right',
              v = h + u[x],
              y = h - u[m]
            h = Sp(v, h, y)
          }
          const g = a.fn({
            ...t,
            [f]: A,
            [d]: h,
          })
          return {
            ...g,
            data: {
              x: g.x - n,
              y: g.y - o,
              enabled: {
                [f]: i,
                [d]: s,
              },
            },
          }
        },
      }
    )
  }
function Xl() {
  return typeof window < 'u'
}
function Kr(e) {
  return xy(e) ? (e.nodeName || '').toLowerCase() : '#document'
}
function Yt(e) {
  var t
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}
function Tn(e) {
  var t
  return (t = (xy(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement
}
function xy(e) {
  return Xl() ? e instanceof Node || e instanceof Yt(e).Node : !1
}
function gn(e) {
  return Xl() ? e instanceof Element || e instanceof Yt(e).Element : !1
}
function Ln(e) {
  return Xl() ? e instanceof HTMLElement || e instanceof Yt(e).HTMLElement : !1
}
function Ip(e) {
  return !Xl() || typeof ShadowRoot > 'u' ? !1 : e instanceof ShadowRoot || e instanceof Yt(e).ShadowRoot
}
function us(e) {
  const { overflow: t, overflowX: n, overflowY: o, display: r } = mn(e)
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !['inline', 'contents'].includes(r)
}
function g3(e) {
  return ['table', 'td', 'th'].includes(Kr(e))
}
function Yl(e) {
  return [':popover-open', ':modal'].some(t => {
    try {
      return e.matches(t)
    } catch {
      return !1
    }
  })
}
function Xd(e) {
  const t = Yd(),
    n = gn(e) ? mn(e) : e
  return (
    n.transform !== 'none' ||
    n.perspective !== 'none' ||
    (n.containerType ? n.containerType !== 'normal' : !1) ||
    (!t && (n.backdropFilter ? n.backdropFilter !== 'none' : !1)) ||
    (!t && (n.filter ? n.filter !== 'none' : !1)) ||
    ['transform', 'perspective', 'filter'].some(o => (n.willChange || '').includes(o)) ||
    ['paint', 'layout', 'strict', 'content'].some(o => (n.contain || '').includes(o))
  )
}
function m3(e) {
  let t = Ao(e)
  for (; Ln(t) && !zr(t); ) {
    if (Xd(t)) return t
    if (Yl(t)) return null
    t = Ao(t)
  }
  return null
}
function Yd() {
  return typeof CSS > 'u' || !CSS.supports ? !1 : CSS.supports('-webkit-backdrop-filter', 'none')
}
function zr(e) {
  return ['html', 'body', '#document'].includes(Kr(e))
}
function mn(e) {
  return Yt(e).getComputedStyle(e)
}
function Hl(e) {
  return gn(e)
    ? {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop,
      }
    : {
        scrollLeft: e.scrollX,
        scrollTop: e.scrollY,
      }
}
function Ao(e) {
  if (Kr(e) === 'html') return e
  const t =
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    (Ip(e) && e.host) || // Fallback.
    Tn(e)
  return Ip(t) ? t.host : t
}
function Cy(e) {
  const t = Ao(e)
  return zr(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : Ln(t) && us(t) ? t : Cy(t)
}
function Yi(e, t, n) {
  var o
  t === void 0 && (t = []), n === void 0 && (n = !0)
  const r = Cy(e),
    i = r === ((o = e.ownerDocument) == null ? void 0 : o.body),
    s = Yt(r)
  if (i) {
    const a = Pu(s)
    return t.concat(s, s.visualViewport || [], us(r) ? r : [], a && n ? Yi(a) : [])
  }
  return t.concat(r, Yi(r, [], n))
}
function Pu(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}
function wy(e) {
  const t = mn(e)
  let n = parseFloat(t.width) || 0,
    o = parseFloat(t.height) || 0
  const r = Ln(e),
    i = r ? e.offsetWidth : n,
    s = r ? e.offsetHeight : o,
    a = wa(n) !== i || wa(o) !== s
  return (
    a && ((n = i), (o = s)),
    {
      width: n,
      height: o,
      $: a,
    }
  )
}
function Hd(e) {
  return gn(e) ? e : e.contextElement
}
function br(e) {
  const t = Hd(e)
  if (!Ln(t)) return Nn(1)
  const n = t.getBoundingClientRect(),
    { width: o, height: r, $: i } = wy(t)
  let s = (i ? wa(n.width) : n.width) / o,
    a = (i ? wa(n.height) : n.height) / r
  return (
    (!s || !Number.isFinite(s)) && (s = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    {
      x: s,
      y: a,
    }
  )
}
const y3 = /* @__PURE__ */ Nn(0)
function Ey(e) {
  const t = Yt(e)
  return !Yd() || !t.visualViewport
    ? y3
    : {
        x: t.visualViewport.offsetLeft,
        y: t.visualViewport.offsetTop,
      }
}
function b3(e, t, n) {
  return t === void 0 && (t = !1), !n || (t && n !== Yt(e)) ? !1 : t
}
function _o(e, t, n, o) {
  t === void 0 && (t = !1), n === void 0 && (n = !1)
  const r = e.getBoundingClientRect(),
    i = Hd(e)
  let s = Nn(1)
  t && (o ? gn(o) && (s = br(o)) : (s = br(e)))
  const a = b3(i, n, o) ? Ey(i) : Nn(0)
  let l = (r.left + a.x) / s.x,
    c = (r.top + a.y) / s.y,
    u = r.width / s.x,
    d = r.height / s.y
  if (i) {
    const f = Yt(i),
      A = o && gn(o) ? Yt(o) : o
    let h = f,
      g = Pu(h)
    for (; g && o && A !== h; ) {
      const x = br(g),
        m = g.getBoundingClientRect(),
        v = mn(g),
        y = m.left + (g.clientLeft + parseFloat(v.paddingLeft)) * x.x,
        b = m.top + (g.clientTop + parseFloat(v.paddingTop)) * x.y
      ;(l *= x.x), (c *= x.y), (u *= x.x), (d *= x.y), (l += y), (c += b), (h = Yt(g)), (g = Pu(h))
    }
  }
  return Sa({
    width: u,
    height: d,
    x: l,
    y: c,
  })
}
function Ud(e, t) {
  const n = Hl(e).scrollLeft
  return t ? t.left + n : _o(Tn(e)).left + n
}
function Sy(e, t, n) {
  n === void 0 && (n = !1)
  const o = e.getBoundingClientRect(),
    r =
      o.left +
      t.scrollLeft -
      (n
        ? 0
        : // RTL <body> scrollbar.
          Ud(e, o)),
    i = o.top + t.scrollTop
  return {
    x: r,
    y: i,
  }
}
function v3(e) {
  let { elements: t, rect: n, offsetParent: o, strategy: r } = e
  const i = r === 'fixed',
    s = Tn(o),
    a = t ? Yl(t.floating) : !1
  if (o === s || (a && i)) return n
  let l = {
      scrollLeft: 0,
      scrollTop: 0,
    },
    c = Nn(1)
  const u = Nn(0),
    d = Ln(o)
  if ((d || (!d && !i)) && ((Kr(o) !== 'body' || us(s)) && (l = Hl(o)), Ln(o))) {
    const A = _o(o)
    ;(c = br(o)), (u.x = A.x + o.clientLeft), (u.y = A.y + o.clientTop)
  }
  const f = s && !d && !i ? Sy(s, l, !0) : Nn(0)
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + f.y,
  }
}
function x3(e) {
  return Array.from(e.getClientRects())
}
function C3(e) {
  const t = Tn(e),
    n = Hl(e),
    o = e.ownerDocument.body,
    r = Go(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth),
    i = Go(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight)
  let s = -n.scrollLeft + Ud(e)
  const a = -n.scrollTop
  return (
    mn(o).direction === 'rtl' && (s += Go(t.clientWidth, o.clientWidth) - r),
    {
      width: r,
      height: i,
      x: s,
      y: a,
    }
  )
}
function w3(e, t) {
  const n = Yt(e),
    o = Tn(e),
    r = n.visualViewport
  let i = o.clientWidth,
    s = o.clientHeight,
    a = 0,
    l = 0
  if (r) {
    ;(i = r.width), (s = r.height)
    const c = Yd()
    ;(!c || (c && t === 'fixed')) && ((a = r.offsetLeft), (l = r.offsetTop))
  }
  return {
    width: i,
    height: s,
    x: a,
    y: l,
  }
}
function E3(e, t) {
  const n = _o(e, !0, t === 'fixed'),
    o = n.top + e.clientTop,
    r = n.left + e.clientLeft,
    i = Ln(e) ? br(e) : Nn(1),
    s = e.clientWidth * i.x,
    a = e.clientHeight * i.y,
    l = r * i.x,
    c = o * i.y
  return {
    width: s,
    height: a,
    x: l,
    y: c,
  }
}
function Np(e, t, n) {
  let o
  if (t === 'viewport') o = w3(e, n)
  else if (t === 'document') o = C3(Tn(e))
  else if (gn(t)) o = E3(t, n)
  else {
    const r = Ey(e)
    o = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height,
    }
  }
  return Sa(o)
}
function By(e, t) {
  const n = Ao(e)
  return n === t || !gn(n) || zr(n) ? !1 : mn(n).position === 'fixed' || By(n, t)
}
function S3(e, t) {
  const n = t.get(e)
  if (n) return n
  let o = Yi(e, [], !1).filter(a => gn(a) && Kr(a) !== 'body'),
    r = null
  const i = mn(e).position === 'fixed'
  let s = i ? Ao(e) : e
  for (; gn(s) && !zr(s); ) {
    const a = mn(s),
      l = Xd(s)
    !l && a.position === 'fixed' && (r = null), (i ? !l && !r : (!l && a.position === 'static' && !!r && ['absolute', 'fixed'].includes(r.position)) || (us(s) && !l && By(e, s))) ? (o = o.filter(u => u !== s)) : (r = a), (s = Ao(s))
  }
  return t.set(e, o), o
}
function B3(e) {
  let { element: t, boundary: n, rootBoundary: o, strategy: r } = e
  const s = [...(n === 'clippingAncestors' ? (Yl(t) ? [] : S3(t, this._c)) : [].concat(n)), o],
    a = s[0],
    l = s.reduce((c, u) => {
      const d = Np(t, u, r)
      return (c.top = Go(d.top, c.top)), (c.right = Ca(d.right, c.right)), (c.bottom = Ca(d.bottom, c.bottom)), (c.left = Go(d.left, c.left)), c
    }, Np(t, a, r))
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top,
  }
}
function I3(e) {
  const { width: t, height: n } = wy(e)
  return {
    width: t,
    height: n,
  }
}
function N3(e, t, n) {
  const o = Ln(t),
    r = Tn(t),
    i = n === 'fixed',
    s = _o(e, !0, i, t)
  let a = {
    scrollLeft: 0,
    scrollTop: 0,
  }
  const l = Nn(0)
  if (o || (!o && !i))
    if (((Kr(t) !== 'body' || us(r)) && (a = Hl(t)), o)) {
      const f = _o(t, !0, i, t)
      ;(l.x = f.x + t.clientLeft), (l.y = f.y + t.clientTop)
    } else r && (l.x = Ud(r))
  const c = r && !o && !i ? Sy(r, a) : Nn(0),
    u = s.left + a.scrollLeft - l.x - c.x,
    d = s.top + a.scrollTop - l.y - c.y
  return {
    x: u,
    y: d,
    width: s.width,
    height: s.height,
  }
}
function Ic(e) {
  return mn(e).position === 'static'
}
function kp(e, t) {
  if (!Ln(e) || mn(e).position === 'fixed') return null
  if (t) return t(e)
  let n = e.offsetParent
  return Tn(e) === n && (n = n.ownerDocument.body), n
}
function Iy(e, t) {
  const n = Yt(e)
  if (Yl(e)) return n
  if (!Ln(e)) {
    let r = Ao(e)
    for (; r && !zr(r); ) {
      if (gn(r) && !Ic(r)) return r
      r = Ao(r)
    }
    return n
  }
  let o = kp(e, t)
  for (; o && g3(o) && Ic(o); ) o = kp(o, t)
  return o && zr(o) && Ic(o) && !Xd(o) ? n : o || m3(e) || n
}
const k3 = async function (e) {
  const t = this.getOffsetParent || Iy,
    n = this.getDimensions,
    o = await n(e.floating)
  return {
    reference: N3(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height,
    },
  }
}
function M3(e) {
  return mn(e).direction === 'rtl'
}
const P3 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: v3,
  getDocumentElement: Tn,
  getClippingRect: B3,
  getOffsetParent: Iy,
  getElementRects: k3,
  getClientRects: x3,
  getDimensions: I3,
  getScale: br,
  isElement: gn,
  isRTL: M3,
}
function L3(e, t) {
  let n = null,
    o
  const r = Tn(e)
  function i() {
    var a
    clearTimeout(o), (a = n) == null || a.disconnect(), (n = null)
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), i()
    const { left: c, top: u, width: d, height: f } = e.getBoundingClientRect()
    if ((a || t(), !d || !f)) return
    const A = Ls(u),
      h = Ls(r.clientWidth - (c + d)),
      g = Ls(r.clientHeight - (u + f)),
      x = Ls(c),
      v = {
        rootMargin: -A + 'px ' + -h + 'px ' + -g + 'px ' + -x + 'px',
        threshold: Go(0, Ca(1, l)) || 1,
      }
    let y = !0
    function b(C) {
      const I = C[0].intersectionRatio
      if (I !== l) {
        if (!y) return s()
        I
          ? s(!1, I)
          : (o = setTimeout(() => {
              s(!1, 1e-7)
            }, 1e3))
      }
      y = !1
    }
    try {
      n = new IntersectionObserver(b, {
        ...v,
        // Handle <iframe>s
        root: r.ownerDocument,
      })
    } catch {
      n = new IntersectionObserver(b, v)
    }
    n.observe(e)
  }
  return s(!0), i
}
function Mp(e, t, n, o) {
  o === void 0 && (o = {})
  const { ancestorScroll: r = !0, ancestorResize: i = !0, elementResize: s = typeof ResizeObserver == 'function', layoutShift: a = typeof IntersectionObserver == 'function', animationFrame: l = !1 } = o,
    c = Hd(e),
    u = r || i ? [...(c ? Yi(c) : []), ...Yi(t)] : []
  u.forEach(m => {
    r &&
      m.addEventListener('scroll', n, {
        passive: !0,
      }),
      i && m.addEventListener('resize', n)
  })
  const d = c && a ? L3(c, n) : null
  let f = -1,
    A = null
  s &&
    ((A = new ResizeObserver(m => {
      let [v] = m
      v &&
        v.target === c &&
        A &&
        (A.unobserve(t),
        cancelAnimationFrame(f),
        (f = requestAnimationFrame(() => {
          var y
          ;(y = A) == null || y.observe(t)
        }))),
        n()
    })),
    c && !l && A.observe(c),
    A.observe(t))
  let h,
    g = l ? _o(e) : null
  l && x()
  function x() {
    const m = _o(e)
    g && (m.x !== g.x || m.y !== g.y || m.width !== g.width || m.height !== g.height) && n(), (g = m), (h = requestAnimationFrame(x))
  }
  return (
    n(),
    () => {
      var m
      u.forEach(v => {
        r && v.removeEventListener('scroll', n), i && v.removeEventListener('resize', n)
      }),
        d == null || d(),
        (m = A) == null || m.disconnect(),
        (A = null),
        l && cancelAnimationFrame(h)
    }
  )
}
const R3 = p3,
  T3 = h3,
  F3 = f3,
  D3 = (e, t, n) => {
    const o = /* @__PURE__ */ new Map(),
      r = {
        platform: P3,
        ...n,
      },
      i = {
        ...r.platform,
        _c: o,
      }
    return d3(e, t, {
      ...r,
      platform: i,
    })
  }
var $s = typeof document < 'u' ? Ma : Ce
function Ba(e, t) {
  if (e === t) return !0
  if (typeof e != typeof t) return !1
  if (typeof e == 'function' && e.toString() === t.toString()) return !0
  let n, o, r
  if (e && t && typeof e == 'object') {
    if (Array.isArray(e)) {
      if (((n = e.length), n !== t.length)) return !1
      for (o = n; o-- !== 0; ) if (!Ba(e[o], t[o])) return !1
      return !0
    }
    if (((r = Object.keys(e)), (n = r.length), n !== Object.keys(t).length)) return !1
    for (o = n; o-- !== 0; ) if (!{}.hasOwnProperty.call(t, r[o])) return !1
    for (o = n; o-- !== 0; ) {
      const i = r[o]
      if (!(i === '_owner' && e.$$typeof) && !Ba(e[i], t[i])) return !1
    }
    return !0
  }
  return e !== e && t !== t
}
function Ny(e) {
  return typeof window > 'u' ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function Pp(e, t) {
  const n = Ny(e)
  return Math.round(t * n) / n
}
function Nc(e) {
  const t = N.useRef(e)
  return (
    $s(() => {
      t.current = e
    }),
    t
  )
}
function z3(e) {
  e === void 0 && (e = {})
  const { placement: t = 'bottom', strategy: n = 'absolute', middleware: o = [], platform: r, elements: { reference: i, floating: s } = {}, transform: a = !0, whileElementsMounted: l, open: c } = e,
    [u, d] = N.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1,
    }),
    [f, A] = N.useState(o)
  Ba(f, o) || A(o)
  const [h, g] = N.useState(null),
    [x, m] = N.useState(null),
    v = N.useCallback(S => {
      S !== I.current && ((I.current = S), g(S))
    }, []),
    y = N.useCallback(S => {
      S !== w.current && ((w.current = S), m(S))
    }, []),
    b = i || h,
    C = s || x,
    I = N.useRef(null),
    w = N.useRef(null),
    M = N.useRef(u),
    L = l != null,
    R = Nc(l),
    T = Nc(r),
    D = Nc(c),
    z = N.useCallback(() => {
      if (!I.current || !w.current) return
      const S = {
        placement: t,
        strategy: n,
        middleware: f,
      }
      T.current && (S.platform = T.current),
        D3(I.current, w.current, S).then(Q => {
          const j = {
            ...Q,
            // The floating element's position may be recomputed while it's closed
            // but still mounted (such as when transitioning out). To ensure
            // `isPositioned` will be `false` initially on the next open, avoid
            // setting it to `true` when `open === false` (must be specified).
            isPositioned: D.current !== !1,
          }
          E.current &&
            !Ba(M.current, j) &&
            ((M.current = j),
            zu.flushSync(() => {
              d(j)
            }))
        })
    }, [f, t, n, T, D])
  $s(() => {
    c === !1 &&
      M.current.isPositioned &&
      ((M.current.isPositioned = !1),
      d(S => ({
        ...S,
        isPositioned: !1,
      })))
  }, [c])
  const E = N.useRef(!1)
  $s(
    () => (
      (E.current = !0),
      () => {
        E.current = !1
      }
    ),
    []
  ),
    $s(() => {
      if ((b && (I.current = b), C && (w.current = C), b && C)) {
        if (R.current) return R.current(b, C, z)
        z()
      }
    }, [b, C, z, R, L])
  const P = N.useMemo(
      () => ({
        reference: I,
        floating: w,
        setReference: v,
        setFloating: y,
      }),
      [v, y]
    ),
    B = N.useMemo(
      () => ({
        reference: b,
        floating: C,
      }),
      [b, C]
    ),
    F = N.useMemo(() => {
      const S = {
        position: n,
        left: 0,
        top: 0,
      }
      if (!B.floating) return S
      const Q = Pp(B.floating, u.x),
        j = Pp(B.floating, u.y)
      return a
        ? {
            ...S,
            transform: 'translate(' + Q + 'px, ' + j + 'px)',
            ...(Ny(B.floating) >= 1.5 && {
              willChange: 'transform',
            }),
          }
        : {
            position: n,
            left: Q,
            top: j,
          }
    }, [n, a, B.floating, u.x, u.y])
  return N.useMemo(
    () => ({
      ...u,
      update: z,
      refs: P,
      elements: B,
      floatingStyles: F,
    }),
    [u, z, P, B, F]
  )
}
const Lp = (e, t) => ({
    ...R3(e),
    options: [e, t],
  }),
  Q3 = (e, t) => ({
    ...T3(e),
    options: [e, t],
  }),
  O3 = (e, t) => ({
    ...F3(e),
    options: [e, t],
  })
function j3(e) {
  return typeof e == 'function' ? e() : e
}
const W3 = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const { children: o, container: r, disablePortal: i = !1 } = t,
      [s, a] = N.useState(null),
      l = Wl(qF(o), n)
    if (
      (Nu(() => {
        i || a(j3(r) || document.body)
      }, [r, i]),
      Nu(() => {
        if (s && !i)
          return (
            Iu(n, s),
            () => {
              Iu(n, null)
            }
          )
      }, [n, s, i]),
      i)
    ) {
      if (/* @__PURE__ */ N.isValidElement(o)) {
        const c = {
          ref: l,
        }
        return /* @__PURE__ */ N.cloneElement(o, c)
      }
      return /* @__PURE__ */ p.jsx(N.Fragment, {
        children: o,
      })
    }
    return /* @__PURE__ */ p.jsx(N.Fragment, {
      children: s && /* @__PURE__ */ zu.createPortal(o, s),
    })
  }),
  ky = 'Popup'
function G3(e) {
  return Vd(ky, e)
}
gy(ky, ['root', 'open'])
const V3 = /* @__PURE__ */ N.createContext(null)
function X3(e) {
  const [t, n] = N.useState(!0),
    o = N.useRef(!1),
    r = N.useRef(0),
    [i, s] = N.useState(!1),
    a = N.useRef(e)
  N.useEffect(() => {
    !e && // checking registeredTransitions.current instead of hasTransition to avoid this effect re-firing whenever hasTransition changes
      r.current > 0 && // prevents waiting for a pending transition right after mounting
      a.current !== e &&
      ((o.current = !0), n(!1)),
      (a.current = e)
  }, [e])
  const l = N.useCallback(() => {
      ;(o.current = !1), n(!0)
    }, []),
    c = N.useCallback(
      () => (
        (r.current += 1),
        s(!0),
        () => {
          ;(r.current -= 1), r.current === 0 && s(!1)
        }
      ),
      []
    )
  let u
  return (
    i ? (e ? (u = !1) : (u = !o.current && t)) : (u = !e),
    {
      contextValue: N.useMemo(
        () => ({
          requestedEnter: e,
          onExited: l,
          registerTransition: c,
          hasExited: u,
        }),
        [l, e, c, u]
      ),
      hasExited: u,
    }
  )
}
const Y3 = /* @__PURE__ */ N.createContext(null)
function H3(e) {
  const { open: t } = e
  return py(
    {
      root: ['root', t && 'open'],
    },
    Ay(G3)
  )
}
function U3(e) {
  return typeof e == 'function' ? e() : e
}
const K3 = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const { anchor: o, children: r, container: i, disablePortal: s = !1, keepMounted: a = !1, middleware: l, offset: c = 0, open: u = !1, placement: d = 'bottom', slotProps: f = {}, slots: A = {}, strategy: h = 'absolute', ...g } = t,
      {
        refs: x,
        elements: m,
        floatingStyles: v,
        update: y,
        placement: b,
      } = z3({
        elements: {
          reference: U3(o),
        },
        open: u,
        middleware: l ?? [Lp(c ?? 0), O3(), Q3()],
        placement: d,
        strategy: h,
        whileElementsMounted: a ? void 0 : Mp,
      }),
      C = Wl(x.setFloating, n)
    Nu(() => {
      if (a && u && m.reference && m.floating) return Mp(m.reference, m.floating, y)
    }, [a, u, m, y])
    const I = {
        ...t,
        disablePortal: s,
        keepMounted: a,
        offset: Lp,
        open: u,
        placement: d,
        finalPlacement: b,
        strategy: h,
      },
      { contextValue: w, hasExited: M } = X3(u),
      L = a && M ? 'hidden' : void 0,
      R = H3(I),
      T = (A == null ? void 0 : A.root) ?? 'div',
      D = mi({
        elementType: T,
        externalSlotProps: f.root,
        externalForwardedProps: g,
        ownerState: I,
        className: R.root,
        additionalProps: {
          ref: C,
          role: 'tooltip',
          style: {
            ...v,
            visibility: L,
          },
        },
      }),
      z = N.useMemo(
        () => ({
          placement: b,
        }),
        [b]
      )
    return a || !M
      ? /* @__PURE__ */ p.jsx(W3, {
          disablePortal: s,
          container: i,
          children: /* @__PURE__ */ p.jsx(Y3.Provider, {
            value: z,
            children: /* @__PURE__ */ p.jsx(V3.Provider, {
              value: w,
              children: /* @__PURE__ */ p.jsx(T, {
                ...D,
                children: r,
              }),
            }),
          }),
        })
      : null
  }),
  My = 'NumberInput'
function q3(e) {
  return Vd(My, e)
}
const Lu = gy(My, ['root', 'formControl', 'focused', 'disabled', 'readOnly', 'error', 'input', 'incrementButton', 'decrementButton', 'adornedStart', 'adornedEnd']),
  Ct = {
    clamp: 'numberInput:clamp',
    inputChange: 'numberInput:inputChange',
    increment: 'numberInput:increment',
    decrement: 'numberInput:decrement',
    decrementToMin: 'numberInput:decrementToMin',
    incrementToMax: 'numberInput:incrementToMax',
    resetInputValue: 'numberInput:resetInputValue',
  }
function Z3(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER, o = NaN) {
  if (Number.isNaN(o)) return Sc(e, t, n)
  const r = o || 1,
    i = e % r,
    s = Math.sign(i)
  return Math.abs(i) > r / 2 ? Sc(e + s * (r - Math.abs(i)), t, n) : Sc(e - s * Math.abs(i), t, n)
}
function Ii(e) {
  return typeof e == 'number' && !Number.isNaN(e) && Number.isFinite(e)
}
function Py(e, t) {
  const { min: n, max: o, step: r } = t,
    i = e === null ? null : Z3(e, n, o, r),
    s = i === null ? '' : String(i)
  return {
    value: i,
    inputValue: s,
  }
}
function J3(e, t, n, o) {
  const { value: r } = e,
    { step: i = 1, min: s, max: a } = t
  return Ii(r)
    ? {
        up: r + (i ?? 1) * o,
        down: r - (i ?? 1) * o,
      }[n]
    : {
        up: s ?? 1,
        down: a ?? -1,
      }[n]
}
function _3(e, t, n) {
  const { getInputValueAsString: o } = t,
    r = o(n),
    i = r === '' || r === '-' ? null : parseInt(r, 10),
    s = Py(i, t)
  return {
    ...e,
    ...s,
  }
}
function $3(e, t, n) {
  const { getInputValueAsString: o } = t,
    r = o(n)
  return r.match(/^-?\d+?$/) || r === '' || r === '-'
    ? {
        ...e,
        inputValue: r,
      }
    : e
}
function Rp(e, t, n, o) {
  const r = n ? t.shiftMultiplier : 1,
    i = J3(e, t, o, r),
    s = Py(i, t)
  return {
    ...e,
    ...s,
  }
}
function Tp(e, t, n) {
  const o = t[n]
  return Ii(o)
    ? {
        ...e,
        value: o,
        inputValue: String(o),
      }
    : e
}
function eD(e, t) {
  const { type: n, context: o } = t
  switch (n) {
    case Ct.clamp:
      return _3(e, o, t.inputValue)
    case Ct.inputChange:
      return $3(e, o, t.inputValue)
    case Ct.increment:
      return Rp(e, o, t.applyMultiplier, 'up')
    case Ct.decrement:
      return Rp(e, o, t.applyMultiplier, 'down')
    case Ct.incrementToMax:
      return Tp(e, o, 'max')
    case Ct.decrementToMin:
      return Tp(e, o, 'min')
    case Ct.resetInputValue:
      return {
        ...e,
        inputValue: String(e.value),
      }
    default:
      return e
  }
}
const tD = ['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown'],
  nD = [...tD, 'Home', 'End']
function oD(e) {
  return String(e && e.trim())
}
function rD(e) {
  const { min: t, max: n, step: o, shiftMultiplier: r = 10, defaultValue: i, disabled: s = !1, error: a = !1, onBlur: l, onInputChange: c, onFocus: u, onChange: d, required: f = !1, readOnly: A = !1, value: h, inputRef: g, inputId: x, componentName: m = 'useNumberInput' } = e,
    v = n3(),
    { current: y } = N.useRef(h != null),
    b = N.useCallback(Y => {}, []),
    C = N.useRef(null),
    I = Wl(C, g, b),
    w = UF(x),
    [M, L] = N.useState(!1),
    R = N.useCallback(
      (Y, H, ee, xe) => {
        if (H === 'value' && typeof ee != 'string')
          switch (xe) {
            case 'numberInput:clamp':
              d == null || d(Y, ee)
              break
            case 'numberInput:increment':
            case 'numberInput:decrement':
            case 'numberInput:incrementToMax':
            case 'numberInput:decrementToMin':
              d == null || d(Y, ee)
              break
          }
      },
      [d]
    ),
    T = N.useMemo(
      () => ({
        min: t,
        max: n,
        step: o,
        shiftMultiplier: r,
        getInputValueAsString: oD,
      }),
      [t, n, o, r]
    ),
    D = h ?? i ?? null,
    z = {
      value: D,
      inputValue: D ? String(D) : '',
    },
    E = N.useMemo(
      () => ({
        value: h,
      }),
      [h]
    ),
    [P, B] = e3({
      reducer: eD,
      controlledProps: E,
      initialState: z,
      onStateChange: R,
      actionContext: N.useMemo(() => T, [T]),
      componentName: m,
    }),
    { value: F, inputValue: S } = P
  N.useEffect(() => {
    !v && s && M && (L(!1), l == null || l())
  }, [v, s, M, l]),
    N.useEffect(() => {
      y &&
        Ii(F) &&
        B({
          type: Ct.resetInputValue,
        })
    }, [F, B, y])
  const Q = Y => H => {
      var ee, xe
      ;(ee = Y.onFocus) == null || ee.call(Y, H), !(H.defaultMuiPrevented || H.defaultPrevented) && (v && v.onFocus && ((xe = v == null ? void 0 : v.onFocus) == null || xe.call(v)), L(!0))
    },
    j = Y => H => {
      var ee, xe
      if (!y && H.target === null) throw new Error(YF(17))
      ;(ee = v == null ? void 0 : v.onChange) == null || ee.call(v, H),
        (xe = Y.onInputChange) == null || xe.call(Y, H),
        !(H.defaultMuiPrevented || H.defaultPrevented) &&
          B({
            type: Ct.inputChange,
            event: H,
            inputValue: H.currentTarget.value,
          })
    },
    U = Y => H => {
      var ee
      v == null || v.onBlur(),
        (ee = Y.onBlur) == null || ee.call(Y, H),
        !(H.defaultMuiPrevented || H.defaultPrevented) &&
          (B({
            type: Ct.clamp,
            event: H,
            inputValue: H.currentTarget.value,
          }),
          L(!1))
    },
    q = Y => H => {
      var ee
      ;(ee = Y.onClick) == null || ee.call(Y, H), !(H.defaultMuiPrevented || H.defaultPrevented) && C.current && H.currentTarget === H.target && C.current.focus()
    },
    ne = Y => H => {
      const ee = !!H.shiftKey,
        xe = {
          up: Ct.increment,
          down: Ct.decrement,
        }[Y]
      B({
        type: xe,
        event: H,
        applyMultiplier: ee,
      })
    },
    G = Y => H => {
      var ee
      if (((ee = Y.onKeyDown) == null || ee.call(Y, H), !(H.defaultMuiPrevented || H.defaultPrevented)))
        switch ((nD.includes(H.key) && H.preventDefault(), H.key)) {
          case 'ArrowUp':
            B({
              type: Ct.increment,
              event: H,
              applyMultiplier: !!H.shiftKey,
            })
            break
          case 'ArrowDown':
            B({
              type: Ct.decrement,
              event: H,
              applyMultiplier: !!H.shiftKey,
            })
            break
          case 'PageUp':
            B({
              type: Ct.increment,
              event: H,
              applyMultiplier: !0,
            })
            break
          case 'PageDown':
            B({
              type: Ct.decrement,
              event: H,
              applyMultiplier: !0,
            })
            break
          case 'Home':
            B({
              type: Ct.incrementToMax,
              event: H,
            })
            break
          case 'End':
            B({
              type: Ct.decrementToMin,
              event: H,
            })
            break
        }
    },
    K = (Y = {}) => {
      const ee = {
        ..._s(e, [
          // these are handled by the input slot
          'onBlur',
          'onInputChange',
          'onFocus',
          'onChange',
        ]),
        ..._s(Y),
      }
      return {
        ...Y,
        ...ee,
        onClick: q(ee),
      }
    },
    $ = (Y = {}) => {
      const ee = {
          ...{
            onBlur: l,
            onFocus: u,
            // onChange from normal props is the custom onChange so we ignore it here
            onChange: c,
          },
          ..._s(Y, [
            // onClick is handled by the root slot
            'onClick',
            // do not ignore 'onInputChange', we want slotProps.input.onInputChange to enter the DOM and throw
          ]),
        },
        xe = {
          ...ee,
          onFocus: Q(ee),
          // slotProps.onChange is renamed to onInputChange and passed to createHandleInputChange
          onChange: j({
            ...ee,
            onInputChange: ee.onChange,
          }),
          onBlur: U(ee),
          onKeyDown: G(ee),
        },
        Fe = (M ? S : F) ?? ''
      return (
        delete Y.onInputChange,
        {
          type: 'text',
          id: w,
          'aria-invalid': a || void 0,
          defaultValue: void 0,
          value: Fe,
          'aria-valuenow': Fe,
          'aria-valuetext': String(Fe),
          'aria-valuemin': t,
          'aria-valuemax': n,
          autoComplete: 'off',
          autoCorrect: 'off',
          spellCheck: 'false',
          required: f,
          readOnly: A,
          'aria-disabled': s,
          disabled: s,
          ...Y,
          ref: I,
          ...xe,
        }
      )
    },
    oe = Y => {
      Y.preventDefault(), C.current && C.current.focus()
    },
    Z = {
      'aria-controls': w,
      tabIndex: -1,
    },
    ie = s || (Ii(F) ? F >= (n ?? Number.MAX_SAFE_INTEGER) : !1),
    fe = (Y = {}) => ({
      ...Y,
      ...Z,
      disabled: ie,
      'aria-disabled': ie,
      onMouseDown: oe,
      onClick: ne('up'),
    }),
    se = s || (Ii(F) ? F <= (t ?? Number.MIN_SAFE_INTEGER) : !1)
  return {
    disabled: s,
    error: a,
    focused: M,
    formControlContext: v,
    getInputProps: $,
    getIncrementButtonProps: fe,
    getDecrementButtonProps: (Y = {}) => ({
      ...Y,
      ...Z,
      disabled: se,
      'aria-disabled': se,
      onMouseDown: oe,
      onClick: ne('down'),
    }),
    getRootProps: K,
    required: f,
    value: F,
    inputValue: S,
    isIncrementDisabled: ie,
    isDecrementDisabled: se,
  }
}
const iD = e => {
    const { disabled: t, error: n, focused: o, readOnly: r, formControlContext: i, isIncrementDisabled: s, isDecrementDisabled: a, startAdornment: l, endAdornment: c } = e
    return py(
      {
        root: ['root', t && 'disabled', n && 'error', o && 'focused', r && 'readOnly', !!i && 'formControl', !!l && 'adornedStart', !!c && 'adornedEnd'],
        input: ['input', t && 'disabled', r && 'readOnly'],
        incrementButton: ['incrementButton', s && 'disabled'],
        decrementButton: ['decrementButton', a && 'disabled'],
      },
      Ay(q3)
    )
  },
  sD = /* @__PURE__ */ N.forwardRef(function (t, n) {
    const { className: o, defaultValue: r, disabled: i, endAdornment: s, error: a, id: l, max: c, min: u, onBlur: d, onInputChange: f, onFocus: A, onChange: h, placeholder: g, required: x, readOnly: m = !1, shiftMultiplier: v, startAdornment: y, step: b, value: C, slotProps: I = {}, slots: w = {}, ...M } = t,
      {
        getRootProps: L,
        getInputProps: R,
        getIncrementButtonProps: T,
        getDecrementButtonProps: D,
        focused: z,
        error: E,
        disabled: P,
        formControlContext: B,
        isIncrementDisabled: F,
        isDecrementDisabled: S,
      } = rD({
        min: u,
        max: c,
        step: b,
        shiftMultiplier: v,
        defaultValue: r,
        disabled: i,
        error: a,
        onFocus: A,
        onInputChange: f,
        onBlur: d,
        onChange: h,
        required: x,
        readOnly: m,
        value: C,
        inputId: l,
        componentName: 'NumberInput',
      }),
      Q = {
        ...t,
        disabled: P,
        error: E,
        focused: z,
        readOnly: m,
        formControlContext: B,
        isIncrementDisabled: F,
        isDecrementDisabled: S,
      },
      j = iD(Q),
      U = {
        placeholder: g,
      },
      q = w.root ?? 'div',
      ne = mi({
        elementType: q,
        getSlotProps: L,
        externalSlotProps: I.root,
        externalForwardedProps: M,
        additionalProps: {
          ref: n,
        },
        ownerState: Q,
        className: [j.root, o],
      }),
      G = w.input ?? 'input',
      K = mi({
        elementType: G,
        getSlotProps: fe =>
          R({
            ...U,
            ...fe,
          }),
        externalSlotProps: I.input,
        ownerState: Q,
        className: j.input,
      }),
      $ = w.incrementButton ?? 'button',
      oe = mi({
        elementType: $,
        getSlotProps: T,
        externalSlotProps: I.incrementButton,
        ownerState: Q,
        className: j.incrementButton,
      }),
      Z = w.decrementButton ?? 'button',
      ie = mi({
        elementType: Z,
        getSlotProps: D,
        externalSlotProps: I.decrementButton,
        ownerState: Q,
        className: j.decrementButton,
      })
    return /* @__PURE__ */ p.jsxs(q, {
      ...ne,
      children: [
        /* @__PURE__ */ p.jsx(Z, {
          ...ie,
        }),
        /* @__PURE__ */ p.jsx($, {
          ...oe,
        }),
        y,
        /* @__PURE__ */ p.jsx(G, {
          ...K,
        }),
        s,
      ],
    })
  }),
  aD = e => /* @__PURE__ */ p.jsx(K3, { ...e }),
  kc = {
    50: '#F3F6F9',
    100: '#E5EAF2',
    200: '#DAE2ED',
    300: '#C7D0DD',
    400: '#B0B8C4',
    500: '#9DA8B7',
    600: '#6B7A90',
    700: '#434D5B',
    800: '#303740',
    900: '#1C2025',
  },
  lD = O('div')(
    ({ theme: e }) => `
  width: max-content;
  padding: 12px 16px;
  margin: 8px;
  border-radius: 8px;
  border: 1px solid ${e.palette.mode === 'dark' ? kc[700] : kc[200]};
  background-color: ${e.palette.mode === 'dark' ? kc[900] : '#fff'};
  box-shadow: ${e.palette.mode === 'dark' ? '0px 4px 8px rgb(0 0 0 / 0.7)' : '0px 4px 8px rgb(0 0 0 / 0.1)'};
  font-family: 'IBM Plex Sans', sans-serif;
  font-size: 0.875rem;
  z-index: 1;
`
  ),
  cD = e => /* @__PURE__ */ p.jsx(lD, { ...e }),
  li = O('div')`
  display: flex;
  gap: 8px;
`,
  ci = O('span')`
  font-weight: 600;
  font-size: 13px;
`,
  ui = O('span')`
  font-size: 13px;
`,
  uD = e => e,
  dD = 12,
  Ft = e =>
    uD(t => {
      const n = ho(),
        [o, r, i, s] = zl(),
        [a, l] = be([]),
        [c, u] = be(null),
        { changesEnabled: d, nodes: f, edges: A } = n,
        h = gF(),
        g = vF(t.id, {
          rotatable: d,
        }),
        x = CF(t.id),
        m = `popup-${t.id}`,
        v = () => {
          i()
        },
        y = () => {
          s()
        },
        b = t,
        C = !Ul(b),
        I = Ir(b),
        w = Qy(b),
        M = Oy(b),
        L = p6(b, f, A),
        R = jy(b),
        { data: T, ...D } = t,
        z = Pe(
          () => ({
            ...T,
            label: C ? h6(T.label, dD) : T.label,
          }),
          [t]
        )
      return /* @__PURE__ */ p.jsxs(p.Fragment, {
        children: [
          /* @__PURE__ */ p.jsx(e, {
            ...D,
            data: z,
            ...h,
            ...g,
            parentRotation: x,
            showPopup: o,
            setShowPopup: r,
            popupAnchor: c,
            setPopupAnchor: u,
            handleNodeBaseHover: v,
            handleNodeBaseMouseLeave: y,
            nodeColor: R,
            customPopupPoints: a,
            setCustomPopupPoints: l,
            flow: n,
          }),
          /* @__PURE__ */ p.jsx(aD, {
            id: m,
            anchor: c,
            open: o,
            placement: 'left',
            children: /* @__PURE__ */ p.jsxs(cD, {
              children: [
                C && /* @__PURE__ */ p.jsxs(li, { children: [/* @__PURE__ */ p.jsx(ci, { children: 'Name:' }), /* @__PURE__ */ p.jsx(ui, { children: I })] }),
                /* @__PURE__ */ p.jsxs(li, { children: [/* @__PURE__ */ p.jsx(ci, { children: 'Class:' }), /* @__PURE__ */ p.jsx(ui, { children: KO[w] })] }),
                M && /* @__PURE__ */ p.jsxs(li, { children: [/* @__PURE__ */ p.jsx(ci, { children: 'Class Code:' }), /* @__PURE__ */ p.jsx(ui, { children: Zd[M] })] }),
                L && /* @__PURE__ */ p.jsxs(li, { children: [/* @__PURE__ */ p.jsx(ci, { children: 'Closest Parent:' }), /* @__PURE__ */ p.jsx(ui, { children: Ir(L) })] }),
                a.map(E => /* @__PURE__ */ p.jsxs(li, { children: [/* @__PURE__ */ p.jsx(ci, { children: E.label }), /* @__PURE__ */ p.jsx(ui, { children: E.value })] }, E.value)),
              ],
            }),
          }),
        ],
      })
    }),
  fD = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s)
    return /* @__PURE__ */ p.jsxs(sT, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [/* @__PURE__ */ p.jsx(Xe, { type: 'target', position: t }), /* @__PURE__ */ p.jsx(iT, { children: e.label }), /* @__PURE__ */ p.jsx(Xe, { type: 'source', position: o })],
    })
  }),
  AD = Te(fD),
  pD = O('div')`
  padding: 4px 4px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
`,
  hD = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: 100%;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`,
  gD = Ft(({ data: e, parentRotation: t, handleNodeBaseHover: n, handleNodeBaseMouseLeave: o, setPopupAnchor: r, nodeColor: i }) => {
    const s = Mt(r)
    return /* @__PURE__ */ p.jsx(hD, {
      ref: s,
      rotation: t ?? 0,
      onMouseEnter: n,
      onMouseLeave: o,
      ...i,
      children: /* @__PURE__ */ p.jsx(pD, { children: e.label }),
    })
  }),
  mD = Te(gD),
  yD = O('div')`
  position: relative;
  padding: 16px 48px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
`,
  bD = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: 100%;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const vD = O('p')`
  margin: 0;
`,
  xD = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      { src: c, alt: u, width: d, height: f } = e.image,
      A = e.code
    return /* @__PURE__ */ p.jsxs(bD, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [/* @__PURE__ */ p.jsx(Xe, { type: 'target', position: t }), /* @__PURE__ */ p.jsxs(yD, { children: [/* @__PURE__ */ p.jsx('img', { src: c, alt: u, width: d, height: f }), /* @__PURE__ */ p.jsx(vD, { children: A })] }), /* @__PURE__ */ p.jsx(Xe, { type: 'source', position: o })],
    })
  }),
  CD = Te(xD),
  wD = O('div')`
  position: relative;
  padding: 4px 4px;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
`,
  ED = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: 100%;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('p')`
  margin: 0;
  position: absolute;
  left: 4px;
  bottom: 2px;
`
const SD = Ft(({ data: e, parentRotation: t, nodeColor: n }) => {
    const { src: o, alt: r, width: i, height: s } = e.image
    return /* @__PURE__ */ p.jsx(ED, { rotation: t ?? 0, ...n, children: /* @__PURE__ */ p.jsx(wD, { children: /* @__PURE__ */ p.jsx('img', { src: o, alt: r, width: i, height: s }) }) })
  }),
  BD = Te(SD),
  ln = e => /* @__PURE__ */ p.jsx('img', { ...e }),
  ID = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  ND = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-top {
    left: ${Ze}px;
  }

  .react-flow__handle-bottom {
    left: ${Ze}px;
  }
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const kD = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  MD = O('div')`
  position: absolute;
  left: ${$n};
  top: 50%;
  transform: translateY(-50%);
`,
  PD = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  LD = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  RD = 'SWITCH',
  TD = qt[RD],
  { src: FD, alt: DD, width: zD, height: QD } = TD,
  OD = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.label,
      u = e.code
    return /* @__PURE__ */ p.jsxs(ND, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, { type: 'target', position: t }),
        /* @__PURE__ */ p.jsxs(ID, { children: [/* @__PURE__ */ p.jsx(kD, { src: FD, alt: DD, width: zD, height: QD }), /* @__PURE__ */ p.jsxs(MD, { children: [/* @__PURE__ */ p.jsx(PD, { children: c }), /* @__PURE__ */ p.jsx(LD, { children: u })] })] }),
        /* @__PURE__ */ p.jsx(Xe, { type: 'source', position: o }),
      ],
    })
  }),
  jD = Te(OD),
  WD = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  GD = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-top {
    left: ${Ze}px;
  }

  .react-flow__handle-bottom {
    left: ${Ze}px;
  }
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const VD = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  XD = O('div')`
  position: absolute;
  left: ${$n - 12}px;
  top: 50%;
  transform: translateY(-50%);
`,
  YD = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  HD = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  UD = 'CAPACITOR',
  KD = qt[UD],
  { src: qD, alt: ZD, width: JD, height: _D } = KD,
  $D = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.label,
      u = e.code
    return /* @__PURE__ */ p.jsxs(GD, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, { type: 'target', position: t }),
        /* @__PURE__ */ p.jsxs(WD, { children: [/* @__PURE__ */ p.jsx(VD, { src: qD, alt: ZD, width: JD, height: _D }), /* @__PURE__ */ p.jsxs(XD, { children: [/* @__PURE__ */ p.jsx(YD, { children: c }), /* @__PURE__ */ p.jsx(HD, { children: u })] })] }),
        /* @__PURE__ */ p.jsx(Xe, { type: 'source', position: o }),
      ],
    })
  }),
  ez = Te($D),
  tz = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an + 20}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  nz = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-top {
    left: ${Ze}px;
  }

  .react-flow__handle-bottom {
    left: ${Ze}px;
  }
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const oz = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  rz = O('div')`
  position: absolute;
  left: ${$n - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
  iz = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  sz = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  az = 'TRANSFORMER',
  lz = qt[az],
  { src: cz, alt: uz, width: dz, height: fz } = lz,
  Az = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.label,
      u = e.code
    return /* @__PURE__ */ p.jsxs(nz, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, { type: 'target', position: t }),
        /* @__PURE__ */ p.jsxs(tz, { children: [/* @__PURE__ */ p.jsx(oz, { src: cz, alt: uz, width: dz, height: fz }), /* @__PURE__ */ p.jsxs(rz, { children: [/* @__PURE__ */ p.jsx(iz, { children: c }), /* @__PURE__ */ p.jsx(sz, { children: u })] })] }),
        /* @__PURE__ */ p.jsx(Xe, { type: 'source', position: o }),
      ],
    })
  }),
  pz = Te(Az),
  hz = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an + 20}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  gz = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-bottom {
    left: ${Ze}px;
  }
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const mz = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  yz = O('div')`
  position: absolute;
  left: ${$n - 12}px;
  top: 50%;
  transform: translateY(-50%);
`,
  bz = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  vz = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  xz = At({
    left: 118.6,
    top: -2,
  }),
  Cz = At({
    left: 145.6,
    top: -2,
  }),
  wz = 'TRANSFER_SWITCH',
  Ez = qt[wz],
  { src: Sz, alt: Bz, width: Iz, height: Nz } = Ez,
  kz = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a, id: l }) => {
    const c = Mt(s),
      u = e.label,
      d = e.code
    return /* @__PURE__ */ p.jsxs(gz, {
      ref: c,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'target',
          position: t,
          style: xz,
          id: `${l}-left`,
        }),
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'target',
          position: t,
          style: Cz,
          id: `${l}-right`,
        }),
        /* @__PURE__ */ p.jsxs(hz, { children: [/* @__PURE__ */ p.jsx(mz, { src: Sz, alt: Bz, width: Iz, height: Nz }), /* @__PURE__ */ p.jsxs(yz, { children: [/* @__PURE__ */ p.jsx(bz, { children: u }), /* @__PURE__ */ p.jsx(vz, { children: d })] })] }),
        /* @__PURE__ */ p.jsx(Xe, { type: 'source', position: o }),
      ],
    })
  }),
  Mz = Te(kz),
  Fp = O('div')`
  position: relative;
  height: 60px;
  width: 100%;
  min-width: ${an}px;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  Dp = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const zp = O('div')`
  position: absolute;
  top: 4px;
  left: 6px;
`,
  Qp = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  Op = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  jp = O('div')`
  width: 100%;
  height: 4px;
  background: #000;
`,
  Pz = At({
    top: 'calc(50% - 4px)',
    zIndex: 1e5,
  }),
  Lz = At({
    opacity: 0,
    pointerEvents: 'none',
    left: 0,
    top: 23,
  }),
  Yn = e => {
    const { style: t, ...n } = e
    return /* @__PURE__ */ p.jsx(Xe, {
      ...n,
      style: { ...Lz, ...t },
    })
  },
  Rz = an,
  Wp = 1,
  Tz = 40,
  Fz = (e, { baseWidthPx: t = Rz } = {}) =>
    e <= Wp
      ? t
      : Array.from({ length: e - Wp })
          .fill(Tz)
          .reduce((n, o) => n + o, t),
  Dz = Ft(e => {
    const { data: t, rotation: n, handleNodeBaseHover: o, handleNodeBaseMouseLeave: r, setPopupAnchor: i, nodeColor: s, sourceHandlePosition: a, setCustomPopupPoints: l, flow: c, id: u } = e,
      [d] = be(an),
      { nodes: f } = c,
      A = Pe(() => ou({ id: u }, f), [f, u]),
      h = Pe(() => A.filter(w => w.data.archetype === et.lineSide), [A]),
      g = Pe(() => A.filter(w => w.data.archetype === et.loadSide), [A]),
      x = Math.max(h.length, g.length),
      m = Fz(x, {
        baseWidthPx: d,
      }),
      v = Mt(i),
      y = t.label,
      b = t.code,
      C = t.electricalPanelType
    return (
      Ce(() => {
        l([
          {
            label: 'Panel Type: ',
            value: C,
          },
        ])
      }, [C]),
      C === Vo.MLO
        ? /* @__PURE__ */ p.jsxs(Dp, {
            ref: v,
            rotation: n,
            onMouseEnter: o,
            onMouseLeave: r,
            ...s,
            children: [
              /* @__PURE__ */ p.jsx(Xe, {
                type: 'target',
                position: ye.Top,
                style: Pz,
              }),
              /* @__PURE__ */ p.jsxs(Fp, { style: { width: m }, children: [/* @__PURE__ */ p.jsxs(zp, { children: [/* @__PURE__ */ p.jsx(Qp, { children: y }), /* @__PURE__ */ p.jsx(Op, { children: b })] }), /* @__PURE__ */ p.jsx(jp, {})] }),
              /* @__PURE__ */ p.jsx(Yn, { position: a, type: 'source' }),
            ],
          })
        : /* @__PURE__ */ p.jsxs(Dp, {
            ref: v,
            rotation: n,
            onMouseEnter: o,
            onMouseLeave: r,
            ...s,
            children: [
              /* @__PURE__ */ p.jsx(Yn, {
                position: ye.Top,
                type: 'target',
                style: At({
                  left: '50%',
                  transform: 'translateX(-50%)',
                }),
              }),
              /* @__PURE__ */ p.jsxs(Fp, { style: { width: m }, children: [/* @__PURE__ */ p.jsxs(zp, { children: [/* @__PURE__ */ p.jsx(Qp, { children: y }), /* @__PURE__ */ p.jsx(Op, { children: b })] }), /* @__PURE__ */ p.jsx(jp, {})] }),
              /* @__PURE__ */ p.jsx(Yn, { position: a, type: 'source' }),
            ],
          })
    )
  }),
  zz = Te(Dz),
  Qz = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an + 12}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  Oz = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;

  .react-flow__handle-top {
    left: ${Ze}px;
  }

  .react-flow__handle-bottom {
    left: ${Ze}px;
  }
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const jz = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  Wz = O('div')`
  position: absolute;
  left: ${$n - 8}px;
  top: 50%;
  transform: translateY(-50%);
`,
  Gz = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  Vz = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  Xz = 'MISC',
  Yz = qt[Xz],
  { src: Hz, alt: Uz, width: Kz, height: qz } = Yz,
  Zz = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.label,
      u = e.code
    return /* @__PURE__ */ p.jsxs(Oz, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, { type: 'target', position: t }),
        /* @__PURE__ */ p.jsxs(Qz, { children: [/* @__PURE__ */ p.jsx(jz, { src: Hz, alt: Uz, width: Kz, height: qz }), /* @__PURE__ */ p.jsxs(Wz, { children: [/* @__PURE__ */ p.jsx(Gz, { children: c }), /* @__PURE__ */ p.jsx(Vz, { children: u })] })] }),
        /* @__PURE__ */ p.jsx(Xe, { type: 'source', position: o }),
      ],
    })
  }),
  Jz = Te(Zz),
  _z = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an + 32}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  $z = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const eQ = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  tQ = O('div')`
  position: absolute;
  left: ${$n - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
  nQ = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  oQ = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  rQ = At({
    left: Ze,
    top: -2,
  }),
  iQ = At({
    left: Ze,
    top: 55,
  }),
  sQ = 'MOTOR',
  aQ = qt[sQ],
  { src: lQ, alt: cQ, width: uQ, height: dQ } = aQ,
  fQ = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.label,
      u = e.code
    return /* @__PURE__ */ p.jsxs($z, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'target',
          position: t,
          style: rQ,
        }),
        /* @__PURE__ */ p.jsxs(_z, { children: [/* @__PURE__ */ p.jsx(eQ, { src: lQ, alt: cQ, width: uQ, height: dQ }), /* @__PURE__ */ p.jsxs(tQ, { children: [/* @__PURE__ */ p.jsx(nQ, { children: c }), /* @__PURE__ */ p.jsx(oQ, { children: u })] })] }),
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'source',
          position: o,
          style: iQ,
        }),
      ],
    })
  }),
  AQ = Te(fQ),
  pQ = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an + 32}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  hQ = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const gQ = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  mQ = O('div')`
  position: absolute;
  left: ${$n - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
  yQ = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  bQ = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  vQ = At({
    left: Ze,
    top: -2,
  }),
  xQ = At({
    left: Ze,
    top: 55,
  }),
  CQ = 'GENERATOR',
  wQ = qt[CQ],
  { src: EQ, alt: SQ, width: BQ, height: IQ } = wQ,
  NQ = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.label,
      u = e.code
    return /* @__PURE__ */ p.jsxs(hQ, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'target',
          position: t,
          style: vQ,
        }),
        /* @__PURE__ */ p.jsxs(pQ, { children: [/* @__PURE__ */ p.jsx(gQ, { src: EQ, alt: SQ, width: BQ, height: IQ }), /* @__PURE__ */ p.jsxs(mQ, { children: [/* @__PURE__ */ p.jsx(yQ, { children: c }), /* @__PURE__ */ p.jsx(bQ, { children: u })] })] }),
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'source',
          position: o,
          style: xQ,
        }),
      ],
    })
  }),
  kQ = Te(NQ),
  MQ = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an + 32}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  PQ = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const LQ = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  RQ = O('div')`
  position: absolute;
  left: ${$n - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
  TQ = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  FQ = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  DQ = At({
    left: Ze,
    top: -2,
  }),
  zQ = At({
    left: Ze,
    top: 55,
  }),
  QQ = 'RELAY',
  OQ = qt[QQ],
  { src: jQ, alt: WQ, width: GQ, height: VQ } = OQ,
  XQ = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.label,
      u = e.code
    return /* @__PURE__ */ p.jsxs(PQ, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'target',
          position: t,
          style: DQ,
        }),
        /* @__PURE__ */ p.jsxs(MQ, { children: [/* @__PURE__ */ p.jsx(LQ, { src: jQ, alt: WQ, width: GQ, height: VQ }), /* @__PURE__ */ p.jsxs(RQ, { children: [/* @__PURE__ */ p.jsx(TQ, { children: c }), /* @__PURE__ */ p.jsx(FQ, { children: u })] })] }),
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'source',
          position: o,
          style: zQ,
        }),
      ],
    })
  }),
  YQ = Te(XQ),
  HQ = O('div')`
  position: relative;
  height: 100%;
  width: 100%;
  min-width: ${an + 20}px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  font-family: 'Inter';
`,
  UQ = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const KQ = O(ln)`
  position: absolute;
  left: ${Ze}px;
  transform: translateX(-50%);
`,
  qQ = O('div')`
  position: absolute;
  left: ${$n - 24}px;
  top: 50%;
  transform: translateY(-50%);
`,
  ZQ = O('p')`
  font-weight: 700;
  font-size: 12px;
  line-height: 1.2423;
  margin: 0;
`,
  JQ = O('p')`
  font-style: italic;
  font-size: 6px;
  line-height: 1.1667;
  margin: 0;
`,
  _Q = At({
    left: Ze,
    top: -2,
  }),
  $Q = At({
    left: Ze,
    top: 55,
  }),
  eO = 'UPS_SYSTEM',
  tO = qt[eO],
  { src: nO, alt: oO, width: rO, height: iO } = tO,
  sO = Ft(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.label,
      u = e.code
    return /* @__PURE__ */ p.jsxs(UQ, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'target',
          position: t,
          style: _Q,
        }),
        /* @__PURE__ */ p.jsxs(HQ, { children: [/* @__PURE__ */ p.jsx(KQ, { src: nO, alt: oO, width: rO, height: iO }), /* @__PURE__ */ p.jsxs(qQ, { children: [/* @__PURE__ */ p.jsx(ZQ, { children: c }), /* @__PURE__ */ p.jsx(JQ, { children: u })] })] }),
        /* @__PURE__ */ p.jsx(Xe, {
          type: 'source',
          position: o,
          style: $Q,
        }),
      ],
    })
  }),
  aO = Te(sO),
  Kd = Ft,
  lO = O('div')`
  position: relative;
  height: ${Pn}px;
  width: ${Pn}px;
  display: flex;
  justify-content: center;
  align-items: center;
`,
  cO = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const uO = O(ln)`
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: ${e => (e.archetype === et.loadSide ? `${Pn}px` : '0')};
`,
  Gp = At({
    top: -2,
  }),
  Vp = At({
    top: 55,
  }),
  dO = O('p')`
  position: absolute;
  top: ${e => (e.lineSide ? '50%' : '164%')};
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8px;
  line-height: 1.14;
  margin: 0;
  min-width: 100px;
`,
  fO = 'SUB_SWITCH',
  AO = qt[fO],
  { src: pO, alt: hO, width: gO, height: mO } = AO,
  yO = Kd(e => {
    const { data: t, targetHandlePosition: n, rotation: o, sourceHandlePosition: r, handleNodeBaseHover: i, handleNodeBaseMouseLeave: s, setPopupAnchor: a, nodeColor: l } = e,
      c = Mt(a),
      u = t.archetype,
      d = Pe(() => u === et.lineSide, [u]),
      f = Pe(() => u === et.loadSide, [u]),
      A = Gd(t)
    return /* @__PURE__ */ p.jsxs(cO, {
      ref: c,
      rotation: o,
      onMouseEnter: i,
      onMouseLeave: s,
      ...l,
      children: [
        d
          ? /* @__PURE__ */ p.jsx(Xe, {
              type: 'target',
              position: n,
              style: Gp,
            })
          : /* @__PURE__ */ p.jsx(Yn, {
              type: 'target',
              position: n,
              style: Gp,
            }),
        /* @__PURE__ */ p.jsxs(lO, {
          children: [
            /* @__PURE__ */ p.jsx(uO, {
              archetype: u,
              src: pO,
              alt: hO,
              width: gO,
              height: mO,
            }),
            /* @__PURE__ */ p.jsx(dO, {
              lineSide: t.archetype === et.lineSide,
              children: A,
            }),
          ],
        }),
        f
          ? /* @__PURE__ */ p.jsx(Xe, {
              type: 'source',
              position: r,
              style: Vp,
            })
          : /* @__PURE__ */ p.jsx(Yn, {
              type: 'source',
              position: r,
              style: Vp,
            }),
      ],
    })
  }),
  bO = Te(yO),
  vO = O('div')`
  position: relative;
  height: ${Pn}px;
  width: ${Pn}px;
  display: flex;
  justify-content: center;
  align-items: center;
`,
  xO = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const CO = O(ln)`
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: ${e => (e.archetype === et.loadSide ? `${Pn}px` : '0')};
`,
  Xp = At({
    top: -2,
  }),
  Yp = At({
    top: 55,
  }),
  wO = O('p')`
  position: absolute;
  top: ${e => (e.lineSide ? '50%' : '164%')};
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8px;
  line-height: 1.14;
  margin: 0;
  min-width: 100px;
`,
  EO = 'FUSE',
  SO = qt[EO],
  { src: BO, alt: IO, width: NO, height: kO } = SO,
  MO = Kd(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.archetype,
      u = c === et.lineSide,
      d = c === et.loadSide,
      f = Gd(e)
    return /* @__PURE__ */ p.jsxs(xO, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        u
          ? /* @__PURE__ */ p.jsx(Xe, {
              type: 'target',
              position: t,
              style: Xp,
            })
          : /* @__PURE__ */ p.jsx(Yn, {
              type: 'target',
              position: t,
              style: Xp,
            }),
        /* @__PURE__ */ p.jsxs(vO, {
          children: [
            /* @__PURE__ */ p.jsx(CO, {
              archetype: c,
              src: BO,
              alt: IO,
              width: NO,
              height: kO,
            }),
            /* @__PURE__ */ p.jsx(wO, {
              lineSide: e.archetype === et.lineSide,
              children: f,
            }),
          ],
        }),
        d
          ? /* @__PURE__ */ p.jsx(Xe, {
              type: 'source',
              position: o,
              style: Yp,
            })
          : /* @__PURE__ */ p.jsx(Yn, {
              type: 'source',
              position: o,
              style: Yp,
            }),
      ],
    })
  }),
  PO = Te(MO),
  LO = O('div')`
  position: relative;
  height: ${Pn}px;
  width: ${Pn}px;
  display: flex;
  justify-content: center;
  align-items: center;
`,
  RO = O('div')`
  transform: rotate(${e => e.rotation}deg);
  height: ${Tt}px;
  flex-shrink: 1;
  width: 100%;
  background: ${e => e.background};
  border-radius: 8px;
`
O('div')`
  display: ${e => (e.rotatable ? 'block' : 'none')};
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3367d9;
  left: 50%;
  top: -30px;
  border-radius: 100%;
  transform: translate(-50%, -50%);
  cursor: alias;

  &::after {
    content: '';
    display: block;
    position: absolute;
    width: 1px;
    height: 30px;
    background: #3367d9;
    left: 4px;
    top: 5px;
  }
`
const TO = O(ln)`
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  top: ${e => (e.archetype === et.loadSide ? `${Pn}px` : '0')};
`,
  Hp = At({
    top: -2,
  }),
  Up = At({
    top: 55,
  }),
  FO = O('p')`
  position: absolute;
  top: ${e => (e.lineSide ? '50%' : '164%')};
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8px;
  line-height: 1.14;
  margin: 0;
  min-width: 100px;
`,
  DO = 'CIRCUIT_BREAKER',
  zO = qt[DO],
  { src: QO, alt: OO, width: jO, height: WO } = zO,
  GO = Kd(({ data: e, targetHandlePosition: t, rotation: n, sourceHandlePosition: o, handleNodeBaseHover: r, handleNodeBaseMouseLeave: i, setPopupAnchor: s, nodeColor: a }) => {
    const l = Mt(s),
      c = e.archetype,
      u = c === et.lineSide,
      d = c === et.loadSide,
      f = Gd(e)
    return /* @__PURE__ */ p.jsxs(RO, {
      ref: l,
      rotation: n,
      onMouseEnter: r,
      onMouseLeave: i,
      ...a,
      children: [
        u
          ? /* @__PURE__ */ p.jsx(Xe, {
              type: 'target',
              position: t,
              style: Hp,
            })
          : /* @__PURE__ */ p.jsx(Yn, {
              type: 'target',
              position: t,
              style: Hp,
            }),
        /* @__PURE__ */ p.jsxs(LO, {
          children: [
            /* @__PURE__ */ p.jsx(TO, {
              archetype: c,
              src: QO,
              alt: OO,
              width: jO,
              height: WO,
            }),
            /* @__PURE__ */ p.jsx(FO, {
              lineSide: e.archetype === et.lineSide,
              children: f,
            }),
          ],
        }),
        d
          ? /* @__PURE__ */ p.jsx(Xe, {
              type: 'source',
              position: o,
              style: Up,
            })
          : /* @__PURE__ */ p.jsx(Yn, {
              type: 'source',
              position: o,
              style: Up,
            }),
      ],
    })
  }),
  VO = Te(GO),
  To = {
    ResizableNode: 'ResizableNode',
    ResizableSubNode: 'ResizableSubNode',
    ImageNode: 'ImageNode',
    ImageSubNode: 'ImageSubNode',
    SwitchNode: 'SwitchNode',
    CapacitorNode: 'CapacitorNode',
    TransformerNode: 'TransformerNode',
    TransferSwitchNode: 'TransferSwitchNode',
    ElectricalPanelNode: 'ElectricalPanelNode',
    MiscNode: 'MiscNode',
    MotorNode: 'MotorNode',
    GeneratorNode: 'GeneratorNode',
    RelayNode: 'RelayNode',
    UPSSystemNode: 'UPSSystemNode',
    SubSwitchNode: 'SubSwitchNode',
    FuseNode: 'FuseNode',
    CircuitBreakerNode: 'CircuitBreakerNode',
  },
  XO = {
    ResizableNode: AD,
    ResizableSubNode: mD,
    ImageNode: CD,
    ImageSubNode: BD,
    SwitchNode: jD,
    CapacitorNode: ez,
    TransformerNode: pz,
    TransferSwitchNode: Mz,
    ElectricalPanelNode: zz,
    MiscNode: Jz,
    MotorNode: AQ,
    GeneratorNode: kQ,
    RelayNode: YQ,
    UPSSystemNode: aO,
    SubSwitchNode: bO,
    FuseNode: PO,
    CircuitBreakerNode: VO,
  },
  yn = {
    vertical: 'TB',
    horizontal: 'LR',
  },
  YO = {
    [yn.vertical]: 'Apply Layout',
    [yn.horizontal]: 'Horizontal',
  },
  Hn = {
    locked: 'LOCKED',
    unlocked: 'UNLOCKED',
  },
  HO = {
    [Hn.locked]: 'Locked',
    [Hn.unlocked]: 'Unlocked',
  },
  uo = {
    standard: 'standard',
    enhanced: 'enhanced',
  },
  UO = {
    [uo.standard]: 'Standard',
    [uo.enhanced]: 'Enhanced',
  },
  _ = {
    circuitBreaker: 'CIRCUIT_BREAKER',
    electricalPanel: 'ELECTRICAL_PANEL',
    fuse: 'FUSE',
    generator: 'GENERATOR',
    groundFaultSystem: 'GROUND_FAULT_SYSTEM',
    groundingOrBonding: 'GROUNDING_OR_BONDING',
    instrumentTransformer: 'INSTRUMENT_TRANSFORMER',
    meter: 'METER',
    misc: 'MISC',
    motor: 'MOTOR',
    relay: 'RELAY',
    switch: 'SWITCH',
    subSwitch: 'SUB_SWITCH',
    transferSwitch: 'TRANSFER_SWITCH',
    transformer: 'TRANSFORMER',
    upsSystem: 'UPS_SYSTEM',
    capacitor: 'CAPACITOR',
  },
  Ly = {
    [_.circuitBreaker]: 'CB',
    [_.fuse]: 'FUSE',
    [_.subSwitch]: 'SWITCH',
  },
  KO = {
    [_.circuitBreaker]: 'CIRCUIT_BREAKER',
    [_.electricalPanel]: 'ELECTRICAL_PANEL',
    [_.fuse]: 'FUSE',
    [_.generator]: 'GENERATOR',
    [_.groundFaultSystem]: 'GROUND_FAULT_SYSTEM',
    [_.groundingOrBonding]: 'GROUNDING_OR_BONDING',
    [_.instrumentTransformer]: 'INSTRUMENT_TRANSFORMER',
    [_.meter]: 'METER',
    [_.misc]: 'MISC',
    [_.motor]: 'MOTOR',
    [_.relay]: 'RELAY',
    [_.switch]: 'SWITCH',
    [_.subSwitch]: 'SWITCH',
    [_.transferSwitch]: 'TRANSFER_SWITCH',
    [_.transformer]: 'TRANSFORMER',
    [_.upsSystem]: 'UPS_SYSTEM',
    [_.capacitor]: 'CAPACITOR',
  },
  qd = {
    CapacitorNode: _.capacitor,
    ElectricalPanelNode: _.electricalPanel,
    SwitchNode: _.switch,
    TransferSwitchNode: _.transferSwitch,
    TransformerNode: _.transformer,
    MiscNode: _.misc,
    MotorNode: _.motor,
    GeneratorNode: _.generator,
    RelayNode: _.relay,
    UPSSystemNode: _.upsSystem,
    SubSwitchNode: _.subSwitch,
    FuseNode: _.fuse,
    CircuitBreakerNode: _.circuitBreaker,
  },
  Ni = ZN(qd),
  Ry = {
    ..._,
    textAsset: 'TEXT_ASSET',
  },
  X = {
    ARCB: 'ARCB',
    AMCB: 'AMCB',
    CTCR: 'CTCR',
    GICB: 'GICB',
    ICCB: 'ICCB',
    LVCB: 'LVCB',
    'MCCB-L-LV': 'MCCB-L-LV',
    'MCCB-S-LV': 'MCCB-S-LV',
    OICB: 'OICB',
    VCCB: 'VCCB',
    RCLS: 'RCLS',
    DPNL: 'DPNL',
    'MCEQ-LV': 'MCEQ-LV',
    'MCEQ-MV': 'MCEQ-MV',
    PANL: 'PANL',
    PDUX: 'PDUX',
    SWBD: 'SWBD',
    'SWGR-LV': 'SWGR-LV',
    'SWGR-MV': 'SWGR-MV',
    'USSX-LV': 'USSX-LV',
    'USSX-MV': 'USSX-MV',
    'FUSE-LV': 'FUSE-LV',
    'FUSE-MV': 'FUSE-MV',
    GENR: 'GENR',
    'GFPS-E-LV': 'GFPS-E-LV',
    'GFPS-E-MV': 'GFPS-E-MV',
    'GFPS-I-LV': 'GFPS-I-LV',
    'GFPS-I-MV': 'GFPS-I-MV',
    REGR: 'REGR',
    BNDG: 'BNDG',
    GRND: 'GRND',
    CITR: 'CITR',
    PITR: 'PITR',
    AMME: 'AMME',
    LIMI: 'LIMI',
    MMME: 'MMME',
    VVME: 'VVME',
    WHME: 'WHME',
    CBBX: 'CBBX',
    ENCL: 'ENCL',
    ENDX: 'ENDX',
    EVCS: 'EVCS',
    FSBX: 'FSBX',
    INVR: 'INVR',
    JCBX: 'JCBX',
    Other: 'Other',
    RCTF: 'RCTF',
    REAC: 'REAC',
    SOLR: 'SOLR',
    WIND: 'WIND',
    'LVMT-DC': 'LVMT-DC',
    'LVMT-L': 'LVMT-L',
    'LVMT-S': 'LVMT-S',
    MVIN: 'MVIN',
    MVSC: 'MVSC',
    EMRE: 'EMRE',
    MPRE: 'MPRE',
    SSRE: 'SSRE',
    'BISW-LV': 'BISW-LV',
    'BISW-MV': 'BISW-MV',
    BPSW: 'BPSW',
    'DISC-F-LV': 'DISC-F-LV',
    'DISC-F-MV': 'DISC-F-MV',
    'DISC-LV': 'DISC-LV',
    'DISC-MV': 'DISC-MV',
    HPSW: 'HPSW',
    LISW: 'LISW',
    'SUB_BISW-LV': 'SUB_BISW-LV',
    'SUB_BISW-MV': 'SUB_BISW-MV',
    SUB_BPSW: 'SUB_BPSW',
    'SUB_DISC-F-LV': 'SUB_DISC-F-LV',
    'SUB_DISC-F-MV': 'SUB_DISC-F-MV',
    'SUB_DISC-LV': 'SUB_DISC-LV',
    'SUB_DISC-MV': 'SUB_DISC-MV',
    SUB_HPSW: 'SUB_HPSW',
    SUB_LISW: 'SUB_LISW',
    'ATSW-LV': 'ATSW-LV',
    'ATSW-MV': 'ATSW-MV',
    'MTSW-LV': 'MTSW-LV',
    'MTSW-MV': 'MTSW-MV',
    'DTTR-LV': 'DTTR-LV',
    'DTTR-MV': 'DTTR-MV',
    OFTR: 'OFTR',
    UPSH: 'UPSH',
    UPSR: 'UPSR',
    UPSS: 'UPSS',
    PCAP: 'PCAP',
    SCAP: 'SCAP',
  },
  Ty = {
    ARCB: 'ARCB Circuit Breaker',
    AMCB: 'Medium-Voltage Air Magnetic Circuit Breaker',
    CTCR: 'Contactor',
    GICB: 'Medim-Voltage Gas Insulated Circuit Breaker',
    ICCB: 'Low-Voltage Insulated Case Circuit Breaker',
    LVCB: 'Low-Voltage Power Circuit Breaker',
    'MCCB-L-LV': 'Low-Voltage Molded Case Circuit Breaker (> 250A)',
    'MCCB-S-LV': 'Low-Voltage Molded Case Circuit Breaker (<= 250A)',
    OICB: 'Medium-Voltage Oil Insulated Circuit Breaker',
    VCCB: 'Medium-Voltage Vacuum Circuit Breaker',
    RCLS: 'Recloser',
    DPNL: 'Distribution Panelboard',
    'MCEQ-LV': 'Motor Control Equipment (<=1000V)',
    'MCEQ-MV': 'Motor Control Equipment (>1000V)',
    PANL: 'Panelboard',
    PDUX: 'Power Distribution Unit',
    SWBD: 'Switchboard',
    'SWGR-LV': 'Switchgear (<= 1000V)',
    'SWGR-MV': 'Switchgear (> 1000V)',
    'USSX-LV': 'Unitized Substation (USS) (<= 1000V)',
    'USSX-MV': 'Unitized Substation (USS) (> 1000V)',
    'FUSE-LV': 'Fuse (<= 1000V)',
    'FUSE-MV': 'Fuse (> 1000V)',
    GENR: 'Generator',
    'GFPS-E-LV': 'Low-Voltage External Ground Fault Protection System',
    'GFPS-E-MV': 'Medium-Voltage External Ground Fault Protection System',
    'GFPS-I-LV': 'Low-Voltage Integral Ground Fault Protection System',
    'GFPS-I-MV': 'Medium-Voltage Integral Ground Fault Protection System',
    REGR: 'Ground Resistor',
    BNDG: 'Bonding',
    GRND: 'Grounding',
    CITR: 'Current Transformer',
    PITR: 'Potential Transformer',
    AMME: 'Ammeter',
    LIMI: 'Line Isolation Monitor',
    MMME: 'Multimeter',
    VVME: 'Votmeter',
    WHME: 'Watt-Hour Meter',
    CBBX: 'Combiner Box',
    ENCL: 'General Enclosure',
    ENDX: 'General Endpoint',
    EVCS: 'Electrical Vehicle Charging Station',
    FSBX: 'Fuse Box',
    INVR: 'Inverter',
    JCBX: 'Junction Box',
    Other: 'Other',
    RCTF: 'Recitifier',
    REAC: 'Reactor',
    SOLR: 'Solar Photovoltaic System',
    WIND: 'Wind Power System',
    'LVMT-DC': 'Low-Voltage Motor (dc)',
    'LVMT-L': 'Low-Voltage Motor (>200hp)',
    'LVMT-S': 'Low-Voltage Motor (<= 200hp)',
    MVIN: 'Medium-Voltage Induction Motor',
    MVSC: 'Medium-Voltage Synchronous Motor',
    EMRE: 'Electromechanical Relay',
    MPRE: 'Microprocessor Relay',
    SSRE: 'Solid-State Relay',
    'BISW-LV': 'Bypass-Isolation Switch (<= 1000V)',
    'BISW-MV': 'Bypass-Isolation Switch (> 1000V)',
    BPSW: 'Bolted-Pressure Switch (BPS)',
    'DISC-F-LV': 'Fused Disconnect Switch (<= 1000V)',
    'DISC-F-MV': 'Fused Disconnect Switch (>1000V)',
    'DISC-LV': 'Disconnect Switch (<= 1000V)',
    'DISC-MV': 'Disconnect Switch (>1000V)',
    HPSW: 'High-Pressure Contact Switch (HPC)',
    LISW: 'Load-Interruptor Switch',
    'SUB_BISW-LV': 'Bypass-Isolation Switch (<= 1000V)',
    'SUB_BISW-MV': 'Bypass-Isolation Switch (> 1000V)',
    SUB_BPSW: 'Bolted-Pressure Switch (BPS)',
    'SUB_DISC-F-LV': 'Fused Disconnect Switch (<= 1000V)',
    'SUB_DISC-F-MV': 'Fused Disconnect Switch (>1000V)',
    'SUB_DISC-LV': 'Disconnect Switch (<= 1000V)',
    'SUB_DISC-MV': 'Disconnect Switch (>1000V)',
    SUB_HPSW: 'High-Pressure Contact Switch (HPC)',
    SUB_LISW: 'Load-Interruptor Switch',
    'ATSW-LV': 'Automatic Transfer Switch (<= 1000V)',
    'ATSW-MV': 'Automatic Transfer Switch (>1000V)',
    'MTSW-LV': 'Transfer Switch (<= 1000V)',
    'MTSW-MV': 'Transfer Switch (> 1000V)',
    'DTTR-LV': 'Dry-Type Transformer (<=600V)',
    'DTTR-MV': 'Dry-Type Transformer (>600V)',
    OFTR: 'Oil-Filled Transformer',
    UPSH: 'Hybrid UPS System',
    UPSR: 'Rotary UPS System',
    UPSS: 'Static UPS System',
    PCAP: 'P-Capacitor',
    SCAP: 'S-Capcitor',
  },
  Zd = {
    ARCB: 'ARCB',
    AMCB: 'AMCB',
    CTCR: 'CTCR',
    GICB: 'GICB',
    ICCB: 'ICCB',
    LVCB: 'LVCB',
    'MCCB-L-LV': 'MCCB-L-LV',
    'MCCB-S-LV': 'MCCB-S-LV',
    OICB: 'OICB',
    VCCB: 'VCCB',
    RCLS: 'RCLS',
    DPNL: 'DPNL',
    'MCEQ-LV': 'MCEQ-LV',
    'MCEQ-MV': 'MCEQ-MV',
    PANL: 'PANL',
    PDUX: 'PDUX',
    SWBD: 'SWBD',
    'SWGR-LV': 'SWGR-LV',
    'SWGR-MV': 'SWGR-MV',
    'USSX-LV': 'USSX-LV',
    'USSX-MV': 'USSX-MV',
    'FUSE-LV': 'FUSE-LV',
    'FUSE-MV': 'FUSE-MV',
    GENR: 'GENR',
    'GFPS-E-LV': 'GFPS-E-LV',
    'GFPS-E-MV': 'GFPS-E-MV',
    'GFPS-I-LV': 'GFPS-I-LV',
    'GFPS-I-MV': 'GFPS-I-MV',
    REGR: 'REGR',
    BNDG: 'BNDG',
    GRND: 'GRND',
    CITR: 'CITR',
    PITR: 'PITR',
    AMME: 'AMME',
    LIMI: 'LIMI',
    MMME: 'MMME',
    VVME: 'VVME',
    WHME: 'WHME',
    CBBX: 'CBBX',
    ENCL: 'ENCL',
    ENDX: 'ENDX',
    EVCS: 'EVCS',
    FSBX: 'FSBX',
    INVR: 'INVR',
    JCBX: 'JCBX',
    Other: 'Other',
    RCTF: 'RCTF',
    REAC: 'REAC',
    SOLR: 'SOLR',
    WIND: 'WIND',
    'LVMT-DC': 'LVMT-DC',
    'LVMT-L': 'LVMT-L',
    'LVMT-S': 'LVMT-S',
    MVIN: 'MVIN',
    MVSC: 'MVSC',
    EMRE: 'EMRE',
    MPRE: 'MPRE',
    SSRE: 'SSRE',
    'BISW-LV': 'BISW-LV',
    'BISW-MV': 'BISW-MV',
    BPSW: 'BPSW',
    'DISC-F-LV': 'DISC-F-LV',
    'DISC-F-MV': 'DISC-F-MV',
    'DISC-LV': 'DISC-LV',
    'DISC-MV': 'DISC-MV',
    HPSW: 'HPSW',
    LISW: 'LISW',
    'SUB_BISW-LV': 'BISW-LV',
    'SUB_BISW-MV': 'BISW-MV',
    SUB_BPSW: 'BPSW',
    'SUB_DISC-F-LV': 'DISC-F-LV',
    'SUB_DISC-F-MV': 'DISC-F-MV',
    'SUB_DISC-LV': 'DISC-LV',
    'SUB_DISC-MV': 'DISC-MV',
    SUB_HPSW: 'HPSW',
    SUB_LISW: 'LISW',
    'ATSW-LV': 'ATSW-LV',
    'ATSW-MV': 'ATSW-MV',
    'MTSW-LV': 'MTSW-LV',
    'MTSW-MV': 'MTSW-MV',
    'DTTR-LV': 'DTTR-LV',
    'DTTR-MV': 'DTTR-MV',
    OFTR: 'OFTR',
    UPSH: 'UPSH',
    UPSR: 'UPSR',
    UPSS: 'UPSS',
    PCAP: 'PCAP',
    SCAP: 'SCAP',
  },
  qO = [
    X['ATSW-LV'],
    X['ATSW-MV'],
    X['MTSW-LV'],
    X['MTSW-MV'],
    X['DTTR-LV'],
    X['DTTR-MV'],
    X.OFTR,
    X.PCAP,
    X.SCAP,
    X['BISW-LV'],
    X['BISW-MV'],
    X.BPSW,
    X['DISC-F-LV'],
    X['DISC-F-MV'],
    X['DISC-LV'],
    X['DISC-MV'],
    X.HPSW,
    X.LISW,
    X.DPNL,
    X['MCEQ-LV'],
    X['MCEQ-MV'],
    X.PANL,
    X.PDUX,
    X.SWBD,
    X['SWGR-LV'],
    X['SWGR-MV'],
    X['USSX-LV'],
    X['USSX-MV'],
    X.UPSH,
    X.UPSR,
    X.UPSS,
    X.GENR,
    X.EMRE,
    X.MPRE,
    X.SSRE,
    X['LVMT-DC'],
    X['LVMT-L'],
    X['LVMT-S'],
    X.MVIN,
    X.MVSC,
    X.CBBX,
    X.ENCL,
    X.ENDX,
    X.EVCS,
    X.FSBX,
    X.INVR,
    X.JCBX,
    X.Other,
    X.RCTF,
    X.REAC,
    X.SOLR,
    X.WIND,
  ],
  ZO = [X.AMCB, X.CTCR, X.ARCB, X.GICB, X.ICCB, X.LVCB, X['MCCB-L-LV'], X['MCCB-S-LV'], X.OICB, X.RCLS, X.VCCB, X['FUSE-LV'], X['FUSE-MV'], X['SUB_BISW-LV'], X['SUB_BISW-MV'], X.SUB_BPSW, X['SUB_DISC-F-LV'], X['SUB_DISC-F-MV'], X['SUB_DISC-LV'], X['SUB_DISC-MV'], X.SUB_HPSW, X.SUB_LISW],
  Ru = {
    [X['ATSW-LV']]: _.transferSwitch,
    [X['ATSW-MV']]: _.transferSwitch,
    [X['MTSW-LV']]: _.transferSwitch,
    [X['MTSW-MV']]: _.transferSwitch,
    [X['DTTR-LV']]: _.transformer,
    [X['DTTR-MV']]: _.transformer,
    [X.OFTR]: _.transformer,
    [X.PCAP]: _.capacitor,
    [X.SCAP]: _.capacitor,
    [X['BISW-LV']]: _.switch,
    [X['BISW-MV']]: _.switch,
    [X.BPSW]: _.switch,
    [X['DISC-F-LV']]: _.switch,
    [X['DISC-F-MV']]: _.switch,
    [X['DISC-LV']]: _.switch,
    [X['DISC-MV']]: _.switch,
    [X.HPSW]: _.switch,
    [X.LISW]: _.switch,
    [X.DPNL]: _.electricalPanel,
    [X['MCEQ-LV']]: _.electricalPanel,
    [X['MCEQ-MV']]: _.electricalPanel,
    [X.PANL]: _.electricalPanel,
    [X.PDUX]: _.electricalPanel,
    [X.SWBD]: _.electricalPanel,
    [X['SWGR-LV']]: _.electricalPanel,
    [X['SWGR-MV']]: _.electricalPanel,
    [X['USSX-LV']]: _.electricalPanel,
    [X['USSX-MV']]: _.electricalPanel,
    [X.UPSH]: _.upsSystem,
    [X.UPSR]: _.upsSystem,
    [X.UPSS]: _.upsSystem,
    [X.GENR]: _.generator,
    [X.EMRE]: _.relay,
    [X.MPRE]: _.relay,
    [X.SSRE]: _.relay,
    [X['LVMT-DC']]: _.motor,
    [X['LVMT-L']]: _.motor,
    [X['LVMT-S']]: _.motor,
    [X.MVIN]: _.motor,
    [X.MVSC]: _.motor,
    [X.CBBX]: _.misc,
    [X.ENCL]: _.misc,
    [X.ENDX]: _.misc,
    [X.EVCS]: _.misc,
    [X.FSBX]: _.misc,
    [X.INVR]: _.misc,
    [X.JCBX]: _.misc,
    [X.Other]: _.misc,
    [X.RCTF]: _.misc,
    [X.REAC]: _.misc,
    [X.SOLR]: _.misc,
    [X.WIND]: _.misc,
  },
  Fy = {
    [X.AMCB]: _.circuitBreaker,
    [X.CTCR]: _.circuitBreaker,
    [X.ARCB]: _.circuitBreaker,
    [X.GICB]: _.circuitBreaker,
    [X.ICCB]: _.circuitBreaker,
    [X.LVCB]: _.circuitBreaker,
    [X['MCCB-L-LV']]: _.circuitBreaker,
    [X['MCCB-S-LV']]: _.circuitBreaker,
    [X.OICB]: _.circuitBreaker,
    [X.RCLS]: _.circuitBreaker,
    [X.VCCB]: _.circuitBreaker,
    [X['FUSE-LV']]: _.fuse,
    [X['FUSE-MV']]: _.fuse,
    [X['SUB_BISW-LV']]: _.subSwitch,
    [X['SUB_BISW-MV']]: _.subSwitch,
    [X.SUB_BPSW]: _.subSwitch,
    [X['SUB_DISC-F-LV']]: _.subSwitch,
    [X['SUB_DISC-F-MV']]: _.subSwitch,
    [X['SUB_DISC-LV']]: _.subSwitch,
    [X['SUB_DISC-MV']]: _.subSwitch,
    [X.SUB_HPSW]: _.subSwitch,
    [X.SUB_LISW]: _.subSwitch,
  },
  et = {
    lineSide: 'line-side',
    loadSide: 'load-side',
  },
  JO = {
    [et.lineSide]: 'Line Side',
    [et.loadSide]: 'Load Side',
  },
  Dy = {
    [et.lineSide]: 'LINE',
    [et.loadSide]: 'LOAD',
  },
  _O = [et.lineSide, et.loadSide],
  Vo = {
    MLO: 'MLO',
    MCB: 'MCB',
  },
  $O = [Vo.MCB, Vo.MLO],
  at = {
    nonFlexConduit: 'Non-Flex Conduit',
    flexibleConduit: 'Flexible Conduit',
    cable: 'Cable',
    busduct: 'Busduct',
  },
  e6 = [at.nonFlexConduit, at.flexibleConduit, at.cable, at.busduct],
  yi = {
    PVC: 'PVC',
    EMT: 'EMT',
    IMC: 'IMC',
    RMC: 'RMC',
  },
  t6 = [yi.PVC, yi.EMT, yi.IMC, yi.RMC],
  ea = {
    smurf: 'Smurf',
    flex: 'Flex',
    sealTight: 'SealTight',
  },
  n6 = [ea.smurf, ea.flex, ea.sealTight],
  di = {
    [at.nonFlexConduit]: yi,
    [at.flexibleConduit]: ea,
    [at.cable]: null,
    [at.busduct]: null,
  },
  $o = {
    copper: 'Copper',
    aluminum: 'Aluminum',
  },
  o6 = {
    [$o.copper]: 'Copper',
    [$o.aluminum]: 'Aluminum',
  },
  r6 = {
    [$o.copper]: 'Cu',
    [$o.aluminum]: 'Al',
  },
  i6 = [$o.copper, $o.aluminum],
  Se = {
    AWG18: '18 AWG',
    AWG16: '16 AWG',
    AWG14: '14 AWG',
    AWG12: '12 AWG',
    AWG10: '10 AWG',
    AWG8: '8 AWG',
    AWG6: '6 AWG',
    AWG4: '4 AWG',
    AWG2: '2 AWG',
    AWG1: '1 AWG',
    AWG1_0: '1/0 AWG',
    AWG2_0: '2/0 AWG',
    AWG3_0: '3/0 AWG',
    AWG4_0: '4/0 AWG',
    KCMIL250: '250 kcmil',
    KCMIL300: '300 kcmil',
    KCMIL350: '350 kcmil',
    KCMIL400: '400 kcmil',
    KCMIL500: '500 kcmil',
    KCMIL600: '600 kcmil',
    KCMIL750: '750 kcmil',
    KCMIL1000: '1000 kcmil',
  },
  s6 = {
    [Se.AWG18]: '18 AWG',
    [Se.AWG16]: '16 AWG',
    [Se.AWG14]: '14 AWG',
    [Se.AWG12]: '12 AWG',
    [Se.AWG10]: '10 AWG',
    [Se.AWG8]: '8 AWG',
    [Se.AWG6]: '6 AWG',
    [Se.AWG4]: '4 AWG',
    [Se.AWG2]: '2 AWG',
    [Se.AWG1]: '1 AWG',
    [Se.AWG1_0]: '1/0 AWG',
    [Se.AWG2_0]: '2/0 AWG',
    [Se.AWG3_0]: '3/0 AWG',
    [Se.AWG4_0]: '4/0 AWG',
    [Se.KCMIL250]: '250 kcmil',
    [Se.KCMIL300]: '300 kcmil',
    [Se.KCMIL350]: '350 kcmil',
    [Se.KCMIL400]: '400 kcmil',
    [Se.KCMIL500]: '500 kcmil',
    [Se.KCMIL600]: '600 kcmil',
    [Se.KCMIL750]: '750 kcmil',
    [Se.KCMIL1000]: '1000 kcmil',
  },
  a6 = [Se.AWG18, Se.AWG16, Se.AWG14, Se.AWG12, Se.AWG10, Se.AWG8, Se.AWG6, Se.AWG4, Se.AWG2, Se.AWG1, Se.AWG1_0, Se.AWG2_0, Se.AWG3_0, Se.AWG4_0, Se.KCMIL250, Se.KCMIL300, Se.KCMIL350, Se.KCMIL400, Se.KCMIL500, Se.KCMIL600, Se.KCMIL750, Se.KCMIL1000],
  zy = e => Object.keys(qd).some(t => t === e.type),
  l6 = (e, t) => t.some(n => n.parentId === e.id),
  Ul = e => !!e.parentId,
  c6 = e => e === Ry.textAsset,
  u6 = XT(),
  fn = e => {
    var o, r
    const { background: t, border: n } = KT()
    return {
      ...e,
      type: e.type ?? To.ResizableNode,
      data: e.data
        ? {
            ...e.data,
            background: ((o = e.data) == null ? void 0 : o.background) ?? t,
            border: ((r = e.data) == null ? void 0 : r.border) ?? n,
          }
        : {
            label: 'NEW ASSET',
            background: t,
            border: n,
          },
      id: e.id ?? Ho(),
      style: e.style ?? u6,
    }
  },
  Qy = e => (rT(e) ? e.data.class : zy(e) ? qd[e.type] : Ry.textAsset),
  Oy = e => ('code' in e.data && typeof e.data.code == 'string' ? e.data.code : void 0),
  jy = e => {
    var t, n
    return {
      background: (t = e.data) == null ? void 0 : t.background,
      border: (n = e.data) == null ? void 0 : n.border,
    }
  },
  d6 = e => ('rotation' in e.data && typeof e.data.rotation == 'number' && e.data.rotation) || void 0,
  f6 = e => 'label' in e.data && typeof e.data.string == 'string',
  Jd = (e, t) => t.find(n => n.id === e.parentId),
  A6 = (e, t) =>
    fn({
      ...e,
      data: {
        ...e.data,
        label: t,
      },
    }),
  p6 = (e, t, n) => {
    const o = n.find(r => r.target === e.id)
    return o ? t.find(r => r.id === o.source) ?? null : null
  },
  Kp = e => !!Ni[e],
  h6 = (e, t) => (e.length >= t ? `${e.slice(0, t)}...` : e),
  g6 = (e, { x: t, y: n, zoom: o }) => ({
    x: (e.clientX - t) * (1 / o) - Ze,
    y: (e.clientY - n) * (1 / o) - Tt / 2,
  }),
  Wy = [
    // node({
    //   id: "1",
    //   type: nodeType.ResizableNode,
    //   position: { x: 100, y: 50 },
    //   data: { label: "ASSET 1" },
    // }),
    // node({
    //   id: "2",
    //   type: nodeType.ResizableNode,
    //   position: { x: 100, y: 150 },
    //   data: { label: "ASSET 2" },
    // }),
    // node({
    //   id: "3",
    //   type: nodeType.SwitchNode,
    //   position: { x: 100, y: 250 },
    //   data: {
    //     code: nodeClassCode.LISW,
    //     label: "AUX SWITCH",
    //   },
    // }),
    // node({
    //   id: "4",
    //   type: nodeType.CapacitorNode,
    //   position: { x: 100, y: 300 },
    //   data: {
    //     code: nodeClassCode.PCAP,
    //     label: "CAPACITOR 1",
    //   },
    // }),
    // node({
    //   id: "5",
    //   type: nodeType.TransformerNode,
    //   position: { x: 100, y: 350 },
    //   data: {
    //     code: nodeClassCode.OFTR,
    //     label: "TRANSF 1",
    //   },
    // }),
    // node({
    //   id: "6",
    //   type: nodeType.TransferSwitchNode,
    //   position: { x: 100, y: 400 },
    //   data: {
    //     code: nodeClassCode["ATSW-MV"],
    //     label: "ATS-400",
    //   },
    // }),
    // node({
    //   id: "7",
    //   type: nodeType.ElectricalPanelNode,
    //   position: { x: 100, y: 450 },
    //   data: {
    //     code: nodeClassCode.PANL,
    //     label: "PANL-15",
    //   },
    // }),
    // node({
    //   id: "8",
    //   type: nodeType.MiscNode,
    //   position: { x: 200, y: 500 },
    //   data: {
    //     code: nodeClassCode.Other,
    //     label: "MISC",
    //   },
    // }),
    // node({
    //   id: "9",
    //   type: nodeType.MotorNode,
    //   position: { x: 100, y: 550 },
    //   data: {
    //     code: nodeClassCode.MVSC,
    //     label: "MOTOR",
    //   },
    // }),
    // node({
    //   id: "10",
    //   type: nodeType.GeneratorNode,
    //   position: { x: 100, y: 600 },
    //   data: {
    //     code: nodeClassCode.GENR,
    //     label: "GENERATOR",
    //   },
    // }),
    // node({
    //   id: "11",
    //   type: nodeType.RelayNode,
    //   position: { x: 100, y: 650 },
    //   data: {
    //     code: nodeClassCode.EMRE,
    //     label: "RELAY",
    //   },
    // }),
    // node({
    //   id: "12",
    //   type: nodeType.UPSSystemNode,
    //   position: { x: 100, y: 700 },
    //   data: {
    //     code: nodeClassCode.UPSS,
    //     label: "UPS-1",
    //   },
    // }),
  ],
  Gy = [
    // edge({ id: "e1-2", source: "1", target: "2" }),
    // edge({ id: "e2-3", source: "2", target: "3" }),
    // edge({ id: "e3-4", source: "3", target: "4" }),
    // edge({ id: "e4-5", source: "4", target: "5" }),
  ]
var m6 = '\0',
  Eo = '\0',
  qp = ''
let y6 = class {
  constructor(t) {
    gt(this, '_isDirected', !0)
    gt(this, '_isMultigraph', !1)
    gt(this, '_isCompound', !1)
    // Label for the graph itself
    gt(this, '_label')
    // Defaults to be set when creating a new node
    gt(this, '_defaultNodeLabelFn', () => {})
    // Defaults to be set when creating a new edge
    gt(this, '_defaultEdgeLabelFn', () => {})
    // v -> label
    gt(this, '_nodes', {})
    // v -> edgeObj
    gt(this, '_in', {})
    // u -> v -> Number
    gt(this, '_preds', {})
    // v -> edgeObj
    gt(this, '_out', {})
    // v -> w -> Number
    gt(this, '_sucs', {})
    // e -> edgeObj
    gt(this, '_edgeObjs', {})
    // e -> label
    gt(this, '_edgeLabels', {})
    /* Number of nodes in the graph. Should only be changed by the implementation. */
    gt(this, '_nodeCount', 0)
    /* Number of edges in the graph. Should only be changed by the implementation. */
    gt(this, '_edgeCount', 0)
    gt(this, '_parent')
    gt(this, '_children')
    t && ((this._isDirected = Object.hasOwn(t, 'directed') ? t.directed : !0), (this._isMultigraph = Object.hasOwn(t, 'multigraph') ? t.multigraph : !1), (this._isCompound = Object.hasOwn(t, 'compound') ? t.compound : !1)), this._isCompound && ((this._parent = {}), (this._children = {}), (this._children[Eo] = {}))
  }
  /* === Graph functions ========= */
  /**
   * Whether graph was created with 'directed' flag set to true or not.
   */
  isDirected() {
    return this._isDirected
  }
  /**
   * Whether graph was created with 'multigraph' flag set to true or not.
   */
  isMultigraph() {
    return this._isMultigraph
  }
  /**
   * Whether graph was created with 'compound' flag set to true or not.
   */
  isCompound() {
    return this._isCompound
  }
  /**
   * Sets the label of the graph.
   */
  setGraph(t) {
    return (this._label = t), this
  }
  /**
   * Gets the graph label.
   */
  graph() {
    return this._label
  }
  /* === Node functions ========== */
  /**
   * Sets the default node label. If newDefault is a function, it will be
   * invoked ach time when setting a label for a node. Otherwise, this label
   * will be assigned as default label in case if no label was specified while
   * setting a node.
   * Complexity: O(1).
   */
  setDefaultNodeLabel(t) {
    return (this._defaultNodeLabelFn = t), typeof t != 'function' && (this._defaultNodeLabelFn = () => t), this
  }
  /**
   * Gets the number of nodes in the graph.
   * Complexity: O(1).
   */
  nodeCount() {
    return this._nodeCount
  }
  /**
   * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
   * not included in list.
   * Complexity: O(1).
   */
  nodes() {
    return Object.keys(this._nodes)
  }
  /**
   * Gets list of nodes without in-edges.
   * Complexity: O(|V|).
   */
  sources() {
    var t = this
    return this.nodes().filter(n => Object.keys(t._in[n]).length === 0)
  }
  /**
   * Gets list of nodes without out-edges.
   * Complexity: O(|V|).
   */
  sinks() {
    var t = this
    return this.nodes().filter(n => Object.keys(t._out[n]).length === 0)
  }
  /**
   * Invokes setNode method for each node in names list.
   * Complexity: O(|names|).
   */
  setNodes(t, n) {
    var o = arguments,
      r = this
    return (
      t.forEach(function (i) {
        o.length > 1 ? r.setNode(i, n) : r.setNode(i)
      }),
      this
    )
  }
  /**
   * Creates or updates the value for the node v in the graph. If label is supplied
   * it is set as the value for the node. If label is not supplied and the node was
   * created by this call then the default node label will be assigned.
   * Complexity: O(1).
   */
  setNode(t, n) {
    return Object.hasOwn(this._nodes, t)
      ? (arguments.length > 1 && (this._nodes[t] = n), this)
      : ((this._nodes[t] = arguments.length > 1 ? n : this._defaultNodeLabelFn(t)), this._isCompound && ((this._parent[t] = Eo), (this._children[t] = {}), (this._children[Eo][t] = !0)), (this._in[t] = {}), (this._preds[t] = {}), (this._out[t] = {}), (this._sucs[t] = {}), ++this._nodeCount, this)
  }
  /**
   * Gets the label of node with specified name.
   * Complexity: O(|V|).
   */
  node(t) {
    return this._nodes[t]
  }
  /**
   * Detects whether graph has a node with specified name or not.
   */
  hasNode(t) {
    return Object.hasOwn(this._nodes, t)
  }
  /**
   * Remove the node with the name from the graph or do nothing if the node is not in
   * the graph. If the node was removed this function also removes any incident
   * edges.
   * Complexity: O(1).
   */
  removeNode(t) {
    var n = this
    if (Object.hasOwn(this._nodes, t)) {
      var o = r => n.removeEdge(n._edgeObjs[r])
      delete this._nodes[t],
        this._isCompound &&
          (this._removeFromParentsChildList(t),
          delete this._parent[t],
          this.children(t).forEach(function (r) {
            n.setParent(r)
          }),
          delete this._children[t]),
        Object.keys(this._in[t]).forEach(o),
        delete this._in[t],
        delete this._preds[t],
        Object.keys(this._out[t]).forEach(o),
        delete this._out[t],
        delete this._sucs[t],
        --this._nodeCount
    }
    return this
  }
  /**
   * Sets node p as a parent for node v if it is defined, or removes the
   * parent for v if p is undefined. Method throws an exception in case of
   * invoking it in context of noncompound graph.
   * Average-case complexity: O(1).
   */
  setParent(t, n) {
    if (!this._isCompound) throw new Error('Cannot set parent in a non-compound graph')
    if (n === void 0) n = Eo
    else {
      n += ''
      for (var o = n; o !== void 0; o = this.parent(o)) if (o === t) throw new Error('Setting ' + n + ' as parent of ' + t + ' would create a cycle')
      this.setNode(n)
    }
    return this.setNode(t), this._removeFromParentsChildList(t), (this._parent[t] = n), (this._children[n][t] = !0), this
  }
  _removeFromParentsChildList(t) {
    delete this._children[this._parent[t]][t]
  }
  /**
   * Gets parent node for node v.
   * Complexity: O(1).
   */
  parent(t) {
    if (this._isCompound) {
      var n = this._parent[t]
      if (n !== Eo) return n
    }
  }
  /**
   * Gets list of direct children of node v.
   * Complexity: O(1).
   */
  children(t = Eo) {
    if (this._isCompound) {
      var n = this._children[t]
      if (n) return Object.keys(n)
    } else {
      if (t === Eo) return this.nodes()
      if (this.hasNode(t)) return []
    }
  }
  /**
   * Return all nodes that are predecessors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  predecessors(t) {
    var n = this._preds[t]
    if (n) return Object.keys(n)
  }
  /**
   * Return all nodes that are successors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  successors(t) {
    var n = this._sucs[t]
    if (n) return Object.keys(n)
  }
  /**
   * Return all nodes that are predecessors or successors of the specified node or undefined if
   * node v is not in the graph.
   * Complexity: O(|V|).
   */
  neighbors(t) {
    var n = this.predecessors(t)
    if (n) {
      const r = new Set(n)
      for (var o of this.successors(t)) r.add(o)
      return Array.from(r.values())
    }
  }
  isLeaf(t) {
    var n
    return this.isDirected() ? (n = this.successors(t)) : (n = this.neighbors(t)), n.length === 0
  }
  /**
   * Creates new graph with nodes filtered via filter. Edges incident to rejected node
   * are also removed. In case of compound graph, if parent is rejected by filter,
   * than all its children are rejected too.
   * Average-case complexity: O(|E|+|V|).
   */
  filterNodes(t) {
    var n = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound,
    })
    n.setGraph(this.graph())
    var o = this
    Object.entries(this._nodes).forEach(function ([s, a]) {
      t(s) && n.setNode(s, a)
    }),
      Object.values(this._edgeObjs).forEach(function (s) {
        n.hasNode(s.v) && n.hasNode(s.w) && n.setEdge(s, o.edge(s))
      })
    var r = {}
    function i(s) {
      var a = o.parent(s)
      return a === void 0 || n.hasNode(a) ? ((r[s] = a), a) : a in r ? r[a] : i(a)
    }
    return this._isCompound && n.nodes().forEach(s => n.setParent(s, i(s))), n
  }
  /* === Edge functions ========== */
  /**
   * Sets the default edge label or factory function. This label will be
   * assigned as default label in case if no label was specified while setting
   * an edge or this function will be invoked each time when setting an edge
   * with no label specified and returned value * will be used as a label for edge.
   * Complexity: O(1).
   */
  setDefaultEdgeLabel(t) {
    return (this._defaultEdgeLabelFn = t), typeof t != 'function' && (this._defaultEdgeLabelFn = () => t), this
  }
  /**
   * Gets the number of edges in the graph.
   * Complexity: O(1).
   */
  edgeCount() {
    return this._edgeCount
  }
  /**
   * Gets edges of the graph. In case of compound graph subgraphs are not considered.
   * Complexity: O(|E|).
   */
  edges() {
    return Object.values(this._edgeObjs)
  }
  /**
   * Establish an edges path over the nodes in nodes list. If some edge is already
   * exists, it will update its label, otherwise it will create an edge between pair
   * of nodes with label provided or default label if no label provided.
   * Complexity: O(|nodes|).
   */
  setPath(t, n) {
    var o = this,
      r = arguments
    return (
      t.reduce(function (i, s) {
        return r.length > 1 ? o.setEdge(i, s, n) : o.setEdge(i, s), s
      }),
      this
    )
  }
  /**
   * Creates or updates the label for the edge (v, w) with the optionally supplied
   * name. If label is supplied it is set as the value for the edge. If label is not
   * supplied and the edge was created by this call then the default edge label will
   * be assigned. The name parameter is only useful with multigraphs.
   */
  setEdge() {
    var t,
      n,
      o,
      r,
      i = !1,
      s = arguments[0]
    typeof s == 'object' && s !== null && 'v' in s ? ((t = s.v), (n = s.w), (o = s.name), arguments.length === 2 && ((r = arguments[1]), (i = !0))) : ((t = s), (n = arguments[1]), (o = arguments[3]), arguments.length > 2 && ((r = arguments[2]), (i = !0))), (t = '' + t), (n = '' + n), o !== void 0 && (o = '' + o)
    var a = bi(this._isDirected, t, n, o)
    if (Object.hasOwn(this._edgeLabels, a)) return i && (this._edgeLabels[a] = r), this
    if (o !== void 0 && !this._isMultigraph) throw new Error('Cannot set a named edge when isMultigraph = false')
    this.setNode(t), this.setNode(n), (this._edgeLabels[a] = i ? r : this._defaultEdgeLabelFn(t, n, o))
    var l = b6(this._isDirected, t, n, o)
    return (t = l.v), (n = l.w), Object.freeze(l), (this._edgeObjs[a] = l), Zp(this._preds[n], t), Zp(this._sucs[t], n), (this._in[n][a] = l), (this._out[t][a] = l), this._edgeCount++, this
  }
  /**
   * Gets the label for the specified edge.
   * Complexity: O(1).
   */
  edge(t, n, o) {
    var r = arguments.length === 1 ? Mc(this._isDirected, arguments[0]) : bi(this._isDirected, t, n, o)
    return this._edgeLabels[r]
  }
  /**
   * Gets the label for the specified edge and converts it to an object.
   * Complexity: O(1)
   */
  edgeAsObj() {
    const t = this.edge(...arguments)
    return typeof t != 'object' ? { label: t } : t
  }
  /**
   * Detects whether the graph contains specified edge or not. No subgraphs are considered.
   * Complexity: O(1).
   */
  hasEdge(t, n, o) {
    var r = arguments.length === 1 ? Mc(this._isDirected, arguments[0]) : bi(this._isDirected, t, n, o)
    return Object.hasOwn(this._edgeLabels, r)
  }
  /**
   * Removes the specified edge from the graph. No subgraphs are considered.
   * Complexity: O(1).
   */
  removeEdge(t, n, o) {
    var r = arguments.length === 1 ? Mc(this._isDirected, arguments[0]) : bi(this._isDirected, t, n, o),
      i = this._edgeObjs[r]
    return i && ((t = i.v), (n = i.w), delete this._edgeLabels[r], delete this._edgeObjs[r], Jp(this._preds[n], t), Jp(this._sucs[t], n), delete this._in[n][r], delete this._out[t][r], this._edgeCount--), this
  }
  /**
   * Return all edges that point to the node v. Optionally filters those edges down to just those
   * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  inEdges(t, n) {
    var o = this._in[t]
    if (o) {
      var r = Object.values(o)
      return n ? r.filter(i => i.v === n) : r
    }
  }
  /**
   * Return all edges that are pointed at by node v. Optionally filters those edges down to just
   * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  outEdges(t, n) {
    var o = this._out[t]
    if (o) {
      var r = Object.values(o)
      return n ? r.filter(i => i.w === n) : r
    }
  }
  /**
   * Returns all edges to or from node v regardless of direction. Optionally filters those edges
   * down to just those between nodes v and w regardless of direction.
   * Complexity: O(|E|).
   */
  nodeEdges(t, n) {
    var o = this.inEdges(t, n)
    if (o) return o.concat(this.outEdges(t, n))
  }
}
function Zp(e, t) {
  e[t] ? e[t]++ : (e[t] = 1)
}
function Jp(e, t) {
  --e[t] || delete e[t]
}
function bi(e, t, n, o) {
  var r = '' + t,
    i = '' + n
  if (!e && r > i) {
    var s = r
    ;(r = i), (i = s)
  }
  return r + qp + i + qp + (o === void 0 ? m6 : o)
}
function b6(e, t, n, o) {
  var r = '' + t,
    i = '' + n
  if (!e && r > i) {
    var s = r
    ;(r = i), (i = s)
  }
  var a = { v: r, w: i }
  return o && (a.name = o), a
}
function Mc(e, t) {
  return bi(e, t.v, t.w, t.name)
}
var _d = y6,
  v6 = '2.2.4',
  x6 = {
    Graph: _d,
    version: v6,
  },
  C6 = _d,
  w6 = {
    write: E6,
    read: I6,
  }
function E6(e) {
  var t = {
    options: {
      directed: e.isDirected(),
      multigraph: e.isMultigraph(),
      compound: e.isCompound(),
    },
    nodes: S6(e),
    edges: B6(e),
  }
  return e.graph() !== void 0 && (t.value = structuredClone(e.graph())), t
}
function S6(e) {
  return e.nodes().map(function (t) {
    var n = e.node(t),
      o = e.parent(t),
      r = { v: t }
    return n !== void 0 && (r.value = n), o !== void 0 && (r.parent = o), r
  })
}
function B6(e) {
  return e.edges().map(function (t) {
    var n = e.edge(t),
      o = { v: t.v, w: t.w }
    return t.name !== void 0 && (o.name = t.name), n !== void 0 && (o.value = n), o
  })
}
function I6(e) {
  var t = new C6(e.options).setGraph(e.value)
  return (
    e.nodes.forEach(function (n) {
      t.setNode(n.v, n.value), n.parent && t.setParent(n.v, n.parent)
    }),
    e.edges.forEach(function (n) {
      t.setEdge({ v: n.v, w: n.w, name: n.name }, n.value)
    }),
    t
  )
}
var N6 = k6
function k6(e) {
  var t = {},
    n = [],
    o
  function r(i) {
    Object.hasOwn(t, i) || ((t[i] = !0), o.push(i), e.successors(i).forEach(r), e.predecessors(i).forEach(r))
  }
  return (
    e.nodes().forEach(function (i) {
      ;(o = []), r(i), o.length && n.push(o)
    }),
    n
  )
}
let M6 = class {
  constructor() {
    gt(this, '_arr', [])
    gt(this, '_keyIndices', {})
  }
  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length
  }
  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(function (t) {
      return t.key
    })
  }
  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(t) {
    return Object.hasOwn(this._keyIndices, t)
  }
  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   *
   * @param {Object} key
   */
  priority(t) {
    var n = this._keyIndices[t]
    if (n !== void 0) return this._arr[n].priority
  }
  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if (this.size() === 0) throw new Error('Queue underflow')
    return this._arr[0].key
  }
  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param {Object} key the key to add
   * @param {Number} priority the initial priority for the key
   */
  add(t, n) {
    var o = this._keyIndices
    if (((t = String(t)), !Object.hasOwn(o, t))) {
      var r = this._arr,
        i = r.length
      return (o[t] = i), r.push({ key: t, priority: n }), this._decrease(i), !0
    }
    return !1
  }
  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1)
    var t = this._arr.pop()
    return delete this._keyIndices[t.key], this._heapify(0), t.key
  }
  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param {Object} key the key for which to raise priority
   * @param {Number} priority the new priority for the key
   */
  decrease(t, n) {
    var o = this._keyIndices[t]
    if (n > this._arr[o].priority) throw new Error('New priority is greater than current priority. Key: ' + t + ' Old: ' + this._arr[o].priority + ' New: ' + n)
    ;(this._arr[o].priority = n), this._decrease(o)
  }
  _heapify(t) {
    var n = this._arr,
      o = 2 * t,
      r = o + 1,
      i = t
    o < n.length && ((i = n[o].priority < n[i].priority ? o : i), r < n.length && (i = n[r].priority < n[i].priority ? r : i), i !== t && (this._swap(t, i), this._heapify(i)))
  }
  _decrease(t) {
    for (var n = this._arr, o = n[t].priority, r; t !== 0 && ((r = t >> 1), !(n[r].priority < o)); ) this._swap(t, r), (t = r)
  }
  _swap(t, n) {
    var o = this._arr,
      r = this._keyIndices,
      i = o[t],
      s = o[n]
    ;(o[t] = s), (o[n] = i), (r[s.key] = t), (r[i.key] = n)
  }
}
var Vy = M6,
  P6 = Vy,
  Xy = R6,
  L6 = () => 1
function R6(e, t, n, o) {
  return T6(
    e,
    String(t),
    n || L6,
    o ||
      function (r) {
        return e.outEdges(r)
      }
  )
}
function T6(e, t, n, o) {
  var r = {},
    i = new P6(),
    s,
    a,
    l = function (c) {
      var u = c.v !== s ? c.v : c.w,
        d = r[u],
        f = n(c),
        A = a.distance + f
      if (f < 0) throw new Error('dijkstra does not allow negative edge weights. Bad edge: ' + c + ' Weight: ' + f)
      A < d.distance && ((d.distance = A), (d.predecessor = s), i.decrease(u, A))
    }
  for (
    e.nodes().forEach(function (c) {
      var u = c === t ? 0 : Number.POSITIVE_INFINITY
      ;(r[c] = { distance: u }), i.add(c, u)
    });
    i.size() > 0 && ((s = i.removeMin()), (a = r[s]), a.distance !== Number.POSITIVE_INFINITY);

  )
    o(s).forEach(l)
  return r
}
var F6 = Xy,
  D6 = z6
function z6(e, t, n) {
  return e.nodes().reduce(function (o, r) {
    return (o[r] = F6(e, r, t, n)), o
  }, {})
}
var Yy = Q6
function Q6(e) {
  var t = 0,
    n = [],
    o = {},
    r = []
  function i(s) {
    var a = (o[s] = {
      onStack: !0,
      lowlink: t,
      index: t++,
    })
    if (
      (n.push(s),
      e.successors(s).forEach(function (u) {
        Object.hasOwn(o, u) ? o[u].onStack && (a.lowlink = Math.min(a.lowlink, o[u].index)) : (i(u), (a.lowlink = Math.min(a.lowlink, o[u].lowlink)))
      }),
      a.lowlink === a.index)
    ) {
      var l = [],
        c
      do (c = n.pop()), (o[c].onStack = !1), l.push(c)
      while (s !== c)
      r.push(l)
    }
  }
  return (
    e.nodes().forEach(function (s) {
      Object.hasOwn(o, s) || i(s)
    }),
    r
  )
}
var O6 = Yy,
  j6 = W6
function W6(e) {
  return O6(e).filter(function (t) {
    return t.length > 1 || (t.length === 1 && e.hasEdge(t[0], t[0]))
  })
}
var G6 = X6,
  V6 = () => 1
function X6(e, t, n) {
  return Y6(
    e,
    t || V6,
    n ||
      function (o) {
        return e.outEdges(o)
      }
  )
}
function Y6(e, t, n) {
  var o = {},
    r = e.nodes()
  return (
    r.forEach(function (i) {
      ;(o[i] = {}),
        (o[i][i] = { distance: 0 }),
        r.forEach(function (s) {
          i !== s && (o[i][s] = { distance: Number.POSITIVE_INFINITY })
        }),
        n(i).forEach(function (s) {
          var a = s.v === i ? s.w : s.v,
            l = t(s)
          o[i][a] = { distance: l, predecessor: i }
        })
    }),
    r.forEach(function (i) {
      var s = o[i]
      r.forEach(function (a) {
        var l = o[a]
        r.forEach(function (c) {
          var u = l[i],
            d = s[c],
            f = l[c],
            A = u.distance + d.distance
          A < f.distance && ((f.distance = A), (f.predecessor = d.predecessor))
        })
      })
    }),
    o
  )
}
function Hy(e) {
  var t = {},
    n = {},
    o = []
  function r(i) {
    if (Object.hasOwn(n, i)) throw new Tu()
    Object.hasOwn(t, i) || ((n[i] = !0), (t[i] = !0), e.predecessors(i).forEach(r), delete n[i], o.push(i))
  }
  if ((e.sinks().forEach(r), Object.keys(t).length !== e.nodeCount())) throw new Tu()
  return o
}
class Tu extends Error {
  constructor() {
    super(...arguments)
  }
}
var Uy = Hy
Hy.CycleException = Tu
var _p = Uy,
  H6 = U6
function U6(e) {
  try {
    _p(e)
  } catch (t) {
    if (t instanceof _p.CycleException) return !1
    throw t
  }
  return !0
}
var Ky = K6
function K6(e, t, n) {
  Array.isArray(t) || (t = [t])
  var o = e.isDirected() ? a => e.successors(a) : a => e.neighbors(a),
    r = n === 'post' ? q6 : Z6,
    i = [],
    s = {}
  return (
    t.forEach(a => {
      if (!e.hasNode(a)) throw new Error('Graph does not have node: ' + a)
      r(a, o, s, i)
    }),
    i
  )
}
function q6(e, t, n, o) {
  for (var r = [[e, !1]]; r.length > 0; ) {
    var i = r.pop()
    i[1] ? o.push(i[0]) : Object.hasOwn(n, i[0]) || ((n[i[0]] = !0), r.push([i[0], !0]), qy(t(i[0]), s => r.push([s, !1])))
  }
}
function Z6(e, t, n, o) {
  for (var r = [e]; r.length > 0; ) {
    var i = r.pop()
    Object.hasOwn(n, i) || ((n[i] = !0), o.push(i), qy(t(i), s => r.push(s)))
  }
}
function qy(e, t) {
  for (var n = e.length; n--; ) t(e[n], n, e)
  return e
}
var J6 = Ky,
  _6 = $6
function $6(e, t) {
  return J6(e, t, 'post')
}
var e4 = Ky,
  t4 = n4
function n4(e, t) {
  return e4(e, t, 'pre')
}
var o4 = _d,
  r4 = Vy,
  i4 = s4
function s4(e, t) {
  var n = new o4(),
    o = {},
    r = new r4(),
    i
  function s(l) {
    var c = l.v === i ? l.w : l.v,
      u = r.priority(c)
    if (u !== void 0) {
      var d = t(l)
      d < u && ((o[c] = i), r.decrease(c, d))
    }
  }
  if (e.nodeCount() === 0) return n
  e.nodes().forEach(function (l) {
    r.add(l, Number.POSITIVE_INFINITY), n.setNode(l)
  }),
    r.decrease(e.nodes()[0], 0)
  for (var a = !1; r.size() > 0; ) {
    if (((i = r.removeMin()), Object.hasOwn(o, i))) n.setEdge(i, o[i])
    else {
      if (a) throw new Error('Input graph is not connected: ' + e)
      a = !0
    }
    e.nodeEdges(i).forEach(s)
  }
  return n
}
var a4 = {
    components: N6,
    dijkstra: Xy,
    dijkstraAll: D6,
    findCycles: j6,
    floydWarshall: G6,
    isAcyclic: H6,
    postorder: _6,
    preorder: t4,
    prim: i4,
    tarjan: Yy,
    topsort: Uy,
  },
  $p = x6,
  xn = {
    Graph: $p.Graph,
    json: w6,
    alg: a4,
    version: $p.version,
  }
let l4 = class {
  constructor() {
    let t = {}
    ;(t._next = t._prev = t), (this._sentinel = t)
  }
  dequeue() {
    let t = this._sentinel,
      n = t._prev
    if (n !== t) return eh(n), n
  }
  enqueue(t) {
    let n = this._sentinel
    t._prev && t._next && eh(t), (t._next = n._next), (n._next._prev = t), (n._next = t), (t._prev = n)
  }
  toString() {
    let t = [],
      n = this._sentinel,
      o = n._prev
    for (; o !== n; ) t.push(JSON.stringify(o, c4)), (o = o._prev)
    return '[' + t.join(', ') + ']'
  }
}
function eh(e) {
  ;(e._prev._next = e._next), (e._next._prev = e._prev), delete e._next, delete e._prev
}
function c4(e, t) {
  if (e !== '_next' && e !== '_prev') return t
}
var u4 = l4
let d4 = xn.Graph,
  f4 = u4
var A4 = h4
let p4 = () => 1
function h4(e, t) {
  if (e.nodeCount() <= 1) return []
  let n = m4(e, t || p4)
  return g4(n.graph, n.buckets, n.zeroIdx).flatMap(r => e.outEdges(r.v, r.w))
}
function g4(e, t, n) {
  let o = [],
    r = t[t.length - 1],
    i = t[0],
    s
  for (; e.nodeCount(); ) {
    for (; (s = i.dequeue()); ) Pc(e, t, n, s)
    for (; (s = r.dequeue()); ) Pc(e, t, n, s)
    if (e.nodeCount()) {
      for (let a = t.length - 2; a > 0; --a)
        if (((s = t[a].dequeue()), s)) {
          o = o.concat(Pc(e, t, n, s, !0))
          break
        }
    }
  }
  return o
}
function Pc(e, t, n, o, r) {
  let i = r ? [] : void 0
  return (
    e.inEdges(o.v).forEach(s => {
      let a = e.edge(s),
        l = e.node(s.v)
      r && i.push({ v: s.v, w: s.w }), (l.out -= a), Fu(t, n, l)
    }),
    e.outEdges(o.v).forEach(s => {
      let a = e.edge(s),
        l = s.w,
        c = e.node(l)
      ;(c.in -= a), Fu(t, n, c)
    }),
    e.removeNode(o.v),
    i
  )
}
function m4(e, t) {
  let n = new d4(),
    o = 0,
    r = 0
  e.nodes().forEach(a => {
    n.setNode(a, { v: a, in: 0, out: 0 })
  }),
    e.edges().forEach(a => {
      let l = n.edge(a.v, a.w) || 0,
        c = t(a),
        u = l + c
      n.setEdge(a.v, a.w, u), (r = Math.max(r, (n.node(a.v).out += c))), (o = Math.max(o, (n.node(a.w).in += c)))
    })
  let i = y4(r + o + 3).map(() => new f4()),
    s = o + 1
  return (
    n.nodes().forEach(a => {
      Fu(i, s, n.node(a))
    }),
    { graph: n, buckets: i, zeroIdx: s }
  )
}
function Fu(e, t, n) {
  n.out ? (n.in ? e[n.out - n.in + t].enqueue(n) : e[e.length - 1].enqueue(n)) : e[0].enqueue(n)
}
function y4(e) {
  const t = []
  for (let n = 0; n < e; n++) t.push(n)
  return t
}
let Zy = xn.Graph
var yt = {
  addBorderNode: I4,
  addDummyNode: Jy,
  applyWithChunking: Kl,
  asNonCompoundGraph: v4,
  buildLayerMatrix: E4,
  intersectRect: w4,
  mapValues: T4,
  maxRank: $y,
  normalizeRanks: S4,
  notime: P4,
  partition: k4,
  pick: R4,
  predecessorWeights: C4,
  range: tb,
  removeEmptyRanks: B4,
  simplify: b4,
  successorWeights: x4,
  time: M4,
  uniqueId: eb,
  zipObject: $d,
}
function Jy(e, t, n, o) {
  let r
  do r = eb(o)
  while (e.hasNode(r))
  return (n.dummy = t), e.setNode(r, n), r
}
function b4(e) {
  let t = new Zy().setGraph(e.graph())
  return (
    e.nodes().forEach(n => t.setNode(n, e.node(n))),
    e.edges().forEach(n => {
      let o = t.edge(n.v, n.w) || { weight: 0, minlen: 1 },
        r = e.edge(n)
      t.setEdge(n.v, n.w, {
        weight: o.weight + r.weight,
        minlen: Math.max(o.minlen, r.minlen),
      })
    }),
    t
  )
}
function v4(e) {
  let t = new Zy({ multigraph: e.isMultigraph() }).setGraph(e.graph())
  return (
    e.nodes().forEach(n => {
      e.children(n).length || t.setNode(n, e.node(n))
    }),
    e.edges().forEach(n => {
      t.setEdge(n, e.edge(n))
    }),
    t
  )
}
function x4(e) {
  let t = e.nodes().map(n => {
    let o = {}
    return (
      e.outEdges(n).forEach(r => {
        o[r.w] = (o[r.w] || 0) + e.edge(r).weight
      }),
      o
    )
  })
  return $d(e.nodes(), t)
}
function C4(e) {
  let t = e.nodes().map(n => {
    let o = {}
    return (
      e.inEdges(n).forEach(r => {
        o[r.v] = (o[r.v] || 0) + e.edge(r).weight
      }),
      o
    )
  })
  return $d(e.nodes(), t)
}
function w4(e, t) {
  let n = e.x,
    o = e.y,
    r = t.x - n,
    i = t.y - o,
    s = e.width / 2,
    a = e.height / 2
  if (!r && !i) throw new Error('Not possible to find intersection inside of the rectangle')
  let l, c
  return Math.abs(i) * s > Math.abs(r) * a ? (i < 0 && (a = -a), (l = (a * r) / i), (c = a)) : (r < 0 && (s = -s), (l = s), (c = (s * i) / r)), { x: n + l, y: o + c }
}
function E4(e) {
  let t = tb($y(e) + 1).map(() => [])
  return (
    e.nodes().forEach(n => {
      let o = e.node(n),
        r = o.rank
      r !== void 0 && (t[r][o.order] = n)
    }),
    t
  )
}
function S4(e) {
  let t = e.nodes().map(o => {
      let r = e.node(o).rank
      return r === void 0 ? Number.MAX_VALUE : r
    }),
    n = Kl(Math.min, t)
  e.nodes().forEach(o => {
    let r = e.node(o)
    Object.hasOwn(r, 'rank') && (r.rank -= n)
  })
}
function B4(e) {
  let t = e.nodes().map(s => e.node(s).rank),
    n = Kl(Math.min, t),
    o = []
  e.nodes().forEach(s => {
    let a = e.node(s).rank - n
    o[a] || (o[a] = []), o[a].push(s)
  })
  let r = 0,
    i = e.graph().nodeRankFactor
  Array.from(o).forEach((s, a) => {
    s === void 0 && a % i !== 0 ? --r : s !== void 0 && r && s.forEach(l => (e.node(l).rank += r))
  })
}
function I4(e, t, n, o) {
  let r = {
    width: 0,
    height: 0,
  }
  return arguments.length >= 4 && ((r.rank = n), (r.order = o)), Jy(e, 'border', r, t)
}
function N4(e, t = _y) {
  const n = []
  for (let o = 0; o < e.length; o += t) {
    const r = e.slice(o, o + t)
    n.push(r)
  }
  return n
}
const _y = 65535
function Kl(e, t) {
  if (t.length > _y) {
    const n = N4(t)
    return e.apply(
      null,
      n.map(o => e.apply(null, o))
    )
  } else return e.apply(null, t)
}
function $y(e) {
  const n = e.nodes().map(o => {
    let r = e.node(o).rank
    return r === void 0 ? Number.MIN_VALUE : r
  })
  return Kl(Math.max, n)
}
function k4(e, t) {
  let n = { lhs: [], rhs: [] }
  return (
    e.forEach(o => {
      t(o) ? n.lhs.push(o) : n.rhs.push(o)
    }),
    n
  )
}
function M4(e, t) {
  let n = Date.now()
  try {
    return t()
  } finally {
    console.log(e + ' time: ' + (Date.now() - n) + 'ms')
  }
}
function P4(e, t) {
  return t()
}
let L4 = 0
function eb(e) {
  var t = ++L4
  return toString(e) + t
}
function tb(e, t, n = 1) {
  t == null && ((t = e), (e = 0))
  let o = i => i < t
  n < 0 && (o = i => t < i)
  const r = []
  for (let i = e; o(i); i += n) r.push(i)
  return r
}
function R4(e, t) {
  const n = {}
  for (const o of t) e[o] !== void 0 && (n[o] = e[o])
  return n
}
function T4(e, t) {
  let n = t
  return typeof t == 'string' && (n = o => o[t]), Object.entries(e).reduce((o, [r, i]) => ((o[r] = n(i, r)), o), {})
}
function $d(e, t) {
  return e.reduce((n, o, r) => ((n[o] = t[r]), n), {})
}
let F4 = A4,
  D4 = yt.uniqueId
var z4 = {
  run: Q4,
  undo: j4,
}
function Q4(e) {
  ;(e.graph().acyclicer === 'greedy' ? F4(e, n(e)) : O4(e)).forEach(o => {
    let r = e.edge(o)
    e.removeEdge(o), (r.forwardName = o.name), (r.reversed = !0), e.setEdge(o.w, o.v, r, D4('rev'))
  })
  function n(o) {
    return r => o.edge(r).weight
  }
}
function O4(e) {
  let t = [],
    n = {},
    o = {}
  function r(i) {
    Object.hasOwn(o, i) ||
      ((o[i] = !0),
      (n[i] = !0),
      e.outEdges(i).forEach(s => {
        Object.hasOwn(n, s.w) ? t.push(s) : r(s.w)
      }),
      delete n[i])
  }
  return e.nodes().forEach(r), t
}
function j4(e) {
  e.edges().forEach(t => {
    let n = e.edge(t)
    if (n.reversed) {
      e.removeEdge(t)
      let o = n.forwardName
      delete n.reversed, delete n.forwardName, e.setEdge(t.w, t.v, n, o)
    }
  })
}
let W4 = yt
var G4 = {
  run: V4,
  undo: Y4,
}
function V4(e) {
  ;(e.graph().dummyChains = []), e.edges().forEach(t => X4(e, t))
}
function X4(e, t) {
  let n = t.v,
    o = e.node(n).rank,
    r = t.w,
    i = e.node(r).rank,
    s = t.name,
    a = e.edge(t),
    l = a.labelRank
  if (i === o + 1) return
  e.removeEdge(t)
  let c, u, d
  for (d = 0, ++o; o < i; ++d, ++o)
    (a.points = []),
      (u = {
        width: 0,
        height: 0,
        edgeLabel: a,
        edgeObj: t,
        rank: o,
      }),
      (c = W4.addDummyNode(e, 'edge', u, '_d')),
      o === l && ((u.width = a.width), (u.height = a.height), (u.dummy = 'edge-label'), (u.labelpos = a.labelpos)),
      e.setEdge(n, c, { weight: a.weight }, s),
      d === 0 && e.graph().dummyChains.push(c),
      (n = c)
  e.setEdge(n, r, { weight: a.weight }, s)
}
function Y4(e) {
  e.graph().dummyChains.forEach(t => {
    let n = e.node(t),
      o = n.edgeLabel,
      r
    for (e.setEdge(n.edgeObj, o); n.dummy; ) (r = e.successors(t)[0]), e.removeNode(t), o.points.push({ x: n.x, y: n.y }), n.dummy === 'edge-label' && ((o.x = n.x), (o.y = n.y), (o.width = n.width), (o.height = n.height)), (t = r), (n = e.node(t))
  })
}
const { applyWithChunking: H4 } = yt
var ql = {
  longestPath: U4,
  slack: K4,
}
function U4(e) {
  var t = {}
  function n(o) {
    var r = e.node(o)
    if (Object.hasOwn(t, o)) return r.rank
    t[o] = !0
    let i = e.outEdges(o).map(a => (a == null ? Number.POSITIVE_INFINITY : n(a.w) - e.edge(a).minlen))
    var s = H4(Math.min, i)
    return s === Number.POSITIVE_INFINITY && (s = 0), (r.rank = s)
  }
  e.sources().forEach(n)
}
function K4(e, t) {
  return e.node(t.w).rank - e.node(t.v).rank - e.edge(t).minlen
}
var q4 = xn.Graph,
  Ia = ql.slack,
  nb = Z4
function Z4(e) {
  var t = new q4({ directed: !1 }),
    n = e.nodes()[0],
    o = e.nodeCount()
  t.setNode(n, {})
  for (var r, i; J4(t, e) < o; ) (r = _4(t, e)), (i = t.hasNode(r.v) ? Ia(e, r) : -Ia(e, r)), $4(t, e, i)
  return t
}
function J4(e, t) {
  function n(o) {
    t.nodeEdges(o).forEach(r => {
      var i = r.v,
        s = o === i ? r.w : i
      !e.hasNode(s) && !Ia(t, r) && (e.setNode(s, {}), e.setEdge(o, s, {}), n(s))
    })
  }
  return e.nodes().forEach(n), e.nodeCount()
}
function _4(e, t) {
  return t.edges().reduce(
    (o, r) => {
      let i = Number.POSITIVE_INFINITY
      return e.hasNode(r.v) !== e.hasNode(r.w) && (i = Ia(t, r)), i < o[0] ? [i, r] : o
    },
    [Number.POSITIVE_INFINITY, null]
  )[1]
}
function $4(e, t, n) {
  e.nodes().forEach(o => (t.node(o).rank += n))
}
var ej = nb,
  th = ql.slack,
  tj = ql.longestPath,
  nj = xn.alg.preorder,
  oj = xn.alg.postorder,
  rj = yt.simplify,
  ij = tr
tr.initLowLimValues = tf
tr.initCutValues = ef
tr.calcCutValue = ob
tr.leaveEdge = ib
tr.enterEdge = sb
tr.exchangeEdges = ab
function tr(e) {
  ;(e = rj(e)), tj(e)
  var t = ej(e)
  tf(t), ef(t, e)
  for (var n, o; (n = ib(t)); ) (o = sb(t, e, n)), ab(t, e, n, o)
}
function ef(e, t) {
  var n = oj(e, e.nodes())
  ;(n = n.slice(0, n.length - 1)), n.forEach(o => sj(e, t, o))
}
function sj(e, t, n) {
  var o = e.node(n),
    r = o.parent
  e.edge(n, r).cutvalue = ob(e, t, n)
}
function ob(e, t, n) {
  var o = e.node(n),
    r = o.parent,
    i = !0,
    s = t.edge(n, r),
    a = 0
  return (
    s || ((i = !1), (s = t.edge(r, n))),
    (a = s.weight),
    t.nodeEdges(n).forEach(l => {
      var c = l.v === n,
        u = c ? l.w : l.v
      if (u !== r) {
        var d = c === i,
          f = t.edge(l).weight
        if (((a += d ? f : -f), lj(e, n, u))) {
          var A = e.edge(n, u).cutvalue
          a += d ? -A : A
        }
      }
    }),
    a
  )
}
function tf(e, t) {
  arguments.length < 2 && (t = e.nodes()[0]), rb(e, {}, 1, t)
}
function rb(e, t, n, o, r) {
  var i = n,
    s = e.node(o)
  return (
    (t[o] = !0),
    e.neighbors(o).forEach(a => {
      Object.hasOwn(t, a) || (n = rb(e, t, n, a, o))
    }),
    (s.low = i),
    (s.lim = n++),
    r ? (s.parent = r) : delete s.parent,
    n
  )
}
function ib(e) {
  return e.edges().find(t => e.edge(t).cutvalue < 0)
}
function sb(e, t, n) {
  var o = n.v,
    r = n.w
  t.hasEdge(o, r) || ((o = n.w), (r = n.v))
  var i = e.node(o),
    s = e.node(r),
    a = i,
    l = !1
  i.lim > s.lim && ((a = s), (l = !0))
  var c = t.edges().filter(u => l === nh(e, e.node(u.v), a) && l !== nh(e, e.node(u.w), a))
  return c.reduce((u, d) => (th(t, d) < th(t, u) ? d : u))
}
function ab(e, t, n, o) {
  var r = n.v,
    i = n.w
  e.removeEdge(r, i), e.setEdge(o.v, o.w, {}), tf(e), ef(e, t), aj(e, t)
}
function aj(e, t) {
  var n = e.nodes().find(r => !t.node(r).parent),
    o = nj(e, n)
  ;(o = o.slice(1)),
    o.forEach(r => {
      var i = e.node(r).parent,
        s = t.edge(r, i),
        a = !1
      s || ((s = t.edge(i, r)), (a = !0)), (t.node(r).rank = t.node(i).rank + (a ? s.minlen : -s.minlen))
    })
}
function lj(e, t, n) {
  return e.hasEdge(t, n)
}
function nh(e, t, n) {
  return n.low <= t.lim && t.lim <= n.lim
}
var cj = ql,
  lb = cj.longestPath,
  uj = nb,
  dj = ij,
  fj = Aj
function Aj(e) {
  switch (e.graph().ranker) {
    case 'network-simplex':
      oh(e)
      break
    case 'tight-tree':
      hj(e)
      break
    case 'longest-path':
      pj(e)
      break
    default:
      oh(e)
  }
}
var pj = lb
function hj(e) {
  lb(e), uj(e)
}
function oh(e) {
  dj(e)
}
var gj = mj
function mj(e) {
  let t = bj(e)
  e.graph().dummyChains.forEach(n => {
    let o = e.node(n),
      r = o.edgeObj,
      i = yj(e, t, r.v, r.w),
      s = i.path,
      a = i.lca,
      l = 0,
      c = s[l],
      u = !0
    for (; n !== r.w; ) {
      if (((o = e.node(n)), u)) {
        for (; (c = s[l]) !== a && e.node(c).maxRank < o.rank; ) l++
        c === a && (u = !1)
      }
      if (!u) {
        for (; l < s.length - 1 && e.node((c = s[l + 1])).minRank <= o.rank; ) l++
        c = s[l]
      }
      e.setParent(n, c), (n = e.successors(n)[0])
    }
  })
}
function yj(e, t, n, o) {
  let r = [],
    i = [],
    s = Math.min(t[n].low, t[o].low),
    a = Math.max(t[n].lim, t[o].lim),
    l,
    c
  l = n
  do (l = e.parent(l)), r.push(l)
  while (l && (t[l].low > s || a > t[l].lim))
  for (c = l, l = o; (l = e.parent(l)) !== c; ) i.push(l)
  return { path: r.concat(i.reverse()), lca: c }
}
function bj(e) {
  let t = {},
    n = 0
  function o(r) {
    let i = n
    e.children(r).forEach(o), (t[r] = { low: i, lim: n++ })
  }
  return e.children().forEach(o), t
}
let Na = yt
var vj = {
  run: xj,
  cleanup: Ej,
}
function xj(e) {
  let t = Na.addDummyNode(e, 'root', {}, '_root'),
    n = Cj(e),
    o = Object.values(n),
    r = Na.applyWithChunking(Math.max, o) - 1,
    i = 2 * r + 1
  ;(e.graph().nestingRoot = t), e.edges().forEach(a => (e.edge(a).minlen *= i))
  let s = wj(e) + 1
  e.children().forEach(a => cb(e, t, i, s, r, n, a)), (e.graph().nodeRankFactor = i)
}
function cb(e, t, n, o, r, i, s) {
  let a = e.children(s)
  if (!a.length) {
    s !== t && e.setEdge(t, s, { weight: 0, minlen: n })
    return
  }
  let l = Na.addBorderNode(e, '_bt'),
    c = Na.addBorderNode(e, '_bb'),
    u = e.node(s)
  e.setParent(l, s),
    (u.borderTop = l),
    e.setParent(c, s),
    (u.borderBottom = c),
    a.forEach(d => {
      cb(e, t, n, o, r, i, d)
      let f = e.node(d),
        A = f.borderTop ? f.borderTop : d,
        h = f.borderBottom ? f.borderBottom : d,
        g = f.borderTop ? o : 2 * o,
        x = A !== h ? 1 : r - i[s] + 1
      e.setEdge(l, A, {
        weight: g,
        minlen: x,
        nestingEdge: !0,
      }),
        e.setEdge(h, c, {
          weight: g,
          minlen: x,
          nestingEdge: !0,
        })
    }),
    e.parent(s) || e.setEdge(t, l, { weight: 0, minlen: r + i[s] })
}
function Cj(e) {
  var t = {}
  function n(o, r) {
    var i = e.children(o)
    i && i.length && i.forEach(s => n(s, r + 1)), (t[o] = r)
  }
  return e.children().forEach(o => n(o, 1)), t
}
function wj(e) {
  return e.edges().reduce((t, n) => t + e.edge(n).weight, 0)
}
function Ej(e) {
  var t = e.graph()
  e.removeNode(t.nestingRoot),
    delete t.nestingRoot,
    e.edges().forEach(n => {
      var o = e.edge(n)
      o.nestingEdge && e.removeEdge(n)
    })
}
let Sj = yt
var Bj = Ij
function Ij(e) {
  function t(n) {
    let o = e.children(n),
      r = e.node(n)
    if ((o.length && o.forEach(t), Object.hasOwn(r, 'minRank'))) {
      ;(r.borderLeft = []), (r.borderRight = [])
      for (let i = r.minRank, s = r.maxRank + 1; i < s; ++i) rh(e, 'borderLeft', '_bl', n, r, i), rh(e, 'borderRight', '_br', n, r, i)
    }
  }
  e.children().forEach(t)
}
function rh(e, t, n, o, r, i) {
  let s = { width: 0, height: 0, rank: i, borderType: t },
    a = r[t][i - 1],
    l = Sj.addDummyNode(e, 'border', s, n)
  ;(r[t][i] = l), e.setParent(l, o), a && e.setEdge(a, l, { weight: 1 })
}
var Nj = {
  adjust: kj,
  undo: Mj,
}
function kj(e) {
  let t = e.graph().rankdir.toLowerCase()
  ;(t === 'lr' || t === 'rl') && ub(e)
}
function Mj(e) {
  let t = e.graph().rankdir.toLowerCase()
  ;(t === 'bt' || t === 'rl') && Pj(e), (t === 'lr' || t === 'rl') && (Lj(e), ub(e))
}
function ub(e) {
  e.nodes().forEach(t => ih(e.node(t))), e.edges().forEach(t => ih(e.edge(t)))
}
function ih(e) {
  let t = e.width
  ;(e.width = e.height), (e.height = t)
}
function Pj(e) {
  e.nodes().forEach(t => Lc(e.node(t))),
    e.edges().forEach(t => {
      let n = e.edge(t)
      n.points.forEach(Lc), Object.hasOwn(n, 'y') && Lc(n)
    })
}
function Lc(e) {
  e.y = -e.y
}
function Lj(e) {
  e.nodes().forEach(t => Rc(e.node(t))),
    e.edges().forEach(t => {
      let n = e.edge(t)
      n.points.forEach(Rc), Object.hasOwn(n, 'x') && Rc(n)
    })
}
function Rc(e) {
  let t = e.x
  ;(e.x = e.y), (e.y = t)
}
let sh = yt
var Rj = Tj
function Tj(e) {
  let t = {},
    n = e.nodes().filter(l => !e.children(l).length),
    o = n.map(l => e.node(l).rank),
    r = sh.applyWithChunking(Math.max, o),
    i = sh.range(r + 1).map(() => [])
  function s(l) {
    if (t[l]) return
    t[l] = !0
    let c = e.node(l)
    i[c.rank].push(l), e.successors(l).forEach(s)
  }
  return n.sort((l, c) => e.node(l).rank - e.node(c).rank).forEach(s), i
}
let Fj = yt.zipObject
var Dj = zj
function zj(e, t) {
  let n = 0
  for (let o = 1; o < t.length; ++o) n += Qj(e, t[o - 1], t[o])
  return n
}
function Qj(e, t, n) {
  let o = Fj(
      n,
      n.map((c, u) => u)
    ),
    r = t.flatMap(c =>
      e
        .outEdges(c)
        .map(u => ({ pos: o[u.w], weight: e.edge(u).weight }))
        .sort((u, d) => u.pos - d.pos)
    ),
    i = 1
  for (; i < n.length; ) i <<= 1
  let s = 2 * i - 1
  i -= 1
  let a = new Array(s).fill(0),
    l = 0
  return (
    r.forEach(c => {
      let u = c.pos + i
      a[u] += c.weight
      let d = 0
      for (; u > 0; ) u % 2 && (d += a[u + 1]), (u = (u - 1) >> 1), (a[u] += c.weight)
      l += c.weight * d
    }),
    l
  )
}
var Oj = jj
function jj(e, t = []) {
  return t.map(n => {
    let o = e.inEdges(n)
    if (o.length) {
      let r = o.reduce(
        (i, s) => {
          let a = e.edge(s),
            l = e.node(s.v)
          return {
            sum: i.sum + a.weight * l.order,
            weight: i.weight + a.weight,
          }
        },
        { sum: 0, weight: 0 }
      )
      return {
        v: n,
        barycenter: r.sum / r.weight,
        weight: r.weight,
      }
    } else return { v: n }
  })
}
let Wj = yt
var Gj = Vj
function Vj(e, t) {
  let n = {}
  e.forEach((r, i) => {
    let s = (n[r.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [r.v],
      i,
    })
    r.barycenter !== void 0 && ((s.barycenter = r.barycenter), (s.weight = r.weight))
  }),
    t.edges().forEach(r => {
      let i = n[r.v],
        s = n[r.w]
      i !== void 0 && s !== void 0 && (s.indegree++, i.out.push(n[r.w]))
    })
  let o = Object.values(n).filter(r => !r.indegree)
  return Xj(o)
}
function Xj(e) {
  let t = []
  function n(r) {
    return i => {
      i.merged || ((i.barycenter === void 0 || r.barycenter === void 0 || i.barycenter >= r.barycenter) && Yj(r, i))
    }
  }
  function o(r) {
    return i => {
      i.in.push(r), --i.indegree === 0 && e.push(i)
    }
  }
  for (; e.length; ) {
    let r = e.pop()
    t.push(r), r.in.reverse().forEach(n(r)), r.out.forEach(o(r))
  }
  return t.filter(r => !r.merged).map(r => Wj.pick(r, ['vs', 'i', 'barycenter', 'weight']))
}
function Yj(e, t) {
  let n = 0,
    o = 0
  e.weight && ((n += e.barycenter * e.weight), (o += e.weight)), t.weight && ((n += t.barycenter * t.weight), (o += t.weight)), (e.vs = t.vs.concat(e.vs)), (e.barycenter = n / o), (e.weight = o), (e.i = Math.min(t.i, e.i)), (t.merged = !0)
}
let Hj = yt
var Uj = Kj
function Kj(e, t) {
  let n = Hj.partition(e, u => Object.hasOwn(u, 'barycenter')),
    o = n.lhs,
    r = n.rhs.sort((u, d) => d.i - u.i),
    i = [],
    s = 0,
    a = 0,
    l = 0
  o.sort(qj(!!t)),
    (l = ah(i, r, l)),
    o.forEach(u => {
      ;(l += u.vs.length), i.push(u.vs), (s += u.barycenter * u.weight), (a += u.weight), (l = ah(i, r, l))
    })
  let c = { vs: i.flat(!0) }
  return a && ((c.barycenter = s / a), (c.weight = a)), c
}
function ah(e, t, n) {
  let o
  for (; t.length && (o = t[t.length - 1]).i <= n; ) t.pop(), e.push(o.vs), n++
  return n
}
function qj(e) {
  return (t, n) => (t.barycenter < n.barycenter ? -1 : t.barycenter > n.barycenter ? 1 : e ? n.i - t.i : t.i - n.i)
}
let Zj = Oj,
  Jj = Gj,
  _j = Uj
var $j = db
function db(e, t, n, o) {
  let r = e.children(t),
    i = e.node(t),
    s = i ? i.borderLeft : void 0,
    a = i ? i.borderRight : void 0,
    l = {}
  s && (r = r.filter(f => f !== s && f !== a))
  let c = Zj(e, r)
  c.forEach(f => {
    if (e.children(f.v).length) {
      let A = db(e, f.v, n, o)
      ;(l[f.v] = A), Object.hasOwn(A, 'barycenter') && tW(f, A)
    }
  })
  let u = Jj(c, n)
  eW(u, l)
  let d = _j(u, o)
  if (s && ((d.vs = [s, d.vs, a].flat(!0)), e.predecessors(s).length)) {
    let f = e.node(e.predecessors(s)[0]),
      A = e.node(e.predecessors(a)[0])
    Object.hasOwn(d, 'barycenter') || ((d.barycenter = 0), (d.weight = 0)), (d.barycenter = (d.barycenter * d.weight + f.order + A.order) / (d.weight + 2)), (d.weight += 2)
  }
  return d
}
function eW(e, t) {
  e.forEach(n => {
    n.vs = n.vs.flatMap(o => (t[o] ? t[o].vs : o))
  })
}
function tW(e, t) {
  e.barycenter !== void 0 ? ((e.barycenter = (e.barycenter * e.weight + t.barycenter * t.weight) / (e.weight + t.weight)), (e.weight += t.weight)) : ((e.barycenter = t.barycenter), (e.weight = t.weight))
}
let nW = xn.Graph,
  oW = yt
var rW = iW
function iW(e, t, n) {
  let o = sW(e),
    r = new nW({ compound: !0 }).setGraph({ root: o }).setDefaultNodeLabel(i => e.node(i))
  return (
    e.nodes().forEach(i => {
      let s = e.node(i),
        a = e.parent(i)
      ;(s.rank === t || (s.minRank <= t && t <= s.maxRank)) &&
        (r.setNode(i),
        r.setParent(i, a || o),
        e[n](i).forEach(l => {
          let c = l.v === i ? l.w : l.v,
            u = r.edge(c, i),
            d = u !== void 0 ? u.weight : 0
          r.setEdge(c, i, { weight: e.edge(l).weight + d })
        }),
        Object.hasOwn(s, 'minRank') &&
          r.setNode(i, {
            borderLeft: s.borderLeft[t],
            borderRight: s.borderRight[t],
          }))
    }),
    r
  )
}
function sW(e) {
  for (var t; e.hasNode((t = oW.uniqueId('_root'))); );
  return t
}
var aW = lW
function lW(e, t, n) {
  let o = {},
    r
  n.forEach(i => {
    let s = e.parent(i),
      a,
      l
    for (; s; ) {
      if (((a = e.parent(s)), a ? ((l = o[a]), (o[a] = s)) : ((l = r), (r = s)), l && l !== s)) {
        t.setEdge(l, s)
        return
      }
      s = a
    }
  })
}
let cW = Rj,
  uW = Dj,
  dW = $j,
  fW = rW,
  AW = aW,
  pW = xn.Graph,
  Rs = yt
var hW = fb
function fb(e, t) {
  if (t && typeof t.customOrder == 'function') {
    t.customOrder(e, fb)
    return
  }
  let n = Rs.maxRank(e),
    o = lh(e, Rs.range(1, n + 1), 'inEdges'),
    r = lh(e, Rs.range(n - 1, -1, -1), 'outEdges'),
    i = cW(e)
  if ((ch(e, i), t && t.disableOptimalOrderHeuristic)) return
  let s = Number.POSITIVE_INFINITY,
    a
  for (let l = 0, c = 0; c < 4; ++l, ++c) {
    gW(l % 2 ? o : r, l % 4 >= 2), (i = Rs.buildLayerMatrix(e))
    let u = uW(e, i)
    u < s && ((c = 0), (a = Object.assign({}, i)), (s = u))
  }
  ch(e, a)
}
function lh(e, t, n) {
  return t.map(function (o) {
    return fW(e, o, n)
  })
}
function gW(e, t) {
  let n = new pW()
  e.forEach(function (o) {
    let r = o.graph().root,
      i = dW(o, r, n, t)
    i.vs.forEach((s, a) => (o.node(s).order = a)), AW(o, n, i.vs)
  })
}
function ch(e, t) {
  Object.values(t).forEach(n => n.forEach((o, r) => (e.node(o).order = r)))
}
let mW = xn.Graph,
  Wn = yt
var yW = {
  positionX: xW,
  findType1Conflicts: Ab,
  findType2Conflicts: pb,
  addConflict: nf,
  hasConflict: hb,
  verticalAlignment: gb,
  horizontalCompaction: mb,
  alignCoordinates: bb,
  findSmallestWidthAlignment: yb,
  balance: vb,
}
function Ab(e, t) {
  let n = {}
  function o(r, i) {
    let s = 0,
      a = 0,
      l = r.length,
      c = i[i.length - 1]
    return (
      i.forEach((u, d) => {
        let f = bW(e, u),
          A = f ? e.node(f).order : l
        ;(f || u === c) &&
          (i.slice(a, d + 1).forEach(h => {
            e.predecessors(h).forEach(g => {
              let x = e.node(g),
                m = x.order
              ;(m < s || A < m) && !(x.dummy && e.node(h).dummy) && nf(n, g, h)
            })
          }),
          (a = d + 1),
          (s = A))
      }),
      i
    )
  }
  return t.length && t.reduce(o), n
}
function pb(e, t) {
  let n = {}
  function o(i, s, a, l, c) {
    let u
    Wn.range(s, a).forEach(d => {
      ;(u = i[d]),
        e.node(u).dummy &&
          e.predecessors(u).forEach(f => {
            let A = e.node(f)
            A.dummy && (A.order < l || A.order > c) && nf(n, f, u)
          })
    })
  }
  function r(i, s) {
    let a = -1,
      l,
      c = 0
    return (
      s.forEach((u, d) => {
        if (e.node(u).dummy === 'border') {
          let f = e.predecessors(u)
          f.length && ((l = e.node(f[0]).order), o(s, c, d, a, l), (c = d), (a = l))
        }
        o(s, c, s.length, l, i.length)
      }),
      s
    )
  }
  return t.length && t.reduce(r), n
}
function bW(e, t) {
  if (e.node(t).dummy) return e.predecessors(t).find(n => e.node(n).dummy)
}
function nf(e, t, n) {
  if (t > n) {
    let r = t
    ;(t = n), (n = r)
  }
  let o = e[t]
  o || (e[t] = o = {}), (o[n] = !0)
}
function hb(e, t, n) {
  if (t > n) {
    let o = t
    ;(t = n), (n = o)
  }
  return !!e[t] && Object.hasOwn(e[t], n)
}
function gb(e, t, n, o) {
  let r = {},
    i = {},
    s = {}
  return (
    t.forEach(a => {
      a.forEach((l, c) => {
        ;(r[l] = l), (i[l] = l), (s[l] = c)
      })
    }),
    t.forEach(a => {
      let l = -1
      a.forEach(c => {
        let u = o(c)
        if (u.length) {
          u = u.sort((f, A) => s[f] - s[A])
          let d = (u.length - 1) / 2
          for (let f = Math.floor(d), A = Math.ceil(d); f <= A; ++f) {
            let h = u[f]
            i[c] === c && l < s[h] && !hb(n, c, h) && ((i[h] = c), (i[c] = r[c] = r[h]), (l = s[h]))
          }
        }
      })
    }),
    { root: r, align: i }
  )
}
function mb(e, t, n, o, r) {
  let i = {},
    s = vW(e, t, n, r),
    a = r ? 'borderLeft' : 'borderRight'
  function l(d, f) {
    let A = s.nodes(),
      h = A.pop(),
      g = {}
    for (; h; ) g[h] ? d(h) : ((g[h] = !0), A.push(h), (A = A.concat(f(h)))), (h = A.pop())
  }
  function c(d) {
    i[d] = s.inEdges(d).reduce((f, A) => Math.max(f, i[A.v] + s.edge(A)), 0)
  }
  function u(d) {
    let f = s.outEdges(d).reduce((h, g) => Math.min(h, i[g.w] - s.edge(g)), Number.POSITIVE_INFINITY),
      A = e.node(d)
    f !== Number.POSITIVE_INFINITY && A.borderType !== a && (i[d] = Math.max(i[d], f))
  }
  return l(c, s.predecessors.bind(s)), l(u, s.successors.bind(s)), Object.keys(o).forEach(d => (i[d] = i[n[d]])), i
}
function vW(e, t, n, o) {
  let r = new mW(),
    i = e.graph(),
    s = CW(i.nodesep, i.edgesep, o)
  return (
    t.forEach(a => {
      let l
      a.forEach(c => {
        let u = n[c]
        if ((r.setNode(u), l)) {
          var d = n[l],
            f = r.edge(d, u)
          r.setEdge(d, u, Math.max(s(e, c, l), f || 0))
        }
        l = c
      })
    }),
    r
  )
}
function yb(e, t) {
  return Object.values(t).reduce(
    (n, o) => {
      let r = Number.NEGATIVE_INFINITY,
        i = Number.POSITIVE_INFINITY
      Object.entries(o).forEach(([a, l]) => {
        let c = wW(e, a) / 2
        ;(r = Math.max(l + c, r)), (i = Math.min(l - c, i))
      })
      const s = r - i
      return s < n[0] && (n = [s, o]), n
    },
    [Number.POSITIVE_INFINITY, null]
  )[1]
}
function bb(e, t) {
  let n = Object.values(t),
    o = Wn.applyWithChunking(Math.min, n),
    r = Wn.applyWithChunking(Math.max, n)
  ;['u', 'd'].forEach(i => {
    ;['l', 'r'].forEach(s => {
      let a = i + s,
        l = e[a]
      if (l === t) return
      let c = Object.values(l),
        u = o - Wn.applyWithChunking(Math.min, c)
      s !== 'l' && (u = r - Wn.applyWithChunking(Math.max, c)), u && (e[a] = Wn.mapValues(l, d => d + u))
    })
  })
}
function vb(e, t) {
  return Wn.mapValues(e.ul, (n, o) => {
    if (t) return e[t.toLowerCase()][o]
    {
      let r = Object.values(e)
        .map(i => i[o])
        .sort((i, s) => i - s)
      return (r[1] + r[2]) / 2
    }
  })
}
function xW(e) {
  let t = Wn.buildLayerMatrix(e),
    n = Object.assign(Ab(e, t), pb(e, t)),
    o = {},
    r
  ;['u', 'd'].forEach(s => {
    ;(r = s === 'u' ? t : Object.values(t).reverse()),
      ['l', 'r'].forEach(a => {
        a === 'r' && (r = r.map(d => Object.values(d).reverse()))
        let l = (s === 'u' ? e.predecessors : e.successors).bind(e),
          c = gb(e, r, n, l),
          u = mb(e, r, c.root, c.align, a === 'r')
        a === 'r' && (u = Wn.mapValues(u, d => -d)), (o[s + a] = u)
      })
  })
  let i = yb(e, o)
  return bb(o, i), vb(o, e.graph().align)
}
function CW(e, t, n) {
  return (o, r, i) => {
    let s = o.node(r),
      a = o.node(i),
      l = 0,
      c
    if (((l += s.width / 2), Object.hasOwn(s, 'labelpos')))
      switch (s.labelpos.toLowerCase()) {
        case 'l':
          c = -s.width / 2
          break
        case 'r':
          c = s.width / 2
          break
      }
    if ((c && (l += n ? c : -c), (c = 0), (l += (s.dummy ? t : e) / 2), (l += (a.dummy ? t : e) / 2), (l += a.width / 2), Object.hasOwn(a, 'labelpos')))
      switch (a.labelpos.toLowerCase()) {
        case 'l':
          c = a.width / 2
          break
        case 'r':
          c = -a.width / 2
          break
      }
    return c && (l += n ? c : -c), (c = 0), l
  }
}
function wW(e, t) {
  return e.node(t).width
}
let xb = yt,
  EW = yW.positionX
var SW = BW
function BW(e) {
  ;(e = xb.asNonCompoundGraph(e)), IW(e), Object.entries(EW(e)).forEach(([t, n]) => (e.node(t).x = n))
}
function IW(e) {
  let t = xb.buildLayerMatrix(e),
    n = e.graph().ranksep,
    o = 0
  t.forEach(r => {
    const i = r.reduce((s, a) => {
      const l = e.node(a).height
      return s > l ? s : l
    }, 0)
    r.forEach(s => (e.node(s).y = o + i / 2)), (o += i + n)
  })
}
let uh = z4,
  dh = G4,
  NW = fj,
  kW = yt.normalizeRanks,
  MW = gj,
  PW = yt.removeEmptyRanks,
  fh = vj,
  LW = Bj,
  Ah = Nj,
  RW = hW,
  TW = SW,
  on = yt,
  FW = xn.Graph
var DW = zW
function zW(e, t) {
  let n = t && t.debugTiming ? on.time : on.notime
  n('layout', () => {
    let o = n('  buildLayoutGraph', () => UW(e))
    n('  runLayout', () => QW(o, n, t)), n('  updateInputGraph', () => OW(e, o))
  })
}
function QW(e, t, n) {
  t('    makeSpaceForEdgeLabels', () => KW(e)),
    t('    removeSelfEdges', () => oG(e)),
    t('    acyclic', () => uh.run(e)),
    t('    nestingGraph.run', () => fh.run(e)),
    t('    rank', () => NW(on.asNonCompoundGraph(e))),
    t('    injectEdgeLabelProxies', () => qW(e)),
    t('    removeEmptyRanks', () => PW(e)),
    t('    nestingGraph.cleanup', () => fh.cleanup(e)),
    t('    normalizeRanks', () => kW(e)),
    t('    assignRankMinMax', () => ZW(e)),
    t('    removeEdgeLabelProxies', () => JW(e)),
    t('    normalize.run', () => dh.run(e)),
    t('    parentDummyChains', () => MW(e)),
    t('    addBorderSegments', () => LW(e)),
    t('    order', () => RW(e, n)),
    t('    insertSelfEdges', () => rG(e)),
    t('    adjustCoordinateSystem', () => Ah.adjust(e)),
    t('    position', () => TW(e)),
    t('    positionSelfEdges', () => iG(e)),
    t('    removeBorderNodes', () => nG(e)),
    t('    normalize.undo', () => dh.undo(e)),
    t('    fixupEdgeLabelCoords', () => eG(e)),
    t('    undoCoordinateSystem', () => Ah.undo(e)),
    t('    translateGraph', () => _W(e)),
    t('    assignNodeIntersects', () => $W(e)),
    t('    reversePoints', () => tG(e)),
    t('    acyclic.undo', () => uh.undo(e))
}
function OW(e, t) {
  e.nodes().forEach(n => {
    let o = e.node(n),
      r = t.node(n)
    o && ((o.x = r.x), (o.y = r.y), (o.rank = r.rank), t.children(n).length && ((o.width = r.width), (o.height = r.height)))
  }),
    e.edges().forEach(n => {
      let o = e.edge(n),
        r = t.edge(n)
      ;(o.points = r.points), Object.hasOwn(r, 'x') && ((o.x = r.x), (o.y = r.y))
    }),
    (e.graph().width = t.graph().width),
    (e.graph().height = t.graph().height)
}
let jW = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy'],
  WW = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' },
  GW = ['acyclicer', 'ranker', 'rankdir', 'align'],
  VW = ['width', 'height'],
  ph = { width: 0, height: 0 },
  XW = ['minlen', 'weight', 'width', 'height', 'labeloffset'],
  YW = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: 'r',
  },
  HW = ['labelpos']
function UW(e) {
  let t = new FW({ multigraph: !0, compound: !0 }),
    n = Fc(e.graph())
  return (
    t.setGraph(Object.assign({}, WW, Tc(n, jW), on.pick(n, GW))),
    e.nodes().forEach(o => {
      let r = Fc(e.node(o))
      const i = Tc(r, VW)
      Object.keys(ph).forEach(s => {
        i[s] === void 0 && (i[s] = ph[s])
      }),
        t.setNode(o, i),
        t.setParent(o, e.parent(o))
    }),
    e.edges().forEach(o => {
      let r = Fc(e.edge(o))
      t.setEdge(o, Object.assign({}, YW, Tc(r, XW), on.pick(r, HW)))
    }),
    t
  )
}
function KW(e) {
  let t = e.graph()
  ;(t.ranksep /= 2),
    e.edges().forEach(n => {
      let o = e.edge(n)
      ;(o.minlen *= 2), o.labelpos.toLowerCase() !== 'c' && (t.rankdir === 'TB' || t.rankdir === 'BT' ? (o.width += o.labeloffset) : (o.height += o.labeloffset))
    })
}
function qW(e) {
  e.edges().forEach(t => {
    let n = e.edge(t)
    if (n.width && n.height) {
      let o = e.node(t.v),
        i = { rank: (e.node(t.w).rank - o.rank) / 2 + o.rank, e: t }
      on.addDummyNode(e, 'edge-proxy', i, '_ep')
    }
  })
}
function ZW(e) {
  let t = 0
  e.nodes().forEach(n => {
    let o = e.node(n)
    o.borderTop && ((o.minRank = e.node(o.borderTop).rank), (o.maxRank = e.node(o.borderBottom).rank), (t = Math.max(t, o.maxRank)))
  }),
    (e.graph().maxRank = t)
}
function JW(e) {
  e.nodes().forEach(t => {
    let n = e.node(t)
    n.dummy === 'edge-proxy' && ((e.edge(n.e).labelRank = n.rank), e.removeNode(t))
  })
}
function _W(e) {
  let t = Number.POSITIVE_INFINITY,
    n = 0,
    o = Number.POSITIVE_INFINITY,
    r = 0,
    i = e.graph(),
    s = i.marginx || 0,
    a = i.marginy || 0
  function l(c) {
    let u = c.x,
      d = c.y,
      f = c.width,
      A = c.height
    ;(t = Math.min(t, u - f / 2)), (n = Math.max(n, u + f / 2)), (o = Math.min(o, d - A / 2)), (r = Math.max(r, d + A / 2))
  }
  e.nodes().forEach(c => l(e.node(c))),
    e.edges().forEach(c => {
      let u = e.edge(c)
      Object.hasOwn(u, 'x') && l(u)
    }),
    (t -= s),
    (o -= a),
    e.nodes().forEach(c => {
      let u = e.node(c)
      ;(u.x -= t), (u.y -= o)
    }),
    e.edges().forEach(c => {
      let u = e.edge(c)
      u.points.forEach(d => {
        ;(d.x -= t), (d.y -= o)
      }),
        Object.hasOwn(u, 'x') && (u.x -= t),
        Object.hasOwn(u, 'y') && (u.y -= o)
    }),
    (i.width = n - t + s),
    (i.height = r - o + a)
}
function $W(e) {
  e.edges().forEach(t => {
    let n = e.edge(t),
      o = e.node(t.v),
      r = e.node(t.w),
      i,
      s
    n.points ? ((i = n.points[0]), (s = n.points[n.points.length - 1])) : ((n.points = []), (i = r), (s = o)), n.points.unshift(on.intersectRect(o, i)), n.points.push(on.intersectRect(r, s))
  })
}
function eG(e) {
  e.edges().forEach(t => {
    let n = e.edge(t)
    if (Object.hasOwn(n, 'x'))
      switch (((n.labelpos === 'l' || n.labelpos === 'r') && (n.width -= n.labeloffset), n.labelpos)) {
        case 'l':
          n.x -= n.width / 2 + n.labeloffset
          break
        case 'r':
          n.x += n.width / 2 + n.labeloffset
          break
      }
  })
}
function tG(e) {
  e.edges().forEach(t => {
    let n = e.edge(t)
    n.reversed && n.points.reverse()
  })
}
function nG(e) {
  e.nodes().forEach(t => {
    if (e.children(t).length) {
      let n = e.node(t),
        o = e.node(n.borderTop),
        r = e.node(n.borderBottom),
        i = e.node(n.borderLeft[n.borderLeft.length - 1]),
        s = e.node(n.borderRight[n.borderRight.length - 1])
      ;(n.width = Math.abs(s.x - i.x)), (n.height = Math.abs(r.y - o.y)), (n.x = i.x + n.width / 2), (n.y = o.y + n.height / 2)
    }
  }),
    e.nodes().forEach(t => {
      e.node(t).dummy === 'border' && e.removeNode(t)
    })
}
function oG(e) {
  e.edges().forEach(t => {
    if (t.v === t.w) {
      var n = e.node(t.v)
      n.selfEdges || (n.selfEdges = []), n.selfEdges.push({ e: t, label: e.edge(t) }), e.removeEdge(t)
    }
  })
}
function rG(e) {
  var t = on.buildLayerMatrix(e)
  t.forEach(n => {
    var o = 0
    n.forEach((r, i) => {
      var s = e.node(r)
      ;(s.order = i + o),
        (s.selfEdges || []).forEach(a => {
          on.addDummyNode(
            e,
            'selfedge',
            {
              width: a.label.width,
              height: a.label.height,
              rank: s.rank,
              order: i + ++o,
              e: a.e,
              label: a.label,
            },
            '_se'
          )
        }),
        delete s.selfEdges
    })
  })
}
function iG(e) {
  e.nodes().forEach(t => {
    var n = e.node(t)
    if (n.dummy === 'selfedge') {
      var o = e.node(n.e.v),
        r = o.x + o.width / 2,
        i = o.y,
        s = n.x - r,
        a = o.height / 2
      e.setEdge(n.e, n.label),
        e.removeNode(t),
        (n.label.points = [
          { x: r + (2 * s) / 3, y: i - a },
          { x: r + (5 * s) / 6, y: i - a },
          { x: r + s, y: i },
          { x: r + (5 * s) / 6, y: i + a },
          { x: r + (2 * s) / 3, y: i + a },
        ]),
        (n.label.x = n.x),
        (n.label.y = n.y)
    }
  })
}
function Tc(e, t) {
  return on.mapValues(on.pick(e, t), Number)
}
function Fc(e) {
  var t = {}
  return (
    e &&
      Object.entries(e).forEach(([n, o]) => {
        typeof n == 'string' && (n = n.toLowerCase()), (t[n] = o)
      }),
    t
  )
}
let sG = yt,
  aG = xn.Graph
var lG = {
  debugOrdering: cG,
}
function cG(e) {
  let t = sG.buildLayerMatrix(e),
    n = new aG({ compound: !0, multigraph: !0 }).setGraph({})
  return (
    e.nodes().forEach(o => {
      n.setNode(o, { label: o }), n.setParent(o, 'layer' + e.node(o).rank)
    }),
    e.edges().forEach(o => n.setEdge(o.v, o.w, {}, o.name)),
    t.forEach((o, r) => {
      let i = 'layer' + r
      n.setNode(i, { rank: 'same' }), o.reduce((s, a) => (n.setEdge(s, a, { style: 'invis' }), a))
    }),
    n
  )
}
var uG = '1.1.4',
  dG = {
    graphlib: xn,
    layout: DW,
    debug: lG,
    util: {
      time: yt.time,
      notime: yt.notime,
    },
    version: uG,
  }
const Cb = /* @__PURE__ */ Oh(dG),
  wb = po({
    nodes: Wy,
    edges: Gy,
    flowDirection: yn.vertical,
    viewMode: uo.enhanced,
    editMode: Hn.unlocked,
    changesEnabled: !1,
    horizontalHelperLine: void 0,
    verticalHelperLine: void 0,
    setNodes: () => {},
    setEdges: () => {},
    setFlowDirection: () => {},
    setViewMode: () => {},
    setEditMode: () => {},
    setHorizontalHelperLine: () => {},
    setVerticalHelperLine: () => {},
    onNodesChange: () => {},
    onEdgesChange: () => {},
    onLayout: () => {},
    takeSnapshot: () => {},
  }),
  dr = new Cb.graphlib.Graph()
dr.setDefaultEdgeLabel(() => ({}))
const Eb = (e, t, n = flowDireflowDirectionMapction.vertical) => {
    const o = n === yn.horizontal
    return (
      dr.setGraph({ rankdir: n }),
      e.forEach(i => {
        dr.setNode(i.id, {
          width: i.measured.width,
          height: i.measured.height,
        })
      }),
      t.forEach(i => {
        dr.setEdge(i.source, i.target)
      }),
      Cb.layout(dr),
      {
        nodes: e.map(i => {
          const s = dr.node(i.id)
          return {
            ...i,
            targetPosition: o ? 'left' : 'top',
            sourcePosition: o ? 'right' : 'bottom',
            position: {
              x: s.x - i.measured.width / 2,
              y: s.y - i.measured.height / 2,
            },
          }
        }),
        edges: t,
      }
    )
  },
  { nodes: fG, edges: AG } = Eb(Wy, Gy, yn.vertical),
  pG = ({ children: e }) => {
    const {
        nodeState: [t, n, o],
        edgeState: [r, i, s],
        viewModeState: [a, l],
        editModeState: [c, u],
        horizontalHelperLineState: [d, f],
        verticalHelperLineState: [A, h],
        history: { undo: g, redo: x, takeSnapshot: m },
      } = AF({
        nodes: fG,
        edges: AG,
        viewMode: uo.enhanced,
        editMode: Hn.unlocked,
        stateId: 'initial-state',
      }),
      [v, y] = be(yn.vertical),
      { cut: b, copy: C, paste: I } = yF(),
      w = (...D) => {
        m(), b(...D)
      },
      M = (...D) => {
        m(), I(...D)
      }
    Cc(['Meta+x', 'Control+x'], w), Cc(['Meta+c', 'Control+c'], C), Cc(['Meta+v', 'Control+v'], M)
    const L = ge(
      D => {
        y(D)
        const { nodes: z, edges: E } = Eb(t, r, D)
        n([...z]), i([...E])
      },
      [t, r, n, i]
    )
    yp(['Ctrl', 'Z'], g), yp(['Ctrl', 'Y'], x)
    const R = Pe(() => c === Hn.unlocked, [c]),
      T = Pe(
        () => ({
          nodes: t,
          edges: r,
          flowDirection: v,
          viewMode: a,
          editMode: c,
          horizontalHelperLine: d,
          verticalHelperLine: A,
          setNodes: n,
          setEdges: i,
          setFlowDirection: y,
          setViewMode: l,
          setEditMode: u,
          setHorizontalHelperLine: f,
          setVerticalHelperLine: h,
          onNodesChange: o,
          onEdgesChange: s,
          onLayout: L,
          takeSnapshot: m,
          changesEnabled: R,
        }),
        [t, r, v, a, c, d, A, n, i, l, u, f, h, o, s, L, m, R]
      )
    return /* @__PURE__ */ p.jsx(wb.Provider, { value: T, children: e })
  },
  ho = () => qn(wb),
  hG = O('div')`
  .react-flow__handle {
    z-index: 30;
  }

  .react-flow__handle.target {
    background-color: ${({ theme: e }) => e.palette.green[300]};
  }

  .react-flow__handle.source {
    background-color: ${({ theme: e }) => e.palette.red[300]};
  }
`,
  gG = ({ children: e }) => /* @__PURE__ */ p.jsx(hG, { children: e }),
  of = e =>
    /* @__PURE__ */ p.jsx(YS, {
      className: e.className,
      ...e,
      style: { maxWidth: 'none', ...e.style },
    }),
  Sb = e => /* @__PURE__ */ p.jsx(ZS, { ...e }),
  Pt = e => /* @__PURE__ */ p.jsx(Hg, { ...e }),
  mG = e => /* @__PURE__ */ p.jsx(wB, { ...e }),
  yG = ({ flexDirection: e = 'row', ...t }) => /* @__PURE__ */ p.jsx(mG, { flexDirection: e, ...t }),
  bG = O('form')`
  width: 450px;
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 0 24px 16px;
`,
  vG = O(Pt)`
  width: 100%;
`,
  xG = O(yG)`
  gap: 20px;
`,
  ki = e => /* @__PURE__ */ p.jsx(cm, { ...e }),
  CG = 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(135deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(135deg, transparent 75%, #ccc 75%) /*! @noflip */',
  wG = 'linear-gradient(to top, #000000, transparent), linear-gradient(to right, #ffffff, transparent) /*! @noflip */',
  EG = {
    Button: O(Hg)(() => ({
      backgroundSize: '8px 8px',
      backgroundPosition: '0 0, 4px 0, 4px -4px, 0px 4px',
      transition: 'none',
      boxShadow: '0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08)',
      border: 0,
      borderRadius: 4,
      width: '24px',
      aspectRatio: '1 / 1',
      height: '24px',
      minWidth: 0,
    })),
  },
  SG = e => {
    const { bgColor: t, className: n, disablePopover: o, isBgColorValid: r, ...i } = e
    return /* @__PURE__ */ p.jsx(EG.Button, {
      disableTouchRipple: !0,
      style: {
        backgroundColor: r ? t : void 0,
        backgroundImage: r ? void 0 : CG,
        cursor: o ? 'default' : void 0,
      },
      className: `MuiColorInput-Button ${n || ''}`,
      variant: 'text',
      disableElevation: !1,
      ...i,
    })
  },
  BG = {
    Container: O('div')(() => ({
      width: 300,
      padding: 8,
    })),
  },
  IG = ({ children: e, className: t, position: n = 'start', ...o }) =>
    /* @__PURE__ */ p.jsx(rm, {
      className: `MuiColorInput-Popover ${t || ''}`,
      anchorOrigin: {
        vertical: 'bottom',
        horizontal: n === 'start' ? 'left' : 'right',
      },
      transformOrigin: {
        vertical: 'top',
        horizontal: n === 'start' ? 'left' : 'right',
      },
      ...o,
      children: /* @__PURE__ */ p.jsx(BG.Container, { children: e }),
    }),
  NG = {
    Slider: O(lm, {
      shouldForwardProp: e => e !== '$rgbaFrom' && e !== '$rgbaTo',
    })(() => ({
      height: 8,
      '& .MuiSlider-rail': {
        opacity: 1,
        // TODO: find better way for perf
        background: 'linear-gradient(to right, rgba(var(--rgb-r), var(--rgb-g), var(--rgb-b), 0) 0%, rgba(var(--rgb-r), var(--rgb-g), var(--rgb-b), 1) 100%)',
      },
      '& .MuiSlider-track': {
        color: 'transparent',
        border: 0,
      },
      '& .MuiSlider-thumb': {
        backgroundColor: '#ffffff',
        border: '3px solid currentColor',
      },
    })),
  },
  kG = e => {
    const { rgbColor: t, style: n, className: o, ...r } = e,
      i = {
        '--rgb-r': t.r,
        '--rgb-g': t.g,
        '--rgb-b': t.b,
        ...n,
      }
    return /* @__PURE__ */ p.jsx(NG.Slider, {
      className: `MuiColorInput-AlphaSlider ${o || ''}`,
      style: i,
      ...r,
    })
  },
  Ts = {
    up: 'ArrowUp',
    down: 'ArrowDown',
    left: 'ArrowLeft',
    right: 'ArrowRight',
  },
  MG = {
    ArrowUp: {
      type: 'hsvV',
      value: 1,
    },
    ArrowDown: {
      type: 'hsvV',
      value: -1,
    },
    ArrowLeft: {
      type: 'hsvS',
      value: -1,
    },
    ArrowRight: {
      type: 'hsvS',
      value: 1,
    },
  }
function PG(e) {
  return e === Ts.up || e === Ts.down || e === Ts.left || e === Ts.right
}
function ka(e, t, n) {
  return Math.max(t, Math.min(e, n))
}
function hh(e) {
  return typeof e == 'number'
}
function gh(e, t, n) {
  const o = e.toLocaleString('en', {
    useGrouping: !1,
    minimumFractionDigits: t,
    maximumFractionDigits: n,
  })
  return Number(o)
}
function LG(e, t, n) {
  const o = e.getBoundingClientRect(),
    r = t - o.left,
    i = n - o.top
  return {
    x: ka(r / o.width, 0, 1),
    y: ka(1 - i / o.height, 0, 1),
  }
}
function RG(e) {
  const t = ve.useRef()
  return (
    (t.current = e),
    ve.useCallback((...n) => {
      var o
      return (o = t.current) == null ? void 0 : o.call(t, ...n)
    }, [])
  )
}
const mh = {
    Space: O('div')(() => ({
      width: '100%',
      height: '180px',
      boxSizing: 'border-box',
      outline: 0,
      position: 'relative',
      backgroundImage: wG,
    })),
    Thumb: O('div')(() => ({
      position: 'absolute',
      border: '3px solid #ffffff',
      borderRadius: '50%',
      width: '20px',
      height: '20px',
      marginLeft: '-10px /*! @noflip */',
      marginBottom: '-10px /*! @noflip */',
      outline: 0,
      boxSizing: 'border-box',
      willChange: 'left, bottom',
      transition: 'box-shadow 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms',
      '&:hover': {
        boxShadow: '0px 0px 0px 4px rgba(255 255 255 / 0.16)',
      },
      '&.MuiColorInput-Thumb-active': {
        boxShadow: '0px 0px 0px 8px rgba(255 255 255 / 0.16)',
      },
      '@media (hover: none)': {
        boxShadow: 'none',
      },
    })),
  },
  TG = e => {
    const { hsv: t, onChange: n, currentHue: o } = e,
      r = ve.useRef(!1),
      i = ve.useRef(null),
      [s, a] = ve.useState(!1),
      l = RG((g, x) => {
        if (!i.current) return
        const { x: m, y: v } = LG(i.current, g, x)
        n({
          s: m,
          v,
        }),
          i.current && document.activeElement !== i.current && i.current.focus()
      }),
      c = ve.useCallback(() => {
        r.current && ((r.current = !1), a(!1))
      }, []),
      u = ve.useCallback(g => {
        r.current && l(g.clientX, g.clientY)
      }, [])
    ve.useEffect(
      () => (
        document.addEventListener('pointermove', u, !1),
        document.addEventListener('pointerup', c, !1),
        () => {
          document.removeEventListener('pointermove', u, !1), document.removeEventListener('pointerup', c, !1)
        }
      ),
      [c, u]
    )
    const d = g => {
        g.preventDefault(), (r.current = !0), l(g.clientX, g.clientY), a(!0)
      },
      f = g => {
        if (PG(g.key)) {
          g.preventDefault()
          const { type: x, value: m } = MG[g.key],
            v = g.shiftKey ? 10 : 1,
            y = x === 'hsvS' ? t.s : t.v,
            b = ka(y + m * v * 0.01, 0, 1)
          a(!0),
            n({
              s: x === 'hsvS' ? b : t.s,
              v: x === 'hsvV' ? b : t.v,
            })
        }
      },
      A = t.s * 100,
      h = t.v * 100
    return /* @__PURE__ */ p.jsx(mh.Space, {
      onPointerDown: d,
      ref: i,
      className: 'MuiColorInput-ColorSpace',
      style: {
        backgroundColor: `hsl(${o} 100% 50%)`,
        touchAction: 'none',
      },
      role: 'slider',
      'aria-valuetext': `Saturation ${gh(A, 0, 0)}%, Brightness ${gh(h, 0, 0)}%`,
      onKeyDown: f,
      tabIndex: 0,
      children: /* @__PURE__ */ p.jsx(mh.Thumb, {
        'aria-label': 'Color space thumb',
        className: s ? 'MuiColorInput-Thumb-active' : '',
        style: {
          left: `${A}%`,
          bottom: `${h}%`,
        },
      }),
    })
  },
  FG = {
    Slider: O(lm)(() => ({
      height: 8,
      '& .MuiSlider-rail': {
        opacity: 1,
        background: 'linear-gradient(to right, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%) /*! @noflip */',
      },
      '& .MuiSlider-track': {
        color: 'transparent',
        border: 0,
      },
      '& .MuiSlider-thumb': {
        backgroundColor: '#ffffff',
        border: '3px solid currentColor',
      },
    })),
  },
  DG = e => {
    const { className: t, ...n } = e
    return /* @__PURE__ */ p.jsx(FG.Slider, {
      className: `MuiColorInput-HueSlider ${t || ''}`,
      ...n,
    })
  }
function zG(e) {
  return typeof e == 'string'
}
function It(e, t) {
  QG(e) && (e = '100%')
  const n = OG(e)
  return (e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e)))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? (e = (e < 0 ? (e % t) + t : e % t) / parseFloat(String(t))) : (e = (e % t) / parseFloat(String(t))), e)
}
function Fs(e) {
  return Math.min(1, Math.max(0, e))
}
function QG(e) {
  return typeof e == 'string' && e.indexOf('.') !== -1 && parseFloat(e) === 1
}
function OG(e) {
  return typeof e == 'string' && e.indexOf('%') !== -1
}
function Bb(e) {
  return (e = parseFloat(e)), (isNaN(e) || e < 0 || e > 1) && (e = 1), e
}
function Ds(e) {
  return Number(e) <= 1 ? `${Number(e) * 100}%` : e
}
function Qo(e) {
  return e.length === 1 ? '0' + e : String(e)
}
function jG(e, t, n) {
  return {
    r: It(e, 255) * 255,
    g: It(t, 255) * 255,
    b: It(n, 255) * 255,
  }
}
function yh(e, t, n) {
  ;(e = It(e, 255)), (t = It(t, 255)), (n = It(n, 255))
  const o = Math.max(e, t, n),
    r = Math.min(e, t, n)
  let i = 0,
    s = 0
  const a = (o + r) / 2
  if (o === r) (s = 0), (i = 0)
  else {
    const l = o - r
    switch (((s = a > 0.5 ? l / (2 - o - r) : l / (o + r)), o)) {
      case e:
        i = (t - n) / l + (t < n ? 6 : 0)
        break
      case t:
        i = (n - e) / l + 2
        break
      case n:
        i = (e - t) / l + 4
        break
    }
    i /= 6
  }
  return { h: i, s, l: a }
}
function Dc(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function WG(e, t, n) {
  let o, r, i
  if (((e = It(e, 360)), (t = It(t, 100)), (n = It(n, 100)), t === 0)) (r = n), (i = n), (o = n)
  else {
    const s = n < 0.5 ? n * (1 + t) : n + t - n * t,
      a = 2 * n - s
    ;(o = Dc(a, s, e + 1 / 3)), (r = Dc(a, s, e)), (i = Dc(a, s, e - 1 / 3))
  }
  return { r: o * 255, g: r * 255, b: i * 255 }
}
function bh(e, t, n) {
  ;(e = It(e, 255)), (t = It(t, 255)), (n = It(n, 255))
  const o = Math.max(e, t, n),
    r = Math.min(e, t, n)
  let i = 0
  const s = o,
    a = o - r,
    l = o === 0 ? 0 : a / o
  if (o === r) i = 0
  else {
    switch (o) {
      case e:
        i = (t - n) / a + (t < n ? 6 : 0)
        break
      case t:
        i = (n - e) / a + 2
        break
      case n:
        i = (e - t) / a + 4
        break
    }
    i /= 6
  }
  return { h: i, s: l, v: s }
}
function GG(e, t, n) {
  ;(e = It(e, 360) * 6), (t = It(t, 100)), (n = It(n, 100))
  const o = Math.floor(e),
    r = e - o,
    i = n * (1 - t),
    s = n * (1 - r * t),
    a = n * (1 - (1 - r) * t),
    l = o % 6,
    c = [n, s, i, i, a, n][l],
    u = [a, n, n, s, i, i][l],
    d = [i, i, a, n, n, s][l]
  return { r: c * 255, g: u * 255, b: d * 255 }
}
function vh(e, t, n, o) {
  const r = [Qo(Math.round(e).toString(16)), Qo(Math.round(t).toString(16)), Qo(Math.round(n).toString(16))]
  return o && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join('')
}
function VG(e, t, n, o, r) {
  const i = [Qo(Math.round(e).toString(16)), Qo(Math.round(t).toString(16)), Qo(Math.round(n).toString(16)), Qo(YG(o))]
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) && i[3].startsWith(i[3].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) + i[3].charAt(0) : i.join('')
}
function XG(e, t, n, o) {
  const r = e / 100,
    i = t / 100,
    s = n / 100,
    a = o / 100,
    l = 255 * (1 - r) * (1 - a),
    c = 255 * (1 - i) * (1 - a),
    u = 255 * (1 - s) * (1 - a)
  return { r: l, g: c, b: u }
}
function xh(e, t, n) {
  let o = 1 - e / 255,
    r = 1 - t / 255,
    i = 1 - n / 255,
    s = Math.min(o, r, i)
  return (
    s === 1 ? ((o = 0), (r = 0), (i = 0)) : ((o = ((o - s) / (1 - s)) * 100), (r = ((r - s) / (1 - s)) * 100), (i = ((i - s) / (1 - s)) * 100)),
    (s *= 100),
    {
      c: Math.round(o),
      m: Math.round(r),
      y: Math.round(i),
      k: Math.round(s),
    }
  )
}
function YG(e) {
  return Math.round(parseFloat(e) * 255).toString(16)
}
function Ch(e) {
  return Gt(e) / 255
}
function Gt(e) {
  return parseInt(e, 16)
}
function HG(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255,
  }
}
const Du = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkgrey: '#a9a9a9',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  goldenrod: '#daa520',
  gold: '#ffd700',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  grey: '#808080',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavenderblush: '#fff0f5',
  lavender: '#e6e6fa',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgreen: '#90ee90',
  lightgrey: '#d3d3d3',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  rebeccapurple: '#663399',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32',
}
function UG(e) {
  let t = { r: 0, g: 0, b: 0 },
    n = 1,
    o = null,
    r = null,
    i = null,
    s = !1,
    a = !1
  return (
    typeof e == 'string' && (e = ZG(e)),
    typeof e == 'object' &&
      (Wt(e.r) && Wt(e.g) && Wt(e.b)
        ? ((t = jG(e.r, e.g, e.b)), (s = !0), (a = String(e.r).substr(-1) === '%' ? 'prgb' : 'rgb'))
        : Wt(e.h) && Wt(e.s) && Wt(e.v)
        ? ((o = Ds(e.s)), (r = Ds(e.v)), (t = GG(e.h, o, r)), (s = !0), (a = 'hsv'))
        : Wt(e.h) && Wt(e.s) && Wt(e.l)
        ? ((o = Ds(e.s)), (i = Ds(e.l)), (t = WG(e.h, o, i)), (s = !0), (a = 'hsl'))
        : Wt(e.c) && Wt(e.m) && Wt(e.y) && Wt(e.k) && ((t = XG(e.c, e.m, e.y, e.k)), (s = !0), (a = 'cmyk')),
      Object.prototype.hasOwnProperty.call(e, 'a') && (n = e.a)),
    (n = Bb(n)),
    {
      ok: s,
      format: e.format || a,
      r: Math.min(255, Math.max(t.r, 0)),
      g: Math.min(255, Math.max(t.g, 0)),
      b: Math.min(255, Math.max(t.b, 0)),
      a: n,
    }
  )
}
const KG = '[-\\+]?\\d+%?',
  qG = '[-\\+]?\\d*\\.\\d+%?',
  so = '(?:' + qG + ')|(?:' + KG + ')',
  zc = '[\\s|\\(]+(' + so + ')[,|\\s]+(' + so + ')[,|\\s]+(' + so + ')\\s*\\)?',
  zs =
    // eslint-disable-next-line prettier/prettier
    '[\\s|\\(]+(' + so + ')[,|\\s]+(' + so + ')[,|\\s]+(' + so + ')[,|\\s]+(' + so + ')\\s*\\)?',
  Jt = {
    CSS_UNIT: new RegExp(so),
    rgb: new RegExp('rgb' + zc),
    rgba: new RegExp('rgba' + zs),
    hsl: new RegExp('hsl' + zc),
    hsla: new RegExp('hsla' + zs),
    hsv: new RegExp('hsv' + zc),
    hsva: new RegExp('hsva' + zs),
    cmyk: new RegExp('cmyk' + zs),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  }
function ZG(e) {
  if (((e = e.trim().toLowerCase()), e.length === 0)) return !1
  let t = !1
  if (Du[e]) (e = Du[e]), (t = !0)
  else if (e === 'transparent') return { r: 0, g: 0, b: 0, a: 0, format: 'name' }
  let n = Jt.rgb.exec(e)
  return n
    ? { r: n[1], g: n[2], b: n[3] }
    : ((n = Jt.rgba.exec(e)),
      n
        ? { r: n[1], g: n[2], b: n[3], a: n[4] }
        : ((n = Jt.hsl.exec(e)),
          n
            ? { h: n[1], s: n[2], l: n[3] }
            : ((n = Jt.hsla.exec(e)),
              n
                ? { h: n[1], s: n[2], l: n[3], a: n[4] }
                : ((n = Jt.hsv.exec(e)),
                  n
                    ? { h: n[1], s: n[2], v: n[3] }
                    : ((n = Jt.hsva.exec(e)),
                      n
                        ? { h: n[1], s: n[2], v: n[3], a: n[4] }
                        : ((n = Jt.cmyk.exec(e)),
                          n
                            ? {
                                c: n[1],
                                m: n[2],
                                y: n[3],
                                k: n[4],
                              }
                            : ((n = Jt.hex8.exec(e)),
                              n
                                ? {
                                    r: Gt(n[1]),
                                    g: Gt(n[2]),
                                    b: Gt(n[3]),
                                    a: Ch(n[4]),
                                    format: t ? 'name' : 'hex8',
                                  }
                                : ((n = Jt.hex6.exec(e)),
                                  n
                                    ? {
                                        r: Gt(n[1]),
                                        g: Gt(n[2]),
                                        b: Gt(n[3]),
                                        format: t ? 'name' : 'hex',
                                      }
                                    : ((n = Jt.hex4.exec(e)),
                                      n
                                        ? {
                                            r: Gt(n[1] + n[1]),
                                            g: Gt(n[2] + n[2]),
                                            b: Gt(n[3] + n[3]),
                                            a: Ch(n[4] + n[4]),
                                            format: t ? 'name' : 'hex8',
                                          }
                                        : ((n = Jt.hex3.exec(e)),
                                          n
                                            ? {
                                                r: Gt(n[1] + n[1]),
                                                g: Gt(n[2] + n[2]),
                                                b: Gt(n[3] + n[3]),
                                                format: t ? 'name' : 'hex',
                                              }
                                            : !1))))))))))
}
function Wt(e) {
  return typeof e == 'number' ? !Number.isNaN(e) : Jt.CSS_UNIT.test(e)
}
class qe {
  constructor(t = '', n = {}) {
    if (t instanceof qe) return t
    typeof t == 'number' && (t = HG(t)), (this.originalInput = t)
    const o = UG(t)
    ;(this.originalInput = t),
      (this.r = o.r),
      (this.g = o.g),
      (this.b = o.b),
      (this.a = o.a),
      (this.roundA = Math.round(100 * this.a) / 100),
      (this.format = n.format ?? o.format),
      (this.gradientType = n.gradientType),
      this.r < 1 && (this.r = Math.round(this.r)),
      this.g < 1 && (this.g = Math.round(this.g)),
      this.b < 1 && (this.b = Math.round(this.b)),
      (this.isValid = o.ok)
  }
  isDark() {
    return this.getBrightness() < 128
  }
  isLight() {
    return !this.isDark()
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   */
  getBrightness() {
    const t = this.toRgb()
    return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3
  }
  /**
   * Returns the perceived luminance of a color, from 0-1.
   */
  getLuminance() {
    const t = this.toRgb()
    let n, o, r
    const i = t.r / 255,
      s = t.g / 255,
      a = t.b / 255
    return i <= 0.03928 ? (n = i / 12.92) : (n = Math.pow((i + 0.055) / 1.055, 2.4)), s <= 0.03928 ? (o = s / 12.92) : (o = Math.pow((s + 0.055) / 1.055, 2.4)), a <= 0.03928 ? (r = a / 12.92) : (r = Math.pow((a + 0.055) / 1.055, 2.4)), 0.2126 * n + 0.7152 * o + 0.0722 * r
  }
  /**
   * Returns the alpha value of a color, from 0-1.
   */
  getAlpha() {
    return this.a
  }
  /**
   * Sets the alpha value on the current color.
   *
   * @param alpha - The new alpha value. The accepted range is 0-1.
   */
  setAlpha(t) {
    return (this.a = Bb(t)), (this.roundA = Math.round(100 * this.a) / 100), this
  }
  /**
   * Returns whether the color is monochrome.
   */
  isMonochrome() {
    const { s: t } = this.toHsl()
    return t === 0
  }
  /**
   * Returns the object as a HSVA object.
   */
  toHsv() {
    const t = bh(this.r, this.g, this.b)
    return { h: t.h * 360, s: t.s, v: t.v, a: this.a }
  }
  /**
   * Returns the hsva values interpolated into a string with the following format:
   * "hsva(xxx, xxx, xxx, xx)".
   */
  toHsvString() {
    const t = bh(this.r, this.g, this.b),
      n = Math.round(t.h * 360),
      o = Math.round(t.s * 100),
      r = Math.round(t.v * 100)
    return this.a === 1 ? `hsv(${n}, ${o}%, ${r}%)` : `hsva(${n}, ${o}%, ${r}%, ${this.roundA})`
  }
  /**
   * Returns the object as a HSLA object.
   */
  toHsl() {
    const t = yh(this.r, this.g, this.b)
    return { h: t.h * 360, s: t.s, l: t.l, a: this.a }
  }
  /**
   * Returns the hsla values interpolated into a string with the following format:
   * "hsla(xxx, xxx, xxx, xx)".
   */
  toHslString() {
    const t = yh(this.r, this.g, this.b),
      n = Math.round(t.h * 360),
      o = Math.round(t.s * 100),
      r = Math.round(t.l * 100)
    return this.a === 1 ? `hsl(${n}, ${o}%, ${r}%)` : `hsla(${n}, ${o}%, ${r}%, ${this.roundA})`
  }
  /**
   * Returns the hex value of the color.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHex(t = !1) {
    return vh(this.r, this.g, this.b, t)
  }
  /**
   * Returns the hex value of the color -with a # prefixed.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHexString(t = !1) {
    return '#' + this.toHex(t)
  }
  /**
   * Returns the hex 8 value of the color.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8(t = !1) {
    return VG(this.r, this.g, this.b, this.a, t)
  }
  /**
   * Returns the hex 8 value of the color -with a # prefixed.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8String(t = !1) {
    return '#' + this.toHex8(t)
  }
  /**
   * Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
   * @param allowShortChar will shorten hex value to 3 or 4 char if possible
   */
  toHexShortString(t = !1) {
    return this.a === 1 ? this.toHexString(t) : this.toHex8String(t)
  }
  /**
   * Returns the object as a RGBA object.
   */
  toRgb() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a,
    }
  }
  /**
   * Returns the RGBA values interpolated into a string with the following format:
   * "RGBA(xxx, xxx, xxx, xx)".
   */
  toRgbString() {
    const t = Math.round(this.r),
      n = Math.round(this.g),
      o = Math.round(this.b)
    return this.a === 1 ? `rgb(${t}, ${n}, ${o})` : `rgba(${t}, ${n}, ${o}, ${this.roundA})`
  }
  /**
   * Returns the object as a RGBA object.
   */
  toPercentageRgb() {
    const t = n => `${Math.round(It(n, 255) * 100)}%`
    return {
      r: t(this.r),
      g: t(this.g),
      b: t(this.b),
      a: this.a,
    }
  }
  /**
   * Returns the RGBA relative values interpolated into a string
   */
  toPercentageRgbString() {
    const t = n => Math.round(It(n, 255) * 100)
    return this.a === 1 ? `rgb(${t(this.r)}%, ${t(this.g)}%, ${t(this.b)}%)` : `rgba(${t(this.r)}%, ${t(this.g)}%, ${t(this.b)}%, ${this.roundA})`
  }
  toCmyk() {
    return {
      ...xh(this.r, this.g, this.b),
    }
  }
  toCmykString() {
    const { c: t, m: n, y: o, k: r } = xh(this.r, this.g, this.b)
    return `cmyk(${t}, ${n}, ${o}, ${r})`
  }
  /**
   * The 'real' name of the color -if there is one.
   */
  toName() {
    if (this.a === 0) return 'transparent'
    if (this.a < 1) return !1
    const t = '#' + vh(this.r, this.g, this.b, !1)
    for (const [n, o] of Object.entries(Du)) if (t === o) return n
    return !1
  }
  toString(t) {
    const n = !!t
    t = t ?? this.format
    let o = !1
    const r = this.a < 1 && this.a >= 0
    return !n && r && (t.startsWith('hex') || t === 'name')
      ? t === 'name' && this.a === 0
        ? this.toName()
        : this.toRgbString()
      : (t === 'rgb' && (o = this.toRgbString()),
        t === 'prgb' && (o = this.toPercentageRgbString()),
        (t === 'hex' || t === 'hex6') && (o = this.toHexString()),
        t === 'hex3' && (o = this.toHexString(!0)),
        t === 'hex4' && (o = this.toHex8String(!0)),
        t === 'hex8' && (o = this.toHex8String()),
        t === 'name' && (o = this.toName()),
        t === 'hsl' && (o = this.toHslString()),
        t === 'hsv' && (o = this.toHsvString()),
        t === 'cmyk' && (o = this.toCmykString()),
        o || this.toHexString())
  }
  toNumber() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
  }
  clone() {
    return new qe(this.toString())
  }
  /**
   * Lighten the color a given amount. Providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  lighten(t = 10) {
    const n = this.toHsl()
    return (n.l += t / 100), (n.l = Fs(n.l)), new qe(n)
  }
  /**
   * Brighten the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  brighten(t = 10) {
    const n = this.toRgb()
    return (n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100))))), (n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100))))), (n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100))))), new qe(n)
  }
  /**
   * Darken the color a given amount, from 0 to 100.
   * Providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  darken(t = 10) {
    const n = this.toHsl()
    return (n.l -= t / 100), (n.l = Fs(n.l)), new qe(n)
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  tint(t = 10) {
    return this.mix('white', t)
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  shade(t = 10) {
    return this.mix('black', t)
  }
  /**
   * Desaturate the color a given amount, from 0 to 100.
   * Providing 100 will is the same as calling greyscale
   * @param amount - valid between 1-100
   */
  desaturate(t = 10) {
    const n = this.toHsl()
    return (n.s -= t / 100), (n.s = Fs(n.s)), new qe(n)
  }
  /**
   * Saturate the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  saturate(t = 10) {
    const n = this.toHsl()
    return (n.s += t / 100), (n.s = Fs(n.s)), new qe(n)
  }
  /**
   * Completely desaturates a color into greyscale.
   * Same as calling `desaturate(100)`
   */
  greyscale() {
    return this.desaturate(100)
  }
  /**
   * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
   * Values outside of this range will be wrapped into this range.
   */
  spin(t) {
    const n = this.toHsl(),
      o = (n.h + t) % 360
    return (n.h = o < 0 ? 360 + o : o), new qe(n)
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(t, n = 50) {
    const o = this.toRgb(),
      r = new qe(t).toRgb(),
      i = n / 100,
      s = {
        r: (r.r - o.r) * i + o.r,
        g: (r.g - o.g) * i + o.g,
        b: (r.b - o.b) * i + o.b,
        a: (r.a - o.a) * i + o.a,
      }
    return new qe(s)
  }
  analogous(t = 6, n = 30) {
    const o = this.toHsl(),
      r = 360 / n,
      i = [this]
    for (o.h = (o.h - ((r * t) >> 1) + 720) % 360; --t; ) (o.h = (o.h + r) % 360), i.push(new qe(o))
    return i
  }
  /**
   * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
   */
  complement() {
    const t = this.toHsl()
    return (t.h = (t.h + 180) % 360), new qe(t)
  }
  monochromatic(t = 6) {
    const n = this.toHsv(),
      { h: o } = n,
      { s: r } = n
    let { v: i } = n
    const s = [],
      a = 1 / t
    for (; t--; ) s.push(new qe({ h: o, s: r, v: i })), (i = (i + a) % 1)
    return s
  }
  splitcomplement() {
    const t = this.toHsl(),
      { h: n } = t
    return [this, new qe({ h: (n + 72) % 360, s: t.s, l: t.l }), new qe({ h: (n + 216) % 360, s: t.s, l: t.l })]
  }
  /**
   * Compute how the color would appear on a background
   */
  onBackground(t) {
    const n = this.toRgb(),
      o = new qe(t).toRgb(),
      r = n.a + o.a * (1 - n.a)
    return new qe({
      r: (n.r * n.a + o.r * o.a * (1 - n.a)) / r,
      g: (n.g * n.a + o.g * o.a * (1 - n.a)) / r,
      b: (n.b * n.a + o.b * o.a * (1 - n.a)) / r,
      a: r,
    })
  }
  /**
   * Alias for `polyad(3)`
   */
  triad() {
    return this.polyad(3)
  }
  /**
   * Alias for `polyad(4)`
   */
  tetrad() {
    return this.polyad(4)
  }
  /**
   * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
   * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
   */
  polyad(t) {
    const n = this.toHsl(),
      { h: o } = n,
      r = [this],
      i = 360 / t
    for (let s = 1; s < t; s++) r.push(new qe({ h: (o + s * i) % 360, s: n.s, l: n.l }))
    return r
  }
  /**
   * compare color vs current color
   */
  equals(t) {
    const n = new qe(t)
    return this.format === 'cmyk' || n.format === 'cmyk' ? this.toCmykString() === n.toCmykString() : this.toRgbString() === n.toRgbString()
  }
}
function vr(e, t) {
  return e.isValid ? e.toString(t) : e.originalInput.toString()
}
function wh(e, t) {
  return new qe(e, t)
}
function JG(e) {
  return zG(e) ? e : new qe(e).toString()
}
const _G = e => {
    const { currentColor: t, format: n, onChange: o, isAlphaHidden: r } = e,
      [i, s] = ve.useState(t.toHsv()),
      a = (u, d) => {
        if (!hh(d)) return
        const f = ka((360 * d) / 100, 0, 359)
        s(h => ({
          ...h,
          h: f,
        }))
        const A = new qe({
          ...i,
          a: t.toHsv().a,
          h: f,
        })
        o == null || o(vr(A, n))
      },
      l = (u, d) => {
        if (!hh(d)) return
        const f = t.clone().setAlpha(d)
        o == null || o(vr(f, n))
      },
      c = ({ s: u, v: d }) => {
        const f = new qe({
          h: i.h,
          a: t.toHsv().a,
          s: u,
          v: d,
        })
        s(A => ({
          ...A,
          s: u,
          v: d,
        })),
          o == null || o(vr(f, n))
      }
    return /* @__PURE__ */ p.jsxs(ic, {
      className: 'MuiColorInput-PopoverBody',
      children: [
        /* @__PURE__ */ p.jsx(TG, {
          currentHue: i.h,
          hsv: i,
          onChange: c,
        }),
        /* @__PURE__ */ p.jsx(ic, {
          mt: '10px',
          px: '3px',
          children: /* @__PURE__ */ p.jsx(DG, {
            min: 0,
            max: 100,
            step: 1,
            onChange: a,
            'aria-label': 'hue',
            value: (i.h * 100) / 360,
          }),
        }),
        r
          ? null
          : /* @__PURE__ */ p.jsx(ic, {
              mt: '10px',
              px: '3px',
              children: /* @__PURE__ */ p.jsx(kG, {
                min: 0,
                max: 1,
                step: 0.01,
                'aria-label': 'alpha',
                rgbColor: t.toRgb(),
                onChange: l,
                value: t.getAlpha(),
              }),
            }),
      ],
    })
  },
  $G = ve.forwardRef((e, t) => {
    const { className: n, ...o } = e
    return /* @__PURE__ */ p.jsx(cm, {
      className: `MuiColorInput-TextField ${n || ''}`,
      ref: t,
      ...o,
    })
  }),
  e9 = 'rgb'
function t9(e) {
  return typeof e == 'object' && !Array.isArray(e) && e !== null
}
function Eh(e, t) {
  typeof t == 'function' ? t(e) : t && t9(t) && 'current' in t && (t.current = e)
}
const n9 = ve.forwardRef((e, t) => {
    const { value: n, format: o, onChange: r, adornmentPosition: i = 'start', PopoverProps: s, Adornment: a = SG, fallbackValue: l, isAlphaHidden: c, disablePopover: u, ...d } = e,
      { onBlur: f, InputProps: A, ...h } = d,
      { onClose: g, ...x } = s || {},
      m = h.disabled || (A == null ? void 0 : A.disabled) || !1,
      v = ve.useRef(null),
      y = ve.useRef(null),
      [b, C] = ve.useState(null),
      I = o || e9,
      w = wh(n, {
        format: I,
      }),
      [M, L] = ve.useState(n),
      [R, T] = ve.useState(n),
      D = G => {
        G.preventDefault(), G.stopPropagation(), !m && !u && C(v.current)
      },
      z = G => {
        const K = new qe(G)
        r == null ||
          r(G, {
            hex: K.isValid ? K.toHexString() : '',
            hsv: K.isValid ? K.toHsvString() : '',
            hsl: K.isValid ? K.toHslString() : '',
            rgb: K.isValid ? K.toRgbString() : '',
            hex8: K.isValid ? K.toHex8String() : '',
          })
      },
      E = G => {
        const K = G.target.value
        if ((L(K), K === '')) T(''), z('')
        else {
          const $ = new qe(K),
            oe = vr($, I)
          T(oe), z(oe)
        }
      },
      P = (...G) => {
        g == null || g(...G),
          C(null),
          queueMicrotask(() => {
            var K
            ;(K = y.current) == null || K.focus()
          })
      },
      B = G => {
        f == null || f(G)
        const K = new qe(M)
        if (K.isValid) K.format !== I && L(vr(K, I))
        else {
          if (M === '') return
          if (l) {
            const $ = new qe(l),
              oe = vr($, I)
            L(oe), T(oe), z(oe)
          }
        }
      }
    ve.useEffect(() => {
      if (n !== R) {
        const G = wh(n).originalInput
        T(G), L(G)
      }
    }, [n, R])
    const F = G => {
        L(G), T(G), z(G)
      },
      S = G => {
        ;(v.current = G), t && Eh(G, t)
      },
      Q = G => {
        ;(y.current = G), y && Eh(G, y)
      },
      j = !!b,
      U = j ? 'color-popover' : void 0,
      q = /* @__PURE__ */ p.jsx(YB, {
        position: i,
        children: /* @__PURE__ */ p.jsx(a, {
          disabled: m,
          'aria-describedby': U,
          disablePopover: u || !1,
          component: u ? 'span' : void 0,
          bgColor: w.toString(),
          isBgColorValid: !!(M !== '' && w.isValid),
          onClick: u ? void 0 : D,
        }),
      }),
      ne =
        i === 'start'
          ? {
              startAdornment: q,
            }
          : {
              endAdornment: q,
            }
    return /* @__PURE__ */ p.jsxs(p.Fragment, {
      children: [
        /* @__PURE__ */ p.jsx($G, {
          ref: S,
          spellCheck: 'false',
          type: 'text',
          autoComplete: 'off',
          onChange: E,
          value: JG(M),
          onBlur: B,
          inputRef: Q,
          disabled: m,
          InputProps: {
            ...ne,
            ...A,
          },
          ...h,
        }),
        u
          ? null
          : /* @__PURE__ */ p.jsx(IG, {
              id: U,
              open: j,
              position: i,
              anchorEl: b,
              onClose: P,
              ...x,
              children: /* @__PURE__ */ p.jsx(_G, {
                onChange: F,
                currentColor: w,
                format: I,
                isAlphaHidden: c,
              }),
            }),
      ],
    })
  }),
  Ib = e => /* @__PURE__ */ p.jsx(n9, { ...e }),
  o9 = e => /* @__PURE__ */ p.jsx(Jg, { ...e }),
  r9 = e => /* @__PURE__ */ p.jsx(em, { ...e }),
  i9 = e => /* @__PURE__ */ p.jsx(_g, { ...e }),
  Qr = ({ formControlProps: e, inputLabelProps: t, inputLabel: n, inputLabelId: o, formHelperTextProps: r, helperText: i, ...s }) =>
    /* @__PURE__ */ p.jsxs(o9, {
      ...e,
      children: [
        /* @__PURE__ */ p.jsx(r9, {
          ...t,
          children: n,
          id: o,
        }),
        /* @__PURE__ */ p.jsx(wd, { ...s }),
        i && /* @__PURE__ */ p.jsx(i9, { ...r, children: i }),
      ],
    }),
  Or = e => /* @__PURE__ */ p.jsx(RI, { ...e }),
  s9 = e => {
    const { edge: t, onSave: n, onClose: o, maxWidth: r, ...i } = e,
      { nodes: s } = ho(),
      [a, l] = be(t.label ?? ''),
      [c, u] = be(oT(t) ?? ''),
      [d, f] = be(t.source),
      [A, h] = be(t.target),
      g = Qh(),
      x = `${g}-edit-edge-name`,
      m = `${g}-edit-edge-color`,
      v = `${g}-edit-source-node`,
      y = `${g}-edit-source-node-label`,
      b = `${g}-edit-target-node`,
      C = `${g}-edit-target-node-label`,
      I = (...B) => {
        o == null || o(...B)
      },
      w = B => {
        l(B.target.value)
      },
      M = B => {
        u(B)
      },
      L = () => {
        n(
          fo({
            ...t,
            label: a,
            source: d,
            target: A,
            style: {
              ...(t.style ?? {}),
              stroke: c,
            },
          })
        )
      },
      R = B => {
        f(B.target.value)
      },
      T = B => {
        h(B.target.value)
      },
      D = Pe(() => s.map(B => /* @__PURE__ */ p.jsx(Or, { value: B.id, children: Ir(B) }, B.id)), [s]),
      z = d === A,
      E = z,
      P = z ? 'Cannot choose the same node' : ''
    return /* @__PURE__ */ p.jsxs(of, {
      onClose: I,
      maxWidth: r ?? 'sm',
      ...i,
      children: [
        /* @__PURE__ */ p.jsx(Sb, { children: 'Edit Edge' }),
        /* @__PURE__ */ p.jsxs(bG, {
          id: g,
          children: [
            /* @__PURE__ */ p.jsx(ki, {
              value: a,
              onChange: w,
              label: 'Edge name',
              size: 'small',
              id: x,
            }),
            /* @__PURE__ */ p.jsx(Ib, {
              value: c,
              onChange: M,
              label: 'Edge Color',
              size: 'small',
              id: m,
            }),
            /* @__PURE__ */ p.jsxs(xG, {
              children: [
                /* @__PURE__ */ p.jsx(Qr, {
                  id: v,
                  labelId: y,
                  inputLabelId: y,
                  label: 'Source Node Id',
                  inputLabel: 'Source Node Id',
                  formControlProps: { fullWidth: !0, error: z },
                  value: d,
                  onChange: R,
                  helperText: P,
                  children: D,
                }),
                /* @__PURE__ */ p.jsx(Qr, {
                  id: b,
                  labelId: C,
                  inputLabelId: C,
                  label: 'Target Node Id',
                  inputLabel: 'Target Node Id',
                  formControlProps: { fullWidth: !0, error: z },
                  value: A,
                  onChange: T,
                  helperText: P,
                  children: D,
                }),
              ],
            }),
            /* @__PURE__ */ p.jsx(vG, {
              onClick: L,
              variant: 'contained',
              disabled: E,
              children: 'Save',
            }),
          ],
        }),
      ],
    })
  },
  Nb = () => qn(Lb),
  a9 = O('div')`
  display: flex;
  align-items: center;
  gap: 12px;
`,
  l9 = O(Pt)``,
  kb = ({ items: e, onChange: t, value: n, className: o, ...r }) => {
    const [i, s] = be(e[0].value),
      a = c => u => {
        s(c), t == null || t(c)
      },
      l = n ?? i
    return /* @__PURE__ */ p.jsx(a9, {
      className: o,
      ...r,
      children: e.map(c =>
        /* @__PURE__ */ p.jsx(
          l9,
          {
            onClick: a(c.value),
            variant: l === c.value ? 'contained' : 'outlined',
            size: 'small',
            children: c.label,
          },
          c.value
        )
      ),
    })
  },
  c9 = O(of)`
  .MuiPaper-root {
    max-width: none !important;
    max-height: none !important;
  }
`,
  u9 = O('form')`
  width: 680px;
  height: 600px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 0 24px 16px;
  position: relative;
`,
  fr = O('div')`
  display: flex;
  justify-content: space-between;
  height: 40px;
`,
  sr = O('p')`
  font-weight: 500;
`,
  fi = O('div')``,
  Qc = O(kb)`
  height: 100%;
`,
  d9 = O(Pt)`
  position: absolute;
  bottom: 20px;
  right: 20px;
`,
  f9 = O(fr)`
  flex-direction: column;
  justify-content: unset;
  gap: 8px;
`,
  A9 = O('div')`
  display: flex;
  justify-content: space-between;
`
var rf = {},
  Oc = {}
const p9 = /* @__PURE__ */ Zn($w)
var Sh
function sf() {
  return (
    Sh ||
      ((Sh = 1),
      (function (e) {
        'use client'
        Object.defineProperty(e, '__esModule', {
          value: !0,
        }),
          Object.defineProperty(e, 'default', {
            enumerable: !0,
            get: function () {
              return t.createSvgIcon
            },
          })
        var t = p9
      })(Oc)),
    Oc
  )
}
var h9 = Ji
Object.defineProperty(rf, '__esModule', {
  value: !0,
})
var Zl = (rf.default = void 0),
  g9 = h9(sf()),
  m9 = p
Zl = rf.default = (0, g9.default)(
  /* @__PURE__ */ (0, m9.jsx)('path', {
    d: 'M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z',
  }),
  'Add'
)
var af = {},
  y9 = Ji
Object.defineProperty(af, '__esModule', {
  value: !0,
})
var Mb = (af.default = void 0),
  b9 = y9(sf()),
  v9 = p
Mb = af.default = (0, b9.default)(
  /* @__PURE__ */ (0, v9.jsx)('path', {
    d: 'M19 13H5v-2h14z',
  }),
  'Remove'
)
const x9 = O('div')`
  display: flex;
  align-items: center;
`,
  C9 = O(Wg)``,
  w9 = O(Wg)``,
  E9 = O('div')`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 40px;
  font-weight: 500;
`,
  ar = {
    INCREMENT: 'INCREMENT',
    DECREMENT: 'DECREMENT',
  },
  vi = ({ value: e, onIncrement: t, onDecrement: n, onChange: o, incrementStep: r = 1, decrementStep: i = 1, ...s }) => {
    const [a, l] = be(0),
      c = A => h => () => {
        switch (A) {
          case ar.INCREMENT:
            l(g => g + h), t == null || t(h), o == null || o(ar.INCREMENT, h)
            break
          case ar.DECREMENT:
            l(g => g - h), n == null || n(h), o == null || o(ar.DECREMENT, h)
            break
        }
      },
      u = c(ar.INCREMENT),
      d = c(ar.DECREMENT),
      f = e ?? a
    return /* @__PURE__ */ p.jsxs(x9, { ...s, children: [/* @__PURE__ */ p.jsx(w9, { onClick: d(i), children: /* @__PURE__ */ p.jsx(Mb, {}) }), /* @__PURE__ */ p.jsx(E9, { children: f }), /* @__PURE__ */ p.jsx(C9, { onClick: u(r), children: /* @__PURE__ */ p.jsx(Zl, {}) })] })
  },
  S9 = e6.map(e => ({
    value: e,
    label: e,
  })),
  B9 = t6.map(e => ({
    value: e,
    label: e,
  })),
  I9 = n6.map(e => ({
    value: e,
    label: e,
  })),
  N9 = {
    [at.nonFlexConduit]: B9,
    [at.flexibleConduit]: I9,
    [at.cable]: null,
    [at.busduct]: null,
  },
  k9 = i6.map(e => ({
    value: e,
    label: o6[e],
  })),
  ro = (e, t) => `${e}-edit-edge-${t}`,
  Bh = {
    amount: 1,
    material: $o.aluminum,
    size: Se.AWG18,
  },
  M9 = e => {
    var tt, $e, Ke, V, W, le
    const { edge: t = { data: {} }, onSave: n, onClose: o, maxWidth: r, ...i } = e,
      { config: s } = cs()
    ho()
    const {
        minEdgeDiameterInches: a,
        maxEdgeDiameterInches: l,
        edgeDiameterIncrementStep: c,
        edgeDiameterDecrementStep: u,
        minEdgeLengthFeet: d,
        maxEdgeLengthFeet: f,
        edgeLengthFeetIncrementStep: A,
        edgeLengthFeetDecrementStep: h,
        minEdgeParallelSets: g,
        maxEdgeParallelSets: x,
        edgeParallelSetsIncrementStep: m,
        edgeParallelSetsDecrementStep: v,
        maxEdgeConductors: y,
        minEdgeConductorAmount: b,
        maxEdgeConductorAmount: C,
        edgeConductorAmountIncrementStep: I,
        edgeConductorAmountDecrementStep: w,
      } = s.edgeParameters,
      M = Pe(() => [Bh], []),
      [L, R] = ir(((tt = t.data) == null ? void 0 : tt.type) ?? at.nonFlexConduit),
      [T, D] = ir((($e = t.data) == null ? void 0 : $e.material) ?? di[at.nonFlexConduit].PVC),
      [z, E] = ir(((Ke = t.data) == null ? void 0 : Ke.diameter) ?? 1),
      [P, B] = ir(((V = t.data) == null ? void 0 : V.length) ?? 50),
      [F, S] = ir(((W = t.data) == null ? void 0 : W.sets) ?? 1),
      [Q, j] = ir(((le = t.data) == null ? void 0 : le.conductors) ?? M)
    Ce(() => {
      if (L === at.nonFlexConduit) return D(di[at.nonFlexConduit].PVC)
      if (L === at.flexibleConduit) return D(di[at.flexibleConduit].smurf)
      if (L === at.cable) return D(di[at.cable])
      if (L === at.busduct) return D(di[at.busduct])
    }, [L])
    const U = Qh(),
      q = ro(U, 'type'),
      ne = ro(U, 'material'),
      G = ro(U, 'diameter'),
      K = ro(U, 'length'),
      $ = ro(U, 'sets'),
      oe = te => {
        R(te)
      },
      Z = te => {
        D(te)
      },
      ie = (...te) => {
        o == null || o(...te)
      },
      fe = Pe(() => `${F} Parallel Sets</br>${z}″${T ? ` ${T} ` : ''}${P}′</br>${Q.map(te => `${te.amount}x ${r6[te.material]} ${te.size}</br>`)}`, [F, z, T, P, Q]),
      se = L !== at.cable && L !== at.busduct && !T,
      re = () => {
        n(
          fo({
            ...t,
            label: fe,
            data: {
              label: fe,
              type: L,
              material: T,
              diameter: z,
              length: P,
              sets: F,
              conductors: Q,
            },
            style: {
              ...(t.style ?? {}),
              stroke: se ? 'red' : '#b1b1b7',
            },
          })
        )
      },
      Y = N9[L],
      H = te => E(ce => Math.min(ce + te, l)),
      ee = te => E(ce => Math.max(ce - te, a)),
      xe = te => B(ce => Math.min(ce + te, f)),
      Fe = te => B(ce => Math.max(ce - te, d)),
      De = te => S(ce => Math.min(ce + te, x)),
      _e = te => S(ce => Math.max(ce - te, g)),
      Be = () => {
        j(te => [...te, { ...Bh }])
      },
      ke = te => ce =>
        j(J =>
          J.map((Ae, we) =>
            we === te
              ? {
                  ...Ae,
                  amount: Math.max(Ae.amount + ce, b),
                }
              : Ae
          )
        ),
      rt = te => ce =>
        j(J =>
          J.map((Ae, we) =>
            we === te
              ? {
                  ...Ae,
                  amount: Math.min(Ae.amount - ce, C),
                }
              : Ae
          )
        ),
      He = te => ce => {
        j(J =>
          J.map((Ae, we) =>
            we === te
              ? {
                  ...Ae,
                  material: ce,
                }
              : Ae
          )
        )
      },
      Le = te => ce => {
        j(J =>
          J.map((Ae, we) =>
            we === te
              ? {
                  ...Ae,
                  size: ce.target.value,
                }
              : Ae
          )
        )
      }
    return /* @__PURE__ */ p.jsxs(c9, {
      onClose: ie,
      maxWidth: r ?? 'sm',
      ...i,
      children: [
        /* @__PURE__ */ p.jsx(Sb, { children: 'Edit Connection' }),
        /* @__PURE__ */ p.jsxs(u9, {
          id: U,
          children: [
            /* @__PURE__ */ p.jsxs(fr, {
              children: [
                /* @__PURE__ */ p.jsx(sr, { children: 'Type' }),
                /* @__PURE__ */ p.jsx(fi, {
                  children: /* @__PURE__ */ p.jsx(Qc, {
                    items: S9,
                    value: L,
                    onChange: oe,
                    id: q,
                  }),
                }),
              ],
            }),
            Y &&
              /* @__PURE__ */ p.jsxs(fr, {
                children: [
                  /* @__PURE__ */ p.jsx(sr, { children: 'Material' }),
                  /* @__PURE__ */ p.jsx(fi, {
                    children: /* @__PURE__ */ p.jsx(Qc, {
                      items: Y,
                      value: T,
                      onChange: Z,
                      id: ne,
                    }),
                  }),
                ],
              }),
            /* @__PURE__ */ p.jsxs(fr, {
              children: [
                /* @__PURE__ */ p.jsx(sr, { children: 'Diameter (inches)' }),
                /* @__PURE__ */ p.jsx(fi, {
                  children: /* @__PURE__ */ p.jsx(vi, {
                    id: G,
                    value: z,
                    onIncrement: H,
                    onDecrement: ee,
                    incrementStep: c,
                    decrementStep: u,
                  }),
                }),
              ],
            }),
            /* @__PURE__ */ p.jsxs(fr, {
              children: [
                /* @__PURE__ */ p.jsx(sr, { children: 'Length (feet)' }),
                /* @__PURE__ */ p.jsx(fi, {
                  children: /* @__PURE__ */ p.jsx(vi, {
                    id: K,
                    value: P,
                    onIncrement: xe,
                    onDecrement: Fe,
                    incrementStep: A,
                    decrementStep: h,
                  }),
                }),
              ],
            }),
            /* @__PURE__ */ p.jsxs(fr, {
              children: [
                /* @__PURE__ */ p.jsx(sr, { children: 'Parallel Sets' }),
                /* @__PURE__ */ p.jsx(fi, {
                  children: /* @__PURE__ */ p.jsx(vi, {
                    id: $,
                    value: F,
                    onIncrement: De,
                    onDecrement: _e,
                    incrementStep: m,
                    decrementStep: v,
                  }),
                }),
              ],
            }),
            /* @__PURE__ */ p.jsxs(f9, {
              children: [
                /* @__PURE__ */ p.jsx(sr, { children: 'Conductors' }),
                Q.slice(0, y).map((te, ce) =>
                  /* @__PURE__ */ p.jsxs(
                    A9,
                    {
                      children: [
                        /* @__PURE__ */ p.jsx(vi, {
                          id: ro(U, `conductor-amount-${ce}`),
                          value: te.amount,
                          onIncrement: ke(ce),
                          onDecrement: rt(ce),
                          incrementStep: I,
                          decrementStep: w,
                        }),
                        /* @__PURE__ */ p.jsx(Qc, {
                          id: ro(U, `conductor-material-${ce}`),
                          value: te.material,
                          onChange: He(ce),
                          items: k9,
                        }),
                        /* @__PURE__ */ p.jsx(Qr, {
                          id: ro(U, `conductor-size-${ce}`),
                          value: te.size,
                          label: 'Conductor Size',
                          inputLabel: 'Conductor Size',
                          onChange: Le(ce),
                          style: At({ width: 160 }),
                          size: 'small',
                          children: a6.map(J => /* @__PURE__ */ p.jsx(Or, { value: J, children: s6[J] }, J)),
                        }),
                      ],
                    },
                    ce
                  )
                ),
                y > Q.length && /* @__PURE__ */ p.jsx(Pt, { variant: 'outlined', onClick: Be, children: 'Add Conductor Type' }),
              ],
            }),
            /* @__PURE__ */ p.jsx(d9, { onClick: re, variant: 'contained', children: 'Save' }),
          ],
        }),
      ],
    })
  },
  On = {
    NONE: 'NONE',
    EDGE_EDIT: 'EDGE_EDIT',
    EDGE_EDIT_V2: 'EDGE_EDIT_V2',
    COPY_SUBNODE: 'COPY_SUBNODE',
  },
  P9 = () => {
    const { invokeModal: e, closeModal: t, open: n } = Nb(),
      o = ge(
        r => {
          e(On.EDGE_EDIT_V2, r)
        },
        [e]
      )
    return {
      open: n,
      invokeModal: o,
      closeModal: t,
    }
  },
  Hi = e => /* @__PURE__ */ p.jsx(Do, { ...e }),
  kt = {
    100: '#DAECFF',
    200: '#80BFFF',
    400: '#3399FF',
    500: '#007FFF',
    600: '#0072E5',
    700: '#0059B2',
  },
  dt = {
    50: '#F3F6F9',
    100: '#E5EAF2',
    200: '#DAE2ED',
    300: '#C7D0DD',
    400: '#B0B8C4',
    500: '#9DA8B7',
    600: '#6B7A90',
    700: '#434D5B',
    800: '#303740',
    900: '#1C2025',
  },
  L9 = O('div')(
    ({ theme: e }) => `
  font-family: 'IBM Plex Sans', sans-serif;
  font-weight: 400;
  border-radius: 8px;
  color: ${e.palette.mode === 'dark' ? dt[300] : dt[900]};
  background: ${e.palette.mode === 'dark' ? dt[900] : '#fff'};
  border: 1px solid ${e.palette.mode === 'dark' ? dt[700] : dt[200]};
  box-shadow: 0 2px 4px ${e.palette.mode === 'dark' ? 'rgba(0,0,0, 0.5)' : 'rgba(0,0,0, 0.05)'};
  display: grid;
  grid-template-columns: 1fr 19px;
  grid-template-rows: 1fr 1fr;
  overflow: hidden;
  column-gap: 8px;
  padding: 4px;

  &.${Lu.focused} {
    border-color: ${kt[400]};
    box-shadow: 0 0 0 3px ${e.palette.mode === 'dark' ? kt[700] : kt[200]};
  }

  &:hover {
    border-color: ${kt[400]};
  }

  /* firefox */
  &:focus-visible {
    outline: 0;
  }
`
  ),
  R9 = O('input')(
    ({ theme: e }) => `
  font-size: 0.875rem;
  font-family: inherit;
  font-weight: 400;
  line-height: 1.5;
  grid-column: 1/2;
  grid-row: 1/3;
  color: ${e.palette.mode === 'dark' ? dt[300] : dt[900]};
  background: inherit;
  border: none;
  border-radius: inherit;
  padding: 8px 12px;
  outline: 0;
`
  ),
  Ih = O('button')(
    ({ theme: e }) => `
  display: flex;
  flex-flow: row nowrap;
  justify-content: center;
  align-items: center;
  appearance: none;
  padding: 0;
  width: 19px;
  height: 19px;
  font-family: system-ui, sans-serif;
  font-size: 0.875rem;
  line-height: 1;
  box-sizing: border-box;
  background: ${e.palette.mode === 'dark' ? dt[900] : '#fff'};
  border: 0;
  color: ${e.palette.mode === 'dark' ? dt[300] : dt[900]};
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 120ms;

  &:hover {
    cursor: pointer;
    color: #FFF;
    background: ${e.palette.mode === 'dark' ? kt[600] : kt[500]};
    border-color: ${e.palette.mode === 'dark' ? kt[400] : kt[600]};
  }

  &.${Lu.incrementButton} {
    grid-column: 2/3;
    grid-row: 1/2;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    border: 1px solid;
    border-bottom: 0;
    border-color: ${e.palette.mode === 'dark' ? dt[700] : dt[200]};
    background: ${e.palette.mode === 'dark' ? dt[900] : dt[50]};
    color: ${e.palette.mode === 'dark' ? dt[200] : dt[900]};

    &:hover {
      cursor: pointer;
      color: #FFF;
      background: ${e.palette.mode === 'dark' ? kt[600] : kt[500]};
      border-color: ${e.palette.mode === 'dark' ? kt[400] : kt[600]};
    }
  }

  &.${Lu.decrementButton} {
    grid-column: 2/3;
    grid-row: 2/3;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    border: 1px solid;
    border-color: ${e.palette.mode === 'dark' ? dt[700] : dt[200]};
    background: ${e.palette.mode === 'dark' ? dt[900] : dt[50]};
    color: ${e.palette.mode === 'dark' ? dt[200] : dt[900]};
    
    &:hover {
      cursor: pointer;
      color: #FFF;
      background: ${e.palette.mode === 'dark' ? kt[600] : kt[500]};
      border-color: ${e.palette.mode === 'dark' ? kt[400] : kt[600]};
    }
  }

  & .arrow {
    transform: translateY(-1px);
  }
`
  ),
  Pb = jr(function (t, n) {
    return /* @__PURE__ */ p.jsx(sD, {
      slots: {
        root: L9,
        input: R9,
        incrementButton: Ih,
        decrementButton: Ih,
      },
      slotProps: {
        incrementButton: {
          children: '▴',
          type: 'button',
        },
        decrementButton: {
          children: '▾',
          type: 'button',
        },
      },
      ...t,
      ref: n,
    })
  }),
  T9 = O(of)``,
  F9 = O('div')`
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px 24px;
`,
  D9 = O(Hi)`
  font-size: 16px;
  font-weight: 500;
`,
  z9 = O(Pb)``,
  Nh = O(Pt)``,
  Q9 = e => {
    const { node: t, onCopy: n, onCancel: o, onChange: r, open: i } = e,
      [s, a] = be(1),
      { config: l } = cs(),
      { minCopies: c, maxCopies: u } = l.subNodeParameters,
      d = (h, g) => {
        a(g), r == null || r(g)
      },
      f = () => {
        n == null || n(s, t)
      },
      A = () => {
        o == null || o(s, t)
      }
    return /* @__PURE__ */ p.jsx(T9, {
      open: i,
      onClose: A,
      children: /* @__PURE__ */ p.jsxs(F9, {
        children: [
          /* @__PURE__ */ p.jsx(D9, { children: 'How many copies?' }),
          /* @__PURE__ */ p.jsx(z9, {
            value: s,
            onChange: d,
            min: c,
            max: u,
          }),
          /* @__PURE__ */ p.jsx(Nh, { onClick: f, variant: 'contained', children: 'Commit' }),
          /* @__PURE__ */ p.jsx(Nh, { onClick: A, variant: 'outlined', children: 'Cancel' }),
        ],
      }),
    })
  },
  Lb = po({
    open: !1,
    invokeModal: () => {},
    closeModal: () => {},
  }),
  O9 = ({ children: e }) => {
    const [t, n] = be({}),
      [o, r] = be(On.NONE),
      i = Pe(() => o !== On.NONE, [o]),
      s = ge(
        (h, g) => {
          r(h), g && n(g)
        },
        [r, n]
      ),
      a = ge(() => {
        r(On.NONE), n({})
      }, []),
      l = Pe(
        () => ({
          open: i,
          invokeModal: s,
          closeModal: a,
        }),
        [i, s, a]
      ),
      { onClose: c, ...u } = Pe(() => t, [t]),
      f = {
        open: !0,
        onClose: ge(
          (...h) => {
            l.closeModal(), c == null || c(...h)
          },
          [c, l]
        ),
      },
      A = {
        [On.NONE]: null,
        [On.EDGE_EDIT]: /* @__PURE__ */ p.jsx(s9, { ...f, ...u }),
        [On.EDGE_EDIT_V2]: /* @__PURE__ */ p.jsx(M9, { ...f, ...u }),
        [On.COPY_SUBNODE]: /* @__PURE__ */ p.jsx(Q9, { ...f, ...u }),
      }
    return /* @__PURE__ */ p.jsxs(Lb.Provider, { value: l, children: [e, A[o]] })
  },
  j9 = ({ ...e }) => /* @__PURE__ */ p.jsx(GT, { autoClose: 3e3, limit: 5, ...e }),
  W9 = ({ bootstrapped: e, services: t, config: n, theme: o, children: r }) =>
    e
      ? t
        ? /* @__PURE__ */ p.jsx(ON, {
            config: n,
            children: /* @__PURE__ */ p.jsx(zN.Provider, {
              value: t,
              children: /* @__PURE__ */ p.jsx(Nw, { theme: o, children: /* @__PURE__ */ p.jsx(Z0, { children: /* @__PURE__ */ p.jsx(pG, { children: /* @__PURE__ */ p.jsxs(aF, { children: [/* @__PURE__ */ p.jsx(gG, { children: /* @__PURE__ */ p.jsxs(O9, { children: [/* @__PURE__ */ p.jsx(gS, {}), r] }) }), /* @__PURE__ */ p.jsx(j9, {})] }) }) }) }),
            }),
          })
        : /* @__PURE__ */ p.jsx('div', { children: 'Failed to initialize App services!' })
      : /* @__PURE__ */ p.jsx('div', { children: 'Initializing App...' }),
  G9 = e => /* @__PURE__ */ p.jsx(FR, { ...e }),
  V9 = e => /* @__PURE__ */ p.jsx($R, { ...e }),
  X9 = jr((e, t) => /* @__PURE__ */ p.jsx(IR, { reconne: !0, ref: t, ...e })),
  Y9 = e => /* @__PURE__ */ p.jsx(es, { ...e }),
  H9 = e => /* @__PURE__ */ p.jsx(nm, { ...e }),
  kh = e => /* @__PURE__ */ p.jsx(iI, { ...e }),
  Mh = e => /* @__PURE__ */ p.jsx(uI, { ...e }),
  U9 = e => /* @__PURE__ */ p.jsx(Kg, { ...e }),
  lf = ({ items: e, itemsAfterDivider: t, paperStyle: n }) =>
    /* @__PURE__ */ p.jsx(Y9, {
      style: n,
      sx: { width: 240, maxWidth: '100%' },
      children: /* @__PURE__ */ p.jsxs(H9, {
        children: [
          e == null
            ? void 0
            : e.map(o =>
                /* @__PURE__ */ p.jsxs(
                  Or,
                  {
                    onClick: r => {
                      var i
                      return (i = o.onClick) == null ? void 0 : i.call(o, r)
                    },
                    children: [
                      /* @__PURE__ */ p.jsx(kh, { color: o.color, children: o.icon }),
                      /* @__PURE__ */ p.jsx(Mh, { color: o.color, children: o.text }),
                      o.command &&
                        /* @__PURE__ */ p.jsx(Hi, {
                          variant: 'body2',
                          color: o.color ?? 'text.secondary',
                          children: o.command,
                        }),
                    ],
                  },
                  o.text
                )
              ),
          t &&
            /* @__PURE__ */ p.jsxs(p.Fragment, {
              children: [/* @__PURE__ */ p.jsx(U9, {}), t.map(o => /* @__PURE__ */ p.jsxs(Or, { children: [/* @__PURE__ */ p.jsx(kh, { children: o.icon }), /* @__PURE__ */ p.jsx(Mh, { children: o.text }), o.command && /* @__PURE__ */ p.jsx(Hi, { variant: 'body2', color: 'text.secondary', children: o.command })] }, o.text))],
            }),
        ],
      }),
    }),
  K9 = ({ iconMenuProps: e, onNodeCreate: t, ...n }) => {
    const o = Pe(
      () => [
        {
          text: 'Create Asset',
          icon: /* @__PURE__ */ p.jsx(Zl, {}),
          onClick: t,
        },
      ],
      [t]
    )
    return /* @__PURE__ */ p.jsx(lf, {
      paperStyle: {
        position: 'absolute',
        zIndex: jd,
        top: n.top - 150,
        left: n.left - 250,
        bottom: n.bottom,
        right: n.right,
      },
      items: o,
      ...e,
    })
  }
var cf = {},
  q9 = Ji
Object.defineProperty(cf, '__esModule', {
  value: !0,
})
var uf = (cf.default = void 0),
  Z9 = q9(sf()),
  J9 = p
uf = cf.default = (0, Z9.default)(
  /* @__PURE__ */ (0, J9.jsx)('path', {
    d: 'M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zm2.46-7.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14zM15.5 4l-1-1h-5l-1 1H5v2h14V4z',
  }),
  'DeleteForever'
)
const Ph = dd(
    /* @__PURE__ */ p.jsx('path', {
      d: 'M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2m0 14H3V5h18zm-5-7v2h-3v3h-2v-3H8v-2h3V7h2v3z',
    }),
    'AddToQueue'
  ),
  _9 = ({ iconMenuProps: e, onNodeDelete: t, onCreateDownstreamAsset: n, onLineSideSubNodeCreate: o, onLoadSideSubNodeCreate: r, targetNode: i, ...s }) => {
    const l = !Ul(i),
      c = Pe(() => i.type === To.ElectricalPanelNode, [i.type]),
      u = c && i.data.electricalPanelType === Vo.MCB,
      d = Pe(
        () => [
          {
            text: 'Delete Asset',
            icon: /* @__PURE__ */ p.jsx(uf, {}),
            onClick: () => (t == null ? void 0 : t(s.id)),
            color: 'error.main',
          },
          ...(l
            ? [
                {
                  text: 'Create Downstream Asset',
                  icon: /* @__PURE__ */ p.jsx(Zl, {}),
                  onClick: () => (n == null ? void 0 : n(i)),
                },
              ]
            : []),
          ...(l && c && u
            ? [
                {
                  text: 'Create New Line-Side Subcomponent',
                  icon: /* @__PURE__ */ p.jsx(Ph, {}),
                  onClick: () => (o == null ? void 0 : o(i)),
                },
              ]
            : []),
          ...(l && c
            ? [
                {
                  text: 'Create New Load-Side Subcomponent',
                  icon: /* @__PURE__ */ p.jsx(Ph, {}),
                  onClick: () => (r == null ? void 0 : r(i)),
                },
              ]
            : []),
        ],
        [l, c, t, s.id, n, i, o, r]
      )
    return /* @__PURE__ */ p.jsx(lf, {
      paperStyle: {
        position: 'absolute',
        zIndex: jd,
        top: s.top - 150,
        left: s.left - 250,
        bottom: s.bottom,
        right: s.right,
        width: 'fit-content',
      },
      items: d,
      ...e,
    })
  },
  $9 = ({ iconMenuProps: e, onEdgeDelete: t, ...n }) => {
    const o = Pe(
      () => [
        {
          text: 'Delete Edge',
          icon: /* @__PURE__ */ p.jsx(uf, {}),
          onClick: () => (t == null ? void 0 : t(n.id)),
          color: 'error.main',
        },
      ],
      [n, t]
    )
    return /* @__PURE__ */ p.jsx(lf, {
      paperStyle: {
        position: 'absolute',
        zIndex: jd,
        top: n.top - 150,
        left: n.left - 250,
        bottom: n.bottom,
        right: n.right,
      },
      items: o,
      ...e,
    })
  },
  e7 = e => /* @__PURE__ */ p.jsx(Fl, { ...e }),
  Lh = O(e7)`
  display: flex;
  gap: 4px;
`,
  t7 = O('input')`
  visibility: hidden;
  width: 0;
  height: 0;
`,
  n7 = {
    width: '100%',
    height: '100%',
    position: 'absolute',
    zIndex: 10,
    pointerEvents: 'none',
  },
  o7 = e => ({
    width: e.width,
    height: e.height,
    transform: e.transform,
  }),
  r7 = ({ horizontal: e, vertical: t }) => {
    const { width: n, height: o, transform: r } = Re(o7),
      i = Ne(null)
    return (
      Ce(() => {
        const s = i.current,
          a = s == null ? void 0 : s.getContext('2d')
        if (!a || !s) return
        const l = window.devicePixelRatio
        ;(s.width = n * l), (s.height = o * l), a.scale(l, l), a.clearRect(0, 0, n, o), (a.strokeStyle = '#0041d0'), typeof t == 'number' && (a.moveTo(t * r[2] + r[0], 0), a.lineTo(t * r[2] + r[0], o), a.stroke()), typeof e == 'number' && (a.moveTo(0, e * r[2] + r[1]), a.lineTo(n, e * r[2] + r[1]), a.stroke())
      }, [n, o, r, e, t]),
      /* @__PURE__ */ p.jsx('canvas', {
        ref: i,
        className: 'react-flow__canvas',
        style: n7,
      })
    )
  },
  i7 = jr(
    (
      {
        paneMenu: e,
        onNodeCreate: t,
        nodeMenu: n,
        onNodeDelete: o,
        edgeMenu: r,
        onEdgeDelete: i,
        viewMode: s,
        editMode: a,
        horizontalHelperLine: l,
        verticalHelperLine: c,
        onCreateDownstreamAsset: u,
        onLineSideSubNodeCreate: d,
        onLoadSideSubNodeCreate: f,
        onHorizontalClick: A,
        onVerticalClick: h,
        onToggleViewMode: g,
        onExportFlow: x,
        onImportFlow: m,
        onToggleEditMode: v,
        onDataChange: y,
        ...b
      },
      C
    ) => {
      const I = Ne(null),
        w = a === Hn.unlocked,
        M = () => {
          var L
          ;(L = I.current) == null || L.click()
        }
      return /* @__PURE__ */ p.jsx('div', {
        style: { width: 'calc(100% - 0px)', height: 'calc(100vh - 128px)' },
        children: /* @__PURE__ */ p.jsxs(X9, {
          ref: C,
          ...b,
          children: [
            /* @__PURE__ */ p.jsx(G9, { gap: YT }),
            /* @__PURE__ */ p.jsx(V9, {}),
            /* @__PURE__ */ p.jsx(r7, {
              horizontal: l,
              vertical: c,
            }),
            e && w && /* @__PURE__ */ p.jsx(K9, { onNodeCreate: t, ...e }),
            n &&
              w &&
              /* @__PURE__ */ p.jsx(_9, {
                onNodeDelete: o,
                onCreateDownstreamAsset: u,
                onLineSideSubNodeCreate: d,
                onLoadSideSubNodeCreate: f,
                ...n,
              }),
            r && w && /* @__PURE__ */ p.jsx($9, { onEdgeDelete: i, ...r }),
            (A || h) && /* @__PURE__ */ p.jsx(Lh, { position: 'top-right', children: h && /* @__PURE__ */ p.jsx(Pt, { onClick: h, variant: 'contained', children: YO[yn.vertical] }) }),
            (g || x || m || v || y) &&
              /* @__PURE__ */ p.jsxs(Lh, {
                position: 'bottom-left',
                children: [
                  g && /* @__PURE__ */ p.jsx(Pt, { variant: 'contained', onClick: g, children: UO[s] }),
                  x && /* @__PURE__ */ p.jsx(Pt, { variant: 'contained', onClick: x, children: 'Export' }),
                  m &&
                    /* @__PURE__ */ p.jsxs(Pt, {
                      variant: 'contained',
                      onClick: M,
                      children: [
                        /* @__PURE__ */ p.jsx(t7, {
                          type: 'file',
                          ref: I,
                          onChange: m,
                        }),
                        'Import',
                      ],
                    }),
                  v && /* @__PURE__ */ p.jsx(p.Fragment, { children: /* @__PURE__ */ p.jsx(Pt, { variant: 'contained', onClick: v, children: HO[a] }) }),
                ],
              }),
          ],
        }),
      })
    }
  ),
  s7 = e => /* @__PURE__ */ p.jsx(pB, { ...e }),
  a7 = O('div')`
  width: 360px;
  padding: 20px 32px;
  display: flex;
  flex-direction: column;
`,
  l7 = ({ children: e, ...t }) => /* @__PURE__ */ p.jsx(s7, { anchor: 'right', ...t, children: /* @__PURE__ */ p.jsx(a7, { children: e }) }),
  c7 = O('form')`
  display: flex;
  flex-direction: column;
  gap: 24px;

  .MuiSelect-select > span {
    display: none;
  }
`,
  u7 = O(Hi)`
  font-size: 24px;
  font-weight: 500;
`,
  d7 = O(Pt)`
  width: 100%;
`,
  f7 = O(Or)`
  display: flex;
  justify-content: space-between;
  align-items: center;
`,
  A7 = O('span')`
  color: #ccccff88;
`,
  p7 = O(kb)`
  & > * {
    flex-grow: 1;
  }
`,
  Rh = O('div')`
  display: flex;
  flex-direction: column;
  gap: 8px;
`,
  Th = O(Hi)`
  font-size: 14px;
  font-weight: 500;
`,
  h7 = O('div')`
  display: flex;
  gap: 12px;
`,
  Fh = O(Pt)`
  flex-grow: 1;
`,
  g7 = _O.map(e => ({
    label: JO[e],
    value: e,
  })),
  m7 = ({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: i, onNodeArchetypeChange: s, onDeleteClick: a, onCopyClick: l }) => {
    const { config: c } = cs(),
      { minAmpereRating: u = 0.01, maxAmpereRating: d = 1e3, polesIncrementStep: f, polesDecrementStep: A } = c.subNodeParameters,
      {
        name: h,
        code: g,
        nameExistsAlready: x,
        handleNameChange: m,
        handleNodeClassCodeChange: v,
        handleSave: y,
        archetype: b,
        handleArchetypeChange: C,
        ampereRating: I,
        handleAmpereRatingChange: w,
        poles: M,
        handlePolesIncrement: L,
        handlePolesDecrement: R,
        handleDeleteClick: T,
        handleCopyClick: D,
      } = Wd({
        node: e,
        onSave: t,
        onNodeNameChange: n,
        onNodeColorChange: o,
        onNodeClassCodeChange: r,
        onNodeElectricalPanelTypeChange: i,
        onNodeArchetypeChange: s,
        onDeleteClick: a,
        onCopyClick: l,
      }),
      z = x ? 'This node exists already' : '',
      E = Pe(() => ZO.map(P => /* @__PURE__ */ p.jsxs(f7, { value: P, children: [Ty[P], /* @__PURE__ */ p.jsx(A7, { children: Zd[P] })] }, P)))
    return /* @__PURE__ */ p.jsxs(c7, {
      children: [
        /* @__PURE__ */ p.jsx(u7, { children: 'Edit OCP Device' }),
        /* @__PURE__ */ p.jsx(ki, {
          value: h,
          onChange: m,
          label: 'Device Name',
          size: 'small',
          error: x,
          helperText: z,
        }),
        /* @__PURE__ */ p.jsx(p7, {
          items: g7,
          value: b,
          onChange: C,
        }),
        /* @__PURE__ */ p.jsx(Qr, {
          label: 'Asset Class',
          inputLabel: 'Asset Class',
          value: g,
          onChange: v,
          size: 'small',
          children: E,
        }),
        /* @__PURE__ */ p.jsxs(Rh, {
          children: [
            /* @__PURE__ */ p.jsx(Th, { children: 'Ampere Rating' }),
            /* @__PURE__ */ p.jsx(Pb, {
              value: I,
              onChange: w,
              min: u,
              max: d,
              placeholder: 'Ampere Rating',
            }),
          ],
        }),
        /* @__PURE__ */ p.jsxs(Rh, {
          children: [
            /* @__PURE__ */ p.jsx(Th, { children: '# of Poles / Conductors' }),
            /* @__PURE__ */ p.jsx(vi, {
              value: M,
              onIncrement: L,
              onDecrement: R,
              incrementStep: f,
              decrementStep: A,
            }),
          ],
        }),
        /* @__PURE__ */ p.jsxs(h7, {
          children: [
            /* @__PURE__ */ p.jsx(Fh, {
              color: 'error',
              variant: 'contained',
              onClick: T,
              children: 'Delete',
            }),
            /* @__PURE__ */ p.jsx(Fh, { variant: 'contained', onClick: D, children: 'Copy' }),
          ],
        }),
        /* @__PURE__ */ p.jsx(d7, { onClick: y, variant: 'contained', children: 'Save' }),
      ],
    })
  },
  y7 = O('form')`
  display: flex;
  flex-direction: column;
  gap: 24px;

  .MuiSelect-select > span {
    display: none;
  }
`,
  b7 = O(Pt)`
  width: 100%;
`,
  Dh = O(Or)`
  display: flex;
  justify-content: space-between;
  align-items: center;
`,
  v7 = O('span')`
  color: #ccccff88;
`,
  x7 = ({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: i }) => {
    const {
        name: s,
        color: a,
        code: l,
        nodeChildren: c,
        electricalPanelType: u,
        hasParent: d,
        isElectricalPanel: f,
        isWithImplicitClass: A,
        nodeParent: h,
        hasChildren: g,
        parentNodeInputLabel: x,
        handleChildNameChange: m,
        nameExistsAlready: v,
        handleNameChange: y,
        handleNodeClassCodeChange: b,
        handleColorChange: C,
        handleElectricalPanelTypeChange: I,
        handleSave: w,
      } = Wd({
        node: e,
        onSave: t,
        onNodeNameChange: n,
        onNodeColorChange: o,
        onNodeClassCodeChange: r,
        onNodeElectricalPanelTypeChange: i,
      }),
      M = v ? 'This node exists already' : '',
      L = Pe(() => qO.map(T => /* @__PURE__ */ p.jsxs(Dh, { value: T, children: [Ty[T], /* @__PURE__ */ p.jsx(v7, { children: Zd[T] })] }, T))),
      R = Pe(() => $O.map(T => /* @__PURE__ */ p.jsx(Dh, { value: T, children: T }, T)), [])
    return /* @__PURE__ */ p.jsxs(y7, {
      children: [
        /* @__PURE__ */ p.jsx(Qr, {
          label: 'Node Class Code',
          inputLabel: 'Node Class Code',
          value: l,
          onChange: b,
          size: 'small',
          children: L,
        }),
        A &&
          /* @__PURE__ */ p.jsx(ki, {
            value: s,
            onChange: y,
            label: 'Node Name',
            size: 'small',
            error: v,
            helperText: M,
          }),
        f &&
          /* @__PURE__ */ p.jsx(Qr, {
            label: 'Electrical Panel Type',
            inputLabel: 'Electrical PanelType',
            value: u,
            onChange: I,
            size: 'small',
            children: R,
          }),
        /* @__PURE__ */ p.jsx(Ib, {
          value: a,
          onChange: C,
          label: 'Node Color',
          size: 'small',
        }),
        d &&
          h &&
          /* @__PURE__ */ p.jsx(ki, {
            disabled: !0,
            label: x,
            size: 'small',
            value: `${Ir(h)}`,
          }),
        g &&
          c.map((T, D) =>
            /* @__PURE__ */ p.jsx(
              ki,
              {
                label: `Subcomponent ${D + 1} `,
                size: 'small',
                value: Ir(T),
                onChange: m(T),
              },
              T.id
            )
          ),
        /* @__PURE__ */ p.jsx(b7, {
          onClick: w,
          variant: 'contained',
          disabled: v,
          children: 'Save',
        }),
      ],
    })
  },
  C7 = ({ node: e, onSave: t, onNodeNameChange: n, onNodeColorChange: o, onNodeClassCodeChange: r, onNodeElectricalPanelTypeChange: i, onNodeArchetypeChange: s, onDeleteClick: a, onCopyClick: l }) => {
    const { isTopLevelNode: c } = Wd({
      node: e,
      onSave: t,
      onNodeNameChange: n,
      onNodeColorChange: o,
      onNodeClassCodeChange: r,
      onNodeElectricalPanelTypeChange: i,
    })
    return c
      ? /* @__PURE__ */ p.jsx(x7, {
          node: e,
          onSave: t,
          onNodeNameChange: n,
          onNodeColorChange: o,
          onNodeClassCodeChange: r,
          onNodeElectricalPanelTypeChange: i,
          onNodeArchetypeChange: s,
          onDeleteClick: a,
          onCopyClick: l,
        })
      : /* @__PURE__ */ p.jsx(m7, {
          node: e,
          onSave: t,
          onNodeNameChange: n,
          onNodeColorChange: o,
          onNodeClassCodeChange: r,
          onNodeElectricalPanelTypeChange: i,
          onDeleteClick: a,
          onCopyClick: l,
        })
  },
  zh = 'application/json',
  w7 = () => {
    const { invokeModal: e, closeModal: t, open: n } = Nb(),
      o = ge(
        r => {
          e(On.COPY_SUBNODE, r)
        },
        [e]
      )
    return {
      open: n,
      invokeModal: o,
      closeModal: t,
    }
  },
  E7 = ({ initialData: e, onDataChange: t, onSingleChange: n }) => {
    const { nodes: o, edges: r, viewMode: i, editMode: s, horizontalHelperLine: a, verticalHelperLine: l, changesEnabled: c, setNodes: u, setEdges: d, setViewMode: f, setEditMode: A, onNodesChange: h, onEdgesChange: g, onLayout: x, takeSnapshot: m } = ho(),
      [v, y] = be(null),
      [b, C] = be(null),
      [I, w] = be(null),
      [M, L] = be(null),
      [R, T] = be({}),
      [D, z] = be([]),
      [E, P] = be([]),
      [B, F] = be({
        isAdding: !1,
        isEditing: !1,
        isDeleting: !1,
        changeData: null,
      }),
      { getNodes: S } = qo(),
      { open: Q, closeDrawer: j, openDrawer: U, nodeToEdit: q } = cF(),
      { invokeModal: ne, closeModal: G } = P9(),
      { invokeModal: K, closeModal: $ } = w7(),
      oe = Ne(null),
      Z = ae => {
        if (!c) return
        m(), De(ae), G()
        const ue = E.find(he => he.id === ae.id)
        ;(ue == null ? void 0 : ue.isNew) === !0 && (ae.isNew = !0)
        const Me = E.filter(he => he.id !== (ue == null ? void 0 : ue.id))
        P([...Me, ae])
      },
      ie = ge(
        ae => {
          d(ue => mu(ae, ue)),
            P(ue => mu({ ...ae, isNew: !0 }, ue)),
            ne({
              edge: fo({
                ...ae,
                id: `xy-edge__${ae.source}-${ae.target}`,
              }),
              onSave: Z,
            })
        },
        [d, ne, Z]
      ),
      { openMenu: fe, closeMenu: se } = tF(oe, y),
      { openMenu: re, closeMenu: Y } = nF(oe, C, {
        onSet: ae => w(ae),
      }),
      { openMenu: H, closeMenu: ee } = oF(oe, L)
    eF(u)
    const xe = rF(u),
      Fe = uF(u),
      De = dF(d)
    pF(d)
    const _e = iF(d),
      Be = hF(u),
      ke = wF(d),
      { getViewport: rt } = qo(),
      He = ae => {
        if (v && c) {
          const ue = g6(ae, rt())
          se()
          const Me = {
            ...B,
            isAdding: !0,
            changeData: ue,
          }
          n(Me)
        }
      },
      Le = ae => {
        if (b && c) {
          m()
          const ue = Be(ae, b == null ? void 0 : b.position, {
            data: { archetype: et.lineSide },
          })
          ke(ue, o, r), Y()
          const Me = {
            ...B,
            isAddingLineSide: !0,
            changeData: { ...ae, lineLoadSideId: 1 },
          }
          n(Me)
        }
      },
      tt = ae => {
        if (b && c) {
          m()
          const ue = Be(ae, b == null ? void 0 : b.position, {
            data: { archetype: et.loadSide },
          })
          ke(ue, o, r), Y()
          const Me = {
            ...B,
            isAddingLineSide: !0,
            changeData: { ...ae, lineLoadSideId: 2 },
          }
          n(Me)
        }
      },
      $e = ae => {
        if (b && c) {
          Y()
          const ue = {
            ...B,
            isAddingDownstream: !0,
            changeData: ae,
          }
          n(ue)
        }
      },
      Ke = ae => {
        if (b && c) {
          Y()
          const ue = {
            ...B,
            isDeleting: !0,
            changeData: ae,
          }
          n(ue)
        }
      },
      V = ae => {
        if (!c) return
        m(), xe(ae.id), j()
        const ue = {
          ...B,
          isDeleting: !0,
          changeData: ae.id,
        }
        n(ue)
      },
      W = (ae, ue) => {
        K({
          node: ae,
          onCancel: $,
          onCopy: (Me, he) => {
            Array.from({ length: Me })
              .fill(null)
              .forEach(() => {
                const Ee = Be(ue, I == null ? void 0 : I.position, {
                  ...he,
                  id: Ho(),
                  data: {
                    ...he.data,
                    label: `${he.data.label} copy-${Ho()}`,
                  },
                })
                ke(Ee, o, r), $(), j()
              })
          },
        })
      },
      le = ae => {
        var ue
        if (M && c) {
          m(), _e(ae), ee()
          const Me = E.filter(Ee => Ee.id !== ae),
            he = ((ue = E.find(Ee => Ee.id === ae)) == null ? void 0 : ue.isNew) === !0
          P([...Me, he ? null : { id: ae, isDeleted: !0 }].filter(Boolean))
        }
      },
      te = () => {
        v && c && se(), b && c && Y(), M && c && ee(), j()
      },
      ce = ae => {
        if ((c || Y(), b && c)) {
          Y()
          return
        }
        fe(ae)
      },
      J = (ae, ue) => {
        if (v && c) {
          se()
          return
        }
        re(ae, ue)
      },
      Ae = (ae, ue) => {
        if (M && c) {
          ee()
          return
        }
        H(ae, ue)
      },
      we = ae => {
        c && (m(), Fe(ae))
      },
      Ie = ae => {
        we(ae), j()
      },
      lt = ae => {
        we(ae)
      },
      Zt = ae => {
        we(ae)
      },
      Fn = ae => {
        we(ae)
      },
      nr = (ae, ue) => {
        if (!c) return
        const Me = {
          ...B,
          isEditing: !0,
          changeData: ue,
        }
        n(Me)
      },
      or = (ae, ue) => {
        !c || ue.data.isInvisibleEdge || ne({ edge: ue, onSave: Z })
      },
      go = () => {
        x(yn.vertical)
      },
      mo = () => {
        x(yn.vertical)
      },
      yo = () => {
        f(ae => (ae === uo.standard ? uo.enhanced : uo.standard))
      },
      bo = () => {
        const ue = JSON.stringify({
            nodes: o,
            edges: r,
          }),
          Me = new Blob([ue], { type: zh }),
          he = URL.createObjectURL(Me)
        UN(he, { filename: JN() }), URL.revokeObjectURL(he)
      },
      qr = ae => {
        var he
        const ue = (he = ae.target.files) == null ? void 0 : he[0]
        if (!ue || ue.type !== zh) return alert('Please upload a JSON file')
        const Me = new FileReader()
        ;(Me.onload = Ee => {
          var ze
          const nt = (ze = Ee.target) == null ? void 0 : ze.result
          if (!nt) return alert('Failed to read the file')
          if (typeof nt != 'string') return alert('File is not a string')
          const vt = JSON.parse(nt)
          qN(vt), u(vt.nodes), d(vt.edges)
        }),
          Me.readAsText(ue)
      },
      vo = () => {
        m()
      },
      xo = () => {
        m()
      },
      Co = () => {
        A(ae => (ae === Hn.locked ? Hn.unlocked : Hn.locked))
      },
      Zr = ae => {
        try {
          return JSON.parse(ae)
        } catch {
          return console.error('Invalid JSON found:', ae), null
        }
      }
    Ce(() => {
      if (!u) {
        console.error('setNodes function is not available. Check FlowContext setup.')
        return
      }
      if (!d) {
        console.error('setEdges function is not available. Check FlowContext setup.')
        return
      }
      u([]),
        Object.keys(e).length > 0 &&
          (u(ae => {
            var Me
            const ue =
              (Me = e == null ? void 0 : e.list) == null
                ? void 0
                : Me.map(he => {
                    var nt, vt, ze, it, eo, Dn, Dt
                    let Ee
                    return (
                      he.extent === 'parent' ? (Ee = Fy[(nt = he.data) == null ? void 0 : nt.code] || 'VCCB') : (Ee = Ru[(vt = he.data) == null ? void 0 : vt.code] || 'MISC'),
                      fn({
                        id: he.assetId,
                        type: Ni[Ee],
                        position: he.position,
                        data: {
                          archetype: (ze = he.data) == null ? void 0 : ze.archetype,
                          label: (it = he.data) == null ? void 0 : it.label,
                          background: (eo = he.data) == null ? void 0 : eo.background,
                          border: (Dn = he.data) == null ? void 0 : Dn.border,
                          code: (Dt = he.data) == null ? void 0 : Dt.code,
                        },
                        style: he.style,
                        parentId: he.parentId,
                        selected: he.selected,
                        dragging: he.dragging,
                        ...(he.extent === 'parent' && { extent: he.extent }),
                      })
                    )
                  })
            return [...ae, ...ue]
          }),
          d(ae => {
            var Me
            const ue =
              (Me = e == null ? void 0 : e.initialEdges) == null
                ? void 0
                : Me.map(he => {
                    const Ee = he.fedbyDetailsJson ? Zr(he.fedbyDetailsJson) : null,
                      nt = {
                        id: he.id,
                        source: he.source,
                        target: he.target,
                        parentAssetId: he.parentAssetId,
                        assetId: he.assetId,
                        viaSubcomponentAssetId: he.viaSubcomponentAssetId,
                        fedByViaSubcomponantAssetId: he.fedByViaSubcomponantAssetId,
                        label: he.label,
                        fedbyDetailsJson: he.fedbyDetailsJson,
                        style: he.style,
                        type: he.type,
                        ...(Ee && {
                          data: {
                            type: Ee.type === 'step' ? Ee.data.type : Ee.type ?? Ee.data.type,
                            material: Ee.material ?? Ee.data.material,
                            diameter: Ee.diameter ?? Ee.data.diameter,
                            length: Ee.length ?? Ee.data.length,
                            sets: Ee.sets ?? Ee.data.sets,
                            conductors: Ee.conductors ?? Ee.data.conductors,
                            label: Ee.label ?? Ee.data.label ?? he.label,
                          },
                        }),
                      }
                    return fo(nt)
                  })
            return [...ae, ...ue]
          }))
    }, [e, u, d]),
      console.log(r)
    const Jr = () => {
        const ae = o,
          ue = [...e.list],
          Me = ae.filter(nt => {
            const vt = ue.find(ze => ze.assetId === nt.id)
            return vt ? nt.position.x !== vt.position.x || nt.position.y !== vt.position.y : !0
          }),
          he = r
            .filter(nt => !e.initialEdges.some(vt => vt.id === nt.id))
            .map(nt => ({
              ...nt,
              isNew: !0,
            })),
          Ee = [...E, ...he].filter((nt, vt, ze) => vt === ze.findIndex(it => it.id === nt.id))
        t
          ? (t({
              changedNodes: Me,
              updatedEdgesMovement: Ee,
            }),
            P([]))
          : console.error('onDataChange function is not defined.')
      },
      _r = () => {
        S().forEach(ue => {
          const Me = R[ue.id] || []
          ;(Me.length === 0 || ue.position.x !== Me[Me.length - 1].x || ue.position.y !== Me[Me.length - 1].y) &&
            (T(Ee => ({
              ...Ee,
              [ue.id]: [...Me, { x: ue.position.x, y: ue.position.y }],
            })),
            z(Ee => [...Ee, ue.id]))
        })
      },
      $r = () => {
        if (D.length === 0) {
          console.log('Nothing to undo.')
          return
        }
        const ae = D[D.length - 1],
          ue = R[ae]
        if (!ue || ue.length < 2) {
          console.log('Nothing to undo for this node.')
          return
        }
        const Me = ue[ue.length - 2]
        u(he => he.map(Ee => (Ee.id === ae ? { ...Ee, position: Me } : Ee))),
          T(he => ({
            ...he,
            [ae]: ue.slice(0, -1),
          })),
          z(he => he.slice(0, -1))
      }
    return (
      Ce(() => {
        o.forEach(ae => {
          R[ae.id] ||
            T(ue => ({
              ...ue,
              [ae.id]: [{ x: ae.position.x, y: ae.position.y }],
            }))
        })
      }, [o]),
      Ce(() => {
        const ae = setTimeout(() => {
          _r()
        }, 500)
        return () => {
          clearTimeout(ae)
        }
      }, [o]),
      /* @__PURE__ */ p.jsxs(p.Fragment, {
        children: [
          /* @__PURE__ */ p.jsx(i7, {
            editMode: s,
            onToggleEditMode: Co,
            nodesConnectable: c,
            edgesReconnectable: c,
            ref: oe,
            nodes: o,
            edges: r,
            viewMode: i,
            setNodes: u,
            setEdges: d,
            horizontalHelperLine: a,
            verticalHelperLine: l,
            onNodesChange: h,
            onEdgesChange: g,
            onConnect: ie,
            nodeTypes: XO,
            edgeTypes: nT,
            onContextMenu: ce,
            onNodeContextMenu: J,
            onEdgeContextMenu: Ae,
            onNodeClick: nr,
            onPaneClick: te,
            paneMenu: v,
            nodeMenu: b,
            edgeMenu: M,
            onNodeCreate: He,
            onNodeDelete: Ke,
            onEdgeDelete: le,
            onEdgeClick: or,
            onCreateDownstreamAsset: $e,
            onLineSideSubNodeCreate: Le,
            onLoadSideSubNodeCreate: tt,
            onVerticalClick: go,
            onHorizontalClick: mo,
            onToggleViewMode: yo,
            onExportFlow: bo,
            onImportFlow: qr,
            onNodeDragStart: vo,
            onConnectStart: xo,
            connectionLineType: En.Step,
            defaultEdgeOptions: {
              type: En.Step,
            },
          }),
          /* @__PURE__ */ p.jsxs('div', {
            style: { position: 'absolute', bottom: '16px', left: '677px' },
            children: [
              /* @__PURE__ */ p.jsx(Pt, { variant: 'contained', onClick: Jr, children: 'Save' }),
              /* @__PURE__ */ p.jsx(Pt, {
                id: 'undo',
                variant: 'contained',
                onClick: $r,
                disabled: D.length === 0,
                sx: { marginLeft: '5px' },
                children: 'Undo',
              }),
            ],
          }),
          /* @__PURE__ */ p.jsx(l7, {
            className: 'nowheel nodrag nopan',
            open: Q,
            children:
              q &&
              c &&
              /* @__PURE__ */ p.jsx(C7, {
                node: q,
                onSave: Ie,
                onNodeClassCodeChange: lt,
                onNodeColorChange: Zt,
                onNodeElectricalPanelTypeChange: Fn,
                onDeleteClick: V,
                onCopyClick: W,
              }),
          }),
        ],
      })
    )
  },
  S7 = ({ initialdata: e, ondatachange: t }) => {
    const { bootstrapped: n, config: o, services: r, theme: i } = cs(),
      s = e ? JSON.parse(e) : { list: [], initialEdges: [] },
      a = c => {
        const u = new CustomEvent('datachange', {
          detail: c,
        })
        document.dispatchEvent(u)
      },
      l = c => {
        const u = new CustomEvent('singlechange', {
          detail: c,
        })
        document.dispatchEvent(u)
      }
    return /* @__PURE__ */ p.jsx(W9, {
      bootstrapped: n,
      services: r,
      config: o,
      theme: i,
      children: /* @__PURE__ */ p.jsx(E7, {
        initialData: s,
        onDataChange: a,
        onSingleChange: l,
      }),
    })
  }
var B7 = Object.defineProperty,
  I7 = (e, t, n) => (t in e ? B7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)),
  Qs = (e, t, n) => I7(e, typeof t != 'symbol' ? t + '' : t, n)
const N7 = {
    stringify: e => (e ? 'true' : 'false'),
    parse: e => /^[ty1-9]/i.test(e),
  },
  k7 = {
    stringify: e => e.name,
    parse: (e, t, n) => {
      const o = (() => {
        if (typeof window < 'u' && e in window) return window[e]
        if (typeof global < 'u' && e in global) return global[e]
      })()
      return typeof o == 'function' ? o.bind(n) : void 0
    },
  },
  M7 = {
    stringify: e => JSON.stringify(e),
    parse: e => JSON.parse(e),
  },
  P7 = {
    stringify: e => `${e}`,
    parse: e => parseFloat(e),
  },
  L7 = {
    stringify: e => e,
    parse: e => e,
  },
  jc = {
    string: L7,
    number: P7,
    boolean: N7,
    function: k7,
    json: M7,
  }
function R7(e) {
  return e.replace(/([a-z0-9])([A-Z])/g, (t, n, o) => `${n}-${o.toLowerCase()}`)
}
const Os = Symbol.for('r2wc.render'),
  js = Symbol.for('r2wc.connected'),
  So = Symbol.for('r2wc.context'),
  Qn = Symbol.for('r2wc.props')
function T7(e, t, n) {
  var o, r, i
  t.props || (t.props = e.propTypes ? Object.keys(e.propTypes) : []), t.events || (t.events = [])
  const s = Array.isArray(t.props) ? t.props.slice() : Object.keys(t.props),
    a = Array.isArray(t.events) ? t.events.slice() : Object.keys(t.events),
    l = {},
    c = {},
    u = {},
    d = {}
  for (const A of s) {
    l[A] = Array.isArray(t.props) ? 'string' : t.props[A]
    const h = R7(A)
    ;(u[A] = h), (d[h] = A)
  }
  for (const A of a) c[A] = Array.isArray(t.events) ? {} : t.events[A]
  class f extends HTMLElement {
    constructor() {
      super(),
        Qs(this, i, !0),
        Qs(this, r),
        Qs(this, o, {}),
        Qs(this, 'container'),
        t.shadow
          ? (this.container = this.attachShadow({
              mode: t.shadow,
            }))
          : (this.container = this),
        (this[Qn].container = this.container)
      for (const h of s) {
        const g = u[h],
          x = this.getAttribute(g),
          m = l[h],
          v = m ? jc[m] : null
        v != null && v.parse && x && (this[Qn][h] = v.parse(x, g, this))
      }
      for (const h of a)
        this[Qn][h] = g => {
          const x = h.replace(/^on/, '').toLowerCase()
          this.dispatchEvent(new CustomEvent(x, { detail: g, ...c[h] }))
        }
    }
    static get observedAttributes() {
      return Object.keys(d)
    }
    connectedCallback() {
      ;(this[js] = !0), this[Os]()
    }
    disconnectedCallback() {
      ;(this[js] = !1), this[So] && n.unmount(this[So]), delete this[So]
    }
    attributeChangedCallback(h, g, x) {
      const m = d[h],
        v = l[m],
        y = v ? jc[v] : null
      m in l && y != null && y.parse && x && ((this[Qn][m] = y.parse(x, h, this)), this[Os]())
    }
    [((i = js), (r = So), (o = Qn), Os)]() {
      this[js] && (this[So] ? n.update(this[So], this[Qn]) : (this[So] = n.mount(this.container, e, this[Qn])))
    }
  }
  for (const A of s) {
    const h = u[A],
      g = l[A]
    Object.defineProperty(f.prototype, A, {
      enumerable: !0,
      configurable: !0,
      get() {
        return this[Qn][A]
      },
      set(x) {
        this[Qn][A] = x
        const m = g ? jc[g] : null
        if (m != null && m.stringify) {
          const v = m.stringify(x, h, this)
          this.getAttribute(h) !== v && this.setAttribute(h, v)
        } else this[Os]()
      },
    })
  }
  return f
}
function F7(e, t, n, o = {}) {
  function r(a, l, c) {
    const u = t.createElement(l, c)
    if ('createRoot' in n) {
      const d = n.createRoot(a)
      return (
        d.render(u),
        {
          container: a,
          root: d,
          ReactComponent: l,
        }
      )
    }
    if ('render' in n)
      return (
        n.render(u, a),
        {
          container: a,
          ReactComponent: l,
        }
      )
    throw new Error('Invalid ReactDOM instance provided.')
  }
  function i({ container: a, root: l, ReactComponent: c }, u) {
    const d = t.createElement(c, u)
    if (l) {
      l.render(d)
      return
    }
    if ('render' in n) {
      n.render(d, a)
      return
    }
  }
  function s({ container: a, root: l }) {
    if (l) {
      l.unmount()
      return
    }
    if ('unmountComponentAtNode' in n) {
      n.unmountComponentAtNode(a)
      return
    }
  }
  return T7(e, o, { mount: r, unmount: s, update: i })
}
const D7 = F7(S7, ve, Ai, {
  props: ['initialdata', 'ondatachange', 'onsinglechange'],
})
customElements.define('react-flow', D7, { shadow: !0 })
